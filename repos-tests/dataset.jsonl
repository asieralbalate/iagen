{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */"}
{"prompt":"is fast,  => {};","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit('is fast', () => {});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('1-1', () => expect(2).toBe(2));\n\ntest('1-2', () => expect(2).toBe(2));\n\ntest('1-3', () => expect(2).toBe(2));"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('2-1', () => expect(2).toBe(2));\n\ntest('2-2', () => expect(2).toBe(2));\n\ntest('2-3', () => expect(2).toBe(2));"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('3-1', () => expect(2).toBe(2));\n\ntest('3-2', () => expect(2).toBe(2));\n\ntest('3-3', () => expect(2).toBe(2));"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ntest('a', () => {});"}
{"prompt":"should add two numbers,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit('should add two numbers', () => {\n  expect(1 + 1).toBe(2);\n});"}
{"prompt":"CustomReporters,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nconst add = require('../add');\n\ndescribe('CustomReporters', () => {\n  test('adds fail', () => {\n    expect(add(1, 3)).toBe(231);\n    expect(add(5, 7)).toBe(120);\n    expect(add(2, 4)).toBe(6);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ntest('advances timers if true is passed', done => {\n  jest.useFakeTimers({advanceTimers: true});\n\n  const start = Date.now();\n\n  setTimeout(() => {\n    done();\n    expect(Date.now() - start).toBe(45);\n  }, 45);\n});\n\ntest('advances timers if a number is passed', done => {\n  jest.useFakeTimers({advanceTimers: 40});\n\n  const start = Date.now();\n\n  setTimeout(() => {\n    done();\n    expect(Date.now() - start).toBe(35);\n  }, 35);\n});\n\ntest('works with `now` option', done => {\n  jest.useFakeTimers({advanceTimers: 30, now: new Date('2015-09-25')});\n\n  expect(Date.now()).toBe(1_443_139_200_000);\n\n  const start = Date.now();\n\n  setTimeout(() => {\n    done();\n    expect(Date.now() - start).toBe(25);\n  }, 25);\n});"}
{"prompt":"describe,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {runTest} from '../__mocks__/testUtils';\n\ntest('tests are not marked done until their parent afterAll runs', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      afterAll(() => {});\n      test('one', () => {});\n      test('two', () => {});\n      describe('2nd level describe', () => {\n        afterAll(() => {});\n        test('2nd level test', () => {});\n\n        describe('3rd level describe', () => {\n          test('3rd level test', () => {});\n          test('3rd level test#2', () => {});\n        });\n      });\n    })\n\n    describe('2nd describe', () => {\n      afterAll(() => { throw new Error('alabama'); });\n      test('2nd describe test', () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('describe block cannot have hooks and no tests', () => {\n  const result = runTest(`\n    describe('describe', () => {\n      afterEach(() => {});\n      beforeEach(() => {});\n      afterAll(() => {});\n      beforeAll(() => {});\n    })\n  `);\n\n  expect(result.stdout).toMatchSnapshot();\n});\n\ntest('describe block _can_ have hooks if a child describe block has tests', () => {\n  const result = runTest(`\n    describe('describe', () => {\n      afterEach(() => console.log('> afterEach'));\n      beforeEach(() => console.log('> beforeEach'));\n      afterAll(() => console.log('> afterAll'));\n      beforeAll(() => console.log('> beforeAll'));\n      describe('child describe', () => {\n        test('my test', () => console.log('> my test'));\n      })\n    })\n  `);\n  expect(result.stdout).toMatchSnapshot();\n});\n\ntest('describe block hooks must not run if describe block is skipped', () => {\n  const result = runTest(`\n    describe.skip('describe', () => {\n      afterAll(() => console.log('> afterAll'));\n      beforeAll(() => console.log('> beforeAll'));\n      test('my test', () => console.log('> my test'));\n    })\n  `);\n  expect(result.stdout).toMatchSnapshot();\n});\n\ntest('child tests marked with todo should not run if describe block is skipped', () => {\n  const result = runTest(`\n    describe.skip('describe', () => {\n      afterAll(() => console.log('> afterAll'));\n      beforeAll(() => console.log('> beforeAll'));\n      test.todo('my test');\n    })\n  `);\n  expect(result.stdout).toMatchSnapshot();\n});\n\ntest('child tests marked with only should not run if describe block is skipped', () => {\n  const result = runTest(`\n    describe.skip('describe', () => {\n      afterAll(() => console.log('> afterAll'));\n      beforeAll(() => console.log('> beforeAll'));\n      test.only('my test', () => console.log('> my test'));\n    })\n  `);\n  expect(result.stdout).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`child tests marked with only should not run if describe block is skipped 1`] = `\n\"start_describe_definition: describe\nadd_hook: afterAll\nadd_hook: beforeAll\nadd_test: my test\nfinish_describe_definition: describe\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe\ntest_start: my test\ntest_skip\nrun_describe_finish: describe\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;\n\nexports[`child tests marked with todo should not run if describe block is skipped 1`] = `\n\"start_describe_definition: describe\nadd_hook: afterAll\nadd_hook: beforeAll\nadd_test: my test\nfinish_describe_definition: describe\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe\ntest_start: my test\ntest_skip\nrun_describe_finish: describe\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;\n\nexports[`describe block _can_ have hooks if a child describe block has tests 1`] = `\n\"start_describe_definition: describe\nadd_hook: afterEach\nadd_hook: beforeEach\nadd_hook: afterAll\nadd_hook: beforeAll\nstart_describe_definition: child describe\nadd_test: my test\nfinish_describe_definition: child describe\nfinish_describe_definition: describe\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe\nhook_start: beforeAll\n> beforeAll\nhook_success: beforeAll\nrun_describe_start: child describe\ntest_start: my test\ntest_started: my test\nhook_start: beforeEach\n> beforeEach\nhook_success: beforeEach\ntest_fn_start: my test\n> my test\ntest_fn_success: my test\nhook_start: afterEach\n> afterEach\nhook_success: afterEach\ntest_done: my test\nrun_describe_finish: child describe\nhook_start: afterAll\n> afterAll\nhook_success: afterAll\nrun_describe_finish: describe\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;\n\nexports[`describe block cannot have hooks and no tests 1`] = `\n\"start_describe_definition: describe\nadd_hook: afterEach\nadd_hook: beforeEach\nadd_hook: afterAll\nadd_hook: beforeAll\nfinish_describe_definition: describe\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe\nrun_describe_finish: describe\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 4\"\n`;\n\nexports[`describe block hooks must not run if describe block is skipped 1`] = `\n\"start_describe_definition: describe\nadd_hook: afterAll\nadd_hook: beforeAll\nadd_test: my test\nfinish_describe_definition: describe\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe\ntest_start: my test\ntest_skip\nrun_describe_finish: describe\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;\n\nexports[`tests are not marked done until their parent afterAll runs 1`] = `\n\"start_describe_definition: describe\nadd_hook: afterAll\nadd_test: one\nadd_test: two\nstart_describe_definition: 2nd level describe\nadd_hook: afterAll\nadd_test: 2nd level test\nstart_describe_definition: 3rd level describe\nadd_test: 3rd level test\nadd_test: 3rd level test#2\nfinish_describe_definition: 3rd level describe\nfinish_describe_definition: 2nd level describe\nfinish_describe_definition: describe\nstart_describe_definition: 2nd describe\nadd_hook: afterAll\nadd_test: 2nd describe test\nfinish_describe_definition: 2nd describe\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe\ntest_start: one\ntest_started: one\ntest_fn_start: one\ntest_fn_success: one\ntest_done: one\ntest_start: two\ntest_started: two\ntest_fn_start: two\ntest_fn_success: two\ntest_done: two\nrun_describe_start: 2nd level describe\ntest_start: 2nd level test\ntest_started: 2nd level test\ntest_fn_start: 2nd level test\ntest_fn_success: 2nd level test\ntest_done: 2nd level test\nrun_describe_start: 3rd level describe\ntest_start: 3rd level test\ntest_started: 3rd level test\ntest_fn_start: 3rd level test\ntest_fn_success: 3rd level test\ntest_done: 3rd level test\ntest_start: 3rd level test#2\ntest_started: 3rd level test#2\ntest_fn_start: 3rd level test#2\ntest_fn_success: 3rd level test#2\ntest_done: 3rd level test#2\nrun_describe_finish: 3rd level describe\nhook_start: afterAll\nhook_success: afterAll\nrun_describe_finish: 2nd level describe\nhook_start: afterAll\nhook_success: afterAll\nrun_describe_finish: describe\nrun_describe_start: 2nd describe\ntest_start: 2nd describe test\ntest_started: 2nd describe test\ntest_fn_start: 2nd describe test\ntest_fn_success: 2nd describe test\ntest_done: 2nd describe test\nhook_start: afterAll\nhook_failure: afterAll\nrun_describe_finish: 2nd describe\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 1\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('access environment methods after done', () => {\n  setTimeout(() => {\n    jest.clearAllTimers();\n  }, 0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('ensure seed exists', () => {\n  expect(jest.getSeed()).toEqual(expect.any(Number));\n});"}
{"prompt":"check,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {Config} from '@jest/types';\nimport {constants} from 'jest-config';\nimport {check} from '../args';\nimport {buildArgv} from '../run';\n\nconst argv = (input: Partial<Config.Argv>): Config.Argv => input as Config.Argv;\n\ndescribe('check', () => {\n  it('returns true if the arguments are valid', () => {\n    expect(check(argv({}))).toBe(true);\n  });\n\n  it('raises an exception if runInBand and maxWorkers are both specified', () => {\n    expect(() => check(argv({maxWorkers: 2, runInBand: true}))).toThrow(\n      'Both --runInBand and --maxWorkers were specified',\n    );\n  });\n\n  it('raises an exception if onlyChanged and watchAll are both specified', () => {\n    expect(() => check(argv({onlyChanged: true, watchAll: true}))).toThrow(\n      'Both --onlyChanged and --watchAll were specified',\n    );\n  });\n\n  it('raises an exception if onlyFailures and watchAll are both specified', () => {\n    expect(() => check(argv({onlyFailures: true, watchAll: true}))).toThrow(\n      'Both --onlyFailures and --watchAll were specified',\n    );\n  });\n\n  it('raises an exception when lastCommit and watchAll are both specified', () => {\n    expect(() => check(argv({lastCommit: true, watchAll: true}))).toThrow(\n      'Both --lastCommit and --watchAll were specified',\n    );\n  });\n\n  it('raises an exception if findRelatedTests is specified with no file paths', () => {\n    expect(() =>\n      check(\n        argv({\n          _: [],\n          findRelatedTests: true,\n        }),\n      ),\n    ).toThrow(\n      'The --findRelatedTests option requires file paths to be specified',\n    );\n  });\n\n  it('raises an exception if maxWorkers is specified with no number', () => {\n    expect(() => check(argv({maxWorkers: undefined}))).toThrow(\n      'The --maxWorkers (-w) option requires a number or string to be specified',\n    );\n  });\n\n  it('allows maxWorkers to be a %', () => {\n    expect(() => check(argv({maxWorkers: '50%'}))).not.toThrow();\n  });\n\n  test.each(constants.JEST_CONFIG_EXT_ORDER.map(e => e.slice(1)))(\n    'allows using \"%s\" file for --config option',\n    ext => {\n      expect(() => check(argv({config: `jest.config.${ext}`}))).not.toThrow();\n      expect(() =>\n        check(argv({config: `../test/test/my_conf.${ext}`})),\n      ).not.toThrow();\n    },\n  );\n\n  it('raises an exception if selectProjects is not provided any project names', () => {\n    expect(() => check(argv({selectProjects: []}))).toThrow(\n      'The --selectProjects option requires the name of at least one project to be specified.\\n',\n    );\n  });\n\n  it('raises an exception if ignoreProjects is not provided any project names', () => {\n    expect(() => check(argv({ignoreProjects: []}))).toThrow(\n      'The --ignoreProjects option requires the name of at least one project to be specified.\\n',\n    );\n  });\n\n  it('raises an exception if config is not a valid JSON string', () => {\n    expect(() => check(argv({config: 'x:1'}))).toThrow(\n      'The --config option requires a JSON string literal, or a file path with one of these extensions: .js, .ts, .mjs, .cjs, .cts, .json',\n    );\n  });\n\n  it('raises an exception if config is not a supported file type', () => {\n    const message =\n      'The --config option requires a JSON string literal, or a file path with one of these extensions: .js, .ts, .mjs, .cjs, .cts, .json';\n\n    expect(() => check(argv({config: 'jest.configjs'}))).toThrow(message);\n    expect(() => check(argv({config: 'jest.config.exe'}))).toThrow(message);\n  });\n});\n\ndescribe('buildArgv', () => {\n  it('should return only camelcased args ', async () => {\n    const mockProcessArgv = jest\n      .spyOn(process.argv, 'slice')\n      .mockImplementation(() => ['--clear-mocks']);\n\n    const actual = await buildArgv();\n    expect(actual).not.toHaveProperty('clear-mocks');\n    expect(actual).toHaveProperty('clearMocks', true);\n    mockProcessArgv.mockRestore();\n  });\n});"}
{"prompt":": jest.fn,","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport pretty from 'pretty-format';\nimport each from '..';\n\nconst noop = () => {};\nconst expectFunction = expect.any(Function);\n\nconst get = <T>(object: T, lensPath: Array<string>): T =>\n  lensPath.reduce((acc, key) => acc[key], object);\n\nconst getGlobalTestMocks = () => {\n  const globals: any = {\n    describe: jest.fn(),\n    fdescribe: jest.fn(),\n    fit: jest.fn(),\n    it: jest.fn(),\n    test: jest.fn(),\n    xdescribe: jest.fn(),\n    xit: jest.fn(),\n    xtest: jest.fn(),\n  };\n  globals.test.only = jest.fn();\n  globals.test.skip = jest.fn();\n  globals.test.concurrent = jest.fn();\n  globals.test.concurrent.only = jest.fn();\n  globals.test.concurrent.skip = jest.fn();\n  globals.it.only = jest.fn();\n  globals.it.skip = jest.fn();\n  globals.describe.only = jest.fn();\n  globals.describe.skip = jest.fn();\n  return globals;\n};\n\ndescribe('jest-each', () => {\n  for (const keyPath of [\n    ['test'],\n    ['test', 'concurrent'],\n    ['test', 'concurrent', 'only'],\n    ['test', 'concurrent', 'skip'],\n    ['test', 'only'],\n    ['it'],\n    ['fit'],\n    ['it', 'only'],\n    ['describe'],\n    ['fdescribe'],\n    ['describe', 'only'],\n  ]) {\n    describe(`.${keyPath.join('.')}`, () => {\n      test('throws an error when not called with an array', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)(undefined);\n        const testFunction = get(eachObject, keyPath);\n\n        testFunction('expected string', noop);\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          globalMock.mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n      });\n\n      test('throws an error when called with an empty array', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([]);\n        const testFunction = get(eachObject, keyPath);\n\n        testFunction('expected string', noop);\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          globalMock.mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n      });\n\n      test('calls global with given title', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([[]]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with given title when multiple tests cases exist', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([[], []]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using printf format', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          [\n            'hello',\n            1,\n            null,\n            undefined,\n            1.2,\n            {foo: 'bar'},\n            () => {},\n            [],\n            Number.POSITIVE_INFINITY,\n            Number.NaN,\n          ],\n          [\n            'world',\n            1,\n            null,\n            undefined,\n            1.2,\n            {baz: 'qux'},\n            () => {},\n            [],\n            Number.POSITIVE_INFINITY,\n            Number.NaN,\n          ],\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction(\n          'expected string: %% %%s %s %d %s %s %d %j %s %j %d %d %# %$',\n          noop,\n        );\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          `expected string: % %s hello 1 null undefined 1.2 ${JSON.stringify({\n            foo: 'bar',\n          })} () => {} [] Infinity NaN 0 1`,\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          `expected string: % %s world 1 null undefined 1.2 ${JSON.stringify({\n            baz: 'qux',\n          })} () => {} [] Infinity NaN 1 2`,\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('does not call global test with title containing more param values than sprintf placeholders', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          ['hello', 1, 2, 3, 4, 5],\n          ['world', 1, 2, 3, 4, 5],\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string: %s', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: hello',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: world',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global test title with %p placeholder injected at the correct positions', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          ['string1', 'pretty1', 'string2', 'pretty2'],\n          ['string1', 'pretty1', 'string2', 'pretty2'],\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string: %s %p %s %p', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          `expected string: string1 ${pretty('pretty1')} string2 ${pretty(\n            'pretty2',\n          )}`,\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          `expected string: string1 ${pretty('pretty1')} string2 ${pretty(\n            'pretty2',\n          )}`,\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('does not calls global test title with %p placeholder when no data is supplied at given position', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          ['string1', 'pretty1', 'string2'],\n          ['string1', 'pretty1', 'string2'],\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string: %s %p %s %p', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          `expected string: string1 ${pretty('pretty1')} string2 %p`,\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          `expected string: string1 ${pretty('pretty1')} string2 %p`,\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with cb function containing all parameters of each test case when given 1d array', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const testCallBack = jest.fn();\n        const eachObject = each.withGlobal(globalTestMocks)(['hello', 'world']);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        globalMock.mock.calls[0][1]();\n        expect(testCallBack).toHaveBeenCalledTimes(1);\n        expect(testCallBack).toHaveBeenCalledWith('hello');\n\n        globalMock.mock.calls[1][1]();\n        expect(testCallBack).toHaveBeenCalledTimes(2);\n        expect(testCallBack).toHaveBeenCalledWith('world');\n      });\n\n      test('calls global with cb function containing all parameters of each test case 2d array', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const testCallBack = jest.fn();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          ['hello', 'world'],\n          ['joe', 'bloggs'],\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        globalMock.mock.calls[0][1]();\n        expect(testCallBack).toHaveBeenCalledTimes(1);\n        expect(testCallBack).toHaveBeenCalledWith('hello', 'world');\n\n        globalMock.mock.calls[1][1]();\n        expect(testCallBack).toHaveBeenCalledTimes(2);\n        expect(testCallBack).toHaveBeenCalledWith('joe', 'bloggs');\n      });\n\n      test('calls global with given timeout', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([['hello']]);\n\n        const testFunction = get(eachObject, keyPath);\n        testFunction('some test', noop, 10_000);\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledWith(\n          'some test',\n          expect.any(Function),\n          10_000,\n        );\n      });\n\n      test('calls global with title containing object property when using $variable', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          {\n            a: 'hello',\n            b: 1,\n            c: null,\n            d: undefined,\n            e: 1.2,\n            f: {key: 'foo'},\n            g: () => {},\n            h: [],\n            i: Number.POSITIVE_INFINITY,\n            j: Number.NaN,\n          },\n          {\n            a: 'world',\n            b: 1,\n            c: null,\n            d: undefined,\n            e: 1.2,\n            f: {key: 'bar'},\n            g: () => {},\n            h: [],\n            i: Number.POSITIVE_INFINITY,\n            j: Number.NaN,\n          },\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction(\n          'expected string: %% %%s $a $b $c $d $e $f $f.key $g $h $i $j $#',\n          noop,\n        );\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: % %s hello 1 null undefined 1.2 {\"key\": \"foo\"} foo [Function g] [] Infinity NaN 0',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: % %s world 1 null undefined 1.2 {\"key\": \"bar\"} bar [Function g] [] Infinity NaN 1',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using both % placeholder and $variable', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          {\n            a: 'hello',\n            b: 1,\n          },\n          {\n            a: 'world',\n            b: 1,\n          },\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string: %p %# $a $b $#', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: {\"a\": \"hello\", \"b\": 1} 0 $a $b $#',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: {\"a\": \"world\", \"b\": 1} 1 $a $b $#',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using %#', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          {name: 'foo'},\n          {name: 'bar'},\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected index: %#', () => {});\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected index: 0',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected index: 1',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using $#', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          {name: 'foo'},\n          {name: 'bar'},\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected index: $#', () => {});\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected index: 0',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected index: 1',\n          expectFunction,\n          undefined,\n        );\n      });\n    });\n  }\n\n  describe('done callback', () => {\n    test.each([\n      [['test']],\n      [['test', 'only']],\n      [['test', 'concurrent']],\n      [['test', 'concurrent', 'only']],\n      [['it']],\n      [['fit']],\n      [['it', 'only']],\n    ])(\n      'calls %O with done when cb function has more args than params of given test row',\n      keyPath => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([['hello']]);\n\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', (hello, done) => {\n          expect(hello).toBe('hello');\n          expect(done).toBe('DONE');\n        });\n        get(globalTestMocks, keyPath).mock.calls[0][1]('DONE');\n      },\n    );\n\n    test.each([[['describe']], [['fdescribe']], [['describe', 'only']]])(\n      'does not call %O with done when test function has more args than params of given test row',\n      keyPath => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([['hello']]);\n\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', function (hello, done) {\n          expect(hello).toBe('hello');\n          // eslint-disable-next-line prefer-rest-params\n          expect(arguments).toHaveLength(1);\n          expect(done).toBeUndefined();\n        });\n        get(globalTestMocks, keyPath).mock.calls[0][1]('DONE');\n      },\n    );\n  });\n\n  for (const keyPath of [\n    ['xtest'],\n    ['test', 'skip'],\n    ['test', 'concurrent', 'skip'],\n    ['xit'],\n    ['it', 'skip'],\n    ['xdescribe'],\n    ['describe', 'skip'],\n  ]) {\n    describe(`.${keyPath.join('.')}`, () => {\n      test('calls global with given title', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([[]]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with given title when multiple tests cases exist', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([[], []]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using sprintf format', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          ['hello', 1],\n          ['world', 2],\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string: %s %s', () => {});\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: hello 1',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: world 2',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title with placeholder values correctly interpolated', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)([\n          ['hello', '%d', 10, '%s', {foo: 'bar'}],\n          ['world', '%i', 1991, '%p', {foo: 'bar'}],\n          ['joe', '%d %d', 10, '%%s', {foo: 'bar'}],\n        ]);\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string: %s %s %d %s %p', () => {});\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(3);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: hello %d 10 %s {\"foo\": \"bar\"}',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: world %i 1991 %p {\"foo\": \"bar\"}',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: joe %d %d 10 %%s {\"foo\": \"bar\"}',\n          expectFunction,\n          undefined,\n        );\n      });\n    });\n  }\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`jest-each .describe throws an error when called with an empty array 1`] = `\n\"Error: \\`.each\\` called with an empty Array of table data.\n\"\n`;\n\nexports[`jest-each .describe throws an error when not called with an array 1`] = `\n\"\\`.each\\` must be called with an Array or Tagged Template Literal.\n\nInstead was called with: undefined\n\"\n`;\n\nexports[`jest-each .describe.only throws an error when called with an empty array 1`] = `\n\"Error: \\`.each\\` called with an empty Array of table data.\n\"\n`;\n\nexports[`jest-each .describe.only throws an error when not called with an array 1`] = `\n\"\\`.each\\` must be called with an Array or Tagged Template Literal.\n\nInstead was called with: undefined\n\"\n`;\n\nexports[`jest-each .fdescribe throws an error when called with an empty array 1`] = `\n\"Error: \\`.each\\` called with an empty Array of table data.\n\"\n`;\n\nexports[`jest-each .fdescribe throws an error when not called with an array 1`] = `\n\"\\`.each\\` must be called with an Array or Tagged Template Literal.\n\nInstead was called with: undefined\n\"\n`;\n\nexports[`jest-each .fit throws an error when called with an empty array 1`] = `\n\"Error: \\`.each\\` called with an empty Array of table data.\n\"\n`;\n\nexports[`jest-each .fit throws an error when not called with an array 1`] = `\n\"\\`.each\\` must be called with an Array or Tagged Template Literal.\n\nInstead was called with: undefined\n\"\n`;\n\nexports[`jest-each .it throws an error when called with an empty array 1`] = `\n\"Error: \\`.each\\` called with an empty Array of table data.\n\"\n`;\n\nexports[`jest-each .it throws an error when not called with an array 1`] = `\n\"\\`.each\\` must be called with an Array or Tagged Template Literal.\n\nInstead was called with: undefined\n\"\n`;\n\nexports[`jest-each .it.only throws an error when called with an empty array 1`] = `\n\"Error: \\`.each\\` called with an empty Array of table data.\n\"\n`;\n\nexports[`jest-each .it.only throws an error when not called with an array 1`] = `\n\"\\`.each\\` must be called with an Array or Tagged Template Literal.\n\nInstead was called with: undefined\n\"\n`;\n\nexports[`jest-each .test throws an error when called with an empty array 1`] = `\n\"Error: \\`.each\\` called with an empty Array of table data.\n\"\n`;\n\nexports[`jest-each .test throws an error when not called with an array 1`] = `\n\"\\`.each\\` must be called with an Array or Tagged Template Literal.\n\nInstead was called with: undefined\n\"\n`;\n\nexports[`jest-each .test.concurrent throws an error when called with an empty array 1`] = `\n\"Error: \\`.each\\` called with an empty Array of table data.\n\"\n`;\n\nexports[`jest-each .test.concurrent throws an error when not called with an array 1`] = `\n\"\\`.each\\` must be called with an Array or Tagged Template Literal.\n\nInstead was called with: undefined\n\"\n`;\n\nexports[`jest-each .test.concurrent.only throws an error when called with an empty array 1`] = `\n\"Error: \\`.each\\` called with an empty Array of table data.\n\"\n`;\n\nexports[`jest-each .test.concurrent.only throws an error when not called with an array 1`] = `\n\"\\`.each\\` must be called with an Array or Tagged Template Literal.\n\nInstead was called with: undefined\n\"\n`;\n\nexports[`jest-each .test.concurrent.skip throws an error when called with an empty array 1`] = `\n\"Error: \\`.each\\` called with an empty Array of table data.\n\"\n`;\n\nexports[`jest-each .test.concurrent.skip throws an error when not called with an array 1`] = `\n\"\\`.each\\` must be called with an Array or Tagged Template Literal.\n\nInstead was called with: undefined\n\"\n`;\n\nexports[`jest-each .test.only throws an error when called with an empty array 1`] = `\n\"Error: \\`.each\\` called with an empty Array of table data.\n\"\n`;\n\nexports[`jest-each .test.only throws an error when not called with an array 1`] = `\n\"\\`.each\\` must be called with an Array or Tagged Template Literal.\n\nInstead was called with: undefined\n\"\n`;"}
{"prompt":".assertions,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nconst throws = () => {\n  expect.assertions(2);\n  expect(false).toBeTruthy();\n};\nconst redeclare = () => {\n  expect.assertions(1);\n  expect(false).toBeTruthy();\n  expect.assertions(2);\n};\n\nconst noAssertions = () => {\n  expect.assertions(0);\n  expect(true).toBeTruthy();\n};\n\nconst hasNoAssertions = () => {\n  expect.hasAssertions();\n};\n\ndescribe('.assertions()', () => {\n  it('throws', throws);\n  it('throws on redeclare of assertion count', redeclare);\n  it('throws on assertion', noAssertions);\n});\n\ndescribe('.hasAssertions()', () => {\n  it('throws when there are not assertions', hasNoAssertions);\n});"}
{"prompt":".assertions,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {alignedAnsiStyleSerializer} from '@jest/test-utils';\nimport jestExpect from '..';\n\nexpect.addSnapshotSerializer(alignedAnsiStyleSerializer);\n\ndescribe('.assertions()', () => {\n  it('does not throw', () => {\n    jestExpect.assertions(2);\n    jestExpect('a').not.toBe('b');\n    jestExpect('a').toBe('a');\n  });\n\n  it('redeclares different assertion count', () => {\n    jestExpect.assertions(3);\n    jestExpect('a').not.toBe('b');\n    jestExpect('a').toBe('a');\n    jestExpect.assertions(2);\n  });\n  it('expects no assertions', () => {\n    jestExpect.assertions(0);\n  });\n});\n\ndescribe('.hasAssertions()', () => {\n  it('does not throw if there is an assertion', () => {\n    jestExpect.hasAssertions();\n    jestExpect('a').toBe('a');\n  });\n\n  it('throws if expected is not undefined', () => {\n    expect(() => {\n      // @ts-expect-error\n      jestExpect.hasAssertions(2);\n    }).toThrowErrorMatchingSnapshot();\n  });\n\n  it('hasAssertions not leaking to global state', () => {});\n});\n\ndescribe('numPassingAsserts', () => {\n  it('verify the default value of numPassingAsserts', () => {\n    const {numPassingAsserts} = jestExpect.getState();\n    expect(numPassingAsserts).toBe(0);\n  });\n\n  it('verify the resetting of numPassingAsserts after a test', () => {\n    expect('a').toBe('a');\n    expect('a').toBe('a');\n    // reset state\n    jestExpect.extractExpectedAssertionsErrors();\n    const {numPassingAsserts} = jestExpect.getState();\n    expect(numPassingAsserts).toBe(0);\n  });\n\n  it('verify the correctness of numPassingAsserts count for passing test', () => {\n    expect('a').toBe('a');\n    expect('a').toBe('a');\n    const {numPassingAsserts} = jestExpect.getState();\n    expect(numPassingAsserts).toBe(2);\n  });\n\n  it('verify the correctness of numPassingAsserts count for failing test', () => {\n    expect('a').toBe('a');\n    try {\n      expect('a').toBe('b');\n    } catch {}\n    const {numPassingAsserts} = jestExpect.getState();\n    expect(numPassingAsserts).toBe(1);\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`.hasAssertions() throws if expected is not undefined 1`] = `\n<d>expect(</><r>received</><d>)[.not].hasAssertions()</>\n\n<b>Matcher error</>: this matcher must not have an expected argument\n\nExpected has type:  number\nExpected has value: <g>2</>\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nconst assert = require('assert');\n\ntest('assert', () => {\n  assert(false);\n});\n\ntest('assert with a message', () => {\n  assert(false, 'this is a message');\n});\n\ntest('assert.ok', () => {\n  assert.ok(false);\n});\n\ntest('assert.ok with a message', () => {\n  assert.ok(false, 'this is a message');\n});\n\ntest('assert.equal', () => {\n  assert.equal(1, 2);\n});\n\ntest('assert.notEqual', () => {\n  assert.notEqual(1, 1);\n});\n\ntest('assert.deepEqual', () => {\n  assert.deepEqual({a: {b: {c: 5}}}, {a: {b: {c: 6}}});\n});\n\ntest('assert.deepEqual with a message', () => {\n  assert.deepEqual({a: {b: {c: 5}}}, {a: {b: {c: 7}}}, 'this is a message');\n});\n\ntest('assert.notDeepEqual', () => {\n  assert.notDeepEqual({a: 1}, {a: 1});\n});\n\ntest('assert.strictEqual', () => {\n  assert.strictEqual(1, Number.NaN);\n});\n\ntest('assert.notStrictEqual', () => {\n  assert.notStrictEqual(1, 1, 'My custom error message');\n});\n\ntest('assert.deepStrictEqual', () => {\n  assert.deepStrictEqual({a: 1}, {a: 2});\n});\n\ntest('assert.notDeepStrictEqual', () => {\n  assert.notDeepStrictEqual({a: 1}, {a: 1});\n});\n\ntest('assert.ifError', () => {\n  assert.ifError(1);\n});\n\ntest('assert.doesNotThrow', () => {\n  assert.doesNotThrow(() => {\n    throw new Error('err!');\n  });\n});\n\ntest('assert.throws', () => {\n  assert.throws(() => {});\n});\n\ntest('assert.throws with different error messages', () => {\n  assert.throws(\n    () => {\n      throw new Error('message 1');\n    },\n    {\n      message: 'message 2',\n    },\n  );\n});\n\ntest('assert.throws with different error types', () => {\n  assert.throws(() => {\n    throw new SyntaxError('message 1');\n  }, TypeError);\n});\n\ntest('async', async () => {\n  assert.equal('hello\\ngoodbye', 'hello', 'hmmm');\n});\n\ntest('assert.fail', () => {\n  assert.fail();\n});\n\ntest('assert.fail with a message', () => {\n  assert.fail('error!');\n});"}
{"prompt":"indent option,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport prettyFormat, {plugins} from '..';\nimport type {OptionsReceived} from '../types';\n\nconst {AsymmetricMatcher} = plugins;\nlet options: OptionsReceived;\n\nfunction fnNameFor(func: (...any: Array<any>) => unknown) {\n  if (func.name) {\n    return func.name;\n  }\n\n  const matches = func.toString().match(/^\\s*function\\s*(\\w*)\\s*\\(/);\n  return matches ? matches[1] : '<anonymous>';\n}\n\nbeforeEach(() => {\n  options = {plugins: [AsymmetricMatcher]};\n});\n\nfor (const type of [\n  String,\n  Function,\n  Array,\n  Object,\n  RegExp,\n  Symbol,\n  Function,\n  () => {},\n  function namedFunction() {},\n]) {\n  test(`supports any(${fnNameFor(type)})`, () => {\n    const result = prettyFormat(expect.any(type), options);\n    expect(result).toBe(`Any<${fnNameFor(type)}>`);\n  });\n\n  test(`supports nested any(${fnNameFor(type)})`, () => {\n    const result = prettyFormat(\n      {\n        test: {\n          nested: expect.any(type),\n        },\n      },\n      options,\n    );\n    expect(result).toBe(\n      `Object {\\n  \"test\": Object {\\n    \"nested\": Any<${fnNameFor(\n        type,\n      )}>,\\n  },\\n}`,\n    );\n  });\n}\n\ntest('anything()', () => {\n  const result = prettyFormat(expect.anything(), options);\n  expect(result).toBe('Anything');\n});\n\ntest('arrayContaining()', () => {\n  const result = prettyFormat(expect.arrayContaining([1, 2]), options);\n  expect(result).toBe(`ArrayContaining [\n  1,\n  2,\n]`);\n});\n\ntest('arrayNotContaining()', () => {\n  const result = prettyFormat(expect.not.arrayContaining([1, 2]), options);\n  expect(result).toBe(`ArrayNotContaining [\n  1,\n  2,\n]`);\n});\n\ntest('objectContaining()', () => {\n  const result = prettyFormat(expect.objectContaining({a: 'test'}), options);\n  expect(result).toBe(`ObjectContaining {\n  \"a\": \"test\",\n}`);\n});\n\ntest('objectNotContaining()', () => {\n  const result = prettyFormat(\n    expect.not.objectContaining({a: 'test'}),\n    options,\n  );\n  expect(result).toBe(`ObjectNotContaining {\n  \"a\": \"test\",\n}`);\n});\n\ntest('stringContaining(string)', () => {\n  const result = prettyFormat(expect.stringContaining('jest'), options);\n  expect(result).toBe('StringContaining \"jest\"');\n});\n\ntest('not.stringContaining(string)', () => {\n  const result = prettyFormat(expect.not.stringContaining('jest'), options);\n  expect(result).toBe('StringNotContaining \"jest\"');\n});\n\ntest('stringMatching(string)', () => {\n  const result = prettyFormat(expect.stringMatching('jest'), options);\n  expect(result).toBe('StringMatching /jest/');\n});\n\ntest('stringMatching(regexp)', () => {\n  const result = prettyFormat(expect.stringMatching(/(jest|niema).*/), options);\n  expect(result).toBe('StringMatching /(jest|niema).*/');\n});\n\ntest('stringMatching(regexp) {escapeRegex: false}', () => {\n  const result = prettyFormat(expect.stringMatching(/regexp\\d/gi), options);\n  expect(result).toBe('StringMatching /regexp\\\\d/gi');\n});\n\ntest('stringMatching(regexp) {escapeRegex: true}', () => {\n  const result = prettyFormat(expect.stringMatching(/regexp\\d/gi), {\n    ...options,\n    escapeRegex: true,\n  });\n  expect(result).toBe('StringMatching /regexp\\\\\\\\d/gi');\n});\n\ntest('stringNotMatching(string)', () => {\n  const result = prettyFormat(expect.not.stringMatching('jest'), options);\n  expect(result).toBe('StringNotMatching /jest/');\n});\n\ntest('closeTo(number, precision)', () => {\n  const result = prettyFormat(expect.closeTo(1.2345, 4), options);\n  expect(result).toBe('NumberCloseTo 1.2345 (4 digits)');\n});\n\ntest('notCloseTo(number, precision)', () => {\n  const result = prettyFormat(expect.not.closeTo(1.2345, 1), options);\n  expect(result).toBe('NumberNotCloseTo 1.2345 (1 digit)');\n});\n\ntest('closeTo(number)', () => {\n  const result = prettyFormat(expect.closeTo(1.2345), options);\n  expect(result).toBe('NumberCloseTo 1.2345 (2 digits)');\n});\n\ntest('closeTo(Infinity)', () => {\n  const result = prettyFormat(\n    expect.closeTo(Number.NEGATIVE_INFINITY),\n    options,\n  );\n  expect(result).toBe('NumberCloseTo -Infinity (2 digits)');\n});\n\ntest('closeTo(scientific number)', () => {\n  const result = prettyFormat(expect.closeTo(1.56e-3, 4), options);\n  expect(result).toBe('NumberCloseTo 0.00156 (4 digits)');\n});\n\ntest('closeTo(very small scientific number)', () => {\n  const result = prettyFormat(expect.closeTo(1.56e-10, 4), options);\n  expect(result).toBe('NumberCloseTo 1.56e-10 (4 digits)');\n});\n\ntest('correctly handles inability to pretty-print matcher', () => {\n  expect(() => prettyFormat(new DummyMatcher(1), options)).toThrow(\n    'Asymmetric matcher DummyMatcher does not implement toAsymmetricMatcher()',\n  );\n});\n\ntest('supports multiple nested asymmetric matchers', () => {\n  const result = prettyFormat(\n    {\n      test: {\n        nested: expect.objectContaining({\n          a: expect.arrayContaining([1]),\n          b: expect.anything(),\n          c: expect.any(String),\n          d: expect.stringContaining('jest'),\n          e: expect.stringMatching('jest'),\n          f: expect.objectContaining({test: 'case'}),\n        }),\n      },\n    },\n    options,\n  );\n  expect(result).toBe(`Object {\n  \"test\": Object {\n    \"nested\": ObjectContaining {\n      \"a\": ArrayContaining [\n        1,\n      ],\n      \"b\": Anything,\n      \"c\": Any<String>,\n      \"d\": StringContaining \"jest\",\n      \"e\": StringMatching /jest/,\n      \"f\": ObjectContaining {\n        \"test\": \"case\",\n      },\n    },\n  },\n}`);\n});\n\ndescribe('indent option', () => {\n  const val = {\n    nested: expect.objectContaining({\n      a: expect.arrayContaining([1]),\n      b: expect.anything(),\n      c: expect.any(String),\n      d: expect.stringContaining('jest'),\n      e: expect.stringMatching('jest'),\n      f: expect.objectContaining({\n        composite: ['exact', 'match'],\n        primitive: 'string',\n      }),\n    }),\n  };\n  const result = `Object {\n  \"nested\": ObjectContaining {\n    \"a\": ArrayContaining [\n      1,\n    ],\n    \"b\": Anything,\n    \"c\": Any<String>,\n    \"d\": StringContaining \"jest\",\n    \"e\": StringMatching /jest/,\n    \"f\": ObjectContaining {\n      \"composite\": Array [\n        \"exact\",\n        \"match\",\n      ],\n      \"primitive\": \"string\",\n    },\n  },\n}`;\n\n  test('default implicit: 2 spaces', () => {\n    expect(prettyFormat(val, options)).toEqual(result);\n  });\n  test('default explicit: 2 spaces', () => {\n    expect(prettyFormat(val, {...options, indent: 2})).toEqual(result);\n  });\n\n  // Tests assume that no strings in val contain multiple adjacent spaces!\n  test('non-default: 0 spaces', () => {\n    expect(prettyFormat(val, {...options, indent: 0})).toEqual(\n      result.replaceAll(/ {2}/g, ''),\n    );\n  });\n  test('non-default: 4 spaces', () => {\n    expect(prettyFormat(val, {...options, indent: 4})).toEqual(\n      result.replaceAll(/ {2}/g, ' '.repeat(4)),\n    );\n  });\n});\n\ndescribe('maxDepth option', () => {\n  test('matchers as leaf nodes', () => {\n    const val = {\n      // ++depth === 1\n      nested: [\n        // ++depth === 2\n        expect.arrayContaining(\n          // ++depth === 3\n          [1],\n        ),\n        expect.objectContaining({\n          // ++depth === 3\n          composite: ['exact', 'match'],\n          primitive: 'string',\n        }),\n        expect.stringContaining('jest'),\n        expect.stringMatching('jest'),\n        expect.any(String),\n        expect.anything(),\n      ],\n    };\n    const result = prettyFormat(val, {...options, maxDepth: 2});\n    expect(result).toBe(`Object {\n  \"nested\": Array [\n    [ArrayContaining],\n    [ObjectContaining],\n    StringContaining \"jest\",\n    StringMatching /jest/,\n    Any<String>,\n    Anything,\n  ],\n}`);\n  });\n  test('matchers as internal nodes', () => {\n    const val = [\n      // ++depth === 1\n      expect.arrayContaining([\n        // ++depth === 2\n        'printed',\n        {\n          // ++depth === 3\n          properties: 'not printed',\n        },\n      ]),\n      expect.objectContaining({\n        // ++depth === 2\n        array: [\n          // ++depth === 3\n          'items',\n          'not',\n          'printed',\n        ],\n        primitive: 'printed',\n      }),\n    ];\n    const result = prettyFormat(val, {...options, maxDepth: 2});\n    expect(result).toBe(`Array [\n  ArrayContaining [\n    \"printed\",\n    [Object],\n  ],\n  ObjectContaining {\n    \"array\": [Array],\n    \"primitive\": \"printed\",\n  },\n]`);\n  });\n});\n\ntest('min option', () => {\n  const result = prettyFormat(\n    {\n      test: {\n        nested: expect.objectContaining({\n          a: expect.arrayContaining([1]),\n          b: expect.anything(),\n          c: expect.any(String),\n          d: expect.stringContaining('jest'),\n          e: expect.stringMatching('jest'),\n          f: expect.objectContaining({test: 'case'}),\n        }),\n      },\n    },\n    {...options, min: true},\n  );\n  expect(result).toBe(\n    '{\"test\": {\"nested\": ObjectContaining {\"a\": ArrayContaining [1], \"b\": Anything, \"c\": Any<String>, \"d\": StringContaining \"jest\", \"e\": StringMatching /jest/, \"f\": ObjectContaining {\"test\": \"case\"}}}}',\n  );\n});\n\nclass DummyMatcher {\n  $$typeof = Symbol.for('jest.asymmetricMatcher');\n\n  constructor(private readonly sample: number) {}\n\n  asymmetricMatch(other: number) {\n    return this.sample === other;\n  }\n\n  toString() {\n    return 'DummyMatcher';\n  }\n\n  getExpectedType() {\n    return 'number';\n  }\n}"}
{"prompt":"eslint-disable-next-line no-new-func","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {runInNewContext} from 'node:vm';\nimport jestExpect from '..';\nimport {\n  any,\n  anything,\n  arrayContaining,\n  arrayNotContaining,\n  closeTo,\n  notCloseTo,\n  objectContaining,\n  objectNotContaining,\n  stringContaining,\n  stringMatching,\n  stringNotContaining,\n  stringNotMatching,\n} from '../asymmetricMatchers';\n\ntest('Any.asymmetricMatch()', () => {\n  class Thing {}\n\n  for (const test of [\n    any(String).asymmetricMatch('jest'),\n    any(Number).asymmetricMatch(1),\n    any(Function).asymmetricMatch(() => {}),\n    any(Boolean).asymmetricMatch(true),\n    any(BigInt).asymmetricMatch(1n),\n    any(Symbol).asymmetricMatch(Symbol()),\n    any(Object).asymmetricMatch({}),\n    any(Object).asymmetricMatch(null),\n    any(Array).asymmetricMatch([]),\n    any(Thing).asymmetricMatch(new Thing()),\n  ]) {\n    jestExpect(test).toBe(true);\n  }\n});\n\ntest('Any.asymmetricMatch() on primitive wrapper classes', () => {\n  for (const test of [\n    /* eslint-disable no-new-wrappers, unicorn/new-for-builtins */\n    any(String).asymmetricMatch(new String('jest')),\n    any(Number).asymmetricMatch(new Number(1)),\n    // eslint-disable-next-line no-new-func\n    any(Function).asymmetricMatch(new Function('() => {}')),\n    any(Boolean).asymmetricMatch(new Boolean(true)),\n    any(BigInt).asymmetricMatch(Object(1n)),\n    any(Symbol).asymmetricMatch(Object(Symbol())),\n    any(Array).asymmetricMatch(runInNewContext('[];')),\n    /* eslint-enable */\n  ]) {\n    jestExpect(test).toBe(true);\n  }\n});\n\ntest('Any.toAsymmetricMatcher()', () => {\n  jestExpect(any(Number).toAsymmetricMatcher()).toBe('Any<Number>');\n});\n\ntest('Any.toAsymmetricMatcher() with function name', () => {\n  for (const [name, fn] of [\n    ['someFunc', function someFunc() {}],\n    ['$someFunc', function $someFunc() {}],\n    [\n      '$someFunc2',\n      (function () {\n        function $someFunc2() {}\n        Object.defineProperty($someFunc2, 'name', {value: ''});\n        return $someFunc2;\n      })(),\n    ],\n    [\n      '$someAsyncFunc',\n      (function () {\n        async function $someAsyncFunc() {}\n        Object.defineProperty($someAsyncFunc, 'name', {value: ''});\n        return $someAsyncFunc;\n      })(),\n    ],\n    [\n      '$someGeneratorFunc',\n      (function () {\n        function* $someGeneratorFunc() {}\n        Object.defineProperty($someGeneratorFunc, 'name', {value: ''});\n        return $someGeneratorFunc;\n      })(),\n    ],\n    [\n      '$someFuncWithFakeToString',\n      (function () {\n        function $someFuncWithFakeToString() {}\n        $someFuncWithFakeToString.toString = () => 'Fake to string';\n        return $someFuncWithFakeToString;\n      })(),\n    ],\n  ]) {\n    jestExpect(any(fn).toAsymmetricMatcher()).toBe(`Any<${name}>`);\n  }\n});\n\ntest('Any throws when called with empty constructor', () => {\n  // @ts-expect-error: Testing runtime error\n  jestExpect(() => any()).toThrow(\n    'any() expects to be passed a constructor function. Please pass one or use anything() to match any object.',\n  );\n});\n\ntest('Anything matches any type', () => {\n  for (const test of [\n    anything().asymmetricMatch('jest'),\n    anything().asymmetricMatch(1),\n    anything().asymmetricMatch(() => {}),\n    anything().asymmetricMatch(true),\n    anything().asymmetricMatch({}),\n    anything().asymmetricMatch([]),\n  ]) {\n    jestExpect(test).toBe(true);\n  }\n});\n\ntest('Anything does not match null and undefined', () => {\n  for (const test of [\n    anything().asymmetricMatch(null),\n    anything().asymmetricMatch(undefined),\n  ]) {\n    jestExpect(test).toBe(false);\n  }\n});\n\ntest('Anything.toAsymmetricMatcher()', () => {\n  jestExpect(anything().toAsymmetricMatcher()).toBe('Anything');\n});\n\ntest('ArrayContaining matches', () => {\n  for (const test of [\n    arrayContaining([]).asymmetricMatch('jest'),\n    arrayContaining(['foo']).asymmetricMatch(['foo']),\n    arrayContaining(['foo']).asymmetricMatch(['foo', 'bar']),\n    arrayContaining([]).asymmetricMatch({}),\n  ]) {\n    jestExpect(test).toEqual(true);\n  }\n});\n\ntest('ArrayContaining does not match', () => {\n  jestExpect(arrayContaining(['foo']).asymmetricMatch(['bar'])).toBe(false);\n});\n\ntest('ArrayContaining throws for non-arrays', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    arrayContaining('foo').asymmetricMatch([]);\n  }).toThrow(\"You must provide an array to ArrayContaining, not 'string'.\");\n});\n\ntest('ArrayNotContaining matches', () => {\n  jestExpect(arrayNotContaining(['foo']).asymmetricMatch(['bar'])).toBe(true);\n});\n\ntest('ArrayNotContaining does not match', () => {\n  for (const test of [\n    arrayNotContaining([]).asymmetricMatch('jest'),\n    arrayNotContaining(['foo']).asymmetricMatch(['foo']),\n    arrayNotContaining(['foo']).asymmetricMatch(['foo', 'bar']),\n    arrayNotContaining([]).asymmetricMatch({}),\n  ]) {\n    jestExpect(test).toEqual(false);\n  }\n});\n\ntest('ArrayNotContaining throws for non-arrays', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    arrayNotContaining('foo').asymmetricMatch([]);\n  }).toThrow(\"You must provide an array to ArrayNotContaining, not 'string'.\");\n});\n\ntest('ObjectContaining matches', () => {\n  const foo = Symbol('foo');\n  for (const test of [\n    objectContaining({}).asymmetricMatch('jest'),\n    objectContaining({foo: 'foo'}).asymmetricMatch({foo: 'foo', jest: 'jest'}),\n    objectContaining({foo: undefined}).asymmetricMatch({foo: undefined}),\n    objectContaining({first: objectContaining({second: {}})}).asymmetricMatch({\n      first: {second: {}},\n    }),\n    objectContaining({foo: Buffer.from('foo')}).asymmetricMatch({\n      foo: Buffer.from('foo'),\n      jest: 'jest',\n    }),\n    objectContaining({[foo]: 'foo'}).asymmetricMatch({[foo]: 'foo'}),\n  ]) {\n    jestExpect(test).toEqual(true);\n  }\n});\n\ntest('ObjectContaining does not match', () => {\n  const foo = Symbol('foo');\n  const bar = Symbol('bar');\n  for (const test of [\n    objectContaining({foo: 'foo'}).asymmetricMatch({bar: 'bar'}),\n    objectContaining({foo: 'foo'}).asymmetricMatch({foo: 'foox'}),\n    objectContaining({foo: undefined}).asymmetricMatch({}),\n    objectContaining({\n      answer: 42,\n      foo: {bar: 'baz', foobar: 'qux'},\n    }).asymmetricMatch({foo: {bar: 'baz'}}),\n    objectContaining({[foo]: 'foo'}).asymmetricMatch({[bar]: 'bar'}),\n  ]) {\n    jestExpect(test).toEqual(false);\n  }\n});\n\ntest('ObjectContaining matches defined properties', () => {\n  const definedPropertyObject = {};\n  Object.defineProperty(definedPropertyObject, 'foo', {get: () => 'bar'});\n  jestExpect(\n    objectContaining({foo: 'bar'}).asymmetricMatch(definedPropertyObject),\n  ).toBe(true);\n});\n\ntest('ObjectContaining matches prototype properties', () => {\n  const prototypeObject = {foo: 'bar'};\n  let obj;\n\n  if (Object.create) {\n    obj = Object.create(prototypeObject);\n  } else {\n    function Foo() {}\n    Foo.prototype = prototypeObject;\n    Foo.prototype.constructor = Foo;\n    obj = new (Foo as any)();\n  }\n  jestExpect(objectContaining({foo: 'bar'}).asymmetricMatch(obj)).toBe(true);\n});\n\ntest('ObjectContaining throws for non-objects', () => {\n  // @ts-expect-error: Testing runtime error\n  jestExpect(() => objectContaining(1337).asymmetricMatch()).toThrow(\n    \"You must provide an object to ObjectContaining, not 'number'.\",\n  );\n});\n\ntest('ObjectContaining does not mutate the sample', () => {\n  const sample = {foo: {bar: {}}};\n  const sample_json = JSON.stringify(sample);\n  expect({foo: {bar: {}}}).toEqual(expect.objectContaining(sample));\n\n  expect(JSON.stringify(sample)).toEqual(sample_json);\n});\n\ntest('ObjectNotContaining matches', () => {\n  const foo = Symbol('foo');\n  const bar = Symbol('bar');\n  for (const test of [\n    objectContaining({}).asymmetricMatch(null),\n    objectContaining({}).asymmetricMatch(undefined),\n    objectNotContaining({[foo]: 'foo'}).asymmetricMatch({[bar]: 'bar'}),\n    objectNotContaining({foo: 'foo'}).asymmetricMatch({bar: 'bar'}),\n    objectNotContaining({foo: 'foo'}).asymmetricMatch({foo: 'foox'}),\n    objectNotContaining({foo: undefined}).asymmetricMatch({}),\n    objectNotContaining({\n      first: objectNotContaining({second: {}}),\n    }).asymmetricMatch({first: {second: {}}}),\n    objectNotContaining({first: {second: {}, third: {}}}).asymmetricMatch({\n      first: {second: {}},\n    }),\n    objectNotContaining({first: {second: {}}}).asymmetricMatch({\n      first: {second: {}, third: {}},\n    }),\n    objectNotContaining({foo: 'foo', jest: 'jest'}).asymmetricMatch({\n      foo: 'foo',\n    }),\n  ]) {\n    jestExpect(test).toEqual(true);\n  }\n});\n\ntest('ObjectNotContaining does not match', () => {\n  for (const test of [\n    objectNotContaining({}).asymmetricMatch('jest'),\n    objectNotContaining({foo: 'foo'}).asymmetricMatch({\n      foo: 'foo',\n      jest: 'jest',\n    }),\n    objectNotContaining({foo: undefined}).asymmetricMatch({foo: undefined}),\n    objectNotContaining({first: {second: {}}}).asymmetricMatch({\n      first: {second: {}},\n    }),\n    objectNotContaining({\n      first: objectContaining({second: {}}),\n    }).asymmetricMatch({first: {second: {}}}),\n    objectNotContaining({}).asymmetricMatch(null),\n    objectNotContaining({}).asymmetricMatch(undefined),\n    objectNotContaining({}).asymmetricMatch({}),\n  ]) {\n    jestExpect(test).toEqual(false);\n  }\n});\n\ntest('ObjectNotContaining inverts ObjectContaining', () => {\n  for (const [sample, received] of [\n    [{}, null],\n    [{foo: 'foo'}, {foo: 'foo', jest: 'jest'}],\n    [{foo: 'foo', jest: 'jest'}, {foo: 'foo'}],\n    [{foo: undefined}, {foo: undefined}],\n    [{foo: undefined}, {}],\n    [{first: {second: {}}}, {first: {second: {}}}],\n    [{first: objectContaining({second: {}})}, {first: {second: {}}}],\n    [{first: objectNotContaining({second: {}})}, {first: {second: {}}}],\n    [{}, {foo: undefined}],\n  ] as const) {\n    jestExpect(objectNotContaining(sample).asymmetricMatch(received)).toEqual(\n      !objectContaining(sample).asymmetricMatch(received),\n    );\n  }\n});\n\ntest('ObjectNotContaining throws for non-objects', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    objectNotContaining(1337).asymmetricMatch();\n  }).toThrow(\n    \"You must provide an object to ObjectNotContaining, not 'number'.\",\n  );\n});\n\ntest('StringContaining matches string against string', () => {\n  jestExpect(stringContaining('en*').asymmetricMatch('queen*')).toBe(true);\n  jestExpect(stringContaining('en').asymmetricMatch('queue')).toBe(false);\n});\n\ntest('StringContaining throws if expected value is not string', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    stringContaining([1]).asymmetricMatch('queen');\n  }).toThrow('Expected is not a string');\n});\n\ntest('StringContaining returns false if received value is not string', () => {\n  jestExpect(stringContaining('en*').asymmetricMatch(1)).toBe(false);\n});\n\ntest('StringNotContaining matches string against string', () => {\n  jestExpect(stringNotContaining('en*').asymmetricMatch('queen*')).toBe(false);\n  jestExpect(stringNotContaining('en').asymmetricMatch('queue')).toBe(true);\n});\n\ntest('StringNotContaining throws if expected value is not string', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    stringNotContaining([1]).asymmetricMatch('queen');\n  }).toThrow('Expected is not a string');\n});\n\ntest('StringNotContaining returns true if received value is not string', () => {\n  jestExpect(stringNotContaining('en*').asymmetricMatch(1)).toBe(true);\n});\n\ntest('StringMatching matches string against regexp', () => {\n  jestExpect(stringMatching(/en/).asymmetricMatch('queen')).toBe(true);\n  jestExpect(stringMatching(/en/).asymmetricMatch('queue')).toBe(false);\n});\n\ntest('StringMatching matches string against string', () => {\n  jestExpect(stringMatching('en').asymmetricMatch('queen')).toBe(true);\n  jestExpect(stringMatching('en').asymmetricMatch('queue')).toBe(false);\n});\n\ntest('StringMatching throws if expected value is neither string nor regexp', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    stringMatching([1]).asymmetricMatch('queen');\n  }).toThrow('Expected is not a String or a RegExp');\n});\n\ntest('StringMatching returns false if received value is not string', () => {\n  jestExpect(stringMatching('en').asymmetricMatch(1)).toBe(false);\n});\n\ntest('StringMatching returns false even if coerced non-string received value matches pattern', () => {\n  jestExpect(stringMatching('null').asymmetricMatch(null)).toBe(false);\n});\n\ntest('StringNotMatching matches string against regexp', () => {\n  jestExpect(stringNotMatching(/en/).asymmetricMatch('queen')).toBe(false);\n  jestExpect(stringNotMatching(/en/).asymmetricMatch('queue')).toBe(true);\n});\n\ntest('StringNotMatching matches string against string', () => {\n  jestExpect(stringNotMatching('en').asymmetricMatch('queen')).toBe(false);\n  jestExpect(stringNotMatching('en').asymmetricMatch('queue')).toBe(true);\n});\n\ntest('StringNotMatching throws if expected value is neither string nor regexp', () => {\n  jestExpect(() => {\n    // @ts-expect-error: Testing runtime error\n    stringNotMatching([1]).asymmetricMatch('queen');\n  }).toThrow('Expected is not a String or a RegExp');\n});\n\ntest('StringNotMatching returns true if received value is not string', () => {\n  jestExpect(stringNotMatching('en').asymmetricMatch(1)).toBe(true);\n});\n\ndescribe('closeTo', () => {\n  for (const [expected, received] of [\n    [0, 0],\n    [0, 0.001],\n    [1.23, 1.229],\n    [1.23, 1.226],\n    [1.23, 1.225],\n    [1.23, 1.234],\n    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\n  ]) {\n    test(`${expected} closeTo ${received} return true`, () => {\n      jestExpect(closeTo(expected).asymmetricMatch(received)).toBe(true);\n    });\n    test(`${expected} notCloseTo ${received} return false`, () => {\n      jestExpect(notCloseTo(expected).asymmetricMatch(received)).toBe(false);\n    });\n  }\n\n  for (const [expected, received] of [\n    [0, 0.01],\n    [1, 1.23],\n    [1.23, 1.224_999_9],\n    [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY],\n    [Number.POSITIVE_INFINITY, 1.23],\n    [Number.NEGATIVE_INFINITY, -1.23],\n  ]) {\n    test(`${expected} closeTo ${received} return false`, () => {\n      jestExpect(closeTo(expected).asymmetricMatch(received)).toBe(false);\n    });\n    test(`${expected} notCloseTo ${received} return true`, () => {\n      jestExpect(notCloseTo(expected).asymmetricMatch(received)).toBe(true);\n    });\n  }\n\n  for (const [expected, received, precision] of [\n    [0, 0.1, 0],\n    [0, 0.0001, 3],\n    [0, 0.000_004, 5],\n    [2.000_000_2, 2, 5],\n  ]) {\n    test(`${expected} closeTo ${received} with precision ${precision} return true`, () => {\n      jestExpect(closeTo(expected, precision).asymmetricMatch(received)).toBe(\n        true,\n      );\n    });\n    test(`${expected} notCloseTo ${received} with precision ${precision} return false`, () => {\n      jestExpect(\n        notCloseTo(expected, precision).asymmetricMatch(received),\n      ).toBe(false);\n    });\n  }\n\n  for (const [expected, received, precision] of [\n    [3.141_592e-7, 3e-7, 8],\n    [56_789, 51_234, -4],\n  ]) {\n    test(`${expected} closeTo ${received} with precision ${precision} return false`, () => {\n      jestExpect(closeTo(expected, precision).asymmetricMatch(received)).toBe(\n        false,\n      );\n    });\n    test(`${expected} notCloseTo ${received} with precision ${precision} return true`, () => {\n      jestExpect(\n        notCloseTo(expected, precision).asymmetricMatch(received),\n      ).toBe(true);\n    });\n  }\n\n  test('closeTo throw if expected is not number', () => {\n    jestExpect(() => {\n      // @ts-expect-error: Testing runtime error\n      closeTo('a');\n    }).toThrow('Expected is not a Number');\n  });\n\n  test('notCloseTo throw if expected is not number', () => {\n    jestExpect(() => {\n      // @ts-expect-error: Testing runtime error\n      notCloseTo('a');\n    }).toThrow('Expected is not a Number');\n  });\n\n  test('closeTo throw if precision is not number', () => {\n    jestExpect(() => {\n      // @ts-expect-error: Testing runtime error\n      closeTo(1, 'a');\n    }).toThrow('Precision is not a Number');\n  });\n\n  test('notCloseTo throw if precision is not number', () => {\n    jestExpect(() => {\n      // @ts-expect-error: Testing runtime error\n      notCloseTo(1, 'a');\n    }).toThrow('Precision is not a Number');\n  });\n\n  test('closeTo return false if received is not number', () => {\n    jestExpect(closeTo(1).asymmetricMatch('a')).toBe(false);\n  });\n\n  test('notCloseTo return false if received is not number', () => {\n    jestExpect(notCloseTo(1).asymmetricMatch('a')).toBe(false);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJasmine();\n\ntest('errors when a test both returns a promise and takes a callback', () => {\n  const result = runJest('promise-and-callback');\n\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n  expect(result.exitCode).toBe(1);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`errors when a test both returns a promise and takes a callback 1`] = `\n\"FAIL __tests__/promise-and-callback.test.js\n  ✕ promise-returning test with callback\n  ✕ async test with callback\n  ✕ test done before return value\n\n  ● promise-returning test with callback\n\n    Test functions cannot both take a 'done' callback and return something. Either use a 'done' callback, or return a promise.\n    Returned value: Promise {}\n\n       8 | 'use strict';\n       9 |\n    > 10 | it('promise-returning test with callback', done => {\n         | ^\n      11 |   done();\n      12 |\n      13 |   return Promise.resolve();\n\n      at Object.it (__tests__/promise-and-callback.test.js:10:1)\n\n  ● async test with callback\n\n    Test functions cannot both take a 'done' callback and return something. Either use a 'done' callback, or return a promise.\n    Returned value: Promise {}\n\n      14 | });\n      15 |\n    > 16 | it('async test with callback', async done => {\n         | ^\n      17 |   done();\n      18 | });\n      19 |\n\n      at Object.it (__tests__/promise-and-callback.test.js:16:1)\n\n  ● test done before return value\n\n    Test functions cannot both take a 'done' callback and return something. Either use a 'done' callback, or return a promise.\n    Returned value: \"foobar\"\n\n      18 | });\n      19 |\n    > 20 | it('test done before return value', done => {\n         | ^\n      21 |   done();\n      22 |\n      23 |   return 'foobar';\n\n      at Object.it (__tests__/promise-and-callback.test.js:20:1)\"\n`;"}
{"prompt":"describe,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('describe', () => {\n  test('correct test def', () => {});\n\n  Promise.resolve().then(() => {\n    test('async definition inside describe', () => {});\n    afterAll(() => {});\n  });\n});\n\nPromise.resolve().then(() => {\n  test('async definition outside describe', () => {});\n  afterAll(() => {});\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\ntest('resolve, but fail', () =>\n  expect(Promise.resolve({foo: 'bar'})).resolves.toEqual({baz: 'bar'}));\n\ntest('reject, but fail', () =>\n  expect(Promise.reject({foo: 'bar'})).rejects.toEqual({baz: 'bar'}));\n\ntest('expect reject', () =>\n  expect(Promise.resolve({foo: 'bar'})).rejects.toEqual({foo: 'bar'}));\n\ntest('expect resolve', () =>\n  expect(Promise.reject({foo: 'bar'})).resolves.toEqual({foo: 'bar'}));\n\ntest('timeout', done => {\n  setTimeout(done, 50);\n}, 5);"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexpect.extend({toThrowCustomAsyncMatcherError});\n\ntest('showing the stack trace for an async matcher', () =>\n  expect(true).toThrowCustomAsyncMatcherError());\n\nfunction toThrowCustomAsyncMatcherError() {\n  const message = () =>\n    'We expect the stack trace and code fence for this matcher to be shown in the console.';\n  return Promise.resolve({message, pass: false});\n}"}
{"prompt":"--no-cache because babel can cache stuff and result in false green","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {runYarnInstall} from '../Utils';\nimport {json as runWithJson} from '../runJest';\n\nconst dir = path.resolve(__dirname, '../async-regenerator');\n\nbeforeEach(() => {\n  runYarnInstall(dir);\n});\n\ntest('successfully transpiles async', () => {\n  // --no-cache because babel can cache stuff and result in false green\n  const {json} = runWithJson(dir, ['--no-cache']);\n  expect(json.success).toBe(true);\n  expect(json.numTotalTests).toBe(1);\n});"}
{"prompt":"async test fails, done => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n'use strict';\n\nit('async test fails', done => {\n  setTimeout(() => {\n    expect(false).toBeTruthy();\n    done();\n  }, 1 * 1000);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst phrase = require('../common-file');\n\ntest('A', () => {\n  expect(phrase).toBe('hello');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('suite with auto-clear', () => {\n  const result = runJest('auto-clear-mocks/with-auto-clear');\n  expect(result.exitCode).toBe(0);\n});\n\ntest('suite without auto-clear', () => {\n  const result = runJest('auto-clear-mocks/without-auto-clear');\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\nimport utils from '../utils';\n\ntest('if utils are mocked', () => {\n  expect(utils.authorize.mock).toBeTruthy();\n  expect(utils.isAuthorized.mock).toBeTruthy();\n});\n\ntest('mocked implementation', () => {\n  utils.authorize.mockReturnValue('mocked_token');\n  utils.isAuthorized.mockReturnValue(true);\n\n  expect(utils.authorize()).toBe('mocked_token');\n  expect(utils.isAuthorized('not_wizard')).toBeTruthy();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('suite with auto-reset', () => {\n  const result = runJest('auto-reset-mocks/with-auto-reset');\n  expect(result.exitCode).toBe(0);\n});\n\ntest('suite without auto-reset', () => {\n  const result = runJest('auto-reset-mocks/without-auto-reset');\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('suite with auto-restore', () => {\n  const result = runJest('auto-restore-mocks/with-auto-restore');\n  expect(result.exitCode).toBe(0);\n});\n\ntest('suite without auto-restore', () => {\n  const result = runJest('auto-restore-mocks/without-auto-restore');\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ntest('b', () => {});"}
{"prompt":"strips flowtypes using babel-jest and .babelrc,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nrequire('../foo');\n\nit('strips flowtypes using babel-jest and .babelrc', () => {\n  const a: string = 'a';\n  expect(a).toBe('a');\n});"}
{"prompt":"successfully runs the tests inside babel-plugin-jest-hoist/,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {runYarnInstall} from '../Utils';\nimport {json as runWithJson} from '../runJest';\n\nconst DIR = path.resolve(__dirname, '..', 'babel-plugin-jest-hoist');\n\nbeforeEach(() => {\n  runYarnInstall(DIR);\n});\n\nit('successfully runs the tests inside `babel-plugin-jest-hoist/`', () => {\n  const {json} = runWithJson(DIR, ['--no-cache', '--coverage']);\n  expect(json.success).toBe(true);\n  expect(json.numTotalTestSuites).toBe(4);\n});"}
{"prompt":"should fail with a proper stacktrace,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nit('should fail with a proper stacktrace', () => {\n  expect(true).toBe(false);\n});\n\n//# sourceMappingURL=badSourceMap.js.map"}
{"prompt":"Test generated from existing file","test":"{\"version\":3,\"file\":\"badSourceMap.js\",\"sources\":[\"dummy:///./index.js\"],\"sourcesContent\":[\"\"],\"mappings\":\";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACRA;;;;;;;;;;;;;;;;A\",\"sourceRoot\":\"\"}"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('suite with test cases that contain malformed sourcemaps', () => {\n  const result = runJest('bad-source-map');\n  expect(result.stderr).not.toMatch('ENOENT');\n});"}
{"prompt":"Typo in the implementation should cause the test to fail","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst {toMatchInlineSnapshot} = require('jest-snapshot');\n\nexpect.extend({\n  toMatchStateInlineSnapshot(...args) {\n    this.dontThrow = () => {};\n    return toMatchInlineSnapshot.call(this, ...args);\n  },\n});\n\nlet state = 'initial';\nfunction transition() {\n  // Typo in the implementation should cause the test to fail\n  if (state === 'INITIAL') {\n    state = 'pending';\n  } else if (state === 'pending') {\n    state = 'done';\n  }\n}\n\nit('transitions as expected', () => {\n  expect(state).toMatchStateInlineSnapshot(`\"initial\"`);\n  transition();\n  // Already produces a mismatch. No point in continuing the test.\n  expect(state).toMatchStateInlineSnapshot(`\"loading\"`);\n  transition();\n  expect(state).toMatchStateInlineSnapshot(`\"done\"`);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nmodule.exports = Symbol();"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('stub', () => expect(2).toBe(2));"}
{"prompt":"describe,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {runTest} from '../__mocks__/testUtils';\n\ntest('simple test', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      beforeEach(() => {});\n      afterEach(() => {});\n      test('one', () => {});\n      test('two', () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('function descriptors', () => {\n  const {stdout} = runTest(`\n    describe(function describer() {}, () => {\n      test(class One {}, () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('failures', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      beforeEach(() => {});\n      afterEach(() => { throw new Error('banana')});\n      test('one', () => { throw new Error('kentucky')});\n      test('two', () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('concurrent', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      beforeEach(() => {});\n      afterEach(() => { throw new Error('banana')});\n      test.concurrent('one', () => { \n        console.log('hello one');\n        throw new Error('kentucky')\n      });\n      test.concurrent('two', () => {\n        console.log('hello two');\n      });\n      test.concurrent('three', async () => { \n        console.log('hello three');\n        await Promise.resolve(); \n      });\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('concurrent.each', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      beforeEach(() => {});\n      afterEach(() => { throw new Error('banana')});\n      test.concurrent.each([\n        ['one'],\n        ['two'],\n        ['three'],\n      ])('%s', async (name) => {\n        console.log('hello %s', name);\n        await Promise.resolve(); \n      });\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`concurrent 1`] = `\n\"start_describe_definition: describe\nadd_hook: beforeEach\nadd_hook: afterEach\nadd_test: one\nadd_test: two\nadd_test: three\nfinish_describe_definition: describe\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe\ntest_start: one\ntest_start: two\ntest_start: three\ntest_started: one\ntest_started: two\ntest_started: three\ntest_fn_start: one\ntest_fn_start: two\ntest_fn_start: three\nhello one\nhello two\nhello three\ntest_fn_failure: one\ntest_fn_success: two\ntest_fn_success: three\ntest_done: one\ntest_done: two\ntest_done: three\nrun_describe_finish: describe\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;\n\nexports[`concurrent.each 1`] = `\n\"start_describe_definition: describe\nadd_hook: beforeEach\nadd_hook: afterEach\nadd_test: one\nadd_test: two\nadd_test: three\nfinish_describe_definition: describe\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe\ntest_start: one\ntest_start: two\ntest_start: three\ntest_started: one\ntest_started: two\ntest_started: three\ntest_fn_start: one\ntest_fn_start: two\ntest_fn_start: three\nhello one\nhello two\nhello three\ntest_fn_success: one\ntest_fn_success: two\ntest_fn_success: three\ntest_done: one\ntest_done: two\ntest_done: three\nrun_describe_finish: describe\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;\n\nexports[`failures 1`] = `\n\"start_describe_definition: describe\nadd_hook: beforeEach\nadd_hook: afterEach\nadd_test: one\nadd_test: two\nfinish_describe_definition: describe\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe\ntest_start: one\ntest_started: one\nhook_start: beforeEach\nhook_success: beforeEach\ntest_fn_start: one\ntest_fn_failure: one\nhook_start: afterEach\nhook_failure: afterEach\ntest_done: one\ntest_start: two\ntest_started: two\nhook_start: beforeEach\nhook_success: beforeEach\ntest_fn_start: two\ntest_fn_success: two\nhook_start: afterEach\nhook_failure: afterEach\ntest_done: two\nrun_describe_finish: describe\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;\n\nexports[`function descriptors 1`] = `\n\"start_describe_definition: describer\nadd_test: One\nfinish_describe_definition: describer\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describer\ntest_start: One\ntest_started: One\ntest_fn_start: One\ntest_fn_success: One\ntest_done: One\nrun_describe_finish: describer\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;\n\nexports[`simple test 1`] = `\n\"start_describe_definition: describe\nadd_hook: beforeEach\nadd_hook: afterEach\nadd_test: one\nadd_test: two\nfinish_describe_definition: describe\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe\ntest_start: one\ntest_started: one\nhook_start: beforeEach\nhook_success: beforeEach\ntest_fn_start: one\ntest_fn_success: one\nhook_start: afterEach\nhook_success: afterEach\ntest_done: one\ntest_start: two\ntest_started: two\nhook_start: beforeEach\nhook_success: beforeEach\ntest_fn_start: two\ntest_fn_success: two\nhook_start: afterEach\nhook_success: afterEach\ntest_done: two\nrun_describe_finish: describe\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;"}
{"prompt":"BaseWorkerPool,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  CHILD_MESSAGE_END,\n  type WorkerInterface,\n  type WorkerOptions,\n  type WorkerPoolOptions,\n} from '../../types';\nimport BaseWorkerPool from '../BaseWorkerPool';\n\nconst Worker =\n  jest.fn<\n    (workerOptions: Omit<WorkerOptions, 'resourceLimits'>) => WorkerInterface\n  >();\n\nconst mockSend = jest.fn();\n\nclass MockWorkerPool extends BaseWorkerPool {\n  override createWorker(workerOptions: WorkerOptions) {\n    return new Worker(workerOptions);\n  }\n  send(...args: Array<unknown>) {\n    return mockSend(...args);\n  }\n}\n\ndescribe('BaseWorkerPool', () => {\n  beforeEach(() => {\n    Worker.mockClear();\n    Worker.mockImplementation(\n      () =>\n        ({\n          forceExit: jest.fn(),\n          getStderr: () =>\n            ({once() {}, pipe() {}}) as unknown as NodeJS.ReadStream,\n          getStdout: () =>\n            ({once() {}, pipe() {}}) as unknown as NodeJS.ReadStream,\n          send: jest.fn(),\n          waitForExit: () => Promise.resolve(),\n        }) as unknown as WorkerInterface,\n    );\n  });\n\n  it('throws error when createWorker is not defined', () => {\n    expect(\n      () =>\n        new BaseWorkerPool('/tmp/baz.js', {\n          forkOptions: {execArgv: []},\n          maxRetries: 6,\n          numWorkers: 4,\n          setupArgs: [],\n        } as unknown as WorkerPoolOptions),\n    ).toThrow('Missing method createWorker in WorkerPool');\n  });\n\n  it('creates and exposes n workers', () => {\n    const pool = new MockWorkerPool('/tmp/baz.js', {\n      forkOptions: {execArgv: []},\n      maxRetries: 6,\n      numWorkers: 4,\n      setupArgs: [],\n    } as unknown as WorkerPoolOptions);\n\n    expect(pool.getWorkers()).toHaveLength(4);\n    expect(pool.getWorkerById(0)).toBeDefined();\n    expect(pool.getWorkerById(1)).toBeDefined();\n    expect(pool.getWorkerById(2)).toBeDefined();\n    expect(pool.getWorkerById(3)).toBeDefined();\n  });\n\n  it('creates workers with the right options', () => {\n    // eslint-disable-next-line no-new\n    new MockWorkerPool('/tmp/baz.js', {\n      forkOptions: {execArgv: []},\n      maxRetries: 6,\n      numWorkers: 4,\n      setupArgs: [{foo: 'bar'}],\n    } as unknown as WorkerPoolOptions);\n\n    expect(Worker).toHaveBeenCalledTimes(4);\n    expect(Worker).toHaveBeenNthCalledWith(1, {\n      forkOptions: {execArgv: []},\n      maxRetries: 6,\n      setupArgs: [{foo: 'bar'}],\n      workerId: 0,\n      workerPath: '/tmp/baz.js',\n    });\n    expect(Worker).toHaveBeenNthCalledWith(2, {\n      forkOptions: {execArgv: []},\n      maxRetries: 6,\n      setupArgs: [{foo: 'bar'}],\n      workerId: 1,\n      workerPath: '/tmp/baz.js',\n    });\n    expect(Worker).toHaveBeenNthCalledWith(3, {\n      forkOptions: {execArgv: []},\n      maxRetries: 6,\n      setupArgs: [{foo: 'bar'}],\n      workerId: 2,\n      workerPath: '/tmp/baz.js',\n    });\n    expect(Worker).toHaveBeenNthCalledWith(4, {\n      forkOptions: {execArgv: []},\n      maxRetries: 6,\n      setupArgs: [{foo: 'bar'}],\n      workerId: 3,\n      workerPath: '/tmp/baz.js',\n    });\n  });\n\n  it('create multiple workers with unique worker ids', () => {\n    // eslint-disable-next-line no-new\n    new MockWorkerPool('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      forkOptions: {execArgv: []},\n      maxRetries: 6,\n      numWorkers: 3,\n    } as unknown as WorkerPoolOptions);\n\n    expect(Worker).toHaveBeenCalledTimes(3);\n    expect(Worker.mock.calls[0][0].workerId).toBe(0);\n    expect(Worker.mock.calls[1][0].workerId).toBe(1);\n    expect(Worker.mock.calls[2][0].workerId).toBe(2);\n  });\n\n  it('aggregates all stdouts and stderrs from all workers', () => {\n    const out: Array<NodeJS.WritableStream> = [];\n    const err: Array<NodeJS.WritableStream> = [];\n\n    Worker.mockImplementation(\n      () =>\n        ({\n          getStderr: () =>\n            ({\n              once() {},\n              pipe(errStream: NodeJS.WritableStream) {\n                err.push(errStream);\n              },\n            }) as unknown as NodeJS.ReadableStream,\n          getStdout: () =>\n            ({\n              once() {},\n              pipe(outStream: NodeJS.WritableStream) {\n                out.push(outStream);\n              },\n            }) as unknown as NodeJS.ReadableStream,\n        }) as WorkerInterface,\n    );\n\n    const farm = new MockWorkerPool('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 2,\n    } as unknown as WorkerPoolOptions);\n\n    expect(out).toHaveLength(2);\n    expect(err).toHaveLength(2);\n\n    const stdout = jest.fn<(a: string) => void>();\n    const stderr = jest.fn<(a: string) => void>();\n\n    farm.getStdout().on('data', stdout);\n    farm.getStderr().on('data', stderr);\n\n    out[0].write(Buffer.from('hello'));\n    out[1].write(Buffer.from('bye'));\n    err[1].write(Buffer.from('house'));\n    err[0].write(Buffer.from('tree'));\n\n    expect(stdout.mock.calls[0][0].toString()).toBe('hello');\n    expect(stdout.mock.calls[1][0].toString()).toBe('bye');\n    expect(stderr.mock.calls[0][0].toString()).toBe('house');\n    expect(stderr.mock.calls[1][0].toString()).toBe('tree');\n  });\n\n  it('works when stdout and stderr are not piped to the parent', () => {\n    Worker.mockImplementation(\n      () =>\n        ({\n          getStderr: () => null,\n          getStdout: () => null,\n          send: () => null,\n        }) as unknown as WorkerInterface,\n    );\n\n    const farm = new MockWorkerPool('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      forkOptions: {\n        silent: false,\n        stdio: 'inherit',\n      },\n      numWorkers: 2,\n    } as unknown as WorkerPoolOptions);\n\n    expect(() => farm.send()).not.toThrow();\n    expect(() => farm.send()).not.toThrow();\n  });\n\n  describe('end', () => {\n    it('ends all workers', async () => {\n      const pool = new MockWorkerPool('/tmp/baz.js', {\n        forkOptions: {execArgv: []},\n        maxRetries: 6,\n        numWorkers: 4,\n        setupArgs: [],\n      } as unknown as WorkerPoolOptions);\n\n      const workers = pool.getWorkers();\n      await pool.end();\n\n      const endMessage = [CHILD_MESSAGE_END, false];\n      expect(jest.mocked(workers[0].send).mock.calls[0][0]).toEqual(endMessage);\n      expect(jest.mocked(workers[1].send).mock.calls[0][0]).toEqual(endMessage);\n      expect(jest.mocked(workers[2].send).mock.calls[0][0]).toEqual(endMessage);\n      expect(jest.mocked(workers[3].send).mock.calls[0][0]).toEqual(endMessage);\n    });\n\n    it('resolves with forceExited=false if workers exited gracefully', async () => {\n      Worker.mockImplementation(\n        () =>\n          ({\n            forceExit: jest.fn(),\n            getStderr: () => null,\n            getStdout: () => null,\n            send: jest.fn(),\n            waitForExit: () => Promise.resolve(),\n          }) as unknown as WorkerInterface,\n      );\n\n      const pool = new MockWorkerPool('/tmp/baz.js', {\n        forkOptions: {execArgv: []},\n        maxRetries: 6,\n        numWorkers: 4,\n        setupArgs: [],\n      } as unknown as WorkerPoolOptions);\n\n      expect(await pool.end()).toEqual({forceExited: false});\n    });\n\n    it('force exits workers that do not exit gracefully and resolves with forceExited=true', async () => {\n      // Set it up so that the first worker does not resolve waitForExit immediately,\n      // but only when forceExit() is called\n      let worker0Exited: (a?: unknown) => void;\n      Worker.mockImplementationOnce(\n        () =>\n          ({\n            forceExit: () => {\n              worker0Exited();\n            },\n            getStderr: () => null,\n            getStdout: () => null,\n            send: jest.fn(),\n            waitForExit: () =>\n              new Promise(resolve => (worker0Exited = resolve)),\n          }) as unknown as WorkerInterface,\n      ).mockImplementation(\n        () =>\n          ({\n            forceExit: jest.fn(),\n            getStderr: () => null,\n            getStdout: () => null,\n            send: jest.fn(),\n            waitForExit: () => Promise.resolve(),\n          }) as unknown as WorkerInterface,\n      );\n\n      const pool = new MockWorkerPool('/tmp/baz.js', {\n        forkOptions: {execArgv: []},\n        maxRetries: 6,\n        numWorkers: 2,\n        setupArgs: [],\n      } as unknown as WorkerPoolOptions);\n\n      const workers = pool.getWorkers();\n      expect(await pool.end()).toEqual({forceExited: true});\n\n      expect(workers[1].forceExit).not.toHaveBeenCalled();\n    });\n  });\n});"}
{"prompt":"should not be retried because hook failure occurred,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\njest.retryTimes(3);\n\nbeforeAll(() => {\n  throw new Error('Failure in beforeAll');\n});\n\nit('should not be retried because hook failure occurred', () => {\n  throw new Error('should not be invoked');\n});"}
{"prompt":".concurrentshould not be retried because hook failure occurred,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\njest.retryTimes(3);\n\nbeforeAll(() => {\n  throw new Error('Failure in beforeAll');\n});\n\nit.concurrent('should not be retried because hook failure occurred', () => {\n  throw new Error('should not be invoked');\n});\n\nit.concurrent('should fail due to the beforeAll', () => {\n  expect(10).toBe(10);\n});"}
{"prompt":".skipin describe.skip,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nlet hasBeforeAllRun = false;\nlet hasAfterAllRun = false;\n\ndescribe.skip('in describe.skip', () => {\n  describe('in describe', () => {\n    beforeAll(() => {\n      hasBeforeAllRun = true;\n    });\n\n    afterAll(() => {\n      hasAfterAllRun = true;\n    });\n\n    test('it should be skipped', () => {\n      throw new Error('This should never happen');\n    });\n\n    // eslint-disable-next-line jest/no-focused-tests\n    test.only('it should be skipped as well', () => {\n      throw new Error('This should never happen');\n    });\n\n    test.todo('it should also be skipped');\n  });\n});\n\ntest('describe.skip should not run beforeAll', () => {\n  expect(hasBeforeAllRun).toBe(false);\n});\n\ntest('describe.skip should not run afterAll', () => {\n  expect(hasAfterAllRun).toBe(false);\n});\n\nlet hasBeforeAllRun2 = false;\nlet hasAfterAllRun2 = false;\n\ndescribe('in describe', () => {\n  beforeAll(() => {\n    hasBeforeAllRun2 = true;\n  });\n\n  afterAll(() => {\n    hasAfterAllRun2 = true;\n  });\n\n  test.skip('it should be skipped', () => {\n    throw new Error('This should never happen');\n  });\n});\n\ntest('describe having only skipped test should not run beforeAll', () => {\n  expect(hasBeforeAllRun2).toBe(false);\n});\n\ntest('describe having only skipped test should not run afterAll', () => {\n  expect(hasAfterAllRun2).toBe(false);\n});"}
{"prompt":"Correct BeforeAll run,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ndescribe('Correct BeforeAll run', () => {\n  it('ensures the BeforeAll of ignored suite is not run', () => {\n    let {stdout} = runJest('before-all-filtered');\n\n    // for some reason Circus does not have the `Object` part\n    stdout = stdout.replaceAll(/at Object.log \\(/g, 'at log (');\n\n    expect(stdout).toMatchSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Correct BeforeAll run ensures the BeforeAll of ignored suite is not run 1`] = `\n\"  console.log\n    beforeAll 1\n\n      at log (__tests__/beforeAllFiltered.test.js:10:13)\n\n  console.log\n    beforeEach 1\n\n      at log (__tests__/beforeAllFiltered.test.js:13:13)\n\n  console.log\n    It Foo\n\n      at log (__tests__/beforeAllFiltered.test.js:22:13)\n\n  console.log\n    afterEach 1\n\n      at log (__tests__/beforeAllFiltered.test.js:16:13)\n\n  console.log\n    afterAll 1\n\n      at log (__tests__/beforeAllFiltered.test.js:19:13)\n\"\n`;"}
{"prompt":"test,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('test', () => {\n  beforeEach(() => {\n    console.log('BeforeEach');\n  });\n\n  it('foo', () => {\n    console.log('It Foo');\n\n    beforeEach(() => {\n      console.log('BeforeEach Inline Foo');\n    });\n  });\n\n  it('bar', () => {\n    console.log('It Bar');\n\n    beforeEach(() => {\n      console.log('BeforeEach Inline Bar');\n    });\n  });\n});"}
{"prompt":"Correct beforeEach order,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {skipSuiteOnJestCircus} from '@jest/test-utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJestCircus(); // Circus does not support funky async definitions\n\ndescribe('Correct beforeEach order', () => {\n  it('ensures the correct order for beforeEach', () => {\n    const result = runJest('before-each-queue');\n    expect(result.stdout.replaceAll('\\\\', '/')).toMatchSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Correct beforeEach order ensures the correct order for beforeEach 1`] = `\n\"  console.log\n    BeforeEach\n\n      at Object.log (__tests__/beforeEachQueue.test.js:10:13)\n\n  console.log\n    It Foo\n\n      at Object.log (__tests__/beforeEachQueue.test.js:14:13)\n\n  console.log\n    BeforeEach Inline Foo\n\n      at Object.log (__tests__/beforeEachQueue.test.js:17:15)\n\n  console.log\n    BeforeEach\n\n      at Object.log (__tests__/beforeEachQueue.test.js:10:13)\n\n  console.log\n    It Bar\n\n      at Object.log (__tests__/beforeEachQueue.test.js:22:13)\n\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment node\n *\n */\n\n/* global document */\n\nconst div = document.createElement('div');\n\nconsole.log(div);\n\ntest('stub', () => expect(1).toBe(1));"}
{"prompt":"Bar,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('Bar', () => {\n  it('fail', () => {\n    throw new Error('Expected failure');\n  });\n});"}
{"prompt":"Foo,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('Foo', () => {\n  it('fail', () => {\n    throw new Error('Expected failure');\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports.isBrowser = true;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jest-environment-jsdom\n */\n\nimport {fn} from 'fake-dual-dep';\n\ntest('returns correct message', () => {\n  expect(fn()).toBe('hello from browser');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {runYarnInstall} from '../Utils';\nimport runJest from '../runJest';\n\ntest('browser resolver works', () => {\n  const dir = path.resolve(__dirname, '../browser-resolver');\n  runYarnInstall(dir);\n\n  const {exitCode} = runJest('browser-resolver');\n\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst phrase = require('../common-file');\n\ntest('B', () => {\n  expect(phrase).toBe('hello');\n});"}
{"prompt":"CustomConsole,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk = require('chalk');\nimport BufferedConsole from '../BufferedConsole';\n\ndescribe('CustomConsole', () => {\n  let _console: BufferedConsole;\n  const stdout = () => {\n    const buffer = _console.getBuffer();\n    if (!buffer) {\n      return '';\n    }\n\n    return buffer.map(log => log.message).join('\\n');\n  };\n\n  beforeEach(() => {\n    _console = new BufferedConsole();\n  });\n\n  describe('assert', () => {\n    test('do not log when the assertion is truthy', () => {\n      _console.assert(true);\n\n      expect(stdout()).toMatch('');\n    });\n\n    test('do not log when the assertion is truthy and there is a message', () => {\n      _console.assert(true, 'ok');\n\n      expect(stdout()).toMatch('');\n    });\n\n    test('log the assertion error when the assertion is falsy', () => {\n      _console.assert(false);\n\n      expect(stdout()).toMatch('AssertionError');\n      expect(stdout()).toMatch(\n        /false == true|The expression evaluated to a falsy value/,\n      );\n    });\n\n    test('log the assertion error when the assertion is falsy with another message argument', () => {\n      _console.assert(false, 'ok');\n\n      expect(stdout()).toMatch('AssertionError');\n      expect(stdout()).toMatch('ok');\n    });\n  });\n\n  describe('count', () => {\n    test('count using the default counter', () => {\n      _console.count();\n      _console.count();\n      _console.count();\n\n      expect(stdout()).toBe('default: 1\\ndefault: 2\\ndefault: 3');\n    });\n\n    test('count using the a labeled counter', () => {\n      _console.count('custom');\n      _console.count('custom');\n      _console.count('custom');\n\n      expect(stdout()).toBe('custom: 1\\ncustom: 2\\ncustom: 3');\n    });\n\n    test('countReset restarts default counter', () => {\n      _console.count();\n      _console.count();\n      _console.countReset();\n      _console.count();\n      expect(stdout()).toBe('default: 1\\ndefault: 2\\ndefault: 1');\n    });\n\n    test('countReset restarts custom counter', () => {\n      _console.count('custom');\n      _console.count('custom');\n      _console.countReset('custom');\n      _console.count('custom');\n\n      expect(stdout()).toBe('custom: 1\\ncustom: 2\\ncustom: 1');\n    });\n  });\n\n  describe('group', () => {\n    test('group without label', () => {\n      _console.group();\n      _console.log('hey');\n      _console.group();\n      _console.log('there');\n\n      expect(stdout()).toBe('  hey\\n    there');\n    });\n\n    test('group with label', () => {\n      _console.group('first');\n      _console.log('hey');\n      _console.group('second');\n      _console.log('there');\n\n      expect(stdout()).toBe(`  ${chalk.bold('first')}\n  hey\n    ${chalk.bold('second')}\n    there`);\n    });\n\n    test('groupEnd remove the indentation of the current group', () => {\n      _console.group();\n      _console.log('hey');\n      _console.groupEnd();\n      _console.log('there');\n\n      expect(stdout()).toBe('  hey\\nthere');\n    });\n\n    test('groupEnd can not remove the indentation below the starting point', () => {\n      _console.groupEnd();\n      _console.groupEnd();\n      _console.group();\n      _console.log('hey');\n      _console.groupEnd();\n      _console.log('there');\n\n      expect(stdout()).toBe('  hey\\nthere');\n    });\n  });\n\n  describe('time', () => {\n    test('should return the time between time() and timeEnd() on default timer', () => {\n      _console.time();\n      _console.timeEnd();\n\n      expect(stdout()).toMatch('default: ');\n      expect(stdout()).toMatch('ms');\n    });\n\n    test('should return the time between time() and timeEnd() on custom timer', () => {\n      _console.time('custom');\n      _console.timeEnd('custom');\n\n      expect(stdout()).toMatch('custom: ');\n      expect(stdout()).toMatch('ms');\n    });\n  });\n\n  describe('dir', () => {\n    test('should print the deepest value', () => {\n      const deepObject = {1: {2: {3: {4: {5: {6: 'value'}}}}}};\n      _console.dir(deepObject, {depth: 6});\n\n      expect(stdout()).toMatch('value');\n      expect(stdout()).not.toMatch('depth');\n    });\n  });\n\n  describe('timeLog', () => {\n    test('should return the time between time() and timeEnd() on default timer', () => {\n      _console.time();\n      _console.timeLog();\n\n      expect(stdout()).toMatch('default: ');\n      expect(stdout()).toMatch('ms');\n      _console.timeEnd();\n    });\n\n    test('should return the time between time() and timeEnd() on custom timer', () => {\n      _console.time('custom');\n      _console.timeLog('custom');\n\n      expect(stdout()).toMatch('custom: ');\n      expect(stdout()).toMatch('ms');\n      _console.timeEnd('custom');\n    });\n\n    test('default timer with data', () => {\n      _console.time();\n      _console.timeLog(undefined, 'foo', 5);\n\n      expect(stdout()).toMatch('default: ');\n      expect(stdout()).toMatch('ms foo 5');\n      _console.timeEnd();\n    });\n\n    test('custom timer with data', () => {\n      _console.time('custom');\n      _console.timeLog('custom', 'foo', 5);\n\n      expect(stdout()).toMatch('custom: ');\n      expect(stdout()).toMatch('ms foo 5');\n      _console.timeEnd('custom');\n    });\n  });\n\n  describe('console', () => {\n    test('should be able to initialize console instance', () => {\n      expect(_console.Console).toBeDefined();\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ntest('c', () => {});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.\n\nimport {describe, expect, it, jest} from '@jest/globals';\nimport Memory from '../Memory';\nimport makeCalc from '../calc';\nimport sub from '../sub';\nimport sum from '../sum';\n\njest.mock('../Memory');\njest.mock('../sub');\njest.mock('../sum');\n\nconst mockSub = jest.mocked(sub);\nconst mockSum = jest.mocked(sum);\nconst MockMemory = jest.mocked(Memory);\n\ndescribe('calc - mocks', () => {\n  const memory = new MockMemory();\n\n  it('returns result from subtract', () => {\n    mockSub.mockReturnValueOnce(0);\n\n    const calc = makeCalc(memory);\n    const result = calc('Sub', [2, 2]);\n\n    expect(result).toBe(0);\n    expect(mockSub).toHaveBeenCalledWith(2, 2);\n  });\n\n  it('returns result from sum', () => {\n    mockSum.mockReturnValueOnce(2);\n\n    const calc = makeCalc(memory);\n    const result = calc('Sum', [1, 1]);\n\n    expect(result).toBe(2);\n    expect(mockSum).toHaveBeenCalledWith(1, 1);\n  });\n\n  it('adds last result to memory', () => {\n    MockMemory.prototype.add.mockImplementationOnce(x => x);\n    mockSum.mockReturnValueOnce(2);\n\n    const calc = makeCalc(memory);\n    const sumResult = calc('Sum', [1, 1]);\n    const memoryResult = calc('MemoryAdd', []);\n\n    expect(sumResult).toBe(2);\n    expect(memoryResult).toBe(2);\n    expect(MockMemory.prototype.add).toHaveBeenCalledWith(2);\n  });\n\n  it('subtracts last result to memory', () => {\n    MockMemory.prototype.subtract.mockImplementationOnce(x => x);\n    mockSum.mockReturnValueOnce(2);\n\n    const calc = makeCalc(memory);\n    const sumResult = calc('Sum', [1, 1]);\n    const memoryResult = calc('MemorySub', []);\n\n    expect(sumResult).toBe(2);\n    expect(memoryResult).toBe(2);\n    expect(MockMemory.prototype.subtract).toHaveBeenCalledWith(2);\n  });\n\n  it('clears the memory', () => {\n    MockMemory.prototype.add.mockImplementationOnce(x => x);\n    mockSum.mockReturnValueOnce(2).mockReturnValueOnce(4);\n\n    const calc = makeCalc(memory);\n    const sumResult = calc('Sum', [1, 1]);\n    const memoryResult = calc('MemoryAdd', []);\n    const sumResult2 = calc('Sum', [2, 2]);\n    const clearResult = calc('MemoryClear', []);\n\n    expect(sumResult).toBe(2);\n    expect(memoryResult).toBe(2);\n    expect(sumResult2).toBe(4);\n    expect(clearResult).toBe(4);\n    expect(MockMemory.prototype.reset).toHaveBeenCalledTimes(1);\n  });\n\n  it('throws an error when invalid Op is passed', () => {\n    const calc = makeCalc(memory);\n\n    // @ts-expect-error\n    expect(() => calc('Multiply', [2, 3])).toThrow(new Error('Invalid op'));\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJasmine();\ntest('`done()` should not be called more than once', () => {\n  const {exitCode, stderr} = runJest('call-done-twice');\n  const {rest} = extractSummary(stderr);\n  expect(rest).toMatchSnapshot();\n  expect(exitCode).toBe(1);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`\\`done()\\` should not be called more than once 1`] = `\n\"FAIL __tests__/index.test.js\n  ● \\`done()\\` called more than once › should fail\n\n    Expected done to be called once, but it was called multiple times.\n\n       8 |   it('should fail', done => {\n       9 |     done();\n    > 10 |     done();\n         |     ^\n      11 |   });\n      12 |\n      13 |   it('should fail inside a promise', done => {\n\n      at Object.done (__tests__/index.test.js:10:5)\n\n  ● \\`done()\\` called more than once › should fail inside a promise\n\n    Expected done to be called once, but it was called multiple times.\n\n      15 |       .then(() => {\n      16 |         done();\n    > 17 |         done();\n         |         ^\n      18 |       })\n      19 |       .catch(error => error);\n      20 |   });\n\n      at done (__tests__/index.test.js:17:9)\n\n  ● multiple \\`done()\\` inside beforeEach › should fail\n\n    Expected done to be called once, but it was called multiple times.\n\n      24 |   beforeEach(done => {\n      25 |     done();\n    > 26 |     done();\n         |     ^\n      27 |   });\n      28 |\n      29 |   it('should fail', () => {\n\n      at Object.done (__tests__/index.test.js:26:5)\n\n  ● multiple \\`done()\\` inside afterEach › should fail\n\n    Expected done to be called once, but it was called multiple times.\n\n      35 |   afterEach(done => {\n      36 |     done();\n    > 37 |     done();\n         |     ^\n      38 |   });\n      39 |\n      40 |   it('should fail', () => {\n\n      at Object.done (__tests__/index.test.js:37:5)\n\n  ● multiple \\`done()\\` inside beforeAll › should fail\n\n    Expected done to be called once, but it was called multiple times.\n\n      46 |   beforeAll(done => {\n      47 |     done();\n    > 48 |     done();\n         |     ^\n      49 |   });\n      50 |\n      51 |   it('should fail', () => {\n\n      at Object.done (__tests__/index.test.js:48:5)\n\n\n  ● Test suite failed to run\n\n    Expected done to be called once, but it was called multiple times.\n\n      57 |   afterAll(done => {\n      58 |     done();\n    > 59 |     done();\n         |     ^\n      60 |   });\n      61 |\n      62 |   it('should fail', () => {\n\n      at Object.done (__tests__/index.test.js:59:5)\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {extractSummary, runYarnInstall} from '../Utils';\nimport runJest from '../runJest';\n\ntest('chai assertion errors should display properly', () => {\n  const dir = path.resolve(__dirname, '../chai-assertion-library-errors');\n  runYarnInstall(dir);\n\n  const {stderr} = runJest('chai-assertion-library-errors');\n  const {rest} = extractSummary(stderr);\n  expect(rest).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`chai assertion errors should display properly 1`] = `\n\"FAIL __tests__/chai_assertion.js\n  ● chai.js assertion library test › expect\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"hello sunshine\"\n    Received:\n      \"hello world\"\n\n    Message:\n      expected 'hello world' to equal 'hello sunshine'\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - hello sunshine\n    + hello world\n\n      11 | describe('chai.js assertion library test', () => {\n      12 |   it('expect', () => {\n    > 13 |     chai.expect('hello world').to.equal('hello sunshine');\n         |                                   ^\n      14 |   });\n      15 |\n      16 |   it('should', () => {\n\n      at Object.equal (__tests__/chai_assertion.js:13:35)\n\n  ● chai.js assertion library test › should\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"hello world\"\n    Received:\n      \"hello sunshine\"\n\n    Message:\n      expected 'hello sunshine' to equal 'hello world'\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - hello world\n    + hello sunshine\n\n      18 |     const expectedString = 'hello world';\n      19 |     const actualString = 'hello sunshine';\n    > 20 |     actualString.should.equal(expectedString);\n         |                         ^\n      21 |   });\n      22 |\n      23 |   it('assert', () => {\n\n      at Object.equal (__tests__/chai_assertion.js:20:25)\n\n  ● chai.js assertion library test › assert\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      \"hello sunshine\"\n    Received:\n      \"hello world\"\n\n    Message:\n      expected 'hello world' to equal 'hello sunshine'\n\n    Difference:\n\n    - Expected\n    + Received\n\n    - hello sunshine\n    + hello world\n\n      22 |\n      23 |   it('assert', () => {\n    > 24 |     chai.assert.strictEqual('hello world', 'hello sunshine');\n         |                 ^\n      25 |   });\n      26 | });\n      27 |\n\n      at Object.strictEqual (__tests__/chai_assertion.js:24:17)\"\n`;"}
{"prompt":"chai.js assertion library test,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\nconst chai = require('chai');\n\ndescribe('chai.js assertion library test', () => {\n  it('expect', () => {\n    chai.expect('hello world').to.equal('hello sunshine');\n  });\n\n  it('should', () => {\n    chai.should();\n    const expectedString = 'hello world';\n    const actualString = 'hello sunshine';\n    actualString.should.equal(expectedString);\n  });\n\n  it('assert', () => {\n    chai.assert.strictEqual('hello world', 'hello sunshine');\n  });\n});"}
{"prompt":"even though we change the cwd, correct config is still found","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst path = require('path');\n\nbeforeAll(() => {\n  process.chdir(path.resolve(__dirname, '../some-dir'));\n\n  // even though we change the cwd, correct config is still found\n  require('../this-directory-is-covered/excludedFromCoverage');\n});\n\nit('strips flowtypes using babel-jest and .babelrc', () => {\n  const a: string = 'a';\n  expect(a).toBe('a');\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\nimport {fireEvent, render} from '@testing-library/react';\nimport CheckboxWithLabel from '../CheckboxWithLabel';\n\nit('CheckboxWithLabel changes the text after click', () => {\n  const {queryByLabelText, getByLabelText} = render(\n    <CheckboxWithLabel labelOn=\"On\" labelOff=\"Off\" />,\n  );\n\n  expect(queryByLabelText(/off/i)).toBeTruthy();\n\n  fireEvent.click(getByLabelText(/off/i));\n\n  expect(queryByLabelText(/on/i)).toBeTruthy();\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.\n\nimport * as React from 'react';\nimport * as TestUtils from 'react-dom/test-utils';\nimport {expect, it} from '@jest/globals';\nimport CheckboxWithLabel from '../CheckboxWithLabel';\n\nit('CheckboxWithLabel changes the text after click', () => {\n  const checkboxLabelRef: React.RefObject<HTMLLabelElement> = React.createRef();\n  const checkboxInputRef: React.RefObject<HTMLInputElement> = React.createRef();\n  // Render a checkbox with label in the document\n  TestUtils.renderIntoDocument(\n    <CheckboxWithLabel\n      labelRef={checkboxLabelRef}\n      inputRef={checkboxInputRef}\n      labelOn=\"On\"\n      labelOff=\"Off\"\n    />,\n  );\n\n  const labelNode = checkboxLabelRef.current;\n  const inputNode = checkboxInputRef.current;\n\n  // Verify that it's Off by default\n  expect(labelNode.textContent).toBe('Off');\n\n  // Simulate a click and verify that it is now On\n  TestUtils.Simulate.change(inputNode);\n  expect(labelNode.textContent).toBe('On');\n});"}
{"prompt":"passes fork options down to child_process.fork, adding the defaults,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EventEmitter} from 'events';\nimport {PassThrough} from 'stream';\nimport getStream = require('get-stream');\nimport * as supportsColor from 'supports-color';\nimport {\n  CHILD_MESSAGE_CALL,\n  CHILD_MESSAGE_INITIALIZE,\n  CHILD_MESSAGE_MEM_USAGE,\n  type ChildMessage,\n  type ChildMessageCall,\n  PARENT_MESSAGE_CLIENT_ERROR,\n  PARENT_MESSAGE_CUSTOM,\n  PARENT_MESSAGE_MEM_USAGE,\n  PARENT_MESSAGE_OK,\n  type WorkerOptions,\n} from '../../types';\n\njest.useFakeTimers();\n\njest.mock('child_process');\n\nlet Worker: typeof import('../ChildProcessWorker').default;\nlet childProcess: typeof import('child_process');\nlet forkInterface: ReturnType<typeof childProcess.fork>;\nlet originalExecArgv: typeof process.execArgv;\n\nconst totalmem = jest.spyOn(require('os') as typeof import('os'), 'totalmem');\n\nclass MockedForkInterface extends EventEmitter {\n  connected = true;\n  kill = jest.fn();\n  send = jest.fn();\n  stderr = new PassThrough();\n  stdout = new PassThrough();\n}\n\nbeforeEach(() => {\n  originalExecArgv = process.execArgv;\n\n  childProcess = require('child_process') as typeof import('child_process');\n  jest.mocked(childProcess.fork).mockImplementation(() => {\n    forkInterface = new MockedForkInterface() as unknown as ReturnType<\n      typeof childProcess.fork\n    >;\n\n    return forkInterface;\n  });\n\n  totalmem.mockReset();\n\n  Worker = (\n    require('../ChildProcessWorker') as typeof import('../ChildProcessWorker')\n  ).default;\n});\n\nafterEach(() => {\n  jest.resetModules();\n  process.execArgv = originalExecArgv;\n});\n\nit('passes fork options down to child_process.fork, adding the defaults', () => {\n  const child = require.resolve('../processChild');\n\n  process.execArgv = ['--inspect', '-p'];\n\n  // eslint-disable-next-line no-new\n  new Worker({\n    forkOptions: {\n      cwd: '/tmp',\n      execPath: 'hello',\n    },\n    maxRetries: 3,\n    workerId: Number(process.env.JEST_WORKER_ID) - 1,\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  expect(jest.mocked(childProcess.fork).mock.calls[0][0]).toBe(child);\n  expect(jest.mocked(childProcess.fork).mock.calls[0][2]).toEqual({\n    cwd: '/tmp', // Overridden default option.\n    env: {...process.env, FORCE_COLOR: supportsColor.stdout ? '1' : undefined}, // Default option.\n    execArgv: ['-p'], // Filtered option.\n    execPath: 'hello', // Added option.\n    serialization: 'advanced', // Default option.\n    silent: true, // Default option.\n  });\n});\n\nit('passes workerId to the child process and assign it to 1-indexed env.JEST_WORKER_ID', () => {\n  // eslint-disable-next-line no-new\n  new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerId: 2,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(jest.mocked(childProcess.fork).mock.calls[0][2]).toMatchObject({\n    env: {JEST_WORKER_ID: '3'},\n  });\n});\n\nit('initializes the child process with the given workerPath', () => {\n  // eslint-disable-next-line no-new\n  new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    setupArgs: ['foo', 'bar'],\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  expect(jest.mocked(forkInterface.send).mock.calls[0][0]).toEqual([\n    CHILD_MESSAGE_INITIALIZE,\n    false,\n    '/tmp/foo/bar/baz.js',\n    ['foo', 'bar'],\n  ]);\n});\n\nit('stops initializing the worker after the amount of retries is exceeded', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  const request: ChildMessageCall = [CHILD_MESSAGE_CALL, false, 'foo', []];\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n\n  worker.send(request, onProcessStart, onProcessEnd, () => {});\n\n  // We fail four times (initial + three retries).\n  forkInterface.emit('exit', 1);\n  forkInterface.emit('exit', 1);\n  forkInterface.emit('exit', 1);\n  forkInterface.emit('exit', 1);\n\n  expect(childProcess.fork).toHaveBeenCalledTimes(5);\n  expect(onProcessStart).toHaveBeenCalledWith(worker);\n  expect(onProcessEnd).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd.mock.calls[0][0]).toBeInstanceOf(Error);\n  expect(onProcessEnd.mock.calls[0][0]).toMatchObject({\n    type: 'WorkerError',\n  });\n  expect(onProcessEnd.mock.calls[0][1]).toBeNull();\n});\n\nit('provides stdout and stderr from the child processes', async () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const stdout = worker.getStdout()!;\n  const stderr = worker.getStderr()!;\n\n  (forkInterface.stdout as PassThrough).end('Hello ', 'utf8');\n  (forkInterface.stderr as PassThrough).end('Jest ', 'utf8');\n  forkInterface.emit('exit', 1);\n  (forkInterface.stdout as PassThrough).end('World!', 'utf8');\n  (forkInterface.stderr as PassThrough).end('Workers!', 'utf8');\n  forkInterface.emit('exit', 0);\n\n  await expect(getStream(stdout)).resolves.toBe('Hello World!');\n  await expect(getStream(stderr)).resolves.toBe('Jest Workers!');\n});\n\nit('sends the task to the child process', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    setupArgs: [],\n    workerPath: '/tmp/foo',\n  } as unknown as WorkerOptions);\n\n  const request: ChildMessage = [CHILD_MESSAGE_CALL, false, 'foo', []];\n\n  worker.send(\n    request,\n    () => {},\n    () => {},\n    () => {},\n  );\n\n  // Skipping call \"0\" because it corresponds to the \"initialize\" one.\n  expect(jest.mocked(forkInterface.send).mock.calls[1][0]).toEqual(request);\n});\n\nit('resends the task to the child process after a retry', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  const request: ChildMessage = [CHILD_MESSAGE_CALL, false, 'foo', []];\n\n  worker.send(\n    request,\n    () => {},\n    () => {},\n    () => {},\n  );\n\n  // Skipping call \"0\" because it corresponds to the \"initialize\" one.\n  expect(jest.mocked(forkInterface.send).mock.calls[1][0]).toEqual(request);\n\n  const previousForkInterface = forkInterface;\n  forkInterface.emit('exit', 1);\n\n  expect(forkInterface).not.toBe(previousForkInterface);\n\n  // Skipping call \"0\" because it corresponds to the \"initialize\" one.\n  expect(jest.mocked(forkInterface.send).mock.calls[1][0]).toEqual(request);\n});\n\nit('calls the onProcessStart method synchronously if the queue is empty', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'foo', []],\n    onProcessStart,\n    onProcessEnd,\n    () => {},\n  );\n\n  // Only onProcessStart has been called\n  expect(onProcessStart).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).not.toHaveBeenCalled();\n\n  // then first call replies...\n  forkInterface.emit('message', [PARENT_MESSAGE_OK]);\n\n  expect(onProcessEnd).toHaveBeenCalledTimes(1);\n});\n\nit('can send multiple messages to parent', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n  const onCustomMessage = jest.fn();\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'foo', []],\n    onProcessStart,\n    onProcessEnd,\n    onCustomMessage,\n  );\n\n  // Only onProcessStart has been called\n  expect(onProcessStart).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).not.toHaveBeenCalled();\n  expect(onCustomMessage).not.toHaveBeenCalled();\n\n  // then first call replies...\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_CUSTOM,\n    {message: 'foo bar', otherKey: 1},\n  ]);\n\n  expect(onProcessEnd).not.toHaveBeenCalled();\n  expect(onCustomMessage).toHaveBeenCalledTimes(1);\n  expect(onCustomMessage).toHaveBeenCalledWith({\n    message: 'foo bar',\n    otherKey: 1,\n  });\n});\n\nit('creates error instances for known errors', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const callback1 = jest.fn();\n  const callback2 = jest.fn();\n  const callback3 = jest.fn();\n\n  // Testing a generic ECMAScript error.\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    callback1,\n    () => {},\n  );\n\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'TypeError',\n    'bar',\n    'TypeError: bar',\n    {},\n  ]);\n\n  expect(callback1.mock.calls[0][0]).toBeInstanceOf(TypeError);\n  expect(callback1.mock.calls[0][0]).toMatchObject({\n    message: 'bar',\n    stack: 'TypeError: bar',\n    type: 'TypeError',\n  });\n\n  // Testing a custom error.\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    callback2,\n    () => {},\n  );\n\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'RandomCustomError',\n    'bar',\n    'RandomCustomError: bar',\n    {qux: 'extra property'},\n  ]);\n\n  expect(callback2.mock.calls[0][0]).toBeInstanceOf(Error);\n  expect(callback2.mock.calls[0][0]).toMatchObject({\n    message: 'bar',\n    qux: 'extra property',\n    stack: 'RandomCustomError: bar',\n    type: 'RandomCustomError',\n  });\n\n  // Testing a non-object throw.\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    callback3,\n    () => {},\n  );\n\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'Number',\n    null,\n    null,\n    412,\n  ]);\n\n  expect(callback3.mock.calls[0][0]).toBe(412);\n});\n\nit('does not throw when the child process returns a strange message', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    () => {},\n    () => {},\n  );\n\n  // Type 27 does not exist.\n  forkInterface.emit('message', [27]);\n\n  forkInterface.emit('message', 'test');\n  forkInterface.emit('message', {foo: 'bar'});\n  forkInterface.emit('message', 0);\n  forkInterface.emit('message', null);\n  forkInterface.emit('message', Symbol('test'));\n  forkInterface.emit('message', true);\n});\n\nit('does not restart the child if it cleanly exited', () => {\n  // eslint-disable-next-line no-new\n  new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(childProcess.fork).toHaveBeenCalledTimes(1);\n  forkInterface.emit('exit', 0);\n  expect(childProcess.fork).toHaveBeenCalledTimes(1);\n});\n\nit('resolves waitForExit() after the child process cleanly exited', async () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(childProcess.fork).toHaveBeenCalledTimes(1);\n  forkInterface.emit('exit', 0);\n  await worker.waitForExit(); // should not timeout\n});\n\nit('restarts the child when the child process dies', () => {\n  // eslint-disable-next-line no-new\n  new Worker({\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(childProcess.fork).toHaveBeenCalledTimes(1);\n  forkInterface.emit('exit', 1);\n  expect(childProcess.fork).toHaveBeenCalledTimes(2);\n});\n\nit('when out of memory occurs the worker is killed and exits', async () => {\n  const worker = new Worker({\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(childProcess.fork).toHaveBeenCalledTimes(1);\n\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n  const onCustomMessage = jest.fn();\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'foo', []],\n    onProcessStart,\n    onProcessEnd,\n    onCustomMessage,\n  );\n\n  // Only onProcessStart has been called\n  expect(onProcessStart).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).not.toHaveBeenCalled();\n  expect(onCustomMessage).not.toHaveBeenCalled();\n\n  // Splitting the emit into 2 to check concat is happening.\n  forkInterface.stderr!.emit(\n    'data',\n    `<--- Last few GCs --->\n\n  [20048:0x7fa356200000]      349 ms: Mark-sweep (reduce) 49.2 (80.6) -> 49.0 (51.6) MB, 6.8 / 0.0 ms  (+ 59.5 ms in 35 steps since start of marking, biggest step 2.3 ms, walltime since start of marking 68 ms) (average mu = 0.679, current mu = 0.679) finali[20048:0x7fa356200000]      418 ms: Mark-sweep 50.0 (51.6) -> 49.9 (55.6) MB, 67.8 / 0.0 ms  (average mu = 0.512, current mu = 0.004) allocation failure scavenge might not succeed\n\n\n  <--- JS stacktrace --->\n\n  FATAL ERROR: Reached heap limit Allocation failed - JavaScript he`,\n  );\n\n  forkInterface.stderr!.emit(\n    'data',\n    `ap out of memory\n   1: 0x10da153a5 node::Abort() (.cold.1) [/Users/paul/.nvm/versions/node/v16.10.0/bin/node]\n   2: 0x10c6f09b9 node::Abort() [/Users/paul/.nvm/versions/node/v16.10.0/bin/node]`,\n  );\n  forkInterface.stderr!.emit('end');\n\n  forkInterface.emit('exit', null, 'SIGABRT');\n\n  // We don't want it to try and restart.\n  expect(childProcess.fork).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).toHaveBeenCalledWith(\n    new Error('Jest worker ran out of memory and crashed'),\n    null,\n  );\n\n  // It should not hang\n  await worker.waitForExit();\n});\n\nit('sends SIGTERM when forceExit() is called', async () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.forceExit();\n  expect(jest.mocked(forkInterface.kill).mock.calls).toEqual([['SIGTERM']]);\n});\n\nit('sends SIGKILL some time after SIGTERM', async () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.forceExit();\n  jest.runAllTimers();\n  expect(jest.mocked(forkInterface.kill).mock.calls).toEqual([\n    ['SIGTERM'],\n    ['SIGKILL'],\n  ]);\n});\n\nit('does not send SIGKILL if SIGTERM exited the process', async () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.forceExit();\n  forkInterface.emit('exit', 143 /* SIGTERM exit code */);\n  await Promise.resolve();\n\n  jest.runAllTimers();\n  expect(jest.mocked(forkInterface.kill).mock.calls).toEqual([['SIGTERM']]);\n});\n\nit('should check for memory limits and not restart if under percentage limit', async () => {\n  const memoryConfig = {\n    limit: 0.2,\n    processHeap: 2500,\n    totalMem: 16_000,\n  };\n\n  const worker = new Worker({\n    forkOptions: {},\n    idleMemoryLimit: memoryConfig.limit,\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n  const onCustomMessage = jest.fn();\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'foo', []],\n    onProcessStart,\n    onProcessEnd,\n    onCustomMessage,\n  );\n\n  // Only onProcessStart has been called\n  expect(onProcessStart).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).not.toHaveBeenCalled();\n  expect(onCustomMessage).not.toHaveBeenCalled();\n\n  // then first call replies...\n  forkInterface.emit('message', [PARENT_MESSAGE_OK]);\n\n  expect(onProcessEnd).toHaveBeenCalledTimes(1);\n\n  // This is the initialization call.\n  expect(jest.mocked(forkInterface.send).mock.calls[0][0]).toEqual([\n    CHILD_MESSAGE_INITIALIZE,\n    false,\n    '/tmp/foo',\n    undefined,\n  ]);\n\n  // This is the child message\n  expect(jest.mocked(forkInterface.send).mock.calls[1][0]).toEqual([\n    CHILD_MESSAGE_CALL,\n    false,\n    'foo',\n    [],\n  ]);\n\n  // This is the subsequent call to get memory usage\n  expect(jest.mocked(forkInterface.send).mock.calls[2][0]).toEqual([\n    CHILD_MESSAGE_MEM_USAGE,\n  ]);\n\n  totalmem.mockReturnValue(memoryConfig.totalMem);\n\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_MEM_USAGE,\n    memoryConfig.processHeap,\n  ]);\n\n  expect(totalmem).toHaveBeenCalledTimes(1);\n  expect(forkInterface.kill).not.toHaveBeenCalled();\n});\n\nit('should check for memory limits and not restart if under absolute limit', async () => {\n  const memoryConfig = {\n    limit: 2600,\n    processHeap: 2500,\n    totalMem: 16_000,\n  };\n\n  const worker = new Worker({\n    forkOptions: {},\n    idleMemoryLimit: memoryConfig.limit,\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.checkMemoryUsage();\n\n  totalmem.mockReturnValue(memoryConfig.totalMem);\n\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_MEM_USAGE,\n    memoryConfig.processHeap,\n  ]);\n\n  expect(totalmem).not.toHaveBeenCalled();\n  expect(forkInterface.kill).not.toHaveBeenCalled();\n});\n\nit('should check for memory limits and restart if above percentage limit', async () => {\n  const memoryConfig = {\n    limit: 0.01,\n    processHeap: 2500,\n    totalMem: 16_000,\n  };\n\n  const worker = new Worker({\n    forkOptions: {},\n    idleMemoryLimit: memoryConfig.limit,\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.checkMemoryUsage();\n\n  totalmem.mockReturnValue(memoryConfig.totalMem);\n\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_MEM_USAGE,\n    memoryConfig.processHeap,\n  ]);\n\n  expect(totalmem).toHaveBeenCalledTimes(1);\n  expect(forkInterface.kill).toHaveBeenCalledTimes(1);\n});\n\nit('should check for memory limits and restart if above absolute limit', async () => {\n  const memoryConfig = {\n    limit: 2000,\n    processHeap: 2500,\n    totalMem: 16_000,\n  };\n\n  const worker = new Worker({\n    forkOptions: {},\n    idleMemoryLimit: memoryConfig.limit,\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.checkMemoryUsage();\n\n  totalmem.mockReturnValue(memoryConfig.totalMem);\n\n  forkInterface.emit('message', [\n    PARENT_MESSAGE_MEM_USAGE,\n    memoryConfig.processHeap,\n  ]);\n\n  expect(totalmem).not.toHaveBeenCalled();\n  expect(forkInterface.kill).toHaveBeenCalledTimes(1);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst {spawn} = require('child_process');\n\ntest('something', () => {\n  const subprocess = spawn(\n    process.argv[0],\n    [require.resolve('../interval-code')],\n    {\n      detached: true,\n      stdio: 'ignore',\n    },\n  );\n  subprocess.unref();\n  expect(true).toBe(true);\n});"}
{"prompt":"matches circular references nested in:,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('matches circular references nested in:', () => {\n  interface CircularObj {\n    ref: unknown;\n    [prop: string]: unknown;\n  }\n\n  test('arrays', () => {\n    type CircularArray = CircularObj & {ref: Array<unknown>};\n\n    const a: CircularArray = {c: 1, ref: [1]};\n    const b: CircularArray = {c: 1, ref: [1]};\n\n    a.ref.push(a);\n    b.ref.push(b);\n    expect(a).toMatchObject(b);\n\n    b.ref = [];\n    expect(a).not.toMatchObject(b);\n\n    b.ref = [1];\n    expect(a).not.toMatchObject(b);\n  });\n\n  test('deeply nested array properties', () => {\n    type DeepCircularArray = CircularObj & {ref: {inner: Array<unknown>}};\n    const a: DeepCircularArray = {\n      c: 1,\n      ref: {\n        inner: [1],\n      },\n    };\n    const b: DeepCircularArray = {\n      c: 1,\n      ref: {\n        inner: [1],\n      },\n    };\n    a.ref.inner.push(a);\n    b.ref.inner.push(b);\n    expect(a).toMatchObject(b);\n\n    b.ref.inner = [];\n    expect(a).not.toMatchObject(b);\n\n    b.ref.inner = [1];\n    expect(a).not.toMatchObject(b);\n  });\n\n  test('sets', () => {\n    type CircularSet = CircularObj & {ref: Set<unknown>};\n\n    const a: CircularSet = {c: 1, ref: new Set()};\n    const b: CircularSet = {c: 1, ref: new Set()};\n\n    a.ref.add(a);\n    b.ref.add(b);\n    expect(a).toMatchObject(b);\n\n    b.ref.clear();\n    expect(a).not.toMatchObject(b);\n\n    b.ref.add(1);\n    expect(a).not.toMatchObject(b);\n  });\n\n  test('maps', () => {\n    type CircularMap = CircularObj & {ref: Map<string, unknown>};\n\n    const a: CircularMap = {c: 1, ref: new Map()};\n    const b: CircularMap = {c: 1, ref: new Map()};\n\n    a.ref.set('innerRef', a);\n    b.ref.set('innerRef', b);\n    expect(a).toMatchObject(b);\n\n    b.ref.clear();\n    expect(a).not.toMatchObject(b);\n\n    b.ref.set('innerRef', 1);\n    expect(a).not.toMatchObject(b);\n  });\n});"}
{"prompt":"all passing,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport exp = require('constants');\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport runJest, {json as runWithJson} from '../runJest';\n\nskipSuiteOnJasmine();\n\ndescribe('all passing', () => {\n  it('runs the correct number of tests', () => {\n    const {json, exitCode} = runWithJson('circus-concurrent', [\n      'concurrent.test.js',\n    ]);\n\n    expect(exitCode).toBe(0);\n    expect(json.numTotalTests).toBe(10);\n    expect(json.numPassedTests).toBe(10);\n    expect(json.numFailedTests).toBe(0);\n    expect(json.numPendingTests).toBe(0);\n  });\n\n  it('runs the tests in the correct order', () => {\n    const {stdout} = runJest('circus-concurrent', ['concurrent.test.js']);\n    expect(stdout).toMatchSnapshot();\n  });\n});\n\ndescribe('with skip', () => {\n  it('runs the correct number of tests', () => {\n    const {json, exitCode} = runWithJson('circus-concurrent', [\n      'concurrent-skip.test.js',\n    ]);\n\n    expect(exitCode).toBe(0);\n    expect(json.numTotalTests).toBe(10);\n    expect(json.numPassedTests).toBe(6);\n    expect(json.numFailedTests).toBe(0);\n    expect(json.numPendingTests).toBe(4);\n  });\n\n  it('runs the tests in the correct order', () => {\n    const {stdout} = runJest('circus-concurrent', ['concurrent-skip.test.js']);\n    expect(stdout).toMatchSnapshot();\n  });\n});\n\ndescribe('with only', () => {\n  it('runs the correct number of tests', () => {\n    const {json, exitCode} = runWithJson('circus-concurrent', [\n      'concurrent-only.test.js',\n    ]);\n\n    expect(exitCode).toBe(0);\n    expect(json.numTotalTests).toBe(10);\n    expect(json.numPassedTests).toBe(3);\n    expect(json.numFailedTests).toBe(0);\n    expect(json.numPendingTests).toBe(7);\n  });\n\n  it('runs the tests in the correct order', () => {\n    const {stdout} = runJest('circus-concurrent', ['concurrent-only.test.js']);\n    expect(stdout).toMatchSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`all passing runs the tests in the correct order 1`] = `\n\"  console.log\n    beforeAll\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    START \"one\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    START \"two\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    START \"three\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    START \"four\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    START \"five\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    END: \"three\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    START \"six\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    END: \"one\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    START \"seven\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    END: \"two\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    START \"eight\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    END: \"four\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    START \"nine\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    END: \"nine\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    START \"ten\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    END: \"five\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    END: \"six\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    END: \"seven\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    END: \"ten\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    END: \"eight\"\n\n      at log (__tests__/concurrent.test.js:15:11)\n\n  console.log\n    afterAll\n\n      at log (__tests__/concurrent.test.js:15:11)\n\"\n`;\n\nexports[`with only runs the tests in the correct order 1`] = `\n\"  console.log\n    beforeAll\n\n      at log (__tests__/concurrent-only.test.js:15:11)\n\n  console.log\n    START \"four\"\n\n      at log (__tests__/concurrent-only.test.js:15:11)\n\n  console.log\n    START \"six\"\n\n      at log (__tests__/concurrent-only.test.js:15:11)\n\n  console.log\n    START \"nine\"\n\n      at log (__tests__/concurrent-only.test.js:15:11)\n\n  console.log\n    END: \"nine\"\n\n      at log (__tests__/concurrent-only.test.js:15:11)\n\n  console.log\n    END: \"six\"\n\n      at log (__tests__/concurrent-only.test.js:15:11)\n\n  console.log\n    END: \"four\"\n\n      at log (__tests__/concurrent-only.test.js:15:11)\n\n  console.log\n    afterAll\n\n      at log (__tests__/concurrent-only.test.js:15:11)\n\"\n`;\n\nexports[`with skip runs the tests in the correct order 1`] = `\n\"  console.log\n    beforeAll\n\n      at log (__tests__/concurrent-skip.test.js:15:11)\n\n  console.log\n    START \"one\"\n\n      at log (__tests__/concurrent-skip.test.js:15:11)\n\n  console.log\n    START \"two\"\n\n      at log (__tests__/concurrent-skip.test.js:15:11)\n\n  console.log\n    START \"four\"\n\n      at log (__tests__/concurrent-skip.test.js:15:11)\n\n  console.log\n    START \"seven\"\n\n      at log (__tests__/concurrent-skip.test.js:15:11)\n\n  console.log\n    START \"eight\"\n\n      at log (__tests__/concurrent-skip.test.js:15:11)\n\n  console.log\n    END: \"one\"\n\n      at log (__tests__/concurrent-skip.test.js:15:11)\n\n  console.log\n    START \"ten\"\n\n      at log (__tests__/concurrent-skip.test.js:15:11)\n\n  console.log\n    END: \"two\"\n\n      at log (__tests__/concurrent-skip.test.js:15:11)\n\n  console.log\n    END: \"seven\"\n\n      at log (__tests__/concurrent-skip.test.js:15:11)\n\n  console.log\n    END: \"four\"\n\n      at log (__tests__/concurrent-skip.test.js:15:11)\n\n  console.log\n    END: \"eight\"\n\n      at log (__tests__/concurrent-skip.test.js:15:11)\n\n  console.log\n    END: \"ten\"\n\n      at log (__tests__/concurrent-skip.test.js:15:11)\n\n  console.log\n    afterAll\n\n      at log (__tests__/concurrent-skip.test.js:15:11)\n\"\n`;"}
{"prompt":"works with concurrent.each,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport {json as runWithJson} from '../runJest';\n\nskipSuiteOnJasmine();\n\nit('works with concurrent.each', () => {\n  const {json} = runWithJson('circus-concurrent', ['concurrent-each.test.js']);\n  expect(json.numTotalTests).toBe(4);\n  expect(json.numPassedTests).toBe(2);\n  expect(json.numFailedTests).toBe(0);\n  expect(json.numPendingTests).toBe(2);\n});\n\nit('works with concurrent.only.each', () => {\n  const {json} = runWithJson('circus-concurrent', [\n    'concurrent-only-each.test.js',\n  ]);\n  expect(json.numTotalTests).toBe(4);\n  expect(json.numPassedTests).toBe(2);\n  expect(json.numFailedTests).toBe(0);\n  expect(json.numPendingTests).toBe(2);\n});"}
{"prompt":"defining tests and hooks asynchronously throws,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJasmine();\n\nit('defining tests and hooks asynchronously throws', () => {\n  const result = runJest('circus-declaration-errors', [\n    'asyncDefinition.test.js',\n  ]);\n\n  expect(result.exitCode).toBe(1);\n\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`defining tests and hooks asynchronously throws 1`] = `\n\"FAIL __tests__/asyncDefinition.test.js\n\n\n  ● Test suite failed to run\n\n    Cannot add a test after tests have started running. Tests must be defined synchronously.\n\n      10 |\n      11 |   Promise.resolve().then(() => {\n    > 12 |     test('async definition inside describe', () => {});\n         |     ^\n      13 |     afterAll(() => {});\n      14 |   });\n      15 | });\n\n      at eventHandler (../../packages/jest-circus/build/jestAdapterInit.js:148:38)\n      at test (__tests__/asyncDefinition.test.js:12:5)\n\n  ● Test suite failed to run\n\n    Cannot add a hook after tests have started running. Hooks must be defined synchronously.\n\n      11 |   Promise.resolve().then(() => {\n      12 |     test('async definition inside describe', () => {});\n    > 13 |     afterAll(() => {});\n         |     ^\n      14 |   });\n      15 | });\n      16 |\n\n      at eventHandler (../../packages/jest-circus/build/jestAdapterInit.js:114:38)\n      at afterAll (__tests__/asyncDefinition.test.js:13:5)\n\n  ● Test suite failed to run\n\n    Cannot add a test after tests have started running. Tests must be defined synchronously.\n\n      16 |\n      17 | Promise.resolve().then(() => {\n    > 18 |   test('async definition outside describe', () => {});\n         |   ^\n      19 |   afterAll(() => {});\n      20 | });\n      21 |\n\n      at eventHandler (../../packages/jest-circus/build/jestAdapterInit.js:148:38)\n      at test (__tests__/asyncDefinition.test.js:18:3)\n\n  ● Test suite failed to run\n\n    Cannot add a hook after tests have started running. Hooks must be defined synchronously.\n\n      17 | Promise.resolve().then(() => {\n      18 |   test('async definition outside describe', () => {});\n    > 19 |   afterAll(() => {});\n         |   ^\n      20 | });\n      21 |\n\n      at eventHandler (../../packages/jest-circus/build/jestAdapterInit.js:114:38)\n      at afterAll (__tests__/asyncDefinition.test.js:19:3)\"\n`;"}
{"prompt":"suite,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment ./CircusAsyncHandleTestEventEnvironment.js\n */\n\ndescribe('suite', () => {\n  beforeEach(() => {});\n  afterEach(() => {\n    throw new Error();\n  });\n\n  test('passing test', () => {\n    expect(true).toBe(true);\n  });\n\n  test('failing test', () => {\n    expect(true).toBe(false);\n  });\n});"}
{"prompt":"Aliases of  and test to avoid collision with global testing APIs.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Global} from '@jest/types';\n\n// Aliases of `it` and `test` to avoid collision with global testing APIs.\nlet circusIt: Global.It;\nlet circusTest: Global.It;\n\nconst aliasCircusIt = () => {\n  const {it, test} = require('../') as typeof import('..');\n  circusIt = it;\n  circusTest = test;\n};\n\naliasCircusIt();\n\ndescribe('test/it.failing error throwing', () => {\n  it(\"it doesn't throw an error with valid arguments\", () => {\n    expect(() => {\n      circusIt.failing('test1', () => {});\n    }).not.toThrow();\n  });\n  it('it throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.failing('test2');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });\n  it(\"it throws an error when first argument isn't valid\", () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.failing(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });\n  it('it throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.failing('test4', 'test4b');\n    }).toThrow(\n      'Invalid second argument, test4b. It must be a callback function.',\n    );\n  });\n  it('test throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusTest.failing('test5');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });\n  it(\"test throws an error when first argument isn't a string\", () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusTest.failing(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });\n  it('test throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusTest.failing('test7', 'test8b');\n    }).toThrow(\n      'Invalid second argument, test8b. It must be a callback function.',\n    );\n  });\n});"}
{"prompt":"Aliases of  and test to avoid collision with global testing APIs.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Global} from '@jest/types';\n\n// Aliases of `it` and `test` to avoid collision with global testing APIs.\nlet circusIt: Global.It;\nlet circusTest: Global.It;\n\nconst aliasCircusIt = () => {\n  const {it, test} = require('../') as typeof import('..');\n  circusIt = it;\n  circusTest = test;\n};\n\naliasCircusIt();\n\ndescribe('test/it error throwing', () => {\n  it(\"it doesn't throw an error with valid arguments\", () => {\n    expect(() => {\n      circusIt('test1', () => {});\n    }).not.toThrow();\n  });\n  it('it throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusIt('test2');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });\n  it(\"it throws an error when first argument isn't valid\", () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusIt(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });\n  it('it throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusIt('test4', 'test4b');\n    }).toThrow(\n      'Invalid second argument, test4b. It must be a callback function.',\n    );\n  });\n  it(\"test doesn't throw an error with valid arguments\", () => {\n    expect(() => {\n      circusTest('test5', () => {});\n    }).not.toThrow();\n  });\n  it('test throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusTest('test6');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });\n  it(\"test throws an error when first argument isn't a string\", () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusTest(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });\n  it('test throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Easy, we're testing runtime errors here\n      circusTest('test8', 'test8b');\n    }).toThrow(\n      'Invalid second argument, test8b. It must be a callback function.',\n    );\n  });\n});"}
{"prompt":"Alias of  to avoid collision with global testing APIs.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Global} from '@jest/types';\n\n// Alias of `it` to avoid collision with global testing APIs.\nlet circusIt: Global.It;\n\nconst aliasCircusIt = () => {\n  const {it} = require('../') as typeof import('..');\n  circusIt = it;\n};\n\naliasCircusIt();\n\ndescribe('test/it.todo error throwing', () => {\n  it('todo throws error when given no arguments', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.todo();\n    }).toThrow('Todo must be called with only a description.');\n  });\n  it('todo throws error when given more than one argument', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      circusIt.todo('test1', () => {});\n    }).toThrow('Todo must be called with only a description.');\n  });\n  it('todo throws error when given none string description', () => {\n    expect(() => {\n      circusIt.todo(() => {});\n    }).toThrow('Todo must be called with only a description.');\n  });\n});"}
{"prompt":"Testing the mocking of a class hierarchy defined in multiple imports,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {SuperTestClass} from './__fixtures__/SuperTestClass';\nimport TestClass from './__fixtures__/TestClass';\njest.mock('./__fixtures__/SuperTestClass');\njest.mock('./__fixtures__/TestClass');\n\ndescribe('Testing the mocking of a class hierarchy defined in multiple imports', () => {\n  it('can call an instance method - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(SuperTestClass.prototype, 'testMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new SuperTestClass();\n    expect(testClassInstance.testMethod()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a superclass instance method - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(TestClass.prototype, 'testMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.testMethod()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n  });\n});"}
{"prompt":"Testing the mocking of exported functions,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport SuperTestClass, * as testTypes from './__fixtures__/class-mocks-types';\njest.mock('./__fixtures__/class-mocks-types');\n\ndescribe('Testing the mocking of exported functions', () => {\n  it('can mock a directly exported function', () => {\n    jest.spyOn(testTypes, 'testFunction1').mockImplementation(() => {\n      return 'mockTestFunction';\n    });\n    expect(testTypes.testFunction1()).toBe('mockTestFunction');\n  });\n\n  it('can mock an indirectly exported function', () => {\n    jest.spyOn(testTypes, 'testFunction2').mockImplementation(() => {\n      return 'mockTestFunction';\n    });\n    expect(testTypes.testFunction2()).toBe('mockTestFunction');\n  });\n\n  it('can mock an indirectly exported anonymous function', () => {\n    jest.spyOn(testTypes, 'testFunction3').mockImplementation(() => {\n      return 'mockTestFunction';\n    });\n    expect(testTypes.testFunction3()).toBe('mockTestFunction');\n  });\n});\n\ndescribe('Testing the mocking of a class hierarchy defined in a single import', () => {\n  it('can call an instance method - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(SuperTestClass.prototype, 'testMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new SuperTestClass();\n    expect(testClassInstance.testMethod()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a superclass instance method - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(testTypes.TestClass.prototype, 'testMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new testTypes.TestClass();\n    expect(testClassInstance.testMethod()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n  });\n\n  it('can call an instance method named \"get\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(SuperTestClass.prototype, 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new SuperTestClass();\n    expect(testClassInstance.get()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a superclass instance method named \"get\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(testTypes.TestClass.prototype, 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new testTypes.TestClass();\n    expect(testClassInstance.get()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call an instance method named \"set\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(SuperTestClass.prototype, 'set')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new SuperTestClass();\n    expect(testClassInstance.set()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a superclass instance method named \"set\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(testTypes.TestClass.prototype, 'set')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new testTypes.TestClass();\n    expect(testClassInstance.set()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a static method - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(SuperTestClass, 'staticTestMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(SuperTestClass.staticTestMethod()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a superclass static method - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(testTypes.TestClass, 'staticTestMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(testTypes.TestClass.staticTestMethod()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n  });\n\n  it('can call a static method named \"get\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(SuperTestClass, 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(SuperTestClass.get()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a superclass static method named \"get\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(testTypes.TestClass, 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(testTypes.TestClass.get()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a static method named \"set\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(SuperTestClass, 'set')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(SuperTestClass.set()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n\n  it('can call a superclass static method named \"set\" - Auto-mocked class', () => {\n    const mockTestMethod = jest\n      .spyOn(testTypes.TestClass, 'set')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(testTypes.TestClass.set()).toBe('mockTestMethod');\n    expect(mockTestMethod).toHaveBeenCalledTimes(1);\n\n    mockTestMethod.mockClear();\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nexport default class SuperTestClass {\n  static staticTestProperty = 'staticTestProperty';\n\n  static get staticTestAccessor(): string {\n    return 'staticTestAccessor';\n  }\n\n  static set staticTestAccessor(_x: string) {\n    return;\n  }\n\n  static staticTestMethod(): string {\n    return 'staticTestMethod';\n  }\n\n  static get(): string {\n    return 'get';\n  }\n\n  static set(): string {\n    return 'set';\n  }\n\n  testProperty = 'testProperty';\n\n  get testAccessor(): string {\n    return 'testAccessor';\n  }\n  set testAccessor(_x: string) {\n    return;\n  }\n\n  testMethod(): string {\n    return 'testMethod';\n  }\n\n  get(): string {\n    return 'get';\n  }\n\n  set(): string {\n    return 'set';\n  }\n}\n\nexport class TestClass extends SuperTestClass {}\n\nexport function testFunction1() {\n  return 'testFunction1';\n}\n\nfunction testFunction() {\n  return 'testFunction2';\n}\nexport const testFunction2 = testFunction;\n\nexport const testFunction3 = () => {\n  return 'testFunction3';\n};"}
{"prompt":"Testing the mocking of a class,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\ndescribe('Testing the mocking of a class', () => {\n  it('can call an instance method', () => {\n    class TestClass {\n      testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'testMethod')\n      .mockImplementation(() => 'mockTestMethod');\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.testMethod()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.testMethod()).toBe('testMethod');\n  });\n\n  it('can call a superclass instance method', () => {\n    class SuperTestClass {\n      testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'testMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.testMethod()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.testMethod()).toBe('testMethod');\n    // eslint-disable-next-line no-prototype-builtins\n    expect(TestClass.prototype.hasOwnProperty('testMethod')).toBe(false);\n  });\n\n  it('can call an instance method named \"get\"', () => {\n    class TestClass {\n      get(): string {\n        return 'get';\n      }\n    }\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.get()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.get()).toBe('get');\n  });\n\n  it('can call a superclass instance method named \"get\"', () => {\n    class SuperTestClass {\n      get(): string {\n        return 'get';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.get()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.get()).toBe('get');\n    // eslint-disable-next-line no-prototype-builtins\n    expect(TestClass.prototype.hasOwnProperty('get')).toBe(false);\n  });\n\n  it('can call an instance method named \"set\"', () => {\n    class TestClass {\n      set(): string {\n        return 'set';\n      }\n    }\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'set')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.set()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.set()).toBe('set');\n  });\n\n  it('can call a superclass instance method named \"set\"', () => {\n    class SuperTestClass {\n      set(): string {\n        return 'set';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'set')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.set()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.set()).toBe('set');\n    // eslint-disable-next-line no-prototype-builtins\n    expect(TestClass.prototype.hasOwnProperty('set')).toBe(false);\n  });\n\n  it('can read a value from an instance getter', () => {\n    class TestClass {\n      get testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'testMethod', 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.testMethod).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.testMethod).toBe('testMethod');\n  });\n\n  it('can read a value from an superclass instance getter', () => {\n    class SuperTestClass {\n      get testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest\n      .spyOn(TestClass.prototype, 'testMethod', 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    const testClassInstance = new TestClass();\n    expect(testClassInstance.testMethod).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(testClassInstance.testMethod).toBe('testMethod');\n  });\n\n  it('can write a value to an instance setter', () => {\n    class TestClass {\n      // eslint-disable-next-line accessor-pairs\n      set testMethod(_x: string) {\n        return;\n      }\n    }\n\n    const mocktestMethod = jest\n      .spyOn(TestClass.prototype, 'testMethod', 'set')\n      .mockImplementation((_x: string) => {\n        return () => {};\n      });\n    const testClassInstance = new TestClass();\n    testClassInstance.testMethod = '';\n    expect(mocktestMethod).toHaveBeenCalledTimes(1);\n\n    mocktestMethod.mockRestore();\n    testClassInstance.testMethod = '';\n    expect(mocktestMethod).toHaveBeenCalledTimes(0);\n  });\n\n  it('can write a value to a superclass instance setter', () => {\n    class SuperTestClass {\n      // eslint-disable-next-line accessor-pairs\n      set testMethod(_x: string) {\n        return;\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mocktestMethod = jest\n      .spyOn(TestClass.prototype, 'testMethod', 'set')\n      .mockImplementation((_x: string) => {\n        return () => {};\n      });\n    const testClassInstance = new TestClass();\n    testClassInstance.testMethod = '';\n    expect(mocktestMethod).toHaveBeenCalledTimes(1);\n\n    mocktestMethod.mockRestore();\n    testClassInstance.testMethod = '';\n    expect(mocktestMethod).toHaveBeenCalledTimes(0);\n  });\n\n  it('can call a static method', () => {\n    class TestClass {\n      static testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    const mockFn = jest\n      .spyOn(TestClass, 'testMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(TestClass.testMethod()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.testMethod()).toBe('testMethod');\n  });\n\n  it('can call a superclass static method', () => {\n    class SuperTestClass {\n      static testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest\n      .spyOn(TestClass, 'testMethod')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(TestClass.testMethod()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.testMethod()).toBe('testMethod');\n  });\n\n  it('can call a static method named \"get\"', () => {\n    class TestClass {\n      static get(): string {\n        return 'get';\n      }\n    }\n\n    const mockFn = jest.spyOn(TestClass, 'get').mockImplementation(() => {\n      return 'mockTestMethod';\n    });\n    expect(TestClass.get()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.get()).toBe('get');\n  });\n\n  it('can call a superclass static method named \"get\"', () => {\n    class SuperTestClass {\n      static get(): string {\n        return 'get';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest.spyOn(TestClass, 'get').mockImplementation(() => {\n      return 'mockTestMethod';\n    });\n    expect(TestClass.get()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.get()).toBe('get');\n    // eslint-disable-next-line no-prototype-builtins\n    expect(TestClass.hasOwnProperty('get')).toBe(false);\n  });\n\n  it('can call a static method named \"set\"', () => {\n    class TestClass {\n      static set(): string {\n        return 'set';\n      }\n    }\n\n    const mockFn = jest.spyOn(TestClass, 'set').mockImplementation(() => {\n      return 'mockTestMethod';\n    });\n    expect(TestClass.set()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.set()).toBe('set');\n  });\n\n  it('can call a superclass static method named \"set\"', () => {\n    class SuperTestClass {\n      static set(): string {\n        return 'set';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest.spyOn(TestClass, 'set').mockImplementation(() => {\n      return 'mockTestMethod';\n    });\n    expect(TestClass.set()).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.set()).toBe('set');\n    // eslint-disable-next-line no-prototype-builtins\n    expect(TestClass.hasOwnProperty('set')).toBe(false);\n  });\n\n  it('can read a value from a static getter', () => {\n    class TestClass {\n      static get testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    const mockFn = jest\n      .spyOn(TestClass, 'testMethod', 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(TestClass.testMethod).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.testMethod).toBe('testMethod');\n  });\n\n  it('can read a value from a superclass static getter', () => {\n    class SuperTestClass {\n      static get testMethod(): string {\n        return 'testMethod';\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mockFn = jest\n      .spyOn(TestClass, 'testMethod', 'get')\n      .mockImplementation(() => {\n        return 'mockTestMethod';\n      });\n    expect(TestClass.testMethod).toBe('mockTestMethod');\n\n    mockFn.mockRestore();\n    expect(TestClass.testMethod).toBe('testMethod');\n  });\n\n  it('can write a value to a static setter', () => {\n    class TestClass {\n      // eslint-disable-next-line accessor-pairs\n      static set testMethod(_x: string) {\n        return;\n      }\n    }\n\n    const mocktestMethod = jest\n      .spyOn(TestClass, 'testMethod', 'set')\n      .mockImplementation((_x: string) => {\n        return () => {};\n      });\n    TestClass.testMethod = '';\n    expect(mocktestMethod).toHaveBeenCalledTimes(1);\n\n    mocktestMethod.mockRestore();\n    expect(mocktestMethod).toHaveBeenCalledTimes(0);\n  });\n\n  it('can write a value to a superclass static setter', () => {\n    class SuperTestClass {\n      // eslint-disable-next-line accessor-pairs\n      static set testMethod(_x: string) {\n        return;\n      }\n    }\n\n    class TestClass extends SuperTestClass {}\n\n    const mocktestMethod = jest\n      .spyOn(TestClass, 'testMethod', 'set')\n      .mockImplementation((_x: string) => {\n        return () => {};\n      });\n    TestClass.testMethod = '';\n    expect(mocktestMethod).toHaveBeenCalledTimes(1);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('stub', () => expect(1).toBe(1));"}
{"prompt":"jest --clearCache,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport runJest from '../runJest';\n\nconst CACHE = path.resolve(tmpdir(), 'clear-cache-directory');\n\ndescribe('jest --clearCache', () => {\n  test('normal run results in cache directory being written', () => {\n    const {exitCode} = runJest('clear-cache', [`--cacheDirectory=${CACHE}`]);\n\n    expect(fs.existsSync(CACHE)).toBe(true);\n    expect(exitCode).toBe(0);\n  });\n  test('clearCache results in deleted directory and exitCode 0', () => {\n    expect(fs.existsSync(CACHE)).toBe(true);\n\n    const {exitCode, stdout, stderr} = runJest('clear-cache', [\n      '--clearCache',\n      `--cacheDirectory=${CACHE}`,\n    ]);\n\n    expect(fs.existsSync(CACHE)).toBe(false);\n    expect(stdout).toBe(`Cleared ${CACHE}`);\n    expect(stderr).toBe('');\n    expect(exitCode).toBe(0);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst dir = path.resolve(tmpdir(), 'clear_FS_and_transform_cache');\nconst testFileContent = `\n'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst absoluteTestHelperFile = path.resolve(__dirname, './testHelper.js');\n\ntest('value is 1', () => {\n  const value = require('./testHelper');\n  expect(value).toBe(1);\n});\n\ntest('value is 1 after file is changed', () => {\n  fs.writeFileSync(absoluteTestHelperFile, 'module.exports = 2;');\n  const value = require('./testHelper');\n  expect(value).toBe(1);\n});\n\ntest('value is 2 after calling \"jest.resetModules\"', () => {\n  jest.resetModules();\n  const value = require('./testHelper');\n  expect(value).toBe(2);\n});\n`;\n\nbeforeEach(() => cleanup(dir));\nafterAll(() => cleanup(dir));\n\ntest('clear FS and transform cache', () => {\n  writeFiles(dir, {\n    'package.json': JSON.stringify({jest: {testEnvironment: 'node'}}),\n    'test.js': testFileContent,\n    'testHelper.js': 'module.exports = 1;',\n  });\n  const {exitCode} = runJest(dir);\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ntest('allows clearing not faked timers', () => {\n  const timer = setTimeout(() => {\n    throw new Error('Should not throw');\n  }, 1000);\n\n  jest.useFakeTimers();\n\n  clearTimeout(timer);\n});"}
{"prompt":"client,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('client', () => {\n  it('should work', () => {});\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {cleanup, extractSummary, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../cli_accepts_exact_filenames');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('CLI accepts exact file names if matchers matched', () => {\n  writeFiles(DIR, {\n    'foo/bar.spec.js': `\n      test('foo', () => {});\n    `,\n    'package.json': JSON.stringify({jest: {testEnvironment: 'node'}}),\n  });\n\n  const result = runJest(DIR, ['-i', '--forceExit', './foo/bar.spec.js']);\n\n  expect(result.exitCode).toBe(0);\n\n  const {rest, summary} = extractSummary(\n    result.stderr.replace('\\\\\\\\foo\\\\\\\\bar', '\\\\/foo\\\\/bar'),\n  );\n\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n  expect(result.stdout).toBe('');\n});\n\ntest('CLI skips exact file names if no matchers matched', () => {\n  writeFiles(DIR, {\n    'foo/bar.js': `\n      test('foo', () => {);\n    `,\n    'package.json': JSON.stringify({jest: {testEnvironment: 'node'}}),\n  });\n\n  const result = runJest(DIR, ['-i', '--forceExit', './foo/bar.js']);\n\n  expect(result.exitCode).toBe(1);\n  expect(result.stdout).toMatch(/No tests found([\\S\\s]*)2 files checked./);\n  expect(result.stderr).toBe('');\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`CLI accepts exact file names if matchers matched 1`] = `\n\"PASS foo/bar.spec.js\n  ✓ foo\n\n\nForce exiting Jest: Have you considered using \\`--detectOpenHandles\\` to detect async operations that kept running after all tests finished?\"\n`;\n\nexports[`CLI accepts exact file names if matchers matched 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching ./foo/bar.spec.js.\"\n`;"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\n'use strict';\n\nimport renderer from 'react-test-renderer';\nimport Clock from '../Clock';\n\njest.useFakeTimers().setSystemTime(1_482_363_367_071);\n\nit('renders correctly', () => {\n  const testRenderer = renderer.create(<Clock />);\n\n  try {\n    expect(testRenderer.toJSON()).toMatchSnapshot();\n  } finally {\n    testRenderer.unmount();\n  }\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`renders correctly 1`] = `\n<p>\n  1482363367.071\n   seconds have elapsed since the UNIX epoch.\n</p>\n`;"}
{"prompt":"collectHandles,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as crypto from 'crypto';\nimport {promises as dns} from 'dns';\nimport http from 'http';\nimport {PerformanceObserver} from 'perf_hooks';\nimport {TLSSocket} from 'tls';\nimport zlib from 'zlib';\nimport collectHandles from '../collectHandles';\n\ndescribe('collectHandles', () => {\n  it('should collect Timeout', async () => {\n    const handleCollector = collectHandles();\n\n    const interval = setInterval(() => {}, 100);\n\n    const openHandles = await handleCollector();\n\n    expect(openHandles).toContainEqual(\n      expect.objectContaining({message: 'Timeout'}),\n    );\n\n    clearInterval(interval);\n  });\n\n  it('should not collect the PerformanceObserver open handle', async () => {\n    const handleCollector = collectHandles();\n\n    const obs = new PerformanceObserver((list, observer) => {});\n    obs.observe({entryTypes: ['mark']});\n\n    const openHandles = await handleCollector();\n\n    expect(openHandles).not.toContainEqual(\n      expect.objectContaining({message: 'PerformanceObserver'}),\n    );\n  });\n\n  it('should not collect the DNSCHANNEL open handle', async () => {\n    const handleCollector = collectHandles();\n\n    const resolver = new dns.Resolver();\n    resolver.getServers();\n\n    const openHandles = await handleCollector();\n\n    expect(openHandles).not.toContainEqual(\n      expect.objectContaining({message: 'DNSCHANNEL'}),\n    );\n  });\n\n  it('should not collect the ZLIB open handle', async () => {\n    const handleCollector = collectHandles();\n\n    const decompressed = zlib.inflateRawSync(\n      Buffer.from('cb2a2d2e5128492d2ec9cc4b0700', 'hex'),\n    );\n\n    const openHandles = await handleCollector();\n\n    expect(openHandles).not.toContainEqual(\n      expect.objectContaining({message: 'ZLIB'}),\n    );\n  });\n\n  it('should not collect the SIGNREQUEST open handle', async () => {\n    const handleCollector = collectHandles();\n\n    const key =\n      '-----BEGIN PRIVATE KEY-----\\r\\nMC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD' +\n      '/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\\r\\n-----END PRIVATE KEY-----';\n    const data = Buffer.from('a');\n    crypto.sign(null, data, key);\n\n    const openHandles = await handleCollector();\n\n    expect(openHandles).not.toContainEqual(\n      expect.objectContaining({message: 'SIGNREQUEST'}),\n    );\n  });\n\n  it('should collect handles opened in test functions with `done` callbacks', done => {\n    const handleCollector = collectHandles();\n    const server = http.createServer((_, response) => response.end('ok'));\n    server.listen(0, () => {\n      // Collect results while server is still open.\n      handleCollector()\n        .then(openHandles => {\n          server.close(() => {\n            expect(openHandles).toContainEqual(\n              expect.objectContaining({message: 'TCPSERVERWRAP'}),\n            );\n            done();\n          });\n        })\n        .catch(done);\n    });\n  });\n\n  it('should not collect handles that have been queued to close', async () => {\n    const handleCollector = collectHandles();\n    const server = http.createServer((_, response) => response.end('ok'));\n\n    // Start and stop server.\n    await new Promise(resolve => server.listen(0, resolve));\n    await new Promise(resolve => server.close(resolve));\n\n    const openHandles = await handleCollector();\n    expect(openHandles).toHaveLength(0);\n  });\n\n  it('should collect handles indirectly triggered by user code', async () => {\n    const handleCollector = collectHandles();\n\n    // Calling `server.listen` with just a port (e.g. `server.listen(0)`)\n    // creates a `TCPSERVERWRAP` async resource. However, including a `host`\n    // option instead creates a `GETADDRINFOREQWRAP` resource that only\n    // lasts for the lifetime of the `listen()` call, but which *indirectly*\n    // creates a long-lived `TCPSERVERWRAP` resource. We want to make sure we\n    // capture that long-lived resource.\n    const server = new http.Server();\n    await new Promise(resolve =>\n      server.listen({host: 'localhost', port: 0}, resolve),\n    );\n\n    const openHandles = await handleCollector();\n\n    await new Promise(resolve => server.close(resolve));\n\n    expect(openHandles).toContainEqual(\n      expect.objectContaining({message: 'TCPSERVERWRAP'}),\n    );\n  });\n\n  it('should not collect the `TLSWRAP` open handle', async () => {\n    const handleCollector = collectHandles();\n\n    const socket = new TLSSocket();\n\n    const openHandles = await handleCollector();\n\n    expect(openHandles).toHaveLength(0);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('does not crash when expect involving a DOM node fails', () => {\n  const result = runJest('compare-dom-nodes');\n\n  expect(result.stderr).toContain('FAIL __tests__/failedAssertion.js');\n});"}
{"prompt":"this is a tiny b flaky","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {\n  cleanup,\n  createEmptyPackage,\n  extractSortedSummary,\n  writeFiles,\n} from '../Utils';\nimport {runContinuous} from '../runJest';\n\nconst tempDir = path.resolve(tmpdir(), 'complex-errors');\n\n// this is a tiny bit flaky\njest.retryTimes(3);\n\nbeforeEach(() => {\n  createEmptyPackage(tempDir);\n});\n\nafterEach(() => {\n  cleanup(tempDir);\n});\n\ntest('handles functions that close over outside variables', async () => {\n  const testFileContent = `\n    const someString = 'hello from the other side';\n\n    test('dummy', () => {\n      const error = new Error('boom');\n\n      error.someProp = () => someString;\n\n      throw error;\n    });\n  `;\n\n  writeFiles(tempDir, {\n    '__tests__/test-1.js': testFileContent,\n    '__tests__/test-2.js': testFileContent,\n  });\n\n  const {end, waitUntil} = runContinuous(\n    tempDir,\n    ['--no-watchman', '--watch-all'],\n    // timeout in case the `waitUntil` below doesn't fire\n    {stripAnsi: true, timeout: 10_000},\n  );\n\n  await waitUntil(({stderr}) => stderr.includes('Ran all test suites.'));\n\n  const {stderr} = await end();\n\n  const {rest} = extractSortedSummary(stderr);\n  expect(rest).toMatchSnapshot();\n});\n\ntest.skip('handles errors with BigInt', async () => {\n  const testFileContent = `\n    test('dummy', () => {\n      expect(1n).toEqual(2n);\n    });\n  `;\n\n  writeFiles(tempDir, {\n    '__tests__/test-1.js': testFileContent,\n    '__tests__/test-2.js': testFileContent,\n  });\n\n  const {end, waitUntil} = runContinuous(\n    tempDir,\n    ['--no-watchman', '--watch-all'],\n    // timeout in case the `waitUntil` below doesn't fire\n    {stripAnsi: true, timeout: 5000},\n  );\n\n  await waitUntil(({stderr}) => stderr.includes('Ran all test suites.'));\n\n  const {stderr} = await end();\n\n  const {rest} = extractSortedSummary(stderr);\n  expect(rest).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`handles errors with BigInt 1`] = `\n\"FAIL __tests__/test-1.js\n  ● dummy\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: 2n\n    Received: 1n\n\n      1 | test('dummy', () => {\n    > 2 |   expect(1n).toEqual(2n);\n        |              ^\n      3 | });\n\n      at Object.toEqual (__tests__/test-1.js:2:14)\n\nFAIL __tests__/test-2.js\n  ● dummy\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: 2n\n    Received: 1n\n\n      1 | test('dummy', () => {\n    > 2 |   expect(1n).toEqual(2n);\n        |              ^\n      3 | });\n\n      at Object.toEqual (__tests__/test-2.js:2:14)\"\n`;\n\nexports[`handles functions that close over outside variables 1`] = `\n\"FAIL __tests__/test-1.js\n  ● dummy\n\n    boom\n\n      2 |\n      3 | test('dummy', () => {\n    > 4 |   const error = new Error('boom');\n        |                 ^\n      5 |\n      6 |   error.someProp = () => someString;\n      7 |\n\n      at Object.<anonymous> (__tests__/test-1.js:4:17)\n\nFAIL __tests__/test-2.js\n  ● dummy\n\n    boom\n\n      2 |\n      3 | test('dummy', () => {\n    > 4 |   const error = new Error('boom');\n        |                 ^\n      5 |\n      6 |   error.someProp = () => someString;\n      7 |\n\n      at Object.<anonymous> (__tests__/test-2.js:4:17)\"\n`;"}
{"prompt":".concurrent.each[","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nit.concurrent.each([\n  [1, 2],\n  [2, 3],\n])('adds one to number', async (a, b) => {\n  expect(a + 1).toBe(b);\n});\n\nit.concurrent.skip.each([\n  [1, 2],\n  [2, 3],\n])('should skip this test', Promise.resolve());"}
{"prompt":".concurrent#${t},  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst sleep = duration => new Promise(resolve => setTimeout(resolve, duration));\nlet current = 0;\n\nfor (let t = 0; t < 10; ++t) {\n  it.concurrent(`#${t}`, () => {\n    current += 1;\n\n    if (current > 5) {\n      current -= 1;\n      throw new Error('Too many processes ran simultaneously');\n    } else {\n      return sleep(20).then(() => {\n        current -= 1;\n      });\n    }\n  });\n}"}
{"prompt":".concurrentone, testFnone, 85;","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst {setTimeout} = require('timers/promises');\n\nlet delta = Date.now();\nconst includeDelta = false;\nconst marker = s => {\n  console.log(s, includeDelta ? `+${Date.now() - delta}ms` : '');\n  delta = Date.now();\n};\n\nbeforeAll(() => marker('beforeAll'));\nafterAll(() => marker('afterAll'));\n\nbeforeEach(() => marker('beforeEach'));\nafterEach(() => marker('afterEach'));\n\nconst testFn = (name, delay, fail) => {\n  return async () => {\n    marker(`START \"${name}\"`);\n    await setTimeout(delay);\n    if (fail) {\n      throw new Error(`${name} failed`);\n    }\n    expect(name).toBe(name);\n    expect.assertions(1);\n    marker(`END: \"${name}\"`);\n  };\n};\n\nit.concurrent('one', testFn('one', 85));\nit('two (sequential)', testFn('two (sequential)', 100));\n\ndescribe('level 1', () => {\n  beforeEach(() => marker('beforeEach level 1'));\n  afterEach(() => marker('afterEach level 1'));\n\n  it.concurrent('three', testFn('three', 70));\n\n  it('four (sequential)', testFn('four (sequential)', 120));\n\n  describe('level 2', () => {\n    beforeEach(() => marker('beforeEach level 2'));\n    afterEach(() => marker('afterEach level 2'));\n    it.concurrent('five', testFn('five', 160));\n\n    it('six (sequential)', testFn('six (sequential)', 100));\n  });\n\n  it.concurrent('seven', testFn('seven', 100));\n  it.concurrent('eight', testFn('eight', 120));\n});\n\nit.concurrent('nine', testFn('nine', 20));\n\nit.concurrent('ten', testFn('ten', 50));"}
{"prompt":".concurrent.only.each[","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable jest/no-focused-tests */\n\n'use strict';\n\nit.concurrent.only.each([\n  [1, 2],\n  [2, 3],\n])('adds one to number', async (a, b) => {\n  expect(a + 1).toBe(b);\n});\n\nit.concurrent.each([\n  [1, 2],\n  [2, 3],\n])('adds one to number', async (a, b) => {\n  expect(a + 1).toBe(b);\n});"}
{"prompt":".concurrentone, testFnone, 85;","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst {setTimeout} = require('timers/promises');\n\nlet delta = Date.now();\nconst includeDelta = false;\nconst marker = s => {\n  console.log(s, includeDelta ? `+${Date.now() - delta}ms` : '');\n  delta = Date.now();\n};\n\nbeforeAll(() => marker('beforeAll'));\nafterAll(() => marker('afterAll'));\n\nbeforeEach(() => marker('beforeEach'));\nafterEach(() => marker('afterEach'));\n\nconst testFn = (name, delay, fail) => {\n  return async () => {\n    marker(`START \"${name}\"`);\n    await setTimeout(delay);\n    if (fail) {\n      throw new Error(`${name} failed`);\n    }\n    expect(name).toBe(name);\n    expect.assertions(1);\n    marker(`END: \"${name}\"`);\n  };\n};\n\nit.concurrent('one', testFn('one', 85));\nit.concurrent('two', testFn('two', 100, true));\n\ndescribe('level 1', () => {\n  beforeEach(() => marker('beforeEach level 1'));\n  afterEach(() => marker('afterEach level 1'));\n\n  it.concurrent('three', testFn('three', 70));\n\n  it.concurrent.only('four', testFn('four', 120));\n\n  describe('level 2', () => {\n    beforeEach(() => marker('beforeEach level 2'));\n    afterEach(() => marker('afterEach level 2'));\n    it.concurrent('five', testFn('five', 160, true));\n\n    it.concurrent.only('six', testFn('six', 100));\n  });\n\n  it.concurrent('seven', testFn('seven', 100));\n  it.concurrent('eight', testFn('eight', 120));\n});\n\nit.concurrent.only('nine', testFn('nine', 20));\n\nit.concurrent('ten', testFn('ten', 50));"}
{"prompt":".concurrentGood Test, async  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nit.concurrent('Good Test', async () => {\n  await new Promise(resolve => setTimeout(resolve, 100));\n});\n\nit.concurrent('Bad Test', async () => {\n  expect('a').toBe('b');\n});"}
{"prompt":".concurrentone, testFnone, 85;","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst {setTimeout} = require('timers/promises');\n\nlet delta = Date.now();\nconst includeDelta = false;\nconst marker = s => {\n  console.log(s, includeDelta ? `+${Date.now() - delta}ms` : '');\n  delta = Date.now();\n};\n\nbeforeAll(() => marker('beforeAll'));\nafterAll(() => marker('afterAll'));\n\nbeforeEach(() => marker('beforeEach'));\nafterEach(() => marker('afterEach'));\n\nconst testFn = (name, delay, fail) => {\n  return async () => {\n    marker(`START \"${name}\"`);\n    await setTimeout(delay);\n    if (fail) {\n      throw new Error(`${name} failed`);\n    }\n    expect(name).toBe(name);\n    expect.assertions(1);\n    marker(`END: \"${name}\"`);\n  };\n};\n\nit.concurrent('one', testFn('one', 85));\nit.concurrent('two', testFn('two', 100));\n\ndescribe('level 1', () => {\n  beforeEach(() => marker('beforeEach level 1'));\n  afterEach(() => marker('afterEach level 1'));\n\n  it.concurrent.skip('skipped three', testFn('three', 70));\n\n  it.concurrent('four', testFn('four', 120));\n\n  describe('level 2', () => {\n    beforeEach(() => marker('beforeEach level 2'));\n    afterEach(() => marker('afterEach level 2'));\n    it.concurrent.skip('five (skipped)', testFn('five', 160));\n\n    it.concurrent.skip('six (skipped)', testFn('six', 100));\n  });\n\n  it.concurrent('seven', testFn('seven', 100));\n  it.concurrent('eight', testFn('eight', 120));\n});\n\nit.concurrent.skip('nine (skipped)', testFn('nine', 20));\n\nit.concurrent('ten', testFn('ten', 50));"}
{"prompt":".concurrentone,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst marker = s => console.log(`[[${s}]]`);\n\nbeforeAll(() => marker('beforeAll'));\nafterAll(() => marker('afterAll'));\n\nbeforeEach(() => marker('beforeEach'));\nafterEach(() => marker('afterEach'));\n\nit.concurrent('one', () => {\n  marker('test');\n  return Promise.resolve();\n});\nit.concurrent.skip('two', () => {\n  marker('test');\n  return Promise.resolve();\n});\nit.concurrent('three', () => {\n  marker('test');\n  return Promise.resolve();\n});\nit.concurrent('concurrent test fails', () => {\n  marker('test');\n  return Promise.reject();\n});"}
{"prompt":"concurrent,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\ndescribe('concurrent', () => {\n  test.concurrent.each([\n    [1, 2],\n    [2, 3],\n    [3, 4],\n  ])('should add 1 to number', async (a, sum) => {\n    expect(a + 1).toEqual(sum);\n  });\n});"}
{"prompt":"one,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ndescribe('one', () => {\n  it.concurrent('concurrent test gets skipped', () => {\n    console.log(`this is not logged ${Math.random()}`);\n    return Promise.resolve();\n  });\n  it.concurrent('concurrent test fails', () => {\n    console.log(`this is logged ${Math.random()}`);\n    return Promise.reject(new Error());\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest, {getConfig} from '../runJest';\n\ntest('config as JSON', () => {\n  const result = runJest('verbose-reporter', [\n    `--config=${JSON.stringify({\n      testEnvironment: 'node',\n      testMatch: ['banana strawberry kiwi'],\n    })}`,\n  ]);\n\n  expect(result.exitCode).toBe(1);\n  expect(result.stdout).toMatch('No tests found');\n});\n\ntest('works with sane config JSON', () => {\n  const result = runJest('verbose-reporter', [\n    `--config=${JSON.stringify({\n      testEnvironment: 'node',\n    })}`,\n  ]);\n\n  expect(result.exitCode).toBe(1);\n  expect(result.stderr).toMatch('works just fine');\n});\n\ntest('watchman config option is respected over default argv', () => {\n  const {stdout} = runJest('verbose-reporter', [\n    '--env=node',\n    '--watchman=false',\n    '--debug',\n  ]);\n\n  expect(stdout).toMatch('\"watchman\": false');\n});\n\ntest('config from argv is respected with sane config JSON', () => {\n  const {stdout} = runJest('verbose-reporter', [\n    `--config=${JSON.stringify({\n      testEnvironment: 'node',\n      watchman: false,\n    })}`,\n    '--debug',\n  ]);\n\n  expect(stdout).toMatch('\"watchman\": false');\n});\n\ntest('works with jsdom testEnvironmentOptions config JSON', () => {\n  const result = runJest('environmentOptions', [\n    `--config=${JSON.stringify({\n      testEnvironment: 'jsdom',\n      testEnvironmentOptions: {\n        url: 'https://jestjs.io',\n      },\n    })}`,\n  ]);\n\n  expect(result.exitCode).toBe(0);\n  expect(result.stderr).toContain('found url jestjs.io');\n});\n\ntest('negated flags override previous flags', () => {\n  const {globalConfig} = getConfig('verbose-reporter', [\n    '--silent',\n    '--no-silent',\n    '--silent',\n  ]);\n\n  expect(globalConfig.silent).toBe(true);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {getConfig} from '../runJest';\n\ntest('reads config from cjs file', () => {\n  const {configs} = getConfig(\n    'config-override',\n    ['--config', 'different-config.json'],\n    {\n      skipPkgJsonCheck: true,\n    },\n  );\n\n  expect(configs).toHaveLength(1);\n  expect(configs[0].displayName).toEqual({\n    color: 'white',\n    name: 'Config from different-config.json file',\n  });\n});"}
{"prompt":"test only works consistently whout tty","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst stdoutWrite = require('../stdout-spy');\n\nprocess.stdout.write = jest.fn(process.stdout.write);\n\ntest('verbose mode prints console output synchronously', () => {\n  // test only works consistently without tty\n  expect(process.stdout.isTTY).not.toBe(true);\n\n  console.log('test');\n\n  expect(stdoutWrite.text).toMatchInlineSnapshot(`\n    \"  console.log\n        test\n\n          at Object.log (__tests__/console-debugging.test.js:17:11)\n\n    \"\n  `);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst winston = require('winston');\nconst logger = winston.createLogger({\n  transports: [new winston.transports.Console()],\n});\n\ntest('using winston should not fail', () => {\n  logger.log('info', 'Log message from winston');\n\n  logger.info('Info message from winston');\n\n  logger.warn('Warn message from winston');\n\n  logger.error('Error message from winston');\n});"}
{"prompt":"Need to pass --config because console test specifies verbose: false","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {extractSummary, runYarnInstall} from '../Utils';\nimport runJest from '../runJest';\n\ntest('console printing', () => {\n  const {stderr, exitCode} = runJest('console');\n  const {summary, rest} = extractSummary(stderr);\n\n  expect(exitCode).toBe(0);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n});\n\ntest('console printing with --verbose', () => {\n  const {stderr, stdout, exitCode} = runJest('console', [\n    '--verbose',\n    '--no-cache',\n  ]);\n  const {summary, rest} = extractSummary(stderr);\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n});\n\ntest('does not print to console with --silent', () => {\n  const {stderr, stdout, exitCode} = runJest('console', [\n    // Need to pass --config because console test specifies `verbose: false`\n    `--config=${JSON.stringify({\n      testEnvironment: 'node',\n    })}`,\n    '--silent',\n    '--no-cache',\n  ]);\n  const {summary, rest} = extractSummary(stderr);\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n});\n\ntest('respects --noStackTrace', () => {\n  const {stderr, stdout, exitCode} = runJest('console', [\n    // Need to pass --config because console test specifies `verbose: false`\n    `--config=${JSON.stringify({\n      testEnvironment: 'node',\n    })}`,\n    '--noStackTrace',\n    '--no-cache',\n  ]);\n  const {summary, rest} = extractSummary(stderr);\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n});\n\ntest('respects noStackTrace in config', () => {\n  const {stderr, stdout, exitCode} = runJest('console', [\n    // Need to pass --config because console test specifies `verbose: false`\n    `--config=${JSON.stringify({\n      noStackTrace: true,\n      testEnvironment: 'node',\n    })}`,\n    '--no-cache',\n  ]);\n  const {summary, rest} = extractSummary(stderr);\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n});\n\n// issue: https://github.com/jestjs/jest/issues/5223\ntest('the jsdom console is the same as the test console', () => {\n  const {stderr, stdout, exitCode} = runJest('console-jsdom');\n  const {summary, rest} = extractSummary(stderr);\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n});\n\ntest('does not error out when using winston', () => {\n  const dir = path.resolve(__dirname, '../console-winston');\n  runYarnInstall(dir);\n  const {stderr, stdout, exitCode} = runJest(dir);\n  const {summary, rest} = extractSummary(stderr);\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`console printing 1`] = `\n\"PASS __tests__/console.test.js\n  ● Console\n\n    console.log\n      This is a log message.\n\n      at Object.log (__tests__/console.test.js:10:11)\n\n    console.info\n      This is an info message.\n\n      at Object.info (__tests__/console.test.js:12:11)\n\n    console.warn\n      This is a warning message.\n\n      12 |   console.info('This is an info message.');\n      13 |\n    > 14 |   console.warn('This is a warning message.');\n         |           ^\n      15 |\n      16 |   console.error('This is an error message.');\n      17 | });\n\n      at Object.warn (__tests__/console.test.js:14:11)\n\n    console.error\n      This is an error message.\n\n      14 |   console.warn('This is a warning message.');\n      15 |\n    > 16 |   console.error('This is an error message.');\n         |           ^\n      17 | });\n      18 |\n\n      at Object.error (__tests__/console.test.js:16:11)\"\n`;\n\nexports[`console printing 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`console printing with --verbose 1`] = `\n\"  console.log\n    This is a log message.\n\n      at Object.log (__tests__/console.test.js:10:11)\n\n  console.info\n    This is an info message.\n\n      at Object.info (__tests__/console.test.js:12:11)\n\n  console.warn\n    This is a warning message.\n\n      12 |   console.info('This is an info message.');\n      13 |\n    > 14 |   console.warn('This is a warning message.');\n         |           ^\n      15 |\n      16 |   console.error('This is an error message.');\n      17 | });\n\n      at Object.warn (__tests__/console.test.js:14:11)\n\n  console.error\n    This is an error message.\n\n      14 |   console.warn('This is a warning message.');\n      15 |\n    > 16 |   console.error('This is an error message.');\n         |           ^\n      17 | });\n      18 |\n\n      at Object.error (__tests__/console.test.js:16:11)\n\"\n`;\n\nexports[`console printing with --verbose 2`] = `\n\"PASS __tests__/console.test.js\n  ✓ works just fine\"\n`;\n\nexports[`console printing with --verbose 3`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`does not error out when using winston 1`] = `\"\"`;\n\nexports[`does not error out when using winston 2`] = `\n\"PASS __tests__/console.test.js\n  ● Console\n\n    console.log\n      {\"level\":\"info\",\"message\":\"Log message from winston\"}\n\n      at Console.log (node_modules/winston/lib/winston/transports/console.js:87:23)\n\n    console.log\n      {\"level\":\"info\",\"message\":\"Info message from winston\"}\n\n      at Console.log (node_modules/winston/lib/winston/transports/console.js:87:23)\n\n    console.log\n      {\"level\":\"warn\",\"message\":\"Warn message from winston\"}\n\n      at Console.log (node_modules/winston/lib/winston/transports/console.js:87:23)\n\n    console.log\n      {\"level\":\"error\",\"message\":\"Error message from winston\"}\n\n      at Console.log (node_modules/winston/lib/winston/transports/console.js:87:23)\"\n`;\n\nexports[`does not error out when using winston 3`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`does not print to console with --silent 1`] = `\"\"`;\n\nexports[`does not print to console with --silent 2`] = `\"PASS __tests__/console.test.js\"`;\n\nexports[`does not print to console with --silent 3`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\"\n`;\n\nexports[`respects --noStackTrace 1`] = `\n\"  console.log\n    This is a log message.\n\n      at Object.log (__tests__/console.test.js:10:11)\n\n  console.info\n    This is an info message.\n\n      at Object.info (__tests__/console.test.js:12:11)\n\n  console.warn\n    This is a warning message.\n\n      at Object.warn (__tests__/console.test.js:14:11)\n\n  console.error\n    This is an error message.\n\n      at Object.error (__tests__/console.test.js:16:11)\n\"\n`;\n\nexports[`respects --noStackTrace 2`] = `\n\"PASS __tests__/console.test.js\n  ✓ works just fine\"\n`;\n\nexports[`respects --noStackTrace 3`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`respects noStackTrace in config 1`] = `\n\"  console.log\n    This is a log message.\n\n      at Object.log (__tests__/console.test.js:10:11)\n\n  console.info\n    This is an info message.\n\n      at Object.info (__tests__/console.test.js:12:11)\n\n  console.warn\n    This is a warning message.\n\n      at Object.warn (__tests__/console.test.js:14:11)\n\n  console.error\n    This is an error message.\n\n      at Object.error (__tests__/console.test.js:16:11)\n\"\n`;\n\nexports[`respects noStackTrace in config 2`] = `\n\"PASS __tests__/console.test.js\n  ✓ works just fine\"\n`;\n\nexports[`respects noStackTrace in config 3`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`the jsdom console is the same as the test console 1`] = `\"\"`;\n\nexports[`the jsdom console is the same as the test console 2`] = `\n\"PASS __tests__/console.test.js\n  ✓ can mock console.error calls from jsdom\"\n`;\n\nexports[`the jsdom console is the same as the test console 3`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\ntest('console printing', () => {\n  const {stderr, exitCode} = runJest('console-after-teardown');\n  const {rest} = extractSummary(stderr);\n\n  expect(exitCode).toBe(1);\n\n  const withoutTrace = rest.split('\\n').slice(0, -3).join('\\n');\n\n  expect(withoutTrace).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`console printing 1`] = `\n\"PASS __tests__/console.test.js\n\n\n  ●  Cannot log after tests are done. Did you forget to wait for something async in your test?\n    Attempted to log \"hello!\".\n\n      10 |   // Named function to have the function be named the same in jasmine and circus\n      11 |   new Promise(resolve => setTimeout(resolve, 500)).then(function log() {\n    > 12 |     console.log('hello!');\n         |             ^\n      13 |   });\n      14 | });\n      15 |\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\ntest('console debugging with --verbose', () => {\n  const {stderr, stdout, exitCode} = runJest('console-debugging', [\n    '--noStackTrace',\n    '--no-cache',\n  ]);\n  const {summary, rest} = extractSummary(stderr);\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`console debugging with --verbose 1`] = `\n\"  console.log\n    test\n\n      at Object.log (__tests__/console-debugging.test.js:17:11)\n\"\n`;\n\nexports[`console debugging with --verbose 2`] = `\n\"PASS __tests__/console-debugging.test.js\n  ✓ verbose mode prints console output synchronously\"\n`;\n\nexports[`console debugging with --verbose 3`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   1 passed, 1 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {cleanup, extractSummary, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../console-log-output-when-run-in-band');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('prints console.logs when run with forceExit', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': `\n      test('banana', () => console.log('Hey'));\n    `,\n    'package.json': '{}',\n  });\n\n  const {stderr, stdout, exitCode} = runJest(DIR, [\n    '-i',\n    '--ci=false',\n    '--forceExit',\n  ]);\n\n  const {rest, summary} = extractSummary(stderr);\n\n  expect(exitCode).toBe(0);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n  expect(stdout).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`prints console.logs when run with forceExit 1`] = `\n\"PASS __tests__/a-banana.js\n  ✓ banana\n\n\nForce exiting Jest: Have you considered using \\`--detectOpenHandles\\` to detect async operations that kept running after all tests finished?\"\n`;\n\nexports[`prints console.logs when run with forceExit 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`prints console.logs when run with forceExit 3`] = `\n\"  console.log\n    Hey\n\n      at Object.<anonymous> (__tests__/a-banana.js:1:41)\n\"\n`;"}
{"prompt":"retryTimes not set,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nit('retryTimes not set', () => {\n  expect(true).toBeFalsy();\n});"}
{"prompt":"retryTimes not set,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nit('retryTimes not set', () => {\n  expect(true).toBeFalsy();\n});"}
{"prompt":"convertDescriptorToString,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport convertDescriptorToString from '../convertDescriptorToString';\n\ndescribe(convertDescriptorToString, () => {\n  test.each([\n    [undefined, 'undefined'],\n    ['name', 'name'],\n    [123, '123'],\n    [function named() {}, 'named'],\n    [class Named {}, 'Named'],\n  ])('%p', (input, output) => {\n    expect(convertDescriptorToString(input)).toBe(output);\n  });\n\n  test.each([\n    ['null', null],\n    ['array', ['abc']],\n    ['object', {abc: 'def'}],\n    ['anonymous function expression', function () {}],\n    ['anonymous arrow function', () => {}],\n    ['anonymous class expression', class {}],\n  ])('%s', (_, input) => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime error\n      return convertDescriptorToString(input);\n    }).toThrow(\n      `Invalid first argument, ${String(\n        input,\n      )}. It must be a named class, named function, number, or string.`,\n    );\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nexports.isNodeModule = true;"}
{"prompt":"code coverage for Handlebars,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {readFileSync} from 'graceful-fs';\nimport {cleanup, runYarnInstall} from '../Utils';\nimport runJest from '../runJest';\n\nconst dir = path.resolve(__dirname, '../coverage-handlebars');\nconst coverageDir = path.join(dir, 'coverage');\n\nbeforeAll(() => {\n  cleanup(coverageDir);\n});\n\nit('code coverage for Handlebars', () => {\n  runYarnInstall(dir);\n  const result = runJest(dir, ['--coverage', '--no-cache']);\n\n  expect(result.exitCode).toBe(0);\n  expect(result.stdout).toMatchSnapshot();\n\n  const coverageMapFile = path.join(coverageDir, 'coverage-final.json');\n  const coverageMap = JSON.parse(readFileSync(coverageMapFile, 'utf8'));\n\n  expect(\n    Object.keys(coverageMap).map(filename => path.basename(filename)),\n  ).toEqual(['greet.hbs']);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`code coverage for Handlebars 1`] = `\n\"-----------|---------|----------|---------|---------|-------------------\nFile       | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n-----------|---------|----------|---------|---------|-------------------\nAll files  |      60 |       45 |      50 |   55.55 |                   \n greet.hbs |      60 |       45 |      50 |   55.55 | 5,8-11            \n-----------|---------|----------|---------|---------|-------------------\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../coverage-provider-v8');\n\ntest('prints coverage with missing sourcemaps', () => {\n  const sourcemapDir = path.join(DIR, 'no-sourcemap');\n\n  const {stdout, exitCode} = runJest(\n    sourcemapDir,\n    ['--coverage', '--coverage-provider', 'v8'],\n    {stripAnsi: true},\n  );\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('prints coverage with empty sourcemaps', () => {\n  const sourcemapDir = path.join(DIR, 'empty-sourcemap');\n\n  const {stdout, exitCode} = runJest(\n    sourcemapDir,\n    ['--coverage', '--coverage-provider', 'v8'],\n    {stripAnsi: true},\n  );\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('reports coverage with `resetModules`', () => {\n  const sourcemapDir = path.join(DIR, 'with-resetModules');\n\n  const {stdout, exitCode} = runJest(\n    sourcemapDir,\n    ['--coverage', '--coverage-provider', 'v8'],\n    {stripAnsi: true},\n  );\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('prints correct coverage report, if a CJS module is put under test without transformation', () => {\n  const sourcemapDir = path.join(DIR, 'cjs-native-without-sourcemap');\n\n  const {stdout, exitCode} = runJest(\n    sourcemapDir,\n    ['--coverage', '--coverage-provider', 'v8', '--no-cache'],\n    {stripAnsi: true},\n  );\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('prints correct coverage report, if a TS module is transpiled by Babel to CJS and put under test', () => {\n  const sourcemapDir = path.join(DIR, 'cjs-with-babel-transformer');\n\n  const {stdout, exitCode} = runJest(\n    sourcemapDir,\n    ['--coverage', '--coverage-provider', 'v8', '--no-cache'],\n    {stripAnsi: true},\n  );\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('prints correct coverage report, if an ESM module is put under test without transformation', () => {\n  const sourcemapDir = path.join(DIR, 'esm-native-without-sourcemap');\n\n  const {stdout, exitCode} = runJest(\n    sourcemapDir,\n    ['--coverage', '--coverage-provider', 'v8', '--no-cache'],\n    {\n      nodeOptions: '--experimental-vm-modules --no-warnings',\n      stripAnsi: true,\n    },\n  );\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('prints correct coverage report, if a TS module is transpiled by custom transformer to ESM put under test', () => {\n  const sourcemapDir = path.join(DIR, 'esm-with-custom-transformer');\n\n  const {stdout, exitCode} = runJest(\n    sourcemapDir,\n    ['--coverage', '--coverage-provider', 'v8', '--no-cache'],\n    {\n      nodeOptions: '--experimental-vm-modules --no-warnings',\n      stripAnsi: true,\n    },\n  );\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('vm script coverage generator', () => {\n  const dir = path.resolve(__dirname, '../vmscript-coverage');\n  const {stdout, exitCode} = runJest(\n    dir,\n    ['--coverage', '--coverage-provider', 'v8'],\n    {stripAnsi: true},\n  );\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`prints correct coverage report, if a CJS module is put under test without transformation 1`] = `\n\"  console.log\n    this will print\n\n      at covered (module.js:11:11)\n\n--------------|---------|----------|---------|---------|-------------------\nFile          | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n--------------|---------|----------|---------|---------|-------------------\nAll files     |   59.37 |       60 |      50 |   59.37 |                   \n module.js    |   79.16 |       75 |   66.66 |   79.16 | 14-16,19-20       \n uncovered.js |       0 |        0 |       0 |       0 | 1-8               \n--------------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`prints correct coverage report, if a TS module is transpiled by Babel to CJS and put under test 1`] = `\n\"  console.log\n    this will print\n\n      at log (module.ts:13:11)\n\n--------------|---------|----------|---------|---------|-------------------\nFile          | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n--------------|---------|----------|---------|---------|-------------------\nAll files     |      50 |       25 |      25 |      50 |                   \n module.ts    |   80.76 |       50 |      50 |   80.76 | 16-18,21-22       \n types.ts     |       0 |        0 |       0 |       0 | 1-8               \n uncovered.ts |       0 |        0 |       0 |       0 | 1-8               \n--------------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`prints correct coverage report, if a TS module is transpiled by custom transformer to ESM put under test 1`] = `\n\"  console.log\n    this will print\n\n      at covered (module.ts:13:11)\n\n--------------|---------|----------|---------|---------|-------------------\nFile          | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n--------------|---------|----------|---------|---------|-------------------\nAll files     |      50 |       25 |      25 |      50 |                   \n module.ts    |   80.76 |       50 |      50 |   80.76 | 16-18,21-22       \n types.ts     |       0 |        0 |       0 |       0 | 1-8               \n uncovered.ts |       0 |        0 |       0 |       0 | 1-8               \n--------------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`prints correct coverage report, if an ESM module is put under test without transformation 1`] = `\n\"  console.log\n    this will print\n\n      at covered (module.js:11:11)\n\n--------------|---------|----------|---------|---------|-------------------\nFile          | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n--------------|---------|----------|---------|---------|-------------------\nAll files     |   59.37 |       50 |   33.33 |   59.37 |                   \n module.js    |   79.16 |    66.66 |      50 |   79.16 | 14-16,19-20       \n uncovered.js |       0 |        0 |       0 |       0 | 1-8               \n--------------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`prints coverage with empty sourcemaps 1`] = `\n\"----------|---------|----------|---------|---------|-------------------\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n----------|---------|----------|---------|---------|-------------------\nAll files |     100 |      100 |     100 |     100 |                   \n types.ts |     100 |      100 |     100 |     100 |                   \n----------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`prints coverage with missing sourcemaps 1`] = `\n\"  console.log\n    42\n\n      at Object.log (__tests__/Thing.test.js:10:9)\n\n----------|---------|----------|---------|---------|-------------------\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n----------|---------|----------|---------|---------|-------------------\nAll files |     100 |      100 |     100 |     100 |                   \n Thing.js |     100 |      100 |     100 |     100 |                   \n x.css    |     100 |      100 |     100 |     100 |                   \n----------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`reports coverage with \\`resetModules\\` 1`] = `\n\"  console.log\n    this will print\n\n      at log (module.js:11:11)\n\n  console.log\n    this will print\n\n      at log (module.js:11:11)\n\n--------------|---------|----------|---------|---------|-------------------\nFile          | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n--------------|---------|----------|---------|---------|-------------------\nAll files     |   59.37 |    33.33 |   33.33 |   59.37 |                   \n module.js    |   79.16 |       50 |      50 |   79.16 | 14-16,19-20       \n uncovered.js |       0 |        0 |       0 |       0 | 1-8               \n--------------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`vm script coverage generator 1`] = `\n\"-------------|---------|----------|---------|---------|-------------------\nFile         | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n-------------|---------|----------|---------|---------|-------------------\nAll files    |   88.88 |      100 |   66.66 |   88.88 |                   \n vmscript.js |   88.88 |      100 |   66.66 |   88.88 | 20-22             \n-------------|---------|----------|---------|---------|-------------------\"\n`;"}
{"prompt":"maps code coverage against original source,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {readFileSync} from 'graceful-fs';\nimport {cleanup, runYarnInstall} from '../Utils';\nimport runJest from '../runJest';\n\nconst dir = path.resolve(__dirname, '../coverage-remapping');\nconst coverageDir = path.join(dir, 'coverage');\n\nbeforeAll(() => {\n  cleanup(coverageDir);\n});\n\nit('maps code coverage against original source', () => {\n  runYarnInstall(dir);\n  const result = runJest(dir, ['--coverage', '--no-cache']);\n\n  expect(result.exitCode).toBe(0);\n\n  const coverageMapFile = path.join(coverageDir, 'coverage-final.json');\n  const coverageMap = JSON.parse(readFileSync(coverageMapFile, 'utf8'));\n\n  // reduce absolute paths embedded in the coverage map to just filenames\n  for (const filename of Object.keys(coverageMap)) {\n    coverageMap[filename].path = path.basename(coverageMap[filename].path);\n    delete coverageMap[filename].hash;\n    coverageMap[path.basename(filename)] = coverageMap[filename];\n    delete coverageMap[filename];\n  }\n  expect(coverageMap).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`maps code coverage against original source 1`] = `\nObject {\n  \"covered.ts\": Object {\n    \"b\": Object {\n      \"0\": Array [\n        1,\n        0,\n      ],\n      \"1\": Array [\n        1,\n        0,\n      ],\n      \"2\": Array [\n        1,\n        0,\n        0,\n      ],\n      \"3\": Array [\n        1,\n        0,\n      ],\n    },\n    \"branchMap\": Object {\n      \"0\": Object {\n        \"loc\": Object {\n          \"end\": Object {\n            \"column\": 39,\n            \"line\": 9,\n          },\n          \"start\": Object {\n            \"column\": 27,\n            \"line\": 9,\n          },\n        },\n        \"locations\": Array [\n          Object {\n            \"end\": Object {\n              \"column\": 35,\n              \"line\": 9,\n            },\n            \"start\": Object {\n              \"column\": 34,\n              \"line\": 9,\n            },\n          },\n          Object {\n            \"end\": Object {\n              \"column\": 39,\n              \"line\": 9,\n            },\n            \"start\": Object {\n              \"column\": 38,\n              \"line\": 9,\n            },\n          },\n        ],\n        \"type\": \"cond-expr\",\n      },\n      \"1\": Object {\n        \"loc\": Object {\n          \"end\": Object {\n            \"column\": 39,\n            \"line\": 10,\n          },\n          \"start\": Object {\n            \"column\": 27,\n            \"line\": 10,\n          },\n        },\n        \"locations\": Array [\n          Object {\n            \"end\": Object {\n              \"column\": 35,\n              \"line\": 10,\n            },\n            \"start\": Object {\n              \"column\": 34,\n              \"line\": 10,\n            },\n          },\n          Object {\n            \"end\": Object {\n              \"column\": 39,\n              \"line\": 10,\n            },\n            \"start\": Object {\n              \"column\": 38,\n              \"line\": 10,\n            },\n          },\n        ],\n        \"type\": \"cond-expr\",\n      },\n      \"2\": Object {\n        \"loc\": Object {\n          \"end\": Object {\n            \"column\": 48,\n            \"line\": 11,\n          },\n          \"start\": Object {\n            \"column\": 27,\n            \"line\": 11,\n          },\n        },\n        \"locations\": Array [\n          Object {\n            \"end\": Object {\n              \"column\": 31,\n              \"line\": 11,\n            },\n            \"start\": Object {\n              \"column\": 27,\n              \"line\": 11,\n            },\n          },\n          Object {\n            \"end\": Object {\n              \"column\": 39,\n              \"line\": 11,\n            },\n            \"start\": Object {\n              \"column\": 35,\n              \"line\": 11,\n            },\n          },\n          Object {\n            \"end\": Object {\n              \"column\": 48,\n              \"line\": 11,\n            },\n            \"start\": Object {\n              \"column\": 43,\n              \"line\": 11,\n            },\n          },\n        ],\n        \"type\": \"binary-expr\",\n      },\n      \"3\": Object {\n        \"loc\": Object {\n          \"end\": Object {\n            \"column\": 53,\n            \"line\": 12,\n          },\n          \"start\": Object {\n            \"column\": 23,\n            \"line\": 12,\n          },\n        },\n        \"locations\": Array [\n          Object {\n            \"end\": Object {\n              \"column\": 40,\n              \"line\": 12,\n            },\n            \"start\": Object {\n              \"column\": 30,\n              \"line\": 12,\n            },\n          },\n          Object {\n            \"end\": Object {\n              \"column\": 53,\n              \"line\": 12,\n            },\n            \"start\": Object {\n              \"column\": 43,\n              \"line\": 12,\n            },\n          },\n        ],\n        \"type\": \"cond-expr\",\n      },\n    },\n    \"f\": Object {\n      \"0\": 1,\n      \"1\": 0,\n      \"2\": 0,\n    },\n    \"fnMap\": Object {\n      \"0\": Object {\n        \"decl\": Object {\n          \"end\": Object {\n            \"column\": 26,\n            \"line\": 8,\n          },\n          \"start\": Object {\n            \"column\": 16,\n            \"line\": 8,\n          },\n        },\n        \"loc\": Object {\n          \"end\": Object {\n            \"column\": 1,\n            \"line\": 15,\n          },\n          \"start\": Object {\n            \"column\": 47,\n            \"line\": 8,\n          },\n        },\n        \"name\": \"difference\",\n      },\n      \"1\": Object {\n        \"decl\": Object {\n          \"end\": Object {\n            \"column\": 36,\n            \"line\": 12,\n          },\n          \"start\": Object {\n            \"column\": 30,\n            \"line\": 12,\n          },\n        },\n        \"loc\": Object {\n          \"end\": Object {\n            \"column\": 40,\n            \"line\": 12,\n          },\n          \"start\": Object {\n            \"column\": 30,\n            \"line\": 12,\n          },\n        },\n        \"name\": \"(anonymous_1)\",\n      },\n      \"2\": Object {\n        \"decl\": Object {\n          \"end\": Object {\n            \"column\": 49,\n            \"line\": 12,\n          },\n          \"start\": Object {\n            \"column\": 43,\n            \"line\": 12,\n          },\n        },\n        \"loc\": Object {\n          \"end\": Object {\n            \"column\": 53,\n            \"line\": 12,\n          },\n          \"start\": Object {\n            \"column\": 43,\n            \"line\": 12,\n          },\n        },\n        \"name\": \"(anonymous_2)\",\n      },\n    },\n    \"path\": \"covered.ts\",\n    \"s\": Object {\n      \"0\": 1,\n      \"1\": 1,\n      \"2\": 1,\n      \"3\": 1,\n      \"4\": 1,\n      \"5\": 0,\n      \"6\": 0,\n      \"7\": 1,\n    },\n    \"statementMap\": Object {\n      \"0\": Object {\n        \"end\": Object {\n          \"column\": 16,\n          \"line\": 8,\n        },\n        \"start\": Object {\n          \"column\": 0,\n          \"line\": 8,\n        },\n      },\n      \"1\": Object {\n        \"end\": Object {\n          \"column\": 39,\n          \"line\": 9,\n        },\n        \"start\": Object {\n          \"column\": 27,\n          \"line\": 9,\n        },\n      },\n      \"2\": Object {\n        \"end\": Object {\n          \"column\": 39,\n          \"line\": 10,\n        },\n        \"start\": Object {\n          \"column\": 27,\n          \"line\": 10,\n        },\n      },\n      \"3\": Object {\n        \"end\": Object {\n          \"column\": 48,\n          \"line\": 11,\n        },\n        \"start\": Object {\n          \"column\": 27,\n          \"line\": 11,\n        },\n      },\n      \"4\": Object {\n        \"end\": Object {\n          \"column\": 53,\n          \"line\": 12,\n        },\n        \"start\": Object {\n          \"column\": 23,\n          \"line\": 12,\n        },\n      },\n      \"5\": Object {\n        \"end\": Object {\n          \"column\": 41,\n          \"line\": 12,\n        },\n        \"start\": Object {\n          \"column\": 36,\n          \"line\": 12,\n        },\n      },\n      \"6\": Object {\n        \"end\": Object {\n          \"column\": 54,\n          \"line\": 12,\n        },\n        \"start\": Object {\n          \"column\": 49,\n          \"line\": 12,\n        },\n      },\n      \"7\": Object {\n        \"end\": Object {\n          \"column\": 15,\n          \"line\": 14,\n        },\n        \"start\": Object {\n          \"column\": 2,\n          \"line\": 14,\n        },\n      },\n    },\n  },\n}\n`;"}
{"prompt":"- the setup.js file is ignored and should not be in the coverage report.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {extractSummary, runYarnInstall} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../coverage-report');\n\nbeforeAll(() => {\n  runYarnInstall(DIR);\n});\n\ntest('outputs coverage report', () => {\n  const {stdout, exitCode} = runJest(DIR, ['--no-cache', '--coverage'], {\n    stripAnsi: true,\n  });\n  const coverageDir = path.join(DIR, 'coverage');\n\n  // - the `setup.js` file is ignored and should not be in the coverage report.\n  // - `SumDependency.js` is mocked and the real module is never required but\n  //  is listed with 0 % coverage.\n  // - `notRequiredInTestSuite.js` is not required but it is listed\n  //  with 0 % coverage.\n  expect(stdout).toMatchSnapshot();\n\n  expect(() => fs.accessSync(coverageDir, fs.constants.F_OK)).not.toThrow();\n  expect(exitCode).toBe(0);\n});\n\ntest('collects coverage only from specified file', () => {\n  const {stdout} = runJest(\n    DIR,\n    [\n      '--no-cache',\n      '--coverage',\n      '--collectCoverageFrom', // overwrites the one in package.json\n      'file.js',\n    ],\n    {stripAnsi: true},\n  );\n\n  // Coverage report should only have `file.js` coverage info\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('collects coverage only from multiple specified files', () => {\n  const {stdout} = runJest(\n    DIR,\n    [\n      '--no-cache',\n      '--coverage',\n      '--collectCoverageFrom',\n      'file.js',\n      '--collectCoverageFrom',\n      'otherFile.js',\n    ],\n    {stripAnsi: true},\n  );\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('collects coverage only from specified files avoiding dependencies', () => {\n  const {stdout} = runJest(\n    DIR,\n    [\n      '--no-cache',\n      '--coverage',\n      '--collectCoverageFrom',\n      'sum.js',\n      '--',\n      'sum.test.js',\n    ],\n    {stripAnsi: true},\n  );\n\n  // Coverage report should only have `sum.js` coverage info\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('json reporter printing with --coverage', () => {\n  const {stderr, exitCode} = runJest('json-reporter', ['--coverage'], {\n    stripAnsi: true,\n  });\n  const {summary} = extractSummary(stderr);\n  expect(exitCode).toBe(1);\n  expect(summary).toMatchSnapshot();\n});\n\ntest('outputs coverage report as json', () => {\n  const {stdout, exitCode} = runJest(\n    DIR,\n    ['--no-cache', '--coverage', '--json'],\n    {stripAnsi: true},\n  );\n  expect(exitCode).toBe(0);\n  expect(() => JSON.parse(stdout)).not.toThrow();\n});\n\ntest('outputs coverage report when text is requested', () => {\n  const {stdout, exitCode} = runJest(\n    DIR,\n    [\n      '--no-cache',\n      '--coverage',\n      '--coverageReporters=text',\n      '--coverageReporters=html',\n    ],\n    {stripAnsi: true},\n  );\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatch(/Stmts | . Branch/);\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('outputs coverage report when text-summary is requested', () => {\n  const {stdout, exitCode} = runJest(\n    DIR,\n    ['--no-cache', '--coverage', '--coverageReporters=text-summary'],\n    {stripAnsi: true},\n  );\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatch(/Coverage summary/);\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('outputs coverage report when text and text-summary is requested', () => {\n  const {stdout, exitCode} = runJest(\n    DIR,\n    [\n      '--no-cache',\n      '--coverage',\n      '--coverageReporters=text-summary',\n      '--coverageReporters=text',\n    ],\n    {stripAnsi: true},\n  );\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatch(/Stmts | . Branch/);\n  expect(stdout).toMatch(/Coverage summary/);\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('does not output coverage report when html is requested', () => {\n  const {stdout, exitCode} = runJest(\n    DIR,\n    ['--no-cache', '--coverage', '--coverageReporters=html'],\n    {stripAnsi: true},\n  );\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatch(/^$/);\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('collects coverage from duplicate files avoiding shared cache', () => {\n  const args = [\n    '--coverage',\n    // Ensure the exitCode is non-zero if super edge case with coverage triggers\n    '--coverageThreshold',\n    '{\"global\": {\"lines\": 100}}',\n    '--collectCoverageFrom',\n    'cached-duplicates/a/identical.js',\n    '--collectCoverageFrom',\n    'cached-duplicates/b/identical.js',\n    '--',\n    'identical.test.js',\n  ];\n  // Run once to prime the cache\n  runJest(DIR, args, {stripAnsi: true});\n\n  // Run for the second time\n  const {stdout, exitCode} = runJest(DIR, args, {stripAnsi: true});\n  expect(stdout).toMatchSnapshot();\n  expect(exitCode).toBe(0);\n});\n\ntest('generates coverage when using the testRegex config param ', () => {\n  const {stdout, exitCode} = runJest(DIR, [\n    '--no-cache',\n    '--testRegex=__tests__',\n    '--coverage',\n  ]);\n  expect(stdout).toMatchSnapshot();\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`collects coverage from duplicate files avoiding shared cache 1`] = `\n\"---------------|---------|----------|---------|---------|-------------------\nFile           | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n---------------|---------|----------|---------|---------|-------------------\nAll files      |     100 |      100 |     100 |     100 |                   \n a             |     100 |      100 |     100 |     100 |                   \n  identical.js |     100 |      100 |     100 |     100 |                   \n b             |     100 |      100 |     100 |     100 |                   \n  identical.js |     100 |      100 |     100 |     100 |                   \n---------------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`collects coverage only from multiple specified files 1`] = `\n\"--------------|---------|----------|---------|---------|-------------------\nFile          | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n--------------|---------|----------|---------|---------|-------------------\nAll files     |     100 |      100 |     100 |     100 |                   \n file.js      |     100 |      100 |     100 |     100 |                   \n otherFile.js |     100 |      100 |     100 |     100 |                   \n--------------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`collects coverage only from specified file 1`] = `\n\"----------|---------|----------|---------|---------|-------------------\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n----------|---------|----------|---------|---------|-------------------\nAll files |     100 |      100 |     100 |     100 |                   \n file.js  |     100 |      100 |     100 |     100 |                   \n----------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`collects coverage only from specified files avoiding dependencies 1`] = `\n\"----------|---------|----------|---------|---------|-------------------\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n----------|---------|----------|---------|---------|-------------------\nAll files |    87.5 |      100 |      50 |     100 |                   \n sum.js   |    87.5 |      100 |      50 |     100 |                   \n----------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`does not output coverage report when html is requested 1`] = `\"\"`;\n\nexports[`generates coverage when using the testRegex config param  1`] = `\n\"-------------------------------------|---------|----------|---------|---------|-------------------\nFile                                 | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n-------------------------------------|---------|----------|---------|---------|-------------------\nAll files                            |      60 |        0 |      50 |      60 |                   \n coverage-report                     |   47.36 |        0 |      25 |      50 |                   \n  file.js                            |     100 |      100 |     100 |     100 |                   \n  notRequiredInTestSuite.js          |       0 |        0 |       0 |       0 | 8-19              \n  otherFile.js                       |     100 |      100 |     100 |     100 |                   \n  sum.js                             |    87.5 |      100 |      50 |     100 |                   \n  sumDependency.js                   |       0 |        0 |       0 |       0 | 8-13              \n coverage-report/cached-duplicates/a |     100 |      100 |     100 |     100 |                   \n  identical.js                       |     100 |      100 |     100 |     100 |                   \n coverage-report/cached-duplicates/b |     100 |      100 |     100 |     100 |                   \n  identical.js                       |     100 |      100 |     100 |     100 |                   \n-------------------------------------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`json reporter printing with --coverage 1`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       1 failed, 1 skipped, 2 passed, 4 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`outputs coverage report 1`] = `\n\"-------------------------------------|---------|----------|---------|---------|-------------------\nFile                                 | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n-------------------------------------|---------|----------|---------|---------|-------------------\nAll files                            |      60 |        0 |      50 |      60 |                   \n coverage-report                     |   47.36 |        0 |      25 |      50 |                   \n  file.js                            |     100 |      100 |     100 |     100 |                   \n  notRequiredInTestSuite.js          |       0 |        0 |       0 |       0 | 8-19              \n  otherFile.js                       |     100 |      100 |     100 |     100 |                   \n  sum.js                             |    87.5 |      100 |      50 |     100 |                   \n  sumDependency.js                   |       0 |        0 |       0 |       0 | 8-13              \n coverage-report/cached-duplicates/a |     100 |      100 |     100 |     100 |                   \n  identical.js                       |     100 |      100 |     100 |     100 |                   \n coverage-report/cached-duplicates/b |     100 |      100 |     100 |     100 |                   \n  identical.js                       |     100 |      100 |     100 |     100 |                   \n-------------------------------------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`outputs coverage report when text and text-summary is requested 1`] = `\n\"\n=============================== Coverage summary ===============================\nStatements   : 60% ( 15/25 )\nBranches     : 0% ( 0/4 )\nFunctions    : 50% ( 3/6 )\nLines        : 60% ( 12/20 )\n================================================================================\n-------------------------------------|---------|----------|---------|---------|-------------------\nFile                                 | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n-------------------------------------|---------|----------|---------|---------|-------------------\nAll files                            |      60 |        0 |      50 |      60 |                   \n coverage-report                     |   47.36 |        0 |      25 |      50 |                   \n  file.js                            |     100 |      100 |     100 |     100 |                   \n  notRequiredInTestSuite.js          |       0 |        0 |       0 |       0 | 8-19              \n  otherFile.js                       |     100 |      100 |     100 |     100 |                   \n  sum.js                             |    87.5 |      100 |      50 |     100 |                   \n  sumDependency.js                   |       0 |        0 |       0 |       0 | 8-13              \n coverage-report/cached-duplicates/a |     100 |      100 |     100 |     100 |                   \n  identical.js                       |     100 |      100 |     100 |     100 |                   \n coverage-report/cached-duplicates/b |     100 |      100 |     100 |     100 |                   \n  identical.js                       |     100 |      100 |     100 |     100 |                   \n-------------------------------------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`outputs coverage report when text is requested 1`] = `\n\"-------------------------------------|---------|----------|---------|---------|-------------------\nFile                                 | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n-------------------------------------|---------|----------|---------|---------|-------------------\nAll files                            |      60 |        0 |      50 |      60 |                   \n coverage-report                     |   47.36 |        0 |      25 |      50 |                   \n  file.js                            |     100 |      100 |     100 |     100 |                   \n  notRequiredInTestSuite.js          |       0 |        0 |       0 |       0 | 8-19              \n  otherFile.js                       |     100 |      100 |     100 |     100 |                   \n  sum.js                             |    87.5 |      100 |      50 |     100 |                   \n  sumDependency.js                   |       0 |        0 |       0 |       0 | 8-13              \n coverage-report/cached-duplicates/a |     100 |      100 |     100 |     100 |                   \n  identical.js                       |     100 |      100 |     100 |     100 |                   \n coverage-report/cached-duplicates/b |     100 |      100 |     100 |     100 |                   \n  identical.js                       |     100 |      100 |     100 |     100 |                   \n-------------------------------------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`outputs coverage report when text-summary is requested 1`] = `\n\"\n=============================== Coverage summary ===============================\nStatements   : 60% ( 15/25 )\nBranches     : 0% ( 0/4 )\nFunctions    : 50% ( 3/6 )\nLines        : 60% ( 12/20 )\n================================================================================\"\n`;"}
{"prompt":"onRunComplete,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\njest\n  .mock('istanbul-lib-source-maps')\n  .mock('istanbul-lib-report', () => ({\n    ...jest.requireActual('istanbul-lib-report'),\n    createContext: jest.fn(),\n    summarizers: {pkg: jest.fn(() => ({visit: jest.fn()}))},\n  }))\n  .mock('istanbul-reports', () => ({\n    ...jest.createMockFromModule('istanbul-reports'),\n    create: jest.fn(() => ({execute: jest.fn()})),\n  }));\n\nlet libCoverage;\nlet libSourceMaps;\nlet CoverageReporter;\nlet istanbulReports;\n\nimport * as path from 'path';\nimport mock from 'mock-fs';\n\nbeforeEach(() => {\n  CoverageReporter = require('../CoverageReporter').default;\n  libCoverage = require('istanbul-lib-coverage');\n  libSourceMaps = require('istanbul-lib-source-maps');\n  istanbulReports = require('istanbul-reports');\n\n  const fileTree = {};\n  fileTree[`${process.cwd()}/path-test-files`] = {\n    '000pc_coverage_file.js': '',\n    '050pc_coverage_file.js': '',\n    '100pc_coverage_file.js': '',\n    'full_path_file.js': '',\n    'glob-path': {\n      'file1.js': '',\n      'file2.js': '',\n    },\n    'non_covered_file.js': '',\n    'relative_path_file.js': '',\n  };\n  fileTree[`${process.cwd()}/path-test`] = {\n    '100pc_coverage_file.js': '',\n  };\n  mock(fileTree);\n});\n\nafterEach(() => {\n  mock.restore();\n});\n\ndescribe('onRunComplete', () => {\n  let mockAggResults;\n\n  beforeEach(() => {\n    mockAggResults = {\n      numFailedTestSuites: 0,\n      numFailedTests: 0,\n      numPassedTestSuites: 1,\n      numPassedTests: 1,\n      numPendingTests: 0,\n      numRuntimeErrorTestSuites: 0,\n      numTotalTestSuites: 1,\n      numTotalTests: 1,\n      startTime: 0,\n      success: true,\n      testFilePath: 'foo',\n      testResults: [],\n    };\n\n    libCoverage.createCoverageMap = jest.fn(() => {\n      const covSummary = {\n        branches: {covered: 0, pct: 0, skipped: 0, total: 0},\n        functions: {covered: 0, pct: 0, skipped: 0, total: 0},\n        lines: {covered: 0, pct: 0, skipped: 0, total: 0},\n        statements: {covered: 5, pct: 50, skipped: 0, total: 10},\n      };\n      const fileCoverage = [\n        [\n          './path-test/100pc_coverage_file.js',\n          {statements: {covered: 10, pct: 100, total: 10}},\n        ],\n        ['./path-test-files/covered_file_without_threshold.js'],\n        ['./path-test-files/full_path_file.js'],\n        ['./path-test-files/relative_path_file.js'],\n        ['./path-test-files/glob-path/file1.js'],\n        ['./path-test-files/glob-path/file2.js'],\n        [\n          './path-test-files/000pc_coverage_file.js',\n          {statements: {covered: 0, pct: 0, total: 10}},\n        ],\n        [\n          './path-test-files/050pc_coverage_file.js',\n          {statements: {covered: 5, pct: 50, total: 10}},\n        ],\n        [\n          './path-test-files/100pc_coverage_file.js',\n          {statements: {covered: 10, pct: 100, total: 10}},\n        ],\n      ].reduce((c, f) => {\n        const file = path.resolve(f[0]);\n        const override = f[1];\n        const obj = {...covSummary, ...override};\n        c[file] = libCoverage.createCoverageSummary(obj);\n        return c;\n      }, {});\n\n      return {\n        fileCoverageFor(path) {\n          if (fileCoverage[path]) {\n            return {\n              toSummary() {\n                return fileCoverage[path];\n              },\n            };\n          } else {\n            return undefined;\n          }\n        },\n        files() {\n          return Object.keys(fileCoverage);\n        },\n      };\n    });\n\n    libSourceMaps.createSourceMapStore = jest.fn(() => ({\n      transformCoverage(map) {\n        return Promise.resolve(map);\n      },\n    }));\n  });\n\n  test('getLastError() returns an error when threshold is not met for global', () => {\n    const testReporter = new CoverageReporter(\n      {\n        collectCoverage: true,\n        coverageThreshold: {\n          global: {\n            statements: 100,\n          },\n        },\n      },\n      {\n        maxWorkers: 2,\n      },\n    );\n    testReporter.log = jest.fn();\n    return testReporter\n      .onRunComplete(new Set(), {}, mockAggResults)\n      .then(() => {\n        expect(testReporter.getLastError().message.split('\\n')).toHaveLength(1);\n      });\n  });\n\n  test('getLastError() returns an error when threshold is not met for file', () => {\n    const covThreshold = {};\n    const paths = [\n      'global',\n      path.resolve(`${process.cwd()}/path-test-files/full_path_file.js`),\n      './path-test-files/relative_path_file.js',\n      'path-test-files/glob-*/*.js',\n    ];\n    for (const path of paths) {\n      covThreshold[path] = {statements: 100};\n    }\n\n    const testReporter = new CoverageReporter(\n      {\n        collectCoverage: true,\n        coverageThreshold: covThreshold,\n      },\n      {\n        maxWorkers: 2,\n      },\n    );\n    testReporter.log = jest.fn();\n    return testReporter\n      .onRunComplete(new Set(), {}, mockAggResults)\n      .then(() => {\n        expect(testReporter.getLastError().message.split('\\n')).toHaveLength(5);\n      });\n  });\n\n  test('getLastError() returns `undefined` when threshold is met', () => {\n    const covThreshold = {};\n    const paths = [\n      'global',\n      path.resolve(`${process.cwd()}/path-test-files/full_path_file.js`),\n      './path-test-files/relative_path_file.js',\n      'path-test-files/glob-*/*.js',\n    ];\n    for (const path of paths) {\n      covThreshold[path] = {statements: 50};\n    }\n\n    const testReporter = new CoverageReporter(\n      {\n        collectCoverage: true,\n        coverageThreshold: covThreshold,\n      },\n      {\n        maxWorkers: 2,\n      },\n    );\n    testReporter.log = jest.fn();\n    return testReporter\n      .onRunComplete(new Set(), {}, mockAggResults)\n      .then(() => {\n        expect(testReporter.getLastError()).toBeUndefined();\n      });\n  });\n\n  test('getLastError() returns an error when threshold is not met for non-covered file', () => {\n    const testReporter = new CoverageReporter(\n      {\n        collectCoverage: true,\n        coverageThreshold: {\n          'path-test-files/non_covered_file.js': {\n            statements: 100,\n          },\n        },\n      },\n      {\n        maxWorkers: 2,\n      },\n    );\n    testReporter.log = jest.fn();\n    return testReporter\n      .onRunComplete(new Set(), {}, mockAggResults)\n      .then(() => {\n        expect(testReporter.getLastError().message.split('\\n')).toHaveLength(1);\n      });\n  });\n\n  test('getLastError() returns an error when threshold is not met for directory', () => {\n    const testReporter = new CoverageReporter(\n      {\n        collectCoverage: true,\n        coverageThreshold: {\n          './path-test-files/glob-path/': {\n            statements: 100,\n          },\n        },\n      },\n      {\n        maxWorkers: 2,\n      },\n    );\n    testReporter.log = jest.fn();\n    return testReporter\n      .onRunComplete(new Set(), {}, mockAggResults)\n      .then(() => {\n        expect(testReporter.getLastError().message.split('\\n')).toHaveLength(1);\n      });\n  });\n\n  test('getLastError() returns `undefined` when threshold is met for directory', () => {\n    const testReporter = new CoverageReporter(\n      {\n        collectCoverage: true,\n        coverageThreshold: {\n          './path-test-files/glob-path/': {\n            statements: 40,\n          },\n        },\n      },\n      {\n        maxWorkers: 2,\n      },\n    );\n    testReporter.log = jest.fn();\n    return testReporter\n      .onRunComplete(new Set(), {}, mockAggResults)\n      .then(() => {\n        expect(testReporter.getLastError()).toBeUndefined();\n      });\n  });\n\n  test('getLastError() returns an error when there is no coverage data for a threshold', () => {\n    const testReporter = new CoverageReporter(\n      {\n        collectCoverage: true,\n        coverageThreshold: {\n          './path/doesnt/exist': {\n            statements: 40,\n          },\n        },\n      },\n      {\n        maxWorkers: 2,\n      },\n    );\n    testReporter.log = jest.fn();\n    return testReporter\n      .onRunComplete(new Set(), {}, mockAggResults)\n      .then(() => {\n        expect(testReporter.getLastError().message.split('\\n')).toHaveLength(1);\n      });\n  });\n\n  test(`getLastError() returns 'undefined' when global threshold group\n   is empty because PATH and GLOB threshold groups have matched all the\n    files in the coverage data.`, () => {\n    const testReporter = new CoverageReporter(\n      {\n        collectCoverage: true,\n        coverageThreshold: {\n          './path-test-files/': {\n            statements: 50,\n          },\n          './path-test/': {\n            statements: 100,\n          },\n          global: {\n            statements: 100,\n          },\n        },\n      },\n      {\n        maxWorkers: 2,\n      },\n    );\n    testReporter.log = jest.fn();\n    return testReporter\n      .onRunComplete(new Set(), {}, mockAggResults)\n      .then(() => {\n        expect(testReporter.getLastError()).toBeUndefined();\n      });\n  });\n\n  test(`getLastError() returns 'undefined' when file and directory path\n  threshold groups overlap`, () => {\n    const covThreshold = {};\n    for (const path of [\n      './path-test-files/',\n      './path-test-files/covered_file_without_threshold.js',\n      './path-test-files/full_path_file.js',\n      './path-test-files/relative_path_file.js',\n      './path-test-files/glob-path/file1.js',\n      './path-test-files/glob-path/file2.js',\n      './path-test-files/*.js',\n    ]) {\n      covThreshold[path] = {\n        statements: 0,\n      };\n    }\n\n    const testReporter = new CoverageReporter(\n      {\n        collectCoverage: true,\n        coverageThreshold: covThreshold,\n      },\n      {\n        maxWorkers: 2,\n      },\n    );\n    testReporter.log = jest.fn();\n    return testReporter\n      .onRunComplete(new Set(), {}, mockAggResults)\n      .then(() => {\n        expect(testReporter.getLastError()).toBeUndefined();\n      });\n  });\n\n  test(`that if globs or paths are specified alongside global, coverage\n  data for matching paths will be subtracted from overall coverage\n  and thresholds will be applied independently`, () => {\n    const testReporter = new CoverageReporter(\n      {\n        collectCoverage: true,\n        coverageThreshold: {\n          './path-test-files/100pc_coverage_file.js': {\n            statements: 100,\n          },\n          './path-test/100pc_coverage_file.js': {\n            statements: 100,\n          },\n          global: {\n            statements: 50,\n          },\n        },\n      },\n      {\n        maxWorkers: 2,\n      },\n    );\n    testReporter.log = jest.fn();\n    // 100% coverage file is removed from overall coverage so\n    // coverage drops to < 50%\n    return testReporter\n      .onRunComplete(new Set(), {}, mockAggResults)\n      .then(() => {\n        expect(testReporter.getLastError().message.split('\\n')).toHaveLength(1);\n      });\n  });\n\n  test('that files are matched by all matching threshold groups', () => {\n    const testReporter = new CoverageReporter(\n      {\n        collectCoverage: true,\n        coverageThreshold: {\n          './path-test-files/': {\n            statements: 50,\n          },\n          './path-test-files/050pc_coverage_file.js': {\n            statements: 50,\n          },\n          './path-test-files/100pc_coverage_*.js': {\n            statements: 100,\n          },\n          './path-test-files/100pc_coverage_file.js': {\n            statements: 100,\n          },\n        },\n      },\n      {\n        maxWorkers: 2,\n      },\n    );\n    testReporter.log = jest.fn();\n    return testReporter\n      .onRunComplete(new Set(), {}, mockAggResults)\n      .then(() => {\n        expect(testReporter.getLastError()).toBeUndefined();\n      });\n  });\n\n  test('that it passes custom options when creating reporters', () => {\n    const testReporter = new CoverageReporter({\n      coverageReporters: ['json', ['lcov', {maxCols: 10, projectRoot: './'}]],\n    });\n    testReporter.log = jest.fn();\n    return testReporter\n      .onRunComplete(new Set(), {}, mockAggResults)\n      .then(() => {\n        expect(istanbulReports.create).toHaveBeenCalledWith('json', {\n          maxCols: process.stdout.columns || Number.POSITIVE_INFINITY,\n        });\n        expect(istanbulReports.create).toHaveBeenCalledWith('lcov', {\n          maxCols: 10,\n          projectRoot: './',\n        });\n        expect(testReporter.getLastError()).toBeUndefined();\n      });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {cleanup, extractSummary, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../coverage-threshold');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('exits with 1 if coverage threshold is not met', () => {\n  const pkgJson = {\n    jest: {\n      collectCoverage: true,\n      collectCoverageFrom: ['**/*.js'],\n      coverageThreshold: {\n        global: {\n          lines: 90,\n        },\n      },\n    },\n  };\n\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': `\n      require('../not-covered.js');\n      test('banana', () => expect(1).toBe(1));\n    `,\n    'not-covered.js': `\n      module.exports = () => {\n        return 1 + 2;\n      };\n    `,\n    'package.json': JSON.stringify(pkgJson, null, 2),\n  });\n\n  const {stdout, stderr, exitCode} = runJest(\n    DIR,\n    ['--coverage', '--ci=false'],\n    {stripAnsi: true},\n  );\n  const {rest, summary} = extractSummary(stderr);\n\n  expect(exitCode).toBe(1);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n  expect(stdout).toMatchSnapshot('stdout');\n});\n\ntest('exits with 1 if path threshold group is not found in coverage data', () => {\n  const pkgJson = {\n    jest: {\n      collectCoverage: true,\n      collectCoverageFrom: ['**/*.js'],\n      coverageThreshold: {\n        'apple.js': {\n          lines: 100,\n        },\n      },\n    },\n  };\n\n  writeFiles(DIR, {\n    '__tests__/banana.test.js': `\n      const banana = require('../banana.js');\n      test('banana', () => expect(banana()).toBe(3));\n    `,\n    'banana.js': `\n      module.exports = () => {\n        return 1 + 2;\n      };\n    `,\n    'package.json': JSON.stringify(pkgJson, null, 2),\n  });\n\n  const {stdout, stderr, exitCode} = runJest(\n    DIR,\n    ['--coverage', '--ci=false'],\n    {stripAnsi: true},\n  );\n  const {rest, summary} = extractSummary(stderr);\n\n  expect(exitCode).toBe(1);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n  expect(stdout).toMatchSnapshot('stdout');\n});\n\ntest('exits with 0 if global threshold group is not found in coverage data', () => {\n  const pkgJson = {\n    jest: {\n      collectCoverage: true,\n      collectCoverageFrom: ['**/*.js'],\n      coverageThreshold: {\n        'banana.js': {\n          lines: 100,\n        },\n        global: {\n          lines: 100,\n        },\n      },\n    },\n  };\n\n  writeFiles(DIR, {\n    '__tests__/banana.test.js': `\n      const banana = require('../banana.js');\n      test('banana', () => expect(banana()).toBe(3));\n    `,\n    'banana.js': `\n      module.exports = () => {\n        return 1 + 2;\n      };\n    `,\n    'package.json': JSON.stringify(pkgJson, null, 2),\n  });\n\n  const {stdout, exitCode} = runJest(DIR, ['--coverage', '--ci=false'], {\n    stripAnsi: true,\n  });\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot('stdout');\n});\n\ntest('excludes tests matched by path threshold groups from global group', () => {\n  const pkgJson = {\n    jest: {\n      collectCoverage: true,\n      collectCoverageFrom: ['**/*.js'],\n      coverageThreshold: {\n        'banana.js': {\n          lines: 100,\n        },\n        global: {\n          lines: 100,\n        },\n      },\n    },\n  };\n\n  writeFiles(DIR, {\n    '__tests__/banana.test.js': `\n      const banana = require('../banana.js');\n      test('banana', () => expect(banana()).toBe(3));\n    `,\n    'apple.js': `\n      module.exports = () => {\n        return 1 + 2;\n      };\n    `,\n    'banana.js': `\n      module.exports = () => {\n        return 1 + 2;\n      };\n    `,\n    'package.json': JSON.stringify(pkgJson, null, 2),\n  });\n\n  const {stdout, stderr, exitCode} = runJest(\n    DIR,\n    ['--coverage', '--ci=false'],\n    {stripAnsi: true},\n  );\n  const {rest, summary} = extractSummary(stderr);\n\n  expect(exitCode).toBe(1);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n  expect(stdout).toMatchSnapshot('stdout');\n});\n\ntest('file is matched by all path and glob threshold groups', () => {\n  const pkgJson = {\n    jest: {\n      collectCoverage: true,\n      collectCoverageFrom: ['**/*.js'],\n      coverageThreshold: {\n        './': {\n          lines: 100,\n        },\n        './ban*.js': {\n          lines: 100,\n        },\n        './banana.js': {\n          lines: 100,\n        },\n      },\n    },\n  };\n\n  writeFiles(DIR, {\n    '__tests__/banana.test.js': `\n      const banana = require('../banana.js');\n      test('banana', () => expect(3).toBe(3));\n    `,\n    'banana.js': `\n      module.exports = () => {\n        return 1 + 2;\n      };\n    `,\n    'package.json': JSON.stringify(pkgJson, null, 2),\n  });\n\n  const {stdout, stderr, exitCode} = runJest(\n    DIR,\n    ['--coverage', '--ci=false'],\n    {stripAnsi: true},\n  );\n  const {rest, summary} = extractSummary(\n    /* This test also runs on windows and when the glob fails it outputs\n    the system specific absolute path to the test file. */\n    stderr.replace(\n      path.resolve(DIR, './banana.js'),\n      '<<FULL_PATH_TO_BANANA_JS>>',\n    ),\n  );\n\n  expect(exitCode).toBe(1);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n  expect(stdout).toMatchSnapshot('stdout');\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`excludes tests matched by path threshold groups from global group 1`] = `\n\"PASS __tests__/banana.test.js\n  ✓ banana\n\nJest: \"global\" coverage threshold for lines (100%) not met: 0%\"\n`;\n\nexports[`excludes tests matched by path threshold groups from global group 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`excludes tests matched by path threshold groups from global group: stdout 1`] = `\n\"-----------|---------|----------|---------|---------|-------------------\nFile       | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n-----------|---------|----------|---------|---------|-------------------\nAll files  |      50 |      100 |      50 |      50 |                   \n apple.js  |       0 |      100 |       0 |       0 | 1-2               \n banana.js |     100 |      100 |     100 |     100 |                   \n-----------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`exits with 0 if global threshold group is not found in coverage data: stdout 1`] = `\n\"-----------|---------|----------|---------|---------|-------------------\nFile       | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n-----------|---------|----------|---------|---------|-------------------\nAll files  |     100 |      100 |     100 |     100 |                   \n banana.js |     100 |      100 |     100 |     100 |                   \n-----------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`exits with 1 if coverage threshold is not met 1`] = `\n\"PASS __tests__/a-banana.js\n  ✓ banana\n\nJest: \"global\" coverage threshold for lines (90%) not met: 50%\"\n`;\n\nexports[`exits with 1 if coverage threshold is not met 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`exits with 1 if coverage threshold is not met: stdout 1`] = `\n\"----------------|---------|----------|---------|---------|-------------------\nFile            | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n----------------|---------|----------|---------|---------|-------------------\nAll files       |      50 |      100 |       0 |      50 |                   \n not-covered.js |      50 |      100 |       0 |      50 | 2                 \n----------------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`exits with 1 if path threshold group is not found in coverage data 1`] = `\n\"PASS __tests__/banana.test.js\n  ✓ banana\n\nJest: Coverage data for apple.js was not found.\"\n`;\n\nexports[`exits with 1 if path threshold group is not found in coverage data 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`exits with 1 if path threshold group is not found in coverage data: stdout 1`] = `\n\"-----------|---------|----------|---------|---------|-------------------\nFile       | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n-----------|---------|----------|---------|---------|-------------------\nAll files  |     100 |      100 |     100 |     100 |                   \n banana.js |     100 |      100 |     100 |     100 |                   \n-----------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`file is matched by all path and glob threshold groups 1`] = `\n\"PASS __tests__/banana.test.js\n  ✓ banana\n\nJest: \"./\" coverage threshold for lines (100%) not met: 50%\nJest: \"<<FULL_PATH_TO_BANANA_JS>>\" coverage threshold for lines (100%) not met: 50%\nJest: \"./banana.js\" coverage threshold for lines (100%) not met: 50%\"\n`;\n\nexports[`file is matched by all path and glob threshold groups 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`file is matched by all path and glob threshold groups: stdout 1`] = `\n\"-----------|---------|----------|---------|---------|-------------------\nFile       | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n-----------|---------|----------|---------|---------|-------------------\nAll files  |      50 |      100 |       0 |      50 |                   \n banana.js |      50 |      100 |       0 |      50 | 2                 \n-----------|---------|----------|---------|---------|-------------------\"\n`;"}
{"prompt":"code coverage for transform instrumented code,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {readFileSync} from 'graceful-fs';\nimport {cleanup, runYarnInstall} from '../Utils';\nimport runJest from '../runJest';\n\nconst dir = path.resolve(__dirname, '../coverage-transform-instrumented');\nconst coverageDir = path.join(dir, 'coverage');\n\nbeforeAll(() => {\n  cleanup(coverageDir);\n});\n\nit('code coverage for transform instrumented code', () => {\n  runYarnInstall(dir);\n  const result = runJest(dir, ['--coverage', '--no-cache']);\n\n  expect(result.exitCode).toBe(0);\n\n  const coverageMapFile = path.join(coverageDir, 'coverage-final.json');\n  const coverageMap = JSON.parse(readFileSync(coverageMapFile, 'utf8'));\n\n  // reduce absolute paths embedded in the coverage map to just filenames\n  for (const filename of Object.keys(coverageMap)) {\n    coverageMap[filename].path = path.basename(coverageMap[filename].path);\n    delete coverageMap[filename].hash;\n    coverageMap[path.basename(filename)] = coverageMap[filename];\n    delete coverageMap[filename];\n  }\n  expect(coverageMap).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`code coverage for transform instrumented code 1`] = `\nObject {\n  \"covered.js\": Object {\n    \"_coverageSchema\": \"1a1c01bbd47fc00a2c39e90264f33305004495a9\",\n    \"b\": Object {},\n    \"branchMap\": Object {},\n    \"f\": Object {\n      \"0\": 1,\n    },\n    \"fnMap\": Object {\n      \"0\": Object {\n        \"decl\": Object {\n          \"end\": Object {\n            \"column\": 36,\n            \"line\": 8,\n          },\n          \"start\": Object {\n            \"column\": 26,\n            \"line\": 8,\n          },\n        },\n        \"line\": 8,\n        \"loc\": Object {\n          \"end\": Object {\n            \"column\": 1,\n            \"line\": 11,\n          },\n          \"start\": Object {\n            \"column\": 58,\n            \"line\": 8,\n          },\n        },\n        \"name\": \"doES6Stuff\",\n      },\n    },\n    \"path\": \"covered.js\",\n    \"s\": Object {\n      \"0\": 1,\n      \"1\": 1,\n      \"2\": 1,\n    },\n    \"statementMap\": Object {\n      \"0\": Object {\n        \"end\": Object {\n          \"column\": 2,\n          \"line\": 11,\n        },\n        \"start\": Object {\n          \"column\": 0,\n          \"line\": 8,\n        },\n      },\n      \"1\": Object {\n        \"end\": Object {\n          \"column\": 41,\n          \"line\": 9,\n        },\n        \"start\": Object {\n          \"column\": 34,\n          \"line\": 9,\n        },\n      },\n      \"2\": Object {\n        \"end\": Object {\n          \"column\": 33,\n          \"line\": 10,\n        },\n        \"start\": Object {\n          \"column\": 2,\n          \"line\": 10,\n        },\n      },\n    },\n  },\n}\n`;"}
{"prompt":"produces code coverage for uncovered files without transformer,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {cleanup} from '../Utils';\nimport runJest from '../runJest';\n\nconst dir = path.resolve(__dirname, '../coverage-without-transform');\nconst coverageDir = path.join(dir, 'coverage');\n\nbeforeAll(() => {\n  cleanup(coverageDir);\n});\n\nafterAll(() => {\n  cleanup(coverageDir);\n});\n\nit('produces code coverage for uncovered files without transformer', () => {\n  const {exitCode, stdout} = runJest(dir, ['--coverage', '--no-cache']);\n\n  expect(exitCode).toBe(0);\n  expect(stdout).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`produces code coverage for uncovered files without transformer 1`] = `\n\"---------------------|---------|----------|---------|---------|-------------------\nFile                 | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n---------------------|---------|----------|---------|---------|-------------------\nAll files            |       0 |      100 |       0 |       0 |                   \n some-random-file.js |       0 |      100 |       0 |       0 | 8-10              \n---------------------|---------|----------|---------|---------|-------------------\"\n`;"}
{"prompt":"We intentionally expect the worker to fail!","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\njest.mock('graceful-fs').mock('../generateEmptyCoverage');\n\nconst globalConfig = {collectCoverage: true};\nconst config = {};\nconst context = {};\nconst workerOptions = {config, context, globalConfig, path: 'banana.js'};\n\nlet fs;\nlet generateEmptyCoverage;\nlet worker;\n\nbeforeEach(() => {\n  jest.resetModules();\n\n  fs = require('graceful-fs');\n  generateEmptyCoverage = require('../generateEmptyCoverage').default;\n  worker = require('../CoverageWorker').worker;\n});\n\ntest('resolves to the result of generateEmptyCoverage upon success', async () => {\n  expect.assertions(2);\n\n  const validJS = 'function(){}';\n\n  fs.readFileSync.mockImplementation(() => validJS);\n  generateEmptyCoverage.mockImplementation(() => 42);\n\n  const result = await worker(workerOptions);\n\n  expect(generateEmptyCoverage).toHaveBeenCalledWith(\n    validJS,\n    'banana.js',\n    globalConfig,\n    config,\n    undefined,\n    undefined,\n  );\n\n  expect(result).toBe(42);\n});\n\ntest('throws errors on invalid JavaScript', async () => {\n  expect.assertions(1);\n\n  generateEmptyCoverage.mockImplementation(() => {\n    throw new Error('SyntaxError');\n  });\n\n  // We intentionally expect the worker to fail!\n  try {\n    await worker(workerOptions);\n  } catch (error) {\n    expect(error).toBeInstanceOf(Error);\n  }\n});"}
{"prompt":"works correctly,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst doES6Stuff = require('../covered.js');\n\nit('works correctly', () => {\n  const someObj = {someNumber: 10, this: 'is irrelevant'};\n  expect(doES6Stuff(someObj, 2)).toBe(20);\n});"}
{"prompt":"adds 1 + 2 to equal 3 in TScript,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit('adds 1 + 2 to equal 3 in TScript', () => {\n  const {sum} = require('../covered.ts');\n  expect(sum(1, 2)).toBe(3);\n});"}
{"prompt":"Symlinks are only enabled on windows wh developer mode.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles, writeSymlinks} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'crawl-symlinks-test');\n\nbeforeEach(() => {\n  cleanup(DIR);\n\n  writeFiles(DIR, {\n    'package.json': JSON.stringify({\n      jest: {\n        testMatch: ['<rootDir>/test-files/test.js'],\n      },\n    }),\n    'symlinked-files/test.js': `\n      test('1+1', () => {\n        expect(1).toBe(1);\n      });\n    `,\n  });\n\n  writeSymlinks(DIR, {\n    'symlinked-files/test.js': 'test-files/test.js',\n  });\n});\n\nafterEach(() => {\n  cleanup(DIR);\n});\n\ntest('Node crawler picks up symlinked files when option is set as flag', () => {\n  // Symlinks are only enabled on windows with developer mode.\n  // https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\n  if (process.platform === 'win32') {\n    return;\n  }\n\n  const {stdout, stderr, exitCode} = runJest(DIR, [\n    '--haste={\"enableSymlinks\": true}',\n    '--no-watchman',\n  ]);\n\n  expect(stdout).toBe('');\n  expect(stderr).toContain('Test Suites: 1 passed, 1 total');\n  expect(exitCode).toBe(0);\n});\n\ntest('Node crawler does not pick up symlinked files by default', () => {\n  const {stdout, stderr, exitCode} = runJest(DIR, ['--no-watchman']);\n  expect(stdout).toContain('No tests found, exiting with code 1');\n  expect(stderr).toBe('');\n  expect(exitCode).toBe(1);\n});\n\ntest('Should throw if watchman used with haste.enableSymlinks', () => {\n  // it should throw both if watchman is explicitly provided and not\n  const run1 = runJest(DIR, ['--haste={\"enableSymlinks\": true}']);\n  const run2 = runJest(DIR, ['--haste={\"enableSymlinks\": true}', '--watchman']);\n\n  expect(run1.exitCode).toEqual(run2.exitCode);\n  expect(run1.stderr).toEqual(run2.stderr);\n  expect(run1.stdout).toEqual(run2.stdout);\n\n  const {exitCode, stderr, stdout} = run1;\n\n  expect(stdout).toBe('');\n  expect(stderr).toMatchInlineSnapshot(`\n    \"Validation Error:\n\n    haste.enableSymlinks is incompatible with watchman\n\n    Either set haste.enableSymlinks to false or do not use watchman\"\n  `);\n  expect(exitCode).toBe(1);\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\nimport utils from '../utils';\n\ntest('implementation created by automock', () => {\n  expect(utils.authorize('wizard')).toBeUndefined();\n  expect(utils.isAuthorized()).toBeUndefined();\n});\n\ntest('implementation created by jest.createMockFromModule', () => {\n  const utils = jest.createMockFromModule('../utils').default;\n  utils.isAuthorized = jest.fn(secret => secret === 'not wizard');\n\n  expect(utils.authorize.mock).toBeTruthy();\n  expect(utils.isAuthorized('not wizard')).toBe(true);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst domain = require('domain');\n\ntest('allows retrieving the current domain', () => {\n  domain.create().run(() => {\n    expect(process.domain).not.toBeNull();\n  });\n});"}
{"prompt":"creates a process object that looks like the original one,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EventEmitter} from 'events';\n\nlet createProcessObject: typeof import('../createProcessObject').default;\n\nfunction requireCreateProcessObject() {\n  jest.isolateModules(() => {\n    createProcessObject = (\n      require('../createProcessObject') as typeof import('../createProcessObject')\n    ).default;\n  });\n}\n\nit('creates a process object that looks like the original one', () => {\n  requireCreateProcessObject();\n  const fakeProcess = createProcessObject();\n\n  // \"process\" inherits from EventEmitter through the prototype chain.\n  expect(fakeProcess instanceof EventEmitter).toBe(true);\n\n  // They look the same, but they are NOT the same (deep copied object).\n  // The `_events` property is checked to ensure event emitter properties are\n  // properly copied.\n  for (const key of ['argv', 'env', '_events'] as const) {\n    // @ts-expect-error: Testing internal `_events` property\n    expect(fakeProcess[key]).toEqual(process[key]);\n    // @ts-expect-error: Testing internal `_events` property\n    expect(fakeProcess[key]).not.toBe(process[key]);\n  }\n\n  // Check that process.stdout/stderr are the same.\n  expect(process.stdout).toBe(fakeProcess.stdout);\n  expect(process.stderr).toBe(fakeProcess.stderr);\n});\n\nit('fakes require(\"process\") so it is equal to \"global.process\"', () => {\n  expect(require('process') === process).toBe(true);\n});\n\nit('checks that process.env works as expected on Linux platforms', () => {\n  Object.defineProperty(process, 'platform', {get: () => 'linux'});\n  requireCreateProcessObject();\n\n  // Existing properties inside process.env are copied to the fake environment.\n  process.env.PROP_STRING = 'foo';\n  // @ts-expect-error: Type 'number' is not assignable to type 'string'.\n  process.env.PROP_NUMBER = 3;\n  process.env.PROP_UNDEFINED = undefined;\n\n  const fake = createProcessObject().env;\n\n  // All values converted to strings.\n  expect(fake.PROP_STRING).toBe('foo');\n  expect(fake.PROP_NUMBER).toBe('3');\n  expect(fake.PROP_UNDEFINED).toBe('undefined');\n\n  // Mac and Linux are case sensitive.\n  expect(fake.PROP_string).toBeUndefined();\n\n  // Added properties to the fake object are not added to the real one.\n  fake.PROP_ADDED = 'new!';\n\n  expect(fake.PROP_ADDED).toBe('new!');\n  expect(process.env.PROP_ADDED).toBeUndefined();\n\n  // You can delete properties, but they are case sensitive!\n  fake.prop = 'foo';\n  fake.PROP = 'bar';\n\n  expect(fake.prop).toBe('foo');\n  expect(fake.PROP).toBe('bar');\n\n  delete fake.PROP;\n\n  expect(fake.prop).toBe('foo');\n  expect(fake.PROP).toBeUndefined();\n});\n\nit('checks that process.env works as expected in Windows platforms', () => {\n  Object.defineProperty(process, 'platform', {get: () => 'win32'});\n  requireCreateProcessObject();\n\n  // Windows is not case sensitive when it comes to property names.\n  process.env.PROP_STRING = 'foo';\n\n  const fake = createProcessObject().env;\n\n  expect(fake.PROP_STRING).toBe('foo');\n  expect(fake.PROP_string).toBe('foo');\n\n  // Inherited methods, however, are not affected by case insensitiveness.\n  expect(typeof fake.toString).toBe('function');\n  expect(typeof fake.valueOf).toBe('function');\n\n  expect(typeof fake.tostring).toBe('undefined');\n  expect(typeof fake.valueof).toBe('undefined');\n\n  // You can delete through case-insensitiveness too.\n  delete fake.prop_string;\n\n  expect(Object.prototype.hasOwnProperty.call(fake, 'PROP_string')).toBe(false);\n  expect(Object.prototype.hasOwnProperty.call(fake, 'PROP_string')).toBe(false);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports.foo = 'foo';"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst {randomFillSync} = require('crypto');\n\ntest('randomFillSync()', () => {\n  const buf = Buffer.alloc(10);\n  randomFillSync(buf);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst phrase = require('../common-file');\n\ntest('C', () => {\n  expect(phrase).toBe('hello');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment <rootDir>/custom-env-conditions-method-override.js\n */\n\nimport {fn} from 'fake-dual-dep';\n\ntest('returns correct message', () => {\n  expect(fn()).toBe('hello from deno');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment <rootDir>/custom-env.js\n * @jest-environment-options {\"customExportConditions\": [\"react-native\"]}\n */\n\nimport {fn} from 'fake-dual-dep';\n\ntest('returns correct message', () => {\n  expect(fn()).toBe('hello from react-native');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment <rootDir>/custom-env.js\n */\n\nimport {fn} from 'fake-dual-dep';\n\ntest('returns correct message', () => {\n  expect(fn()).toBe('hello from deno');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\ntest('setup', () => {\n  expect(globalThis.setup).toBe('setup');\n});"}
{"prompt":"CustomConsole,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {Writable} from 'stream';\nimport type {WriteStream} from 'tty';\nimport chalk = require('chalk');\nimport CustomConsole from '../CustomConsole';\n\ndescribe('CustomConsole', () => {\n  let _console: CustomConsole;\n  let _stdout: string;\n  let _stderr: string;\n\n  beforeEach(() => {\n    _stdout = '';\n    _stderr = '';\n\n    const stdout = new Writable({\n      write(chunk: string, _encoding, callback) {\n        _stdout += chunk.toString();\n        callback();\n      },\n    }) as WriteStream;\n\n    const stderr = new Writable({\n      write(chunk: string, _encoding, callback) {\n        _stderr += chunk.toString();\n        callback();\n      },\n    }) as WriteStream;\n\n    _console = new CustomConsole(stdout, stderr);\n  });\n\n  describe('log', () => {\n    test('should print to stdout', () => {\n      _console.log('Hello world!');\n\n      expect(_stdout).toBe('Hello world!\\n');\n    });\n  });\n\n  describe('error', () => {\n    test('should print to stderr', () => {\n      _console.error('Found some error!');\n\n      expect(_stderr).toBe('Found some error!\\n');\n    });\n  });\n\n  describe('warn', () => {\n    test('should print to stderr', () => {\n      _console.warn('Found some warning!');\n\n      expect(_stderr).toBe('Found some warning!\\n');\n    });\n  });\n\n  describe('assert', () => {\n    test('do not log when the assertion is truthy', () => {\n      _console.assert(true);\n\n      expect(_stderr).toMatch('');\n    });\n\n    test('do not log when the assertion is truthy and there is a message', () => {\n      _console.assert(true, 'ok');\n\n      expect(_stderr).toMatch('');\n    });\n\n    test('log the assertion error when the assertion is falsy', () => {\n      _console.assert(false);\n\n      expect(_stderr).toMatch('AssertionError');\n      expect(_stderr).toMatch(\n        // The message may differ across Node versions\n        /(false == true)|(The expression evaluated to a falsy value:)/,\n      );\n    });\n\n    test('log the assertion error when the assertion is falsy with another message argument', () => {\n      _console.assert(false, 'this should not happen');\n\n      expect(_stderr).toMatch('AssertionError');\n      expect(_stderr).toMatch('this should not happen');\n    });\n  });\n\n  describe('count', () => {\n    test('count using the default counter', () => {\n      _console.count();\n      _console.count();\n      _console.count();\n\n      expect(_stdout).toBe('default: 1\\ndefault: 2\\ndefault: 3\\n');\n    });\n\n    test('count using the a labeled counter', () => {\n      _console.count('custom');\n      _console.count('custom');\n      _console.count('custom');\n\n      expect(_stdout).toBe('custom: 1\\ncustom: 2\\ncustom: 3\\n');\n    });\n\n    test('countReset restarts default counter', () => {\n      _console.count();\n      _console.count();\n      _console.countReset();\n      _console.count();\n      expect(_stdout).toBe('default: 1\\ndefault: 2\\ndefault: 1\\n');\n    });\n\n    test('countReset restarts custom counter', () => {\n      _console.count('custom');\n      _console.count('custom');\n      _console.countReset('custom');\n      _console.count('custom');\n\n      expect(_stdout).toBe('custom: 1\\ncustom: 2\\ncustom: 1\\n');\n    });\n  });\n\n  describe('group', () => {\n    test('group without label', () => {\n      _console.group();\n      _console.log('hey');\n      _console.group();\n      _console.log('there');\n\n      expect(_stdout).toBe('  hey\\n    there\\n');\n    });\n\n    test('group with label', () => {\n      _console.group('first');\n      _console.log('hey');\n      _console.group('second');\n      _console.log('there');\n\n      expect(_stdout).toBe(`  ${chalk.bold('first')}\n  hey\n    ${chalk.bold('second')}\n    there\n`);\n    });\n\n    test('groupEnd remove the indentation of the current group', () => {\n      _console.group();\n      _console.log('hey');\n      _console.groupEnd();\n      _console.log('there');\n\n      expect(_stdout).toBe('  hey\\nthere\\n');\n    });\n\n    test('groupEnd can not remove the indentation below the starting point', () => {\n      _console.groupEnd();\n      _console.groupEnd();\n      _console.group();\n      _console.log('hey');\n      _console.groupEnd();\n      _console.log('there');\n\n      expect(_stdout).toBe('  hey\\nthere\\n');\n    });\n  });\n\n  describe('time', () => {\n    test('should return the time between time() and timeEnd() on default timer', () => {\n      _console.time();\n      _console.timeEnd();\n\n      expect(_stdout).toMatch('default: ');\n      expect(_stdout).toMatch('ms');\n    });\n\n    test('should return the time between time() and timeEnd() on custom timer', () => {\n      _console.time('custom');\n      _console.timeEnd('custom');\n\n      expect(_stdout).toMatch('custom: ');\n      expect(_stdout).toMatch('ms');\n    });\n  });\n\n  describe('dir', () => {\n    test('should print the deepest value', () => {\n      const deepObject = {1: {2: {3: {4: {5: {6: 'value'}}}}}};\n      _console.dir(deepObject, {depth: 6});\n\n      expect(_stdout).toMatch('value');\n      expect(_stdout).not.toMatch('depth');\n    });\n  });\n\n  describe('timeLog', () => {\n    test('should return the time between time() and timeEnd() on default timer', () => {\n      _console.time();\n      _console.timeLog();\n\n      expect(_stdout).toMatch('default: ');\n      expect(_stdout).toMatch('ms');\n      _console.timeEnd();\n    });\n\n    test('should return the time between time() and timeEnd() on custom timer', () => {\n      _console.time('custom');\n      _console.timeLog('custom');\n\n      expect(_stdout).toMatch('custom: ');\n      expect(_stdout).toMatch('ms');\n      _console.timeEnd('custom');\n    });\n\n    test('default timer with data', () => {\n      _console.time();\n      _console.timeLog(undefined, 'foo', 5);\n\n      expect(_stdout).toMatch('default: ');\n      expect(_stdout).toMatch('ms foo 5');\n      _console.timeEnd();\n    });\n\n    test('custom timer with data', () => {\n      _console.time('custom');\n      _console.timeLog('custom', 'foo', 5);\n\n      expect(_stdout).toMatch('custom: ');\n      expect(_stdout).toMatch('ms foo 5');\n      _console.timeEnd('custom');\n    });\n  });\n\n  describe('console', () => {\n    test('should be able to initialize console instance', () => {\n      expect(_console.Console).toBeDefined();\n    });\n  });\n});"}
{"prompt":"Create Volumes wh different specifications but the same value for use in","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {Tester} from '@jest/expect-utils';\nimport jestExpect from '..';\n\nclass Volume {\n  public amount: number;\n  public unit: 'L' | 'mL';\n\n  constructor(amount: number, unit: 'L' | 'mL') {\n    this.amount = amount;\n    this.unit = unit;\n  }\n\n  toString(): string {\n    return `[Volume ${this.amount}${this.unit}]`;\n  }\n\n  equals(other: Volume): boolean {\n    if (this.unit === other.unit) {\n      return this.amount === other.amount;\n    } else if (this.unit === 'L' && other.unit === 'mL') {\n      return this.amount * 1000 === other.amount;\n    } else {\n      return this.amount === other.amount * 1000;\n    }\n  }\n}\n\nfunction createVolume(amount: number, unit: 'L' | 'mL' = 'L') {\n  return new Volume(amount, unit);\n}\n\nfunction isVolume(a: unknown): a is Volume {\n  return a instanceof Volume;\n}\n\nconst areVolumesEqual: Tester = (\n  a: unknown,\n  b: unknown,\n): boolean | undefined => {\n  const isAVolume = isVolume(a);\n  const isBVolume = isVolume(b);\n\n  if (isAVolume && isBVolume) {\n    return a.equals(b);\n  } else if (isAVolume === isBVolume) {\n    return undefined;\n  } else {\n    return false;\n  }\n};\n\nfunction* toIterator<T>(array: Array<T>): Iterator<T> {\n  for (const obj of array) {\n    yield obj;\n  }\n}\n\ndeclare module '../types' {\n  interface Matchers<R> {\n    toEqualVolume(expected: Volume): R;\n  }\n}\n\njestExpect.extend({\n  toEqualVolume(expected: Volume, actual: Volume) {\n    const result = this.equals(expected, actual, this.customTesters);\n\n    return {\n      message: () =>\n        `Expected Volume object: ${expected.toString()}. Actual Volume object: ${actual.toString()}`,\n      pass: result,\n    };\n  },\n});\n\n// Create Volumes with different specifications but the same value for use in\n// tests. Without the custom tester, these volumes would not be equal because\n// their properties have different values. However, with our custom tester they\n// are equal.\nconst volume1 = createVolume(1, 'L');\nconst volume2 = createVolume(1000, 'mL');\n\nconst volumeArg1 = createVolume(1, 'L');\nconst volumeArg2 = createVolume(1000, 'mL');\nconst volumeArg3 = createVolume(2, 'L');\nconst volumeArg4 = createVolume(2000, 'mL');\n\nconst volumeReturn1 = createVolume(2, 'L');\nconst volumeReturn2 = createVolume(2000, 'mL');\n\nconst testArgs = [volumeArg1, volumeArg2, [volumeArg3, volumeArg4]];\n// Swap the order of args to assert custom tester sees these volumes as equal\nconst expectedArgs = [volumeArg2, volumeArg1, [volumeArg4, volumeArg3]];\n\nexpect.addEqualityTesters([areVolumesEqual]);\n\ndescribe('with custom equality testers', () => {\n  it('basic matchers customTesters do not apply to still do not pass different Volume objects', () => {\n    expect(volume1).not.toBe(volume2);\n    expect([volume1]).not.toContain(volume2);\n  });\n\n  it('basic matchers pass different Volume objects', () => {\n    expect(volume1).toEqual(volume1);\n    expect(volume1).toEqual(volume2);\n    expect([volume1, volume2]).toEqual([volume2, volume1]);\n    expect(new Map([['key', volume1]])).toEqual(new Map([['key', volume2]]));\n    expect(new Set([volume1])).toEqual(new Set([volume2]));\n    expect(toIterator([volume1, volume2])).toEqual(\n      toIterator([volume2, volume1]),\n    );\n    expect([volume1]).toContainEqual(volume2);\n    expect({a: volume1}).toHaveProperty('a', volume2);\n    expect({a: volume1, b: undefined}).toStrictEqual({\n      a: volume2,\n      b: undefined,\n    });\n    expect({a: 1, b: {c: volume1}}).toMatchObject({\n      a: 1,\n      b: {c: volume2},\n    });\n  });\n\n  it('asymmetric matchers pass different Volume objects', () => {\n    expect([volume1]).toEqual(expect.arrayContaining([volume2]));\n    expect({a: 1, b: {c: volume1}}).toEqual(\n      expect.objectContaining({b: {c: volume2}}),\n    );\n  });\n\n  it('spy matchers pass different Volume objects', () => {\n    const mockFn = jest.fn<(...args: Array<unknown>) => unknown>(\n      () => volumeReturn1,\n    );\n    mockFn(...testArgs);\n\n    expect(mockFn).toHaveBeenCalledWith(...expectedArgs);\n    expect(mockFn).toHaveBeenLastCalledWith(...expectedArgs);\n    expect(mockFn).toHaveBeenNthCalledWith(1, ...expectedArgs);\n\n    expect(mockFn).toHaveReturnedWith(volumeReturn2);\n    expect(mockFn).toHaveLastReturnedWith(volumeReturn2);\n    expect(mockFn).toHaveNthReturnedWith(1, volumeReturn2);\n  });\n\n  it('custom matchers pass different Volume objects', () => {\n    expect(volume1).toEqualVolume(volume2);\n  });\n\n  it('toBe recommends toStrictEqual even with different Volume objects', () => {\n    expect(() => expect(volume1).toBe(volume2)).toThrow('toStrictEqual');\n  });\n\n  it('toBe recommends toEqual even with different Volume objects', () => {\n    expect(() => expect({a: undefined, b: volume1}).toBe({b: volume2})).toThrow(\n      'toEqual',\n    );\n  });\n\n  it('toContains recommends toContainEquals even with different Volume objects', () => {\n    expect(() => expect([volume1]).toContain(volume2)).toThrow(\n      'toContainEqual',\n    );\n  });\n\n  it('toMatchObject error shows Volume objects as equal', () => {\n    expect(() =>\n      expect({a: 1, b: volume1}).toMatchObject({a: 2, b: volume2}),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  it('iterableEquality still properly detects cycles', () => {\n    const a = new Set();\n    a.add(volume1);\n    a.add(a);\n\n    const b = new Set();\n    b.add(volume2);\n    b.add(b);\n\n    expect(a).toEqual(b);\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`with custom equality testers toMatchObject error shows Volume objects as equal 1`] = `\n\"<dim>expect(</intensity><red>received</color><dim>).</intensity>toMatchObject<dim>(</intensity><green>expected</color><dim>)</intensity>\n\n<green>- Expected  - 1</color>\n<red>+ Received  + 1</color>\n\n<dim>  Object {</intensity>\n<green>-   \"a\": 2,</color>\n<red>+   \"a\": 1,</color>\n<dim>    \"b\": Volume {</intensity>\n<dim>      \"amount\": 1000,</intensity>\n<dim>      \"unit\": \"mL\",</intensity>\n<dim>    },</intensity>\n<dim>  }</intensity>\"\n`;"}
{"prompt":"Test test file demonstrates and tests the capabily of recursive custom","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {type Tester, equals} from '@jest/expect-utils';\nimport jestExpect from '..';\n\n// Test test file demonstrates and tests the capability of recursive custom\n// testers that call `equals` within their tester logic. These testers should\n// receive the array of custom testers and be able to pass it into equals\n\nconst CONNECTION_PROP = '__connection';\ntype DbConnection = number;\nlet DbConnectionId = 0;\n\nclass Author {\n  public name: string;\n  public [CONNECTION_PROP]: DbConnection;\n\n  constructor(name: string) {\n    this.name = name;\n    this[CONNECTION_PROP] = DbConnectionId++;\n  }\n}\n\nclass Book {\n  public name: string;\n  public authors: Array<Author>;\n  public [CONNECTION_PROP]: DbConnection;\n\n  constructor(name: string, authors: Array<Author>) {\n    this.name = name;\n    this.authors = authors;\n    this[CONNECTION_PROP] = DbConnectionId++;\n  }\n}\n\nconst areAuthorsEqual: Tester = (a: unknown, b: unknown) => {\n  const isAAuthor = a instanceof Author;\n  const isBAuthor = b instanceof Author;\n\n  if (isAAuthor && isBAuthor) {\n    return a.name === b.name;\n  } else if (isAAuthor === isBAuthor) {\n    return undefined;\n  } else {\n    return false;\n  }\n};\n\nconst areBooksEqual: Tester = function (\n  a: unknown,\n  b: unknown,\n  customTesters: Array<Tester>,\n) {\n  const isABook = a instanceof Book;\n  const isBBook = b instanceof Book;\n\n  if (isABook && isBBook) {\n    return (\n      a.name === b.name && this.equals(a.authors, b.authors, customTesters)\n    );\n  } else if (isABook === isBBook) {\n    return undefined;\n  } else {\n    return false;\n  }\n};\n\nfunction* toIterator<T>(array: Array<T>): Iterator<T> {\n  for (const obj of array) {\n    yield obj;\n  }\n}\n\ndeclare module '../types' {\n  interface Matchers<R> {\n    toEqualBook(expected: Book): R;\n  }\n}\n\njestExpect.extend({\n  toEqualBook(expected: Book, actual: Book) {\n    const result = this.equals(expected, actual, this.customTesters);\n\n    return {\n      message: () =>\n        `Expected Book object: ${expected.name}. Actual Book object: ${actual.name}`,\n      pass: result,\n    };\n  },\n});\n\n// Create books with the same name and authors for use in tests. Without the\n// custom tester, these books would not be equal because their DbConnections\n// would have different values. However, with our custom tester they are equal.\nconst book1 = new Book('Book 1', [\n  new Author('Author 1'),\n  new Author('Author 2'),\n]);\nconst book1b = new Book('Book 1', [\n  new Author('Author 1'),\n  new Author('Author 2'),\n]);\n\nconst bookArg1a = new Book('Book Arg 1', [\n  new Author('Author Arg 1'),\n  new Author('Author Arg 2'),\n]);\nconst bookArg1b = new Book('Book Arg 1', [\n  new Author('Author Arg 1'),\n  new Author('Author Arg 2'),\n]);\nconst bookArg2a = new Book('Book Arg 2', [\n  new Author('Author Arg 3'),\n  new Author('Author Arg 4'),\n]);\nconst bookArg2b = new Book('Book Arg 2', [\n  new Author('Author Arg 3'),\n  new Author('Author Arg 4'),\n]);\n\nconst bookReturn1a = new Book('Book Return 1', [\n  new Author('Author Return 1'),\n  new Author('Author Return 2'),\n]);\nconst bookReturn1b = new Book('Book Return 1', [\n  new Author('Author Return 1'),\n  new Author('Author Return 2'),\n]);\n\nconst testArgs = [bookArg1a, bookArg1b, [bookArg2a, bookArg2b]];\n// Swap the order of args to assert custom tester works correctly and ignores\n// DbConnection differences\nconst expectedArgs = [bookArg1b, bookArg1a, [bookArg2b, bookArg2a]];\n\nexpect.addEqualityTesters([areAuthorsEqual, areBooksEqual]);\n\ndescribe('with custom equality testers', () => {\n  it('exposes an equality function to custom testers', () => {\n    const runTestSymbol = Symbol('run this test');\n\n    // jestExpect and expect share the same global state\n    expect.assertions(3);\n    jestExpect.addEqualityTesters([\n      function dummyTester(a) {\n        // Equality testers are globally added. Only run this assertion for this test\n        if (a === runTestSymbol) {\n          expect(this.equals).toBe(equals);\n          return true;\n        }\n\n        return undefined;\n      },\n    ]);\n\n    expect(() =>\n      jestExpect(runTestSymbol).toEqual(runTestSymbol),\n    ).not.toThrow();\n  });\n\n  it('basic matchers customTesters do not apply to still do not pass different Book objects', () => {\n    expect(book1).not.toBe(book1b);\n    expect([book1]).not.toContain(book1b);\n  });\n\n  it('basic matchers pass different Book objects', () => {\n    expect(book1).toEqual(book1);\n    expect(book1).toEqual(book1b);\n    expect([book1, book1b]).toEqual([book1b, book1]);\n    expect(new Map([['key', book1]])).toEqual(new Map([['key', book1b]]));\n    expect(new Set([book1])).toEqual(new Set([book1b]));\n    expect(toIterator([book1, book1b])).toEqual(toIterator([book1b, book1]));\n    expect([book1]).toContainEqual(book1b);\n    expect({a: book1}).toHaveProperty('a', book1b);\n    expect({a: book1, b: undefined}).toStrictEqual({\n      a: book1b,\n      b: undefined,\n    });\n    expect({a: 1, b: {c: book1}}).toMatchObject({\n      a: 1,\n      b: {c: book1b},\n    });\n  });\n\n  it('asymmetric matchers pass different Book objects', () => {\n    expect([book1]).toEqual(expect.arrayContaining([book1b]));\n    expect({a: 1, b: {c: book1}}).toEqual(\n      expect.objectContaining({b: {c: book1b}}),\n    );\n  });\n\n  it('spy matchers pass different Book objects', () => {\n    const mockFn = jest.fn<(...args: Array<unknown>) => unknown>(\n      () => bookReturn1a,\n    );\n    mockFn(...testArgs);\n\n    expect(mockFn).toHaveBeenCalledWith(...expectedArgs);\n    expect(mockFn).toHaveBeenLastCalledWith(...expectedArgs);\n    expect(mockFn).toHaveBeenNthCalledWith(1, ...expectedArgs);\n\n    expect(mockFn).toHaveReturnedWith(bookReturn1b);\n    expect(mockFn).toHaveLastReturnedWith(bookReturn1b);\n    expect(mockFn).toHaveNthReturnedWith(1, bookReturn1b);\n  });\n\n  it('custom matchers pass different Book objects', () => {\n    expect(book1).toEqualBook(book1b);\n  });\n\n  it('toBe recommends toStrictEqual even with different Book objects', () => {\n    expect(() => expect(book1).toBe(book1b)).toThrow('toStrictEqual');\n  });\n\n  it('toBe recommends toEqual even with different Book objects', () => {\n    expect(() => expect({a: undefined, b: book1}).toBe({b: book1b})).toThrow(\n      'toEqual',\n    );\n  });\n\n  it('toContains recommends toContainEquals even with different Book objects', () => {\n    expect(() => expect([book1]).toContain(book1b)).toThrow('toContainEqual');\n  });\n\n  it('toMatchObject error shows Book objects as equal', () => {\n    expect(() =>\n      expect({a: 1, b: book1}).toMatchObject({a: 2, b: book1b}),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  it('iterableEquality still properly detects cycles', () => {\n    const a = new Set();\n    a.add(book1);\n    a.add(a);\n\n    const b = new Set();\n    b.add(book1b);\n    b.add(b);\n\n    expect(a).toEqual(b);\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`with custom equality testers toMatchObject error shows Book objects as equal 1`] = `\n\"<dim>expect(</intensity><red>received</color><dim>).</intensity>toMatchObject<dim>(</intensity><green>expected</color><dim>)</intensity>\n\n<green>- Expected  - 1</color>\n<red>+ Received  + 1</color>\n\n<yellow>@@ -1,7 +1,7 @@</color>\n<dim>  Object {</intensity>\n<green>-   \"a\": 2,</color>\n<red>+   \"a\": 1,</color>\n<dim>    \"b\": Book {</intensity>\n<dim>      \"__connection\": 5,</intensity>\n<dim>      \"authors\": Array [</intensity>\n<dim>        Author {</intensity>\n<dim>          \"__connection\": 3,</intensity>\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\nconst dir = path.resolve(__dirname, '../custom-esm-test-sequencer');\n\ntest('run prioritySequence', () => {\n  const result = runJest(dir, ['-i'], {\n    nodeOptions: '--experimental-vm-modules --no-warnings',\n  });\n\n  expect(result.exitCode).toBe(0);\n  const sequence = extractSummary(result.stderr)\n    .rest.replaceAll('PASS ', '')\n    .split('\\n');\n  expect(sequence).toEqual([\n    './a.test.js',\n    './b.test.js',\n    './c.test.js',\n    './d.test.js',\n    './e.test.js',\n  ]);\n});"}
{"prompt":"Custom Haste Integration,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport runJest from '../runJest';\n\ndescribe('Custom Haste Integration', () => {\n  test('valid test with fake module resolutions', () => {\n    const config = {\n      haste: {\n        hasteMapModulePath: path.resolve(\n          __dirname,\n          '..',\n          'custom-haste-map/hasteMap.js',\n        ),\n      },\n    };\n\n    const {exitCode} = runJest('custom-haste-map', [\n      '--config',\n      JSON.stringify(config),\n      'hasteExample.test.js',\n    ]);\n    expect(exitCode).toBe(0);\n  });\n});"}
{"prompt":"Prevent adding new snapshots or rather changing the test.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\ntest('works with custom inline snapshot matchers', () => {\n  const {stderr} = runJest('custom-inline-snapshot-matchers', [\n    // Prevent adding new snapshots or rather changing the test.\n    '--ci',\n    'asynchronous.test.js',\n  ]);\n\n  let {rest} = extractSummary(stderr);\n\n  rest = rest\n    .split('\\n')\n    .filter(line => !line.includes('at Error (native)'))\n    .join('\\n');\n\n  expect(rest).toMatchSnapshot();\n});\n\ntest('can bail with a custom inline snapshot matcher', () => {\n  const {stderr} = runJest('custom-inline-snapshot-matchers', [\n    // Prevent adding new snapshots or rather changing the test.\n    '--ci',\n    'bail.test.js',\n  ]);\n\n  let {rest} = extractSummary(stderr);\n\n  rest = rest\n    .split('\\n')\n    .filter(line => !line.includes('at Error (native)'))\n    .join('\\n');\n\n  expect(rest).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`can bail with a custom inline snapshot matcher 1`] = `\n\"FAIL __tests__/bail.test.js\n  ✕ transitions as expected\n\n  ● transitions as expected\n\n    expect(received).toMatchInlineSnapshot(snapshot)\n\n    Snapshot name: \\`transitions as expected 2\\`\n\n    Snapshot: \"loading\"\n    Received: \"initial\"\n\n      28 |   transition();\n      29 |   // Already produces a mismatch. No point in continuing the test.\n    > 30 |   expect(state).toMatchStateInlineSnapshot(\\`\"loading\"\\`);\n         |                 ^\n      31 |   transition();\n      32 |   expect(state).toMatchStateInlineSnapshot(\\`\"done\"\\`);\n      33 | });\n\n      at Object.toMatchStateInlineSnapshot (__tests__/bail.test.js:30:17)\n\n › 1 snapshot failed.\nSnapshot Summary\n › 1 snapshot failed from 1 test suite. Inspect your code changes or re-run jest with \\`-u\\` to update them.\"\n`;\n\nexports[`works with custom inline snapshot matchers 1`] = `\n\"FAIL __tests__/asynchronous.test.js\n  ✕ new async, inline snapshots\n  ✕ mismatching async, inline snapshots\n\n  ● new async, inline snapshots\n\n    expect(received).toMatchInlineSnapshot()\n\n    Snapshot name: \\`new async, inline snapshots 1\\`\n\n    New snapshot was not written. The update flag must be explicitly passed to write a new snapshot.\n\n    This is likely because this test is run in a continuous integration (CI) environment in which snapshots are not written by default.\n\n    Received: \"result #1\"\n\n      20 |\n      21 | test('new async, inline snapshots', async () => {\n    > 22 |   await expect(async () => 'result #1').toMatchObservationInlineSnapshot();\n         |                                         ^\n      23 |   await expect(async () => 'result #2').toMatchObservationInlineSnapshot();\n      24 | });\n      25 |\n\n      at Object.toMatchObservationInlineSnapshot (__tests__/asynchronous.test.js:22:41)\n\n  ● new async, inline snapshots\n\n    expect(received).toMatchInlineSnapshot()\n\n    Snapshot name: \\`new async, inline snapshots 2\\`\n\n    New snapshot was not written. The update flag must be explicitly passed to write a new snapshot.\n\n    This is likely because this test is run in a continuous integration (CI) environment in which snapshots are not written by default.\n\n    Received: \"result #2\"\n\n      21 | test('new async, inline snapshots', async () => {\n      22 |   await expect(async () => 'result #1').toMatchObservationInlineSnapshot();\n    > 23 |   await expect(async () => 'result #2').toMatchObservationInlineSnapshot();\n         |                                         ^\n      24 | });\n      25 |\n      26 | test('mismatching async, inline snapshots', async () => {\n\n      at Object.toMatchObservationInlineSnapshot (__tests__/asynchronous.test.js:23:41)\n\n  ● mismatching async, inline snapshots\n\n    expect(received).toMatchInlineSnapshot(snapshot)\n\n    Snapshot name: \\`mismatching async, inline snapshots 1\\`\n\n    Snapshot: \"result #?\"\n    Received: \"result #1\"\n\n      25 |\n      26 | test('mismatching async, inline snapshots', async () => {\n    > 27 |   await expect(async () => 'result #1').toMatchObservationInlineSnapshot(\n         |                                         ^\n      28 |     \\`\"result #?\"\\`,\n      29 |   );\n      30 |   await expect(async () => 'result #2').toMatchObservationInlineSnapshot(\n\n      at Object.toMatchObservationInlineSnapshot (__tests__/asynchronous.test.js:27:41)\n\n  ● mismatching async, inline snapshots\n\n    expect(received).toMatchInlineSnapshot(snapshot)\n\n    Snapshot name: \\`mismatching async, inline snapshots 2\\`\n\n    Snapshot: \"result #?\"\n    Received: \"result #2\"\n\n      28 |     \\`\"result #?\"\\`,\n      29 |   );\n    > 30 |   await expect(async () => 'result #2').toMatchObservationInlineSnapshot(\n         |                                         ^\n      31 |     \\`\"result #?\"\\`,\n      32 |   );\n      33 | });\n\n      at Object.toMatchObservationInlineSnapshot (__tests__/asynchronous.test.js:30:41)\n\n › 4 snapshots failed.\nSnapshot Summary\n › 4 snapshots failed from 1 test suite. Inspect your code changes or re-run jest with \\`-u\\` to update them.\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\ntest('works with custom matchers', () => {\n  const {stderr} = runJest('custom-matcher-stack-trace', ['sync.test.js']);\n\n  let {rest} = extractSummary(stderr);\n\n  rest = rest\n    .split('\\n')\n    .filter(line => !line.includes('at Error (native)'))\n    .join('\\n');\n\n  expect(rest).toMatchSnapshot();\n});\n\ntest('custom async matchers', () => {\n  const {stderr} = runJest('custom-matcher-stack-trace', [\n    'asynchronous.test.js',\n  ]);\n\n  const {rest} = extractSummary(stderr);\n\n  expect(rest).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`custom async matchers 1`] = `\n\"FAIL __tests__/asynchronous.test.js\n  ✕ showing the stack trace for an async matcher\n\n  ● showing the stack trace for an async matcher\n\n    We expect the stack trace and code fence for this matcher to be shown in the console.\n\n       9 |\n      10 | test('showing the stack trace for an async matcher', () =>\n    > 11 |   expect(true).toThrowCustomAsyncMatcherError());\n         |                ^\n      12 |\n      13 | function toThrowCustomAsyncMatcherError() {\n      14 |   const message = () =>\n\n      at Object.toThrowCustomAsyncMatcherError (__tests__/asynchronous.test.js:11:16)\"\n`;\n\nexports[`works with custom matchers 1`] = `\n\"FAIL __tests__/sync.test.js\n  Custom matcher\n    ✓ passes\n    ✓ fails\n    ✕ preserves error stack\n\n  ● Custom matcher › preserves error stack\n\n    qux\n\n      44 |     const baz = () => {\n      45 |       // eslint-disable-next-line unicorn/throw-new-error,unicorn/new-for-builtins\n    > 46 |       throw Error('qux');\n         |             ^\n      47 |     };\n      48 |\n      49 |     // This expectation fails due to an error we throw (intentionally)\n\n      at Error (__tests__/sync.test.js:46:13)\n      at baz (__tests__/sync.test.js:43:23)\n      at bar (__tests__/sync.test.js:42:23)\n      at foo (__tests__/sync.test.js:53:7)\n      at Object.callback (__tests__/sync.test.js:11:18)\n      at Object.toCustomMatch (__tests__/sync.test.js:54:8)\"\n`;"}
{"prompt":"instruments by setting globalThis.__INSTRUMENTED__,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nrequire('../src');\n\nit('instruments by setting globalThis.__INSTRUMENTED__', () => {\n  expect(globalThis.__INSTRUMENTED__).toBe(true);\n});\n\nit('preprocesses by setting globalThis.__PREPROCESSED__', () => {\n  expect(globalThis.__PREPROCESSED__).toBe(true);\n});"}
{"prompt":"Custom Reporters Integration,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, extractSummary, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'custom-reporters-test-dir');\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ndescribe('Custom Reporters Integration', () => {\n  test('valid string format for adding reporters', () => {\n    const reporterConfig = {\n      reporters: ['<rootDir>/reporters/TestReporter.js'],\n    };\n\n    const {exitCode} = runJest('custom-reporters', [\n      '--config',\n      JSON.stringify(reporterConfig),\n      'add.test.js',\n    ]);\n\n    expect(exitCode).toBe(0);\n  });\n\n  test('valid array format for adding reporters', () => {\n    const reporterConfig = {\n      reporters: [\n        ['<rootDir>/reporters/TestReporter.js', {'Aaron Abramov': 'Awesome'}],\n      ],\n    };\n\n    const {exitCode, stdout} = runJest('custom-reporters', [\n      '--config',\n      JSON.stringify(reporterConfig),\n      'add.test.js',\n    ]);\n\n    expect(stdout).toMatchSnapshot();\n    expect(exitCode).toBe(0);\n  });\n\n  test('invalid format for adding reporters', () => {\n    const reporterConfig = {\n      reporters: [[3_243_242]],\n    };\n\n    const {exitCode, stderr} = runJest('custom-reporters', [\n      '--config',\n      JSON.stringify(reporterConfig),\n      'add.test.js',\n    ]);\n\n    expect(exitCode).toBe(1);\n    expect(stderr).toMatchSnapshot();\n  });\n\n  test('default reporters enabled', () => {\n    const {stderr, stdout, exitCode} = runJest('custom-reporters', [\n      '--config',\n      JSON.stringify({\n        reporters: ['default', '<rootDir>/reporters/TestReporter.js'],\n      }),\n      'add.test.js',\n    ]);\n\n    const {summary, rest} = extractSummary(stderr);\n    const parsedJSON = JSON.parse(stdout);\n\n    expect(exitCode).toBe(0);\n    expect(rest).toMatchSnapshot();\n    expect(summary).toMatchSnapshot();\n    expect(parsedJSON).toMatchSnapshot();\n  });\n\n  test('TestReporter with all tests passing', () => {\n    const {stdout, exitCode, stderr} = runJest('custom-reporters', [\n      'add.test.js',\n    ]);\n\n    const parsedJSON = JSON.parse(stdout);\n\n    expect(exitCode).toBe(0);\n    expect(stderr).toBe('');\n    expect(parsedJSON).toMatchSnapshot();\n  });\n\n  test('TestReporter with all tests failing', () => {\n    const {stdout, exitCode, stderr} = runJest('custom-reporters', [\n      'addFail.test.js',\n    ]);\n\n    const parsedJSON = JSON.parse(stdout);\n\n    expect(exitCode).toBe(1);\n    expect(stderr).toBe('');\n    expect(parsedJSON).toMatchSnapshot();\n  });\n\n  test('IncompleteReporter for flexibility', () => {\n    const {stderr, stdout, exitCode} = runJest('custom-reporters', [\n      '--no-cache',\n      '--config',\n      JSON.stringify({\n        reporters: ['<rootDir>/reporters/IncompleteReporter.js'],\n      }),\n      'add.test.js',\n    ]);\n\n    expect(exitCode).toBe(0);\n    expect(stderr).toBe('');\n\n    expect(stdout).toMatchSnapshot();\n  });\n\n  test('reporters can be default exports', () => {\n    const {stderr, stdout, exitCode} = runJest('custom-reporters', [\n      '--no-cache',\n      '--config',\n      JSON.stringify({\n        reporters: ['<rootDir>/reporters/DefaultExportReporter.js'],\n      }),\n      'add.test.js',\n    ]);\n\n    expect(stderr).toBe('');\n    expect(exitCode).toBe(0);\n    expect(stdout).toMatchSnapshot();\n  });\n\n  test('prints reporter errors', () => {\n    writeFiles(DIR, {\n      '__tests__/test.test.js': \"test('test', () => {});\",\n      'package.json': JSON.stringify({\n        jest: {\n          reporters: ['default', '<rootDir>/reporter.js'],\n        },\n      }),\n      'reporter.js': `\n        'use strict';\n        module.exports = class Reporter {\n          onRunStart() {\n            throw new Error('ON_RUN_START_ERROR');\n          }\n        };\n      `,\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n    expect(stderr).toMatch(/ON_RUN_START_ERROR/);\n    expect(exitCode).toBe(1);\n  });\n\n  test('supports reporter written in ESM', () => {\n    writeFiles(DIR, {\n      '__tests__/test.test.js': \"test('test', () => {});\",\n      'package.json': JSON.stringify({\n        jest: {\n          reporters: ['default', '<rootDir>/reporter.mjs'],\n        },\n      }),\n      'reporter.mjs': `\n        export default class Reporter {\n          onRunStart() {\n            throw new Error('ON_RUN_START_ERROR');\n          }\n        };\n      `,\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n    expect(stderr).toMatch(/ON_RUN_START_ERROR/);\n    expect(exitCode).toBe(1);\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Custom Reporters Integration IncompleteReporter for flexibility 1`] = `\n\"onRunComplete is called\nPassed Tests: 1\nFailed Tests: 0\nTotal Tests: 1\"\n`;\n\nexports[`Custom Reporters Integration TestReporter with all tests failing 1`] = `\nObject {\n  \"onRunComplete\": Object {\n    \"called\": true,\n    \"numFailedTests\": 1,\n    \"numPassedTests\": 0,\n    \"numTotalTests\": 1,\n  },\n  \"onRunStart\": Object {\n    \"called\": true,\n    \"options\": \"object\",\n  },\n  \"onTestResult\": Object {\n    \"called\": true,\n    \"times\": 1,\n  },\n  \"onTestStart\": Object {\n    \"called\": true,\n    \"path\": false,\n  },\n  \"reporterContext\": Object {\n    \"firstRun\": true,\n    \"previousSuccess\": true,\n  },\n  \"reporterOptions\": Object {\n    \"christoph\": \"pojer\",\n    \"dmitrii\": \"abramov\",\n    \"hello\": \"world\",\n  },\n}\n`;\n\nexports[`Custom Reporters Integration TestReporter with all tests passing 1`] = `\nObject {\n  \"onRunComplete\": Object {\n    \"called\": true,\n    \"numFailedTests\": 0,\n    \"numPassedTests\": 1,\n    \"numTotalTests\": 1,\n  },\n  \"onRunStart\": Object {\n    \"called\": true,\n    \"options\": \"object\",\n  },\n  \"onTestResult\": Object {\n    \"called\": true,\n    \"times\": 1,\n  },\n  \"onTestStart\": Object {\n    \"called\": true,\n    \"path\": false,\n  },\n  \"reporterContext\": Object {\n    \"firstRun\": true,\n    \"previousSuccess\": true,\n  },\n  \"reporterOptions\": Object {\n    \"christoph\": \"pojer\",\n    \"dmitrii\": \"abramov\",\n    \"hello\": \"world\",\n  },\n}\n`;\n\nexports[`Custom Reporters Integration default reporters enabled 1`] = `\n\"PASS __tests__/add.test.js\n  Custom Reporters\n    ✓ adds ok\"\n`;\n\nexports[`Custom Reporters Integration default reporters enabled 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching add.test.js.\"\n`;\n\nexports[`Custom Reporters Integration default reporters enabled 3`] = `\nObject {\n  \"onRunComplete\": Object {\n    \"called\": true,\n    \"numFailedTests\": 0,\n    \"numPassedTests\": 1,\n    \"numTotalTests\": 1,\n  },\n  \"onRunStart\": Object {\n    \"called\": true,\n    \"options\": \"object\",\n  },\n  \"onTestResult\": Object {\n    \"called\": true,\n    \"times\": 1,\n  },\n  \"onTestStart\": Object {\n    \"called\": true,\n    \"path\": false,\n  },\n  \"reporterContext\": Object {\n    \"firstRun\": true,\n    \"previousSuccess\": true,\n  },\n  \"reporterOptions\": Object {},\n}\n`;\n\nexports[`Custom Reporters Integration invalid format for adding reporters 1`] = `\n\"● Reporter Validation Error:\n\n  Unexpected value for Path at index 0 of reporter at index 0\n  Expected:\n    string\n  Got:\n    number\n  Reporter configuration:\n    [\n      3243242\n    ]\n\n  Configuration Documentation:\n  https://jestjs.io/docs/configuration\n\"\n`;\n\nexports[`Custom Reporters Integration reporters can be default exports 1`] = `\n\"run start\ntest start\ntest complete\nrun complete\"\n`;\n\nexports[`Custom Reporters Integration valid array format for adding reporters 1`] = `\n\"{\n    \"onRunComplete\": {\n        \"called\": true,\n        \"numPassedTests\": 1,\n        \"numFailedTests\": 0,\n        \"numTotalTests\": 1\n    },\n    \"onRunStart\": {\n        \"called\": true,\n        \"options\": \"object\"\n    },\n    \"onTestResult\": {\n        \"times\": 1,\n        \"called\": true\n    },\n    \"onTestStart\": {\n        \"called\": true,\n        \"path\": false\n    },\n    \"reporterContext\": {\n        \"firstRun\": true,\n        \"previousSuccess\": true\n    },\n    \"reporterOptions\": {\n        \"Aaron Abramov\": \"Awesome\"\n    }\n}\"\n`;"}
{"prompt":"Custom Reporters Integration on jest-circus,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJasmine();\n\ndescribe('Custom Reporters Integration on jest-circus', () => {\n  test('valid passing assertion counts for adding reporters', () => {\n    const {stdout} = runJest('custom-reporters', [\n      '--config',\n      JSON.stringify({\n        reporters: [\n          'default',\n          '<rootDir>/reporters/AssertionCountsReporter.js',\n        ],\n      }),\n      'add.test.js',\n    ]);\n\n    expect(stdout).toMatchSnapshot();\n  });\n\n  test('valid failing assertion counts for adding reporters', () => {\n    const {stdout} = runJest('custom-reporters', [\n      '--config',\n      JSON.stringify({\n        reporters: [\n          'default',\n          '<rootDir>/reporters/AssertionCountsReporter.js',\n        ],\n      }),\n      'addFail.test.js',\n    ]);\n\n    expect(stdout).toMatchSnapshot();\n  });\n\n  test('push test case results for todo tests', () => {\n    const {stdout} = runJest('custom-reporters', [\n      '--config',\n      JSON.stringify({\n        reporters: [\n          'default',\n          '<rootDir>/reporters/AssertionCountsReporter.js',\n        ],\n      }),\n      'todo.test.js',\n    ]);\n\n    expect(stdout).toMatchSnapshot();\n  });\n\n  test('push test case start', () => {\n    const {stdout} = runJest('custom-reporters', [\n      '--config',\n      JSON.stringify({\n        reporters: ['default', '<rootDir>/reporters/TestCaseStartReporter.js'],\n      }),\n      'just2Tests.test.js',\n    ]);\n\n    expect(stdout).toMatchSnapshot();\n  });\n\n  test(\"doesn't push test case start for todo tests\", () => {\n    const {stdout} = runJest('custom-reporters', [\n      '--config',\n      JSON.stringify({\n        reporters: ['default', '<rootDir>/reporters/TestCaseStartReporter.js'],\n      }),\n      'todo.test.js',\n    ]);\n\n    expect(stdout).toMatchSnapshot();\n  });\n\n  test(\"doesn't push test case start for skip tests\", () => {\n    const {stdout} = runJest('custom-reporters', [\n      '--config',\n      JSON.stringify({\n        reporters: ['default', '<rootDir>/reporters/TestCaseStartReporter.js'],\n      }),\n      'skip.test.js',\n    ]);\n\n    expect(stdout).toMatchSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Custom Reporters Integration on jest-circus valid failing assertion counts for adding reporters 1`] = `\n\"onTestCaseResult: adds fail, started: today, status: failed, numExpectations: 0\nonTestFileResult testCaseResult 0: adds fail, status: failed, numExpectations: 0\"\n`;\n\nexports[`Custom Reporters Integration on jest-circus valid passing assertion counts for adding reporters 1`] = `\n\"onTestCaseResult: adds ok, started: today, status: passed, numExpectations: 3\nonTestFileResult testCaseResult 0: adds ok, status: passed, numExpectations: 3\"\n`;\n\nexports[`Custom Reporters Integration on jest-circus push test case results for todo tests 1`] = `\n\"onTestCaseResult: sample, started: today, status: todo, numExpectations: 0\nonTestFileResult testCaseResult 0: sample, status: todo, numExpectations: 0\"\n`;\n\nexports[`Custom Reporters Integration on jest-circus push test case start 1`] = `\n\"onTestCaseStart: test 1, mode: undefined, ancestorTitles: Custom Reporters\nonTestCaseStart: test 2, mode: undefined, ancestorTitles: Custom Reporters\"\n`;\n\nexports[`Custom Reporters Integration on jest-circus doesn't push test case start for skip tests 1`] = `\"\"`;\n\nexports[`Custom Reporters Integration on jest-circus doesn't push test case start for todo tests 1`] = `\"\"`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('should use the custom resolver', () => {\n  require('foo');\n});\n\ntest('should work with automock', () => {\n  jest.mock('foo');\n\n  const foo = require('foo');\n  foo();\n\n  expect(foo).toHaveBeenCalled();\n});\n\ntest('should allow manual mocks to make require calls through the resolver', () => {\n  jest.mock('../manualMock');\n\n  expect(require('../manualMock')).toBe('bar');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('use the custom resolver', () => {\n  const result = runJest('custom-resolver');\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports = {\n  resolveSnapshotPath: (testPath, snapshotExtension) =>\n    testPath.replace('__tests__', '__snapshots__') + snapshotExtension,\n\n  resolveTestPath: (snapshotFilePath, snapshotExtension) =>\n    snapshotFilePath\n      .replace('__snapshots__', '__SPECS__')\n      .slice(0, -snapshotExtension.length),\n\n  testPathForConsistencyCheck: 'foo/__tests__/bar.test.js',\n};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports = {\n  resolveTestPath: () => {},\n  testPathForConsistencyCheck: 'foo/__tests__/bar.test.js',\n};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports = {\n  resolveSnapshotPath: () => {},\n  testPathForConsistencyCheck: 'foo/__tests__/bar.test.js',\n};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports = {\n  resolveSnapshotPath: (testPath, snapshotExtension) => {},\n  resolveTestPath: (snapshotFilePath, snapshotExtension) => {},\n};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports = {\n  resolveSnapshotPath: (testPath, snapshotExtension) =>\n    testPath.replace('__tests__', '__snapshots__') + snapshotExtension,\n\n  resolveTestPath: (snapshotFilePath, snapshotExtension) =>\n    snapshotFilePath\n      .replace('__snapshots__', '__tests__')\n      .slice(0, -snapshotExtension.length),\n\n  testPathForConsistencyCheck: 'foo/__tests__/bar.test.js',\n};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\nconst dir = path.resolve(__dirname, '../custom-test-sequencer');\n\ntest('run prioritySequence first sync', () => {\n  const result = runJest(\n    dir,\n    [\n      '-i',\n      '--config',\n      JSON.stringify({\n        testSequencer: '<rootDir>/testSequencer.js',\n      }),\n    ],\n    {},\n  );\n  expect(result.exitCode).toBe(0);\n  const sequence = extractSummary(result.stderr)\n    .rest.replaceAll('PASS ', '')\n    .split('\\n');\n  expect(sequence).toEqual([\n    './a.test.js',\n    './b.test.js',\n    './c.test.js',\n    './d.test.js',\n    './e.test.js',\n  ]);\n});\n\ntest('run prioritySequence first async', () => {\n  const result = runJest(\n    dir,\n    [\n      '-i',\n      '--config',\n      JSON.stringify({\n        testSequencer: '<rootDir>/testSequencerAsync.js',\n      }),\n    ],\n    {},\n  );\n  expect(result.exitCode).toBe(0);\n  const sequence = extractSummary(result.stderr)\n    .rest.replaceAll('PASS ', '')\n    .split('\\n');\n  expect(sequence).toEqual([\n    './a.test.js',\n    './b.test.js',\n    './c.test.js',\n    './d.test.js',\n    './e.test.js',\n  ]);\n});\n\ntest('run failed tests async', () => {\n  const result = runJest(\n    dir,\n    [\n      '--onlyFailures',\n      '-i',\n      '--config',\n      JSON.stringify({\n        testSequencer: '<rootDir>/testSequencerAsync.js',\n      }),\n    ],\n    {},\n  );\n  expect(result.exitCode).toBe(0);\n  const sequence = extractSummary(result.stderr)\n    .rest.replaceAll('PASS ', '')\n    .split('\\n');\n  expect(sequence).toEqual(['./c.test.js', './d.test.js']);\n});\n\ntest('run tests based on even seed', () => {\n  const result = runJest(\n    dir,\n    [\n      '-i',\n      '--config',\n      JSON.stringify({\n        testSequencer: '<rootDir>/testSequencerWithSeed.js',\n      }),\n      '--seed=2',\n    ],\n    {},\n  );\n  expect(result.exitCode).toBe(0);\n  const sequence = extractSummary(result.stderr)\n    .rest.replaceAll('PASS ', '')\n    .split('\\n');\n  expect(sequence).toEqual([\n    './a.test.js',\n    './b.test.js',\n    './c.test.js',\n    './d.test.js',\n    './e.test.js',\n  ]);\n});\n\ntest('run tests based on odd seed', () => {\n  const result = runJest(\n    dir,\n    [\n      '-i',\n      '--config',\n      JSON.stringify({\n        testSequencer: '<rootDir>/testSequencerWithSeed.js',\n      }),\n      '--seed=1',\n    ],\n    {},\n  );\n  expect(result.exitCode).toBe(0);\n  const sequence = extractSummary(result.stderr)\n    .rest.replaceAll('PASS ', '')\n    .split('\\n');\n  expect(sequence).toEqual([\n    './e.test.js',\n    './d.test.js',\n    './c.test.js',\n    './b.test.js',\n    './a.test.js',\n  ]);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ntest('d', () => {});"}
{"prompt":"jest --debug,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport runJest from '../runJest';\n\ndescribe('jest --debug', () => {\n  const dir = path.resolve(__dirname, '..', 'verbose-reporter');\n\n  it('outputs debugging info before running the test', () => {\n    const {stdout} = runJest(dir, ['--debug', '--no-cache']);\n    expect(stdout).toMatch('\"version\": \"');\n    expect(stdout).toMatch('\"configs\": [');\n    // config contains many file paths so we cannot do snapshot test\n  });\n});"}
{"prompt":"circus-jasmine normalization","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nconst extractMessage = (str: string) =>\n  extractSummary(str)\n    .rest.replaceAll(\n      // circus-jasmine normalization\n      /.+addSpecsToSuite (.+:\\d+:\\d+).+\\n/g,\n      '',\n    )\n    .match(\n      // all lines from the first to the last mentioned \"describe\" after the \"●\" line\n      /●(.|\\n)*?\\n(?<lines>.*describe((.|\\n)*describe)*.*)(\\n|$)/imu,\n    )?.groups?.lines ?? '';\n\nit('errors if describe returns a Promise', () => {\n  const result = runJest('declaration-errors', [\n    'describeReturnPromise.test.js',\n  ]);\n\n  expect(result.exitCode).toBe(1);\n  expect(extractMessage(result.stderr)).toMatchSnapshot();\n});\n\nit('errors if describe returns something', () => {\n  const result = runJest('declaration-errors', [\n    'describeReturnSomething.test.js',\n  ]);\n\n  expect(result.exitCode).toBe(1);\n  expect(extractMessage(result.stderr)).toMatchSnapshot();\n});\n\nit('errors if describe throws', () => {\n  const result = runJest('declaration-errors', ['describeThrow.test.js']);\n\n  expect(result.exitCode).toBe(1);\n  expect(result.stderr).toContain('whoops');\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`errors if describe returns a Promise 1`] = `\n\"    Returning a Promise from \"describe\" is not supported. Tests must be defined synchronously.\n\n       9 | 'use strict';\n      10 |\n    > 11 | describe('Promise describe errors', () => {\n         | ^\n      12 |   it('t', () => {});\n      13 |   return Promise.resolve();\n      14 | });\n\n      at Object.describe (__tests__/describeReturnPromise.test.js:11:1)\"\n`;\n\nexports[`errors if describe returns something 1`] = `\n\"    A \"describe\" callback must not return a value.\n\n       9 | 'use strict';\n      10 |\n    > 11 | describe('describe return errors', () => {\n         | ^\n      12 |   it('t', () => {});\n      13 |   return 42;\n      14 | });\n\n      at Object.describe (__tests__/describeReturnSomething.test.js:11:1)\"\n`;"}
{"prompt":"dedentLines non-null,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {plugins as builtinPlugins, format} from 'pretty-format';\nimport {dedentLines} from '../dedentLines';\n\nconst $$typeof = Symbol.for('react.test.json');\nconst plugins = [builtinPlugins.ReactTestComponent];\n\nconst formatLines2 = (val: unknown) =>\n  format(val, {indent: 2, plugins}).split('\\n');\nconst formatLines0 = (val: unknown) =>\n  format(val, {indent: 0, plugins}).split('\\n');\n\ndescribe('dedentLines non-null', () => {\n  test('no lines', () => {\n    const indented: Array<string> = [];\n    const dedented = indented;\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n\n  test('one line empty string', () => {\n    const indented = [''];\n    const dedented = indented;\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n\n  test('one line empty object', () => {\n    const val = {};\n    const indented = formatLines2(val);\n    const dedented = formatLines0(val);\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n\n  test('one line self-closing element', () => {\n    const val = {\n      $$typeof,\n      children: null,\n      type: 'br',\n    };\n    const indented = formatLines2(val);\n    const dedented = formatLines0(val);\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n\n  test('object value empty string', () => {\n    const val = {\n      key: '',\n    };\n    const indented = formatLines2(val);\n    const dedented = formatLines0(val);\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n\n  test('object value string includes double-quote marks', () => {\n    const val = {\n      key: '\"Always bet on JavaScript\",',\n    };\n    const indented = formatLines2(val);\n    const dedented = formatLines0(val);\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n\n  test('markup with props and text', () => {\n    const val = {\n      $$typeof,\n      children: [\n        {\n          $$typeof,\n          props: {\n            alt: 'Jest logo',\n            src: 'jest.svg',\n          },\n          type: 'img',\n        },\n        {\n          $$typeof,\n          children: ['Delightful JavaScript testing'],\n          type: 'h2',\n        },\n      ],\n      type: 'header',\n    };\n    const indented = formatLines2(val);\n    const dedented = formatLines0(val);\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n\n  test('markup with components as props', () => {\n    // https://daveceddia.com/pluggable-slots-in-react-components/\n    const val = {\n      $$typeof,\n      children: null,\n      props: {\n        content: {\n          $$typeof,\n          children: ['main content here'],\n          type: 'Content',\n        },\n        sidebar: {\n          $$typeof,\n          children: null,\n          props: {\n            user: '0123456789abcdef',\n          },\n          type: 'UserStats',\n        },\n      },\n      type: 'Body',\n    };\n    const indented = formatLines2(val);\n    const dedented = formatLines0(val);\n\n    expect(dedentLines(indented)).toEqual(dedented);\n  });\n});\n\ndescribe('dedentLines null', () => {\n  test.each([\n    ['object key multi-line', {'multi\\nline\\nkey': false}],\n    ['object value multi-line', {key: 'multi\\nline\\nvalue'}],\n    ['object key and value multi-line', {'multi\\nline': '\\nleading nl'}],\n  ])('%s', (_name, val) => {\n    expect(dedentLines(formatLines2(val))).toBeNull();\n  });\n\n  test('markup prop multi-line', () => {\n    const val = {\n      $$typeof,\n      children: null,\n      props: {\n        alt: 'trailing newline\\n',\n        src: 'jest.svg',\n      },\n      type: 'img',\n    };\n    const indented = formatLines2(val);\n\n    expect(dedentLines(indented)).toBeNull();\n  });\n\n  test('markup prop component with multi-line text', () => {\n    // https://daveceddia.com/pluggable-slots-in-react-components/\n    const val = {\n      $$typeof,\n      children: [\n        {\n          $$typeof,\n          children: null,\n          props: {\n            content: {\n              $$typeof,\n              children: ['\\n'],\n              type: 'Content',\n            },\n            sidebar: {\n              $$typeof,\n              children: null,\n              props: {\n                user: '0123456789abcdef',\n              },\n              type: 'UserStats',\n            },\n          },\n          type: 'Body',\n        },\n      ],\n      type: 'main',\n    };\n    const indented = formatLines2(val);\n\n    expect(dedentLines(indented)).toBeNull();\n  });\n\n  test('markup text multi-line', () => {\n    const text = [\n      'for (key in foo) {',\n      '  if (Object.prototype.hasOwnProperty.call(foo, key)) {',\n      '    doSomething(key);',\n      '  }',\n      '}',\n    ].join('\\n');\n    const val = {\n      $$typeof,\n      children: [\n        {\n          $$typeof,\n          children: [text],\n          props: {\n            className: 'language-js',\n          },\n          type: 'pre',\n        },\n      ],\n      type: 'div',\n    };\n    const indented = formatLines2(val);\n\n    expect(dedentLines(indented)).toBeNull();\n  });\n\n  test('markup text multiple lines', () => {\n    const lines = [\n      'for (key in foo) {',\n      '  if (Object.prototype.hasOwnProperty.call(foo, key)) {',\n      '    doSomething(key);',\n      '  }',\n      '}',\n    ];\n    const val = {\n      $$typeof,\n      children: [\n        {\n          $$typeof,\n          children: lines,\n          props: {\n            className: 'language-js',\n          },\n          type: 'pre',\n        },\n      ],\n      type: 'div',\n    };\n    const indented = formatLines2(val);\n\n    expect(dedentLines(indented)).toBeNull();\n  });\n\n  test('markup unclosed self-closing start tag', () => {\n    const indented = ['<img', '  alt=\"Jest logo\"', '  src=\"jest.svg\"'];\n\n    expect(dedentLines(indented)).toBeNull();\n  });\n\n  test('markup unclosed because no end tag', () => {\n    const indented = ['<p>', '  Delightful JavaScript testing'];\n\n    expect(dedentLines(indented)).toBeNull();\n  });\n});"}
{"prompt":"returns the same value for primitive or function values,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport deepCyclicCopy from '../deepCyclicCopy';\n\nit('returns the same value for primitive or function values', () => {\n  const fn = () => {};\n\n  expect(deepCyclicCopy(undefined)).toBeUndefined();\n  expect(deepCyclicCopy(null)).toBeNull();\n  expect(deepCyclicCopy(true)).toBe(true);\n  expect(deepCyclicCopy(42)).toBe(42);\n  expect(Number.isNaN(deepCyclicCopy(Number.NaN))).toBe(true);\n  expect(deepCyclicCopy('foo')).toBe('foo');\n  expect(deepCyclicCopy(fn)).toBe(fn);\n});\n\nit('does not execute getters/setters, but copies them', () => {\n  const fn = jest.fn();\n  const obj = {\n    get foo() {\n      fn();\n      return;\n    },\n  };\n  const copy = deepCyclicCopy(obj);\n\n  expect(Object.getOwnPropertyDescriptor(copy, 'foo')).toBeDefined();\n  expect(fn).not.toHaveBeenCalled();\n});\n\nit('copies symbols', () => {\n  const symbol = Symbol('foo');\n  const obj = {[symbol]: 42};\n\n  expect(deepCyclicCopy(obj)[symbol]).toBe(42);\n});\n\nit('copies arrays as array objects', () => {\n  const array = [null, 42, 'foo', 'bar', [], {}];\n\n  expect(deepCyclicCopy(array)).toEqual(array);\n  expect(Array.isArray(deepCyclicCopy(array))).toBe(true);\n});\n\nit('handles cyclic dependencies', () => {\n  type Cyclic = {[key: string]: unknown | Cyclic} & {subcycle?: Cyclic};\n\n  const cyclic: Cyclic = {a: 42};\n\n  cyclic.subcycle = {};\n  cyclic.subcycle.baz = cyclic;\n  cyclic.bar = cyclic;\n\n  expect(() => deepCyclicCopy(cyclic)).not.toThrow();\n\n  const copy = deepCyclicCopy(cyclic);\n\n  expect(copy.a).toBe(42);\n  expect(copy.bar).toEqual(copy);\n  expect(copy.subcycle?.baz).toEqual(copy);\n});\n\nit('uses the blacklist to avoid copying properties on the first level', () => {\n  const obj = {\n    blacklisted: 41,\n    blacklisted2: 42,\n    subObj: {\n      blacklisted: 43,\n    },\n  };\n\n  expect(\n    deepCyclicCopy(obj, {\n      blacklist: new Set(['blacklisted', 'blacklisted2']),\n    }),\n  ).toEqual({\n    subObj: {\n      blacklisted: 43,\n    },\n  });\n});\n\nit('does not keep the prototype by default when top level is object', () => {\n  // @ts-expect-error: Testing purpose\n  const sourceObject = new (function () {})();\n  // @ts-expect-error: Testing purpose\n  sourceObject.nestedObject = new (function () {})();\n  // @ts-expect-error: Testing purpose\n  sourceObject.nestedArray = new (function () {\n    // @ts-expect-error: Testing purpose\n    this.length = 0;\n  })();\n\n  const spyArray = jest\n    .spyOn(Array, 'isArray')\n    .mockImplementation(object => object === sourceObject.nestedArray);\n\n  const copy = deepCyclicCopy(sourceObject, {keepPrototype: false});\n\n  expect(Object.getPrototypeOf(copy)).not.toBe(\n    Object.getPrototypeOf(sourceObject),\n  );\n  expect(Object.getPrototypeOf(copy.nestedObject)).not.toBe(\n    Object.getPrototypeOf(sourceObject.nestedObject),\n  );\n  expect(Object.getPrototypeOf(copy.nestedArray)).not.toBe(\n    Object.getPrototypeOf(sourceObject.nestedArray),\n  );\n\n  expect(Object.getPrototypeOf(copy)).toBe(Object.getPrototypeOf({}));\n  expect(Object.getPrototypeOf(copy.nestedObject)).toBe(\n    Object.getPrototypeOf({}),\n  );\n  expect(Object.getPrototypeOf(copy.nestedArray)).toBe(\n    Object.getPrototypeOf([]),\n  );\n\n  spyArray.mockRestore();\n});\n\nit('does not keep the prototype by default when top level is array', () => {\n  const spyArray = jest.spyOn(Array, 'isArray').mockImplementation(() => true);\n\n  // @ts-expect-error: Testing purpose\n  const sourceArray = new (function () {\n    // @ts-expect-error: Testing purpose\n    this.length = 0;\n  })();\n\n  const copy = deepCyclicCopy(sourceArray);\n  expect(Object.getPrototypeOf(copy)).not.toBe(\n    Object.getPrototypeOf(sourceArray),\n  );\n\n  expect(Object.getPrototypeOf(copy)).toBe(Object.getPrototypeOf([]));\n  spyArray.mockRestore();\n});\n\nit('does not keep the prototype of arrays when keepPrototype = false', () => {\n  const spyArray = jest.spyOn(Array, 'isArray').mockImplementation(() => true);\n\n  // @ts-expect-error: Testing purpose\n  const sourceArray = new (function () {\n    // @ts-expect-error: Testing purpose\n    this.length = 0;\n  })();\n\n  const copy = deepCyclicCopy(sourceArray, {keepPrototype: false});\n  expect(Object.getPrototypeOf(copy)).not.toBe(\n    Object.getPrototypeOf(sourceArray),\n  );\n\n  expect(Object.getPrototypeOf(copy)).toBe(Object.getPrototypeOf([]));\n  spyArray.mockRestore();\n});\n\nit('keeps the prototype of arrays when keepPrototype = true', () => {\n  const spyArray = jest.spyOn(Array, 'isArray').mockImplementation(() => true);\n\n  // @ts-expect-error: Testing purpose\n  const sourceArray = new (function () {\n    // @ts-expect-error: Testing purpose\n    this.length = 0;\n  })();\n\n  const copy = deepCyclicCopy(sourceArray, {keepPrototype: true});\n  expect(Object.getPrototypeOf(copy)).toBe(Object.getPrototypeOf(sourceArray));\n\n  spyArray.mockRestore();\n});\n\nit('does not keep the prototype for objects when keepPrototype = false', () => {\n  // @ts-expect-error: Testing purpose\n  const sourceObject = new (function () {})();\n  // @ts-expect-error\n  sourceObject.nestedObject = new (function () {})();\n  // @ts-expect-error: Testing purpose\n  sourceObject.nestedArray = new (function () {\n    // @ts-expect-error: Testing purpose\n    this.length = 0;\n  })();\n\n  const spyArray = jest\n    .spyOn(Array, 'isArray')\n    .mockImplementation(object => object === sourceObject.nestedArray);\n\n  const copy = deepCyclicCopy(sourceObject, {keepPrototype: false});\n\n  expect(Object.getPrototypeOf(copy)).not.toBe(\n    Object.getPrototypeOf(sourceObject),\n  );\n  expect(Object.getPrototypeOf(copy.nestedObject)).not.toBe(\n    Object.getPrototypeOf(sourceObject.nestedObject),\n  );\n  expect(Object.getPrototypeOf(copy.nestedArray)).not.toBe(\n    Object.getPrototypeOf(sourceObject.nestedArray),\n  );\n  expect(Object.getPrototypeOf(copy)).toBe(Object.getPrototypeOf({}));\n  expect(Object.getPrototypeOf(copy.nestedObject)).toBe(\n    Object.getPrototypeOf({}),\n  );\n  expect(Object.getPrototypeOf(copy.nestedArray)).toBe(\n    Object.getPrototypeOf([]),\n  );\n\n  spyArray.mockRestore();\n});\n\nit('keeps the prototype for objects when keepPrototype = true', () => {\n  // @ts-expect-error: Testing purpose\n  const sourceObject = new (function () {})();\n  // @ts-expect-error: Testing purpose\n  sourceObject.nestedObject = new (function () {})();\n  // @ts-expect-error: Testing purpose\n  sourceObject.nestedArray = new (function () {\n    // @ts-expect-error: Testing purpose\n    this.length = 0;\n  })();\n\n  const spyArray = jest\n    .spyOn(Array, 'isArray')\n    .mockImplementation(object => object === sourceObject.nestedArray);\n\n  const copy = deepCyclicCopy(sourceObject, {keepPrototype: true});\n\n  expect(Object.getPrototypeOf(copy)).toBe(Object.getPrototypeOf(sourceObject));\n  expect(Object.getPrototypeOf(copy.nestedObject)).toBe(\n    Object.getPrototypeOf(sourceObject.nestedObject),\n  );\n  expect(Object.getPrototypeOf(copy.nestedArray)).toBe(\n    Object.getPrototypeOf(sourceObject.nestedArray),\n  );\n  spyArray.mockRestore();\n});"}
{"prompt":"@ts-expect-error: Testing purpose","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport deepCyclicCopyReplaceable, {\n  SERIALIZABLE_PROPERTIES,\n} from '../deepCyclicCopyReplaceable';\n\ntest('returns the same value for primitive or function values', () => {\n  const fn = () => {};\n\n  expect(deepCyclicCopyReplaceable(undefined)).toBeUndefined();\n  expect(deepCyclicCopyReplaceable(null)).toBeNull();\n  expect(deepCyclicCopyReplaceable(true)).toBe(true);\n  expect(deepCyclicCopyReplaceable(42)).toBe(42);\n  expect(Number.isNaN(deepCyclicCopyReplaceable(Number.NaN))).toBe(true);\n  expect(deepCyclicCopyReplaceable('foo')).toBe('foo');\n  expect(deepCyclicCopyReplaceable(fn)).toBe(fn);\n});\n\ntest('convert accessor descriptor into value descriptor', () => {\n  const obj = {\n    set foo(_) {},\n    get foo() {\n      return 'bar';\n    },\n  };\n  expect(Object.getOwnPropertyDescriptor(obj, 'foo')).toEqual({\n    configurable: true,\n    enumerable: true,\n    get: expect.any(Function),\n    set: expect.any(Function),\n  });\n  const copy = deepCyclicCopyReplaceable(obj);\n\n  expect(Object.getOwnPropertyDescriptor(copy, 'foo')).toEqual({\n    configurable: true,\n    enumerable: true,\n    value: 'bar',\n    writable: true,\n  });\n});\n\ntest('should not skip non-enumerables', () => {\n  const obj = {};\n  Object.defineProperty(obj, 'foo', {enumerable: false, value: 'bar'});\n\n  const copy = deepCyclicCopyReplaceable(obj);\n\n  expect(Object.getOwnPropertyDescriptors(copy)).toEqual({\n    foo: {\n      configurable: true,\n      enumerable: false,\n      value: 'bar',\n      writable: true,\n    },\n  });\n});\n\ntest('copies symbols', () => {\n  const symbol = Symbol('foo');\n  const obj = {[symbol]: 42};\n\n  expect(deepCyclicCopyReplaceable(obj)[symbol]).toBe(42);\n});\n\ntest('copies value of inherited getters', () => {\n  class Foo {\n    #foo = 42;\n    get foo() {\n      return this.#foo;\n    }\n  }\n  const obj = new Foo();\n\n  expect(deepCyclicCopyReplaceable(obj).foo).toBe(42);\n});\n\ntest('copies arrays as array objects', () => {\n  const array = [null, 42, 'foo', 'bar', [], {}];\n\n  expect(deepCyclicCopyReplaceable(array)).toEqual(array);\n  expect(Array.isArray(deepCyclicCopyReplaceable(array))).toBe(true);\n});\n\ntest('handles cyclic dependencies', () => {\n  const cyclic: any = {a: 42, subcycle: {}};\n\n  cyclic.subcycle.baz = cyclic;\n  cyclic.bar = cyclic;\n\n  expect(() => deepCyclicCopyReplaceable(cyclic)).not.toThrow();\n\n  const copy = deepCyclicCopyReplaceable(cyclic);\n\n  expect(copy.a).toBe(42);\n  expect(copy.bar).toEqual(copy);\n  expect(copy.subcycle.baz).toEqual(copy);\n});\n\ntest('Copy Map', () => {\n  const map = new Map([\n    ['a', 1],\n    ['b', 2],\n  ]);\n  const copy = deepCyclicCopyReplaceable(map);\n  expect(copy).toEqual(map);\n  expect(copy.constructor).toBe(Map);\n});\n\ntest('Copy cyclic Map', () => {\n  const map = new Map<string, unknown>([\n    ['a', 1],\n    ['b', 2],\n  ]);\n  map.set('map', map);\n  expect(deepCyclicCopyReplaceable(map)).toEqual(map);\n});\n\ntest('return same value for built-in object type except array, map and object', () => {\n  const date = new Date();\n  const buffer = Buffer.from('jest');\n  const numberArray = new Uint8Array([1, 2, 3]);\n  const regexp = /jest/;\n  const set = new Set(['foo', 'bar']);\n\n  expect(deepCyclicCopyReplaceable(date)).toBe(date);\n  expect(deepCyclicCopyReplaceable(buffer)).toBe(buffer);\n  expect(deepCyclicCopyReplaceable(numberArray)).toBe(numberArray);\n  expect(deepCyclicCopyReplaceable(regexp)).toBe(regexp);\n  expect(deepCyclicCopyReplaceable(set)).toBe(set);\n});\n\ntest('should copy object symbol key property', () => {\n  const symbolKey = Symbol.for('key');\n  expect(deepCyclicCopyReplaceable({[symbolKey]: 1})).toEqual({[symbolKey]: 1});\n});\n\ntest('should set writable, configurable to true', () => {\n  const a = {};\n  Object.defineProperty(a, 'key', {\n    configurable: false,\n    enumerable: true,\n    value: 1,\n    writable: false,\n  });\n  const copied = deepCyclicCopyReplaceable(a);\n  expect(Object.getOwnPropertyDescriptors(copied)).toEqual({\n    key: {configurable: true, enumerable: true, value: 1, writable: true},\n  });\n});\n\ntest('should only copy the properties mapped to be serializable', () => {\n  class Foo {\n    foo = 'foo';\n    bar = ['bar'];\n    get baz() {\n      throw new Error('should not call getter');\n    }\n  }\n\n  // @ts-expect-error: Testing purpose\n  Foo.prototype[SERIALIZABLE_PROPERTIES] = ['foo', 'bar'];\n\n  const obj = new Foo();\n\n  const copied = deepCyclicCopyReplaceable(obj);\n  expect(Object.getOwnPropertyDescriptors(copied)).toEqual({\n    bar: {configurable: true, enumerable: true, value: ['bar'], writable: true},\n    foo: {configurable: true, enumerable: true, value: 'foo', writable: true},\n  });\n});"}
{"prompt":"/ <reference lib=dom />","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n/// <reference lib=\"dom\" />\n\n/* global document */\n\nimport deepCyclicCopyReplaceable from '../deepCyclicCopyReplaceable';\n\ntest('should copy dom element', () => {\n  const div = document.createElement('div');\n  const copied = deepCyclicCopyReplaceable(div);\n  expect(copied).toEqual(div);\n  expect(div === copied).toBe(false); //assert reference is not the same\n});\n\ntest('should copy complex element', () => {\n  const div = document.createElement('div');\n  const span = document.createElement('span');\n  div.setAttribute('id', 'div');\n  div.textContent = 'this is div';\n  div.append(span);\n  const copied = deepCyclicCopyReplaceable(div);\n  expect(copied).toEqual(div);\n  expect(div === copied).toBe(false); //assert reference is not the same\n  expect(div.children[0] === copied.children[0]).toBe(false); //assert reference is not the same\n});"}
{"prompt":"This is not a CI environment, which removes all output by default.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport DefaultReporter from '../DefaultReporter';\n\njest.mock('jest-util', () => ({\n  ...jest.requireActual('jest-util'),\n  // This is not a CI environment, which removes all output by default.\n  isInteractive: true,\n}));\n\nconst aggregatedResults = {};\nconst options = {};\nconst testCase = {\n  context: {config: {rootDir: '/'}},\n  duration: 0,\n  path: '/foo',\n};\nconst testResult = {\n  snapshot: {\n    added: 0,\n    fileDeleted: true,\n    matched: 1,\n    unchecked: 0,\n    unmatched: 0,\n    updated: 0,\n  },\n  testFilePath: '/foo',\n  testResults: [],\n};\n\nlet stdout;\n\nlet oldIsTTY;\nlet oldStderr;\nlet oldStdout;\n\nbeforeEach(() => {\n  jest.useFakeTimers();\n\n  oldIsTTY = process.stdin.isTTY;\n  oldStdout = process.stdout.write;\n  oldStderr = process.stderr.write;\n\n  // We mock stderr (even if we do not use it right now on the tests) to avoid\n  // fake reporters created while testing to mess with the real output of the\n  // tests itself.\n  process.stdin.isTTY = true;\n  process.stderr.write = jest.fn();\n  stdout = process.stdout.write = jest.fn();\n});\n\nafterEach(() => {\n  process.stdin.isTTY = oldIsTTY;\n  process.stderr.write = oldStderr;\n  process.stdout.write = oldStdout;\n});\n\ntest('normal output, everything goes to stdout', () => {\n  const reporter = new DefaultReporter({rootDir: '', useStderr: false});\n\n  reporter.onRunStart(aggregatedResults, options);\n  reporter.onTestStart(testCase);\n  reporter.onTestResult(testCase, testResult, aggregatedResults);\n  reporter.onRunComplete();\n\n  jest.runAllTimers();\n\n  expect(stdout).toHaveBeenCalled();\n});\n\ntest('when using stderr as output, no stdout call is made', () => {\n  const reporter = new DefaultReporter({rootDir: '', useStderr: true});\n\n  reporter.onRunStart(aggregatedResults, options);\n  reporter.onTestStart(testCase);\n  reporter.onTestResult(testCase, testResult, aggregatedResults);\n  reporter.onRunComplete();\n\n  jest.runAllTimers();\n\n  expect(stdout).not.toHaveBeenCalled();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports = (request, opts) => {\n  return opts.defaultResolver(request, opts);\n};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {defaults} from '..';\n\ntest('get configuration defaults', () => {\n  expect(defaults).toBeDefined();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('Default Timeout Interval', () => {\n  jasmine.DEFAULT_TIMEOUT_INTERVAL = 1000;\n  expect(true).toBe(true);\n});"}
{"prompt":"doing test in a temp directory because we dont want jest node_modules affect","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, createEmptyPackage, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\n// doing test in a temp directory because we don't want jest node_modules affect it\nconst tempDir = path.resolve(tmpdir(), 'clashing-dependencies-test');\nconst hasteImplModulePath = path\n  .resolve('./packages/jest-haste-map/src/__tests__/haste_impl.js')\n  .replaceAll('\\\\', '\\\\\\\\');\n\nbeforeEach(() => {\n  cleanup(tempDir);\n  createEmptyPackage(tempDir, {});\n});\n\n// This test case is checking that when having both\n// `invariant` package from npm and `invariant.js` that provides `invariant`\n// module we can still require the right invariant. This is pretty specific\n// use case and in the future we should probably delete this test.\n// see: https://github.com/jestjs/jest/pull/6687\ntest('does not require project modules from inside node_modules', () => {\n  writeFiles(tempDir, {\n    '__tests__/test.js': `\n      const invariant = require('invariant');\n      test('haii', () => expect(invariant(false, 'haii')).toBe('haii'));\n    `,\n    'invariant.js': `\n      INVALID CODE FRAGMENT THAT WILL BE REMOVED BY THE TRANSFORMER\n      const invariant = (condition, message) => message;\n      module.exports = invariant;\n    `,\n    'jest.config.js': `module.exports = {\n      haste: {\n        hasteImplModulePath: '${hasteImplModulePath}',\n      },\n      transform: {'.*\\\\.js': './third-party/node_modules/transform'},\n    };`,\n    'third-party/node_modules/invariant/index.js': `\n      const invariant = (condition, message) => {\n        if (!condition) {\n          throw new Error(message);\n        }\n      };\n      module.exports = invariant;\n    `,\n    'third-party/node_modules/transform/index.js': `\n      const invariant = require('invariant');\n      module.exports = {\n        process: script => {\n          let threw = false;\n          try {\n            invariant(false, 'this should throw');\n          } catch (e) {\n            threw = true;\n          }\n          if (!threw) {\n            throw new Error('It used the wrong invariant module!');\n          }\n          return {\n            code: script.replace(\n              'INVALID CODE FRAGMENT THAT WILL BE REMOVED BY THE TRANSFORMER',\n              '',\n            ),\n          };\n        },\n      };\n    `,\n  });\n  const {stderr, exitCode} = runJest(tempDir, ['--no-cache', '--no-watchman']);\n  // make sure there are no errors that lead to invariant.js (if we were to\n  // require a wrong `invariant.js` we'd have a syntax error, because jest\n  // internals wouldn't be able to parse flow annotations)\n  expect(stderr).not.toMatch('invariant');\n  expect(stderr).toMatch('PASS');\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst blockCommentRe = /\\/\\*[^]*?\\*\\//g;\nconst lineCommentRe = /\\/\\/.*/g;\nconst LOAD_MODULE_RE =\n  /(?:^|[^.]\\s*)(\\bloadModule\\s*?\\(\\s*?)([\"'`])([^\"'`]+)(\\2\\s*?\\))/g;\n\nexport function extract(code, filePath, defaultDependencyExtractor) {\n  const dependencies = defaultDependencyExtractor(code);\n\n  const addDependency = (match, pre, quot, dep, post) => {\n    dependencies.add(dep);\n    return match;\n  };\n\n  code\n    .replaceAll(blockCommentRe, '')\n    .replaceAll(lineCommentRe, '')\n    .replaceAll(LOAD_MODULE_RE, addDependency);\n\n  return dependencies;\n}\n\nlet cacheKey;\n\nexport function getCacheKey() {\n  return cacheKey;\n}\n\nexport function setCacheKey(key) {\n  cacheKey = key;\n}"}
{"prompt":"dependencyExtractor,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractor} from '../dependencyExtractor';\n\ndescribe('dependencyExtractor', () => {\n  it('should not extract dependencies inside comments', () => {\n    const code = `\n      // import a from 'ignore-line-comment';\n      // import 'ignore-line-comment';\n      // import './ignore-line-comment';\n      // require('ignore-line-comment');\n      /*\n       * import a from 'ignore-block-comment';\n       * import './ignore-block-comment';\n       * import 'ignore-block-comment';\n       * require('ignore-block-comment');\n       */\n    `;\n    expect(extractor.extract(code)).toEqual(new Set());\n  });\n\n  it('should not extract dependencies inside comments (windows line endings)', () => {\n    const code = [\n      '// const module1 = require(\"module1\");',\n      '/**',\n      ' * const module2 = require(\"module2\");',\n      ' */',\n    ].join('\\r\\n');\n\n    expect(extractor.extract(code)).toEqual(new Set([]));\n  });\n\n  it('should not extract dependencies inside comments (unicode line endings)', () => {\n    const code = [\n      '// const module1 = require(\"module1\");\\u2028',\n      '// const module1 = require(\"module2\");\\u2029',\n      '/*\\u2028',\n      'const module2 = require(\"module3\");\\u2029',\n      ' */',\n    ].join('');\n\n    expect(extractor.extract(code)).toEqual(new Set([]));\n  });\n\n  it('should extract dependencies from `import` statements', () => {\n    const code = `\n      // Good\n      import * as depNS from 'dep1';\n      import {\n        a as aliased_a,\n        b,\n      } from 'dep2';\n      import depDefault from 'dep3';\n      import * as depNS, {\n        a as aliased_a,\n        b,\n      }, depDefault from 'dep4';\n\n      // Bad\n      foo . import ('inv1');\n      foo . export ('inv2');\n    `;\n    expect(extractor.extract(code)).toEqual(\n      new Set(['dep1', 'dep2', 'dep3', 'dep4']),\n    );\n  });\n\n  // https://github.com/jestjs/jest/issues/8547\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import#Import_a_module_for_its_side_effects_only\n  it('should extract dependencies from side-effect only `import` statements', () => {\n    const code = `\n        // Good\n        import './side-effect-dep1';\n        import 'side-effect-dep2';\n\n        // Bad\n        import ./inv1;\n        import inv2\n      `;\n    expect(extractor.extract(code)).toEqual(\n      new Set(['./side-effect-dep1', 'side-effect-dep2']),\n    );\n  });\n\n  it('should not extract dependencies from `import type/typeof` statements', () => {\n    const code = `\n      // Bad\n      import typeof {foo} from 'inv1';\n      import type {foo} from 'inv2';\n    `;\n    expect(extractor.extract(code)).toEqual(new Set([]));\n  });\n\n  it('should extract dependencies from `export` statements', () => {\n    const code = `\n      // Good\n      export * as depNS from 'dep1';\n      export {\n        a as aliased_a,\n        b,\n      } from 'dep2';\n      export depDefault from 'dep3';\n      export * as depNS, {\n        a as aliased_a,\n        b,\n      }, depDefault from 'dep4';\n\n      // Bad\n      foo . export ('inv1');\n      foo . export ('inv2');\n    `;\n    expect(extractor.extract(code)).toEqual(\n      new Set(['dep1', 'dep2', 'dep3', 'dep4']),\n    );\n  });\n\n  it('should extract dependencies from `export-from` statements', () => {\n    const code = `\n      // Good\n      export * as depNS from 'dep1';\n      export {\n        a as aliased_a,\n        b,\n      } from 'dep2';\n      export depDefault from 'dep3';\n      export * as depNS, {\n        a as aliased_a,\n        b,\n      }, depDefault from 'dep4';\n\n      // Bad\n      foo . export ('inv1');\n      foo . export ('inv2');\n    `;\n    expect(extractor.extract(code)).toEqual(\n      new Set(['dep1', 'dep2', 'dep3', 'dep4']),\n    );\n  });\n\n  it('should not extract dependencies from `export type/typeof` statements', () => {\n    const code = `\n      // Bad\n      export typeof {foo} from 'inv1';\n      export type {foo} from 'inv2';\n    `;\n    expect(extractor.extract(code)).toEqual(new Set([]));\n  });\n\n  it('should extract dependencies from dynamic `import` calls', () => {\n    const code = `\n      // Good\n      import('dep1').then();\n      const dep2 = await import(\n        \"dep2\",\n      );\n      if (await import(\\`dep3\\`)) {}\n\n      // Bad\n      await foo . import('inv1')\n      await ximport('inv2');\n      importx('inv3');\n      import('inv4', 'inv5');\n    `;\n    expect(extractor.extract(code)).toEqual(new Set(['dep1', 'dep2', 'dep3']));\n  });\n\n  it('should extract dependencies from `require` calls', () => {\n    const code = `\n      // Good\n      require('dep1');\n      const dep2 = require(\n        \"dep2\",\n      );\n      if (require(\\`dep3\\`).cond) {}\n\n      // Bad\n      foo . require('inv1')\n      xrequire('inv2');\n      requirex('inv3');\n      require('inv4', 'inv5');\n    `;\n    expect(extractor.extract(code)).toEqual(new Set(['dep1', 'dep2', 'dep3']));\n  });\n\n  it('should extract dependencies from `jest.requireActual` calls', () => {\n    const code = `\n      // Good\n      jest.requireActual('dep1');\n      const dep2 = jest.requireActual(\n        \"dep2\",\n      );\n      if (jest.requireActual(\\`dep3\\`).cond) {}\n      jest\n        .requireActual('dep4');\n\n      // Bad\n      foo . jest.requireActual('inv1')\n      xjest.requireActual('inv2');\n      jest.requireActualx('inv3');\n      jest.requireActual('inv4', 'inv5');\n    `;\n    expect(extractor.extract(code)).toEqual(\n      new Set(['dep1', 'dep2', 'dep3', 'dep4']),\n    );\n  });\n\n  it('should extract dependencies from `jest.requireMock` calls', () => {\n    const code = `\n      // Good\n      jest.requireMock('dep1');\n      const dep2 = jest.requireMock(\n        \"dep2\",\n      );\n      if (jest.requireMock(\\`dep3\\`).cond) {}\n      jest\n        .requireMock('dep4');\n\n      // Bad\n      foo . jest.requireMock('inv1')\n      xjest.requireMock('inv2');\n      jest.requireMockx('inv3');\n      jest.requireMock('inv4', 'inv5');\n    `;\n    expect(extractor.extract(code)).toEqual(\n      new Set(['dep1', 'dep2', 'dep3', 'dep4']),\n    );\n  });\n\n  it('should extract dependencies from `jest.createMockFromModule` calls', () => {\n    const code = `\n      // Good\n      jest.createMockFromModule('dep1');\n      const dep2 = jest.createMockFromModule(\n        \"dep2\",\n      );\n      if (jest.createMockFromModule(\\`dep3\\`).cond) {}\n      jest\n        .requireMock('dep4');\n\n      // Bad\n     foo . jest.createMockFromModule('inv1')\n      xjest.createMockFromModule('inv2');\n      jest.createMockFromModulex('inv3');\n      jest.createMockFromModule('inv4', 'inv5');\n    `;\n    expect(extractor.extract(code)).toEqual(\n      new Set(['dep1', 'dep2', 'dep3', 'dep4']),\n    );\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {makeProjectConfig} from '@jest/test-utils';\nimport type {Config} from '@jest/types';\nimport type Resolver from 'jest-resolve';\nimport {buildSnapshotResolver} from 'jest-snapshot';\nimport {DependencyResolver} from '../index';\n\nconst maxWorkers = 1;\nlet dependencyResolver: DependencyResolver;\nlet runtimeContextResolver: Resolver;\nlet config: Config.ProjectConfig;\nconst cases: Record<string, (path: string) => boolean> = {\n  fancyCondition: path => path.length > 10,\n  testRegex: path => /.test.js$/.test(path),\n};\nconst filter = (path: string) =>\n  Object.keys(cases).every(key => cases[key](path));\n\nbeforeEach(async () => {\n  const Runtime = (require('jest-runtime') as typeof import('jest-runtime'))\n    .default;\n  config = makeProjectConfig({\n    cacheDirectory: path.resolve(tmpdir(), 'jest-resolve-dependencies-test'),\n    moduleDirectories: ['node_modules'],\n    moduleNameMapper: [['^\\\\$asdf/(.*)$', '<rootDir>/$1']],\n    rootDir: '.',\n    roots: ['./packages/jest-resolve-dependencies'],\n  });\n  const runtimeContext = await Runtime.createContext(config, {\n    maxWorkers,\n    watchman: false,\n  });\n\n  runtimeContextResolver = runtimeContext.resolver;\n  dependencyResolver = new DependencyResolver(\n    runtimeContext.resolver,\n    runtimeContext.hasteFS,\n    await buildSnapshotResolver(config),\n  );\n});\n\ntest('resolves no dependencies for non-existent path', () => {\n  const resolved = dependencyResolver.resolve('/non/existent/path');\n  expect(resolved).toHaveLength(0);\n});\n\ntest('resolves dependencies for existing path', () => {\n  const resolved = dependencyResolver.resolve(\n    path.resolve(__dirname, '__fixtures__', 'file.js'),\n  );\n  expect(resolved).toEqual([\n    expect.stringContaining('jest-resolve-dependencies'),\n    expect.stringContaining('jest-regex-util'),\n  ]);\n});\n\ntest('includes the mocks of dependencies as dependencies', () => {\n  const resolved = dependencyResolver.resolve(\n    path.resolve(__dirname, '__fixtures__/hasMocked/file.test.js'),\n  );\n\n  expect(resolved).toEqual([\n    expect.stringContaining(path.join('hasMocked', 'file.js')),\n    expect.stringContaining(path.join('hasMocked', '__mocks__', 'file.js')),\n    expect.stringContaining(path.join('__mocks__', 'fake-node-module.js')),\n  ]);\n});\n\ntest('resolves dependencies for scoped packages', () => {\n  const resolved = dependencyResolver.resolve(\n    path.resolve(__dirname, '__fixtures__', 'scoped.js'),\n  );\n  expect(resolved).toEqual([\n    expect.stringContaining(path.join('@myorg', 'pkg')),\n  ]);\n});\n\ntest('resolves no inverse dependencies for empty paths set', () => {\n  const paths = new Set<string>();\n  const resolved = dependencyResolver.resolveInverse(paths, filter);\n  expect(resolved).toHaveLength(0);\n});\n\ntest('resolves no inverse dependencies for set of non-existent paths', () => {\n  const paths = new Set(['/non/existent/path', '/another/one']);\n  const resolved = dependencyResolver.resolveInverse(paths, filter);\n  expect(resolved).toHaveLength(0);\n});\n\ntest('resolves inverse dependencies for existing path', () => {\n  const paths = new Set([path.resolve(__dirname, '__fixtures__/file.js')]);\n  const resolved = dependencyResolver.resolveInverse(paths, filter);\n  expect(resolved).toEqual([\n    expect.stringContaining(\n      path.join('__tests__', '__fixtures__', 'file.test.js'),\n    ),\n  ]);\n});\n\ntest('resolves inverse dependencies of mock', () => {\n  const paths = new Set([\n    path.resolve(__dirname, '__fixtures__/hasMocked/__mocks__/file.js'),\n  ]);\n  const resolved = dependencyResolver.resolveInverse(paths, filter);\n\n  expect(resolved).toEqual([\n    expect.stringContaining(\n      path.join('__tests__/__fixtures__/hasMocked/file.test.js'),\n    ),\n  ]);\n});\n\ntest('resolves inverse dependencies from available snapshot', () => {\n  const paths = new Set([\n    path.resolve(__dirname, '__fixtures__/file.js'),\n    path.resolve(__dirname, '__fixtures__/__snapshots__/related.test.js.snap'),\n  ]);\n  const resolved = dependencyResolver.resolveInverse(paths, filter);\n  expect(resolved).toEqual(\n    expect.arrayContaining([\n      expect.stringContaining(\n        path.join('__tests__', '__fixtures__', 'file.test.js'),\n      ),\n      expect.stringContaining(\n        path.join('__tests__', '__fixtures__', 'related.test.js'),\n      ),\n    ]),\n  );\n});\n\ntest('resolves dependencies correctly when dependency resolution fails', () => {\n  jest.spyOn(runtimeContextResolver, 'resolveModule').mockImplementation(() => {\n    throw new Error('resolveModule has failed');\n  });\n  jest.spyOn(runtimeContextResolver, 'getMockModule').mockImplementation(() => {\n    throw new Error('getMockModule has failed');\n  });\n\n  const resolved = dependencyResolver.resolve(\n    path.resolve(__dirname, '__fixtures__', 'file.test.js'),\n  );\n\n  expect(resolved).toEqual([]);\n});\n\ntest('resolves dependencies correctly when mock dependency resolution fails', () => {\n  jest.spyOn(runtimeContextResolver, 'getMockModule').mockImplementation(() => {\n    throw new Error('getMockModule has failed');\n  });\n\n  const resolved = dependencyResolver.resolve(\n    path.resolve(__dirname, '__fixtures__', 'file.test.js'),\n  );\n\n  expect(resolved).toEqual([\n    expect.stringContaining(path.join('__tests__', '__fixtures__', 'file.js')),\n  ]);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst mappedTest = require('testMapped/moduleInMapped');\n\nexports.result = mappedTest;"}
{"prompt":".only.each[","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable jest/no-focused-tests */\n\ndescribe.only.each([\n  [true, true],\n  [true, true],\n])('passes all rows expected %s == %s', (left, right) => {\n  it('passes', () => {\n    expect(left).toBe(right);\n  });\n});\n\n// This failing tests should never because of the above `only` so the suite\n// should pass\ndescribe.each([[false, true]])(\n  'fails all rows expected %s == %s',\n  (left, right) => {\n    it('fails', () => {\n      expect(left).toBe(right);\n    });\n  },\n);"}
{"prompt":"Promise describe errors,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\ndescribe('Promise describe errors', () => {\n  it('t', () => {});\n  return Promise.resolve();\n});"}
{"prompt":"describe return errors,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\ndescribe('describe return errors', () => {\n  it('t', () => {});\n  return 42;\n});"}
{"prompt":"describe throw does not warn,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\ndescribe('describe throw does not warn', () => {\n  it('t', () => {});\n  throw new Error('whoops');\n});"}
{"prompt":"prints message about flag on slow tests, async  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {onNodeVersions} from '@jest/test-utils';\nimport runJest, {runContinuous} from '../runJest';\n\nfunction getTextAfterTest(stderr: string) {\n  return (stderr.split(/Ran all test suites(.*)\\n/)[2] || '').trim();\n}\n\nbeforeAll(() => {\n  jest.retryTimes(3);\n});\n\nit('prints message about flag on slow tests', async () => {\n  const run = runContinuous('detect-open-handles', ['outside']);\n  await run.waitUntil(({stderr}) =>\n    stderr.includes(\n      'Jest did not exit one second after the test run has completed.',\n    ),\n  );\n  const {stderr} = await run.end();\n  const textAfterTest = getTextAfterTest(stderr);\n\n  expect(textAfterTest).toMatchSnapshot();\n});\n\nit('prints message about flag on slow tests with a custom timeout', async () => {\n  const run = runContinuous('detect-open-handles', [\n    'outside',\n    '--openHandlesTimeout=500',\n  ]);\n  await run.waitUntil(({stderr}) =>\n    stderr.includes('Jest did not exit 0.5 seconds'),\n  );\n  const {stderr} = await run.end();\n  const textAfterTest = getTextAfterTest(stderr);\n\n  expect(textAfterTest).toMatchSnapshot();\n});\n\nit('prints message about flag on forceExit', async () => {\n  const run = runContinuous('detect-open-handles', ['outside', '--forceExit']);\n  await run.waitUntil(({stderr}) => stderr.includes('Force exiting Jest'));\n  const {stderr} = await run.end();\n  const textAfterTest = getTextAfterTest(stderr);\n\n  expect(textAfterTest).toMatchSnapshot();\n});\n\nit('prints out info about open handlers', async () => {\n  const run = runContinuous('detect-open-handles', [\n    'outside',\n    '--detectOpenHandles',\n  ]);\n  await run.waitUntil(({stderr}) => stderr.includes('Jest has detected'));\n  const {stderr} = await run.end();\n  const textAfterTest = getTextAfterTest(stderr);\n\n  expect(textAfterTest).toMatchSnapshot();\n});\n\nit('does not report promises', () => {\n  // The test here is basically that it exits cleanly without reporting anything (does not need `until`)\n  const {stderr} = runJest('detect-open-handles', [\n    'promise',\n    '--detectOpenHandles',\n  ]);\n  const textAfterTest = getTextAfterTest(stderr);\n\n  expect(textAfterTest).toBe('');\n});\n\nit('does not report crypto random data', () => {\n  // The test here is basically that it exits cleanly without reporting anything (does not need `until`)\n  const {stderr} = runJest('detect-open-handles', [\n    'crypto',\n    '--detectOpenHandles',\n  ]);\n  const textAfterTest = getTextAfterTest(stderr);\n\n  expect(textAfterTest).toBe('');\n});\n\nit('does not report ELD histograms', () => {\n  const {stderr} = runJest('detect-open-handles', [\n    'histogram',\n    '--detectOpenHandles',\n  ]);\n  const textAfterTest = getTextAfterTest(stderr);\n\n  expect(textAfterTest).toBe('');\n});\n\ndescribe('notify', () => {\n  it('does not report --notify flag', () => {\n    if (process.platform === 'win32') {\n      console.warn('[SKIP] Does not work on Windows');\n\n      return;\n    }\n\n    // The test here is basically that it exits cleanly without reporting anything (does not need `until`)\n    const {stderr} = runJest('detect-open-handles', ['notify', '--notify']);\n    const textAfterTest = getTextAfterTest(stderr);\n\n    expect(textAfterTest).toBe('');\n  });\n});\n\nit('does not report timeouts using unref', () => {\n  // The test here is basically that it exits cleanly without reporting anything (does not need `until`)\n  const {stderr} = runJest('detect-open-handles', [\n    'unref',\n    '--detectOpenHandles',\n  ]);\n  const textAfterTest = getTextAfterTest(stderr);\n\n  expect(textAfterTest).toBe('');\n});\n\nit('does not report child_process using unref', () => {\n  // The test here is basically that it exits cleanly without reporting anything (does not need `until`)\n  const {stderr} = runJest('detect-open-handles', [\n    'child_process',\n    '--detectOpenHandles',\n  ]);\n  const textAfterTest = getTextAfterTest(stderr);\n\n  expect(textAfterTest).toBe('');\n});\n\nonNodeVersions('>=18.1.0', () => {\n  it('does not report worker using unref', () => {\n    // The test here is basically that it exits cleanly without reporting anything (does not need `until`)\n    const {stderr} = runJest('detect-open-handles', [\n      'worker',\n      '--detectOpenHandles',\n    ]);\n    const textAfterTest = getTextAfterTest(stderr);\n\n    expect(textAfterTest).toBe('');\n  });\n});\n\nit('prints out info about open handlers from inside tests', async () => {\n  const run = runContinuous('detect-open-handles', [\n    'inside',\n    '--detectOpenHandles',\n  ]);\n  await run.waitUntil(({stderr}) => stderr.includes('Jest has detected'));\n  const {stderr} = await run.end();\n  const textAfterTest = getTextAfterTest(stderr);\n\n  expect(textAfterTest).toMatchSnapshot();\n});\n\nit('prints out info about open handlers from tests with a `done` callback', async () => {\n  const run = runContinuous('detect-open-handles', [\n    'in-done-function',\n    '--detectOpenHandles',\n  ]);\n  await run.waitUntil(({stderr}) => stderr.includes('Jest has detected'));\n  const {stderr} = await run.end();\n  const textAfterTest = getTextAfterTest(stderr);\n\n  expect(textAfterTest).toMatchSnapshot();\n});\n\nit('prints out info about open handlers from lifecycle functions with a `done` callback', async () => {\n  const run = runContinuous('detect-open-handles', [\n    'in-done-lifecycle',\n    '--detectOpenHandles',\n  ]);\n  await run.waitUntil(({stderr}) => stderr.includes('Jest has detected'));\n  const {stderr} = await run.end();\n  let textAfterTest = getTextAfterTest(stderr);\n\n  // Circus and Jasmine have different contexts, leading to slightly different\n  // names for call stack functions. The difference shouldn't be problematic\n  // for users, so this normalizes them so the test works in both environments.\n  textAfterTest = textAfterTest.replace(\n    'at Object.setTimeout',\n    'at setTimeout',\n  );\n\n  expect(textAfterTest).toMatchSnapshot();\n});\n\nit('does not print info about open handlers for a server that is already closed', async () => {\n  const run = runContinuous('detect-open-handles', [\n    'recently-closed',\n    '--detectOpenHandles',\n  ]);\n  await run.waitUntil(({stderr}) => stderr.includes('Ran all test suites'));\n  const {stderr} = await run.end();\n  const textAfterTest = getTextAfterTest(stderr);\n\n  expect(textAfterTest).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`does not print info about open handlers for a server that is already closed 1`] = `\"\"`;\n\nexports[`prints message about flag on forceExit 1`] = `\"Force exiting Jest: Have you considered using \\`--detectOpenHandles\\` to detect async operations that kept running after all tests finished?\"`;\n\nexports[`prints message about flag on slow tests 1`] = `\n\"Jest did not exit one second after the test run has completed.\n\n'This usually means that there are asynchronous operations that weren't stopped in your tests. Consider running Jest with \\`--detectOpenHandles\\` to troubleshoot this issue.\"\n`;\n\nexports[`prints message about flag on slow tests with a custom timeout 1`] = `\n\"Jest did not exit 0.5 seconds after the test run has completed.\n\n'This usually means that there are asynchronous operations that weren't stopped in your tests. Consider running Jest with \\`--detectOpenHandles\\` to troubleshoot this issue.\"\n`;\n\nexports[`prints out info about open handlers 1`] = `\n\"Jest has detected the following 1 open handle potentially keeping Jest from exiting:\n\n  ●  TCPSERVERWRAP\n\n      12 | const app = new Server();\n      13 |\n    > 14 | app.listen({host: 'localhost', port: 0});\n         |     ^\n      15 |\n\n      at Object.listen (server.js:14:5)\n      at Object.require (__tests__/outside.js:8:1)\"\n`;\n\nexports[`prints out info about open handlers from inside tests 1`] = `\n\"Jest has detected the following 1 open handle potentially keeping Jest from exiting:\n\n  ●  Timeout\n\n       7 |\n       8 | test('something', () => {\n    >  9 |   setTimeout(() => {}, 30_000);\n         |   ^\n      10 |   expect(true).toBe(true);\n      11 | });\n      12 |\n\n      at Object.setTimeout (__tests__/inside.js:9:3)\"\n`;\n\nexports[`prints out info about open handlers from lifecycle functions with a \\`done\\` callback 1`] = `\n\"Jest has detected the following 1 open handle potentially keeping Jest from exiting:\n\n  ●  Timeout\n\n       7 |\n       8 | beforeAll(done => {\n    >  9 |   setTimeout(() => {}, 10_000);\n         |   ^\n      10 |   done();\n      11 | });\n      12 |\n\n      at setTimeout (__tests__/in-done-lifecycle.js:9:3)\"\n`;\n\nexports[`prints out info about open handlers from tests with a \\`done\\` callback 1`] = `\n\"Jest has detected the following 1 open handle potentially keeping Jest from exiting:\n\n  ●  Timeout\n\n       7 |\n       8 | test('something', done => {\n    >  9 |   setTimeout(() => {}, 10_000);\n         |   ^\n      10 |   expect(true).toBe(true);\n      11 |   done();\n      12 | });\n\n      at Object.setTimeout (__tests__/in-done-function.js:9:3)\"\n`;"}
{"prompt":"Use only in toBe assertions for edge case messages.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk = require('chalk');\nimport stripAnsi = require('strip-ansi');\nimport {alignedAnsiStyleSerializer} from '@jest/test-utils';\nimport {diff} from '..';\nimport {NO_DIFF_MESSAGE} from '../constants';\nimport {diffLinesUnified, diffLinesUnified2} from '../diffLines';\nimport {noColor} from '../normalizeDiffOptions';\nimport {diffStringsUnified} from '../printDiffs';\nimport type {DiffOptions} from '../types';\n\nconst optionsCounts: DiffOptions = {\n  includeChangeCounts: true,\n};\n\n// Use only in toBe assertions for edge case messages.\nconst stripped = (a: unknown, b: unknown) => stripAnsi(diff(a, b) ?? '');\n\n// Use in toBe assertions for comparison lines.\nconst optionsBe: DiffOptions = {\n  aColor: noColor,\n  bColor: noColor,\n  commonColor: noColor,\n  omitAnnotationLines: true,\n};\nconst unexpandedBe: DiffOptions = {\n  ...optionsBe,\n  expand: false,\n};\nconst expandedBe: DiffOptions = {\n  ...optionsBe,\n  expand: true,\n};\n\n// Use for toMatchSnapshot assertions.\nconst unexpanded = {expand: false};\nconst expanded = {expand: true};\n\nconst elementSymbol = Symbol.for('react.element');\n\nexpect.addSnapshotSerializer(alignedAnsiStyleSerializer);\n\ndescribe('different types', () => {\n  for (const values of [\n    [1, 'a', 'number', 'string'],\n    [{}, 'a', 'object', 'string'],\n    [[], 2, 'array', 'number'],\n    [null, undefined, 'null', 'undefined'],\n    [() => {}, 3, 'function', 'number'],\n  ]) {\n    const a = values[0];\n    const b = values[1];\n    const typeA = values[2];\n    const typeB = values[3];\n\n    test(`'${String(a)}' and '${String(b)}'`, () => {\n      expect(stripped(a, b)).toBe(\n        '  Comparing two different types of values. ' +\n          `Expected ${String(typeA)} but received ${String(typeB)}.`,\n      );\n    });\n  }\n});\n\ndescribe('no visual difference', () => {\n  for (const values of [\n    ['a', 'a'],\n    [{}, {}],\n    [[], []],\n    [\n      [1, 2],\n      [1, 2],\n    ],\n    [11, 11],\n    /* eslint-disable unicorn/prefer-number-properties */\n    [NaN, NaN],\n    [Number.NaN, NaN],\n    /* eslint-enable */\n    [() => {}, () => {}],\n    [null, null],\n    [undefined, undefined],\n    [false, false],\n    [{a: 1}, {a: 1}],\n    [{a: {b: 5}}, {a: {b: 5}}],\n  ]) {\n    test(`'${JSON.stringify(values[0])}' and '${JSON.stringify(\n      values[1],\n    )}'`, () => {\n      expect(stripped(values[0], values[1])).toBe(NO_DIFF_MESSAGE);\n    });\n  }\n\n  test('Map key order should be irrelevant', () => {\n    const arg1 = new Map([\n      [1, 'foo'],\n      [2, 'bar'],\n    ]);\n    const arg2 = new Map([\n      [2, 'bar'],\n      [1, 'foo'],\n    ]);\n\n    expect(stripped(arg1, arg2)).toBe(NO_DIFF_MESSAGE);\n  });\n\n  test('Set value order should be irrelevant', () => {\n    const arg1 = new Set([1, 2]);\n    const arg2 = new Set([2, 1]);\n\n    expect(stripped(arg1, arg2)).toBe(NO_DIFF_MESSAGE);\n  });\n});\n\ntest('oneline strings', () => {\n  expect(diff('ab', 'aa', optionsCounts)).toMatchSnapshot();\n  expect(diff('123456789', '234567890', optionsCounts)).toMatchSnapshot();\n  expect(diff('oneline', 'multi\\nline', optionsCounts)).toMatchSnapshot();\n  expect(diff('multi\\nline', 'oneline', optionsCounts)).toMatchSnapshot();\n});\n\ndescribe('falls back to not call toJSON', () => {\n  describe('if serialization has no differences', () => {\n    const toJSON = function toJSON() {\n      return 'it’s all the same to me';\n    };\n\n    test('but then objects have differences', () => {\n      const a = {line: 1, toJSON};\n      const b = {line: 2, toJSON};\n      expect(diff(a, b, optionsCounts)).toMatchSnapshot();\n    });\n    test('and then objects have no differences', () => {\n      const a = {line: 2, toJSON};\n      const b = {line: 2, toJSON};\n      expect(stripped(a, b)).toBe(NO_DIFF_MESSAGE);\n    });\n  });\n  describe('if it throws', () => {\n    const toJSON = function toJSON() {\n      throw new Error('catch me if you can');\n    };\n\n    test('and then objects have differences', () => {\n      const a = {line: 1, toJSON};\n      const b = {line: 2, toJSON};\n      expect(diff(a, b, optionsCounts)).toMatchSnapshot();\n    });\n    test('and then objects have no differences', () => {\n      const a = {line: 2, toJSON};\n      const b = {line: 2, toJSON};\n      expect(stripped(a, b)).toBe(NO_DIFF_MESSAGE);\n    });\n  });\n});\n\n// Some of the following assertions seem complex, but compare to alternatives:\n// * toBe instead of toMatchSnapshot:\n//   * to avoid visual complexity of escaped quotes in expected string\n//   * to omit Expected/Received heading which is an irrelevant detail\n// * join lines of expected string instead of multiline string:\n//   * to avoid ambiguity about indentation in diff lines\n\ndescribe('multiline strings', () => {\n  const a = `line 1\nline 2\nline 3\nline 4`;\n  const b = `line 1\nline  2\nline 3\nline 4`;\n  const expected = [\n    '  line 1',\n    '- line 2',\n    '+ line  2',\n    '  line 3',\n    '  line 4',\n  ].join('\\n');\n\n  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });\n  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });\n});\n\ndescribe('objects', () => {\n  const a = {a: {b: {c: 5}}};\n  const b = {a: {b: {c: 6}}};\n  const expected = [\n    '  Object {',\n    '    \"a\": Object {',\n    '      \"b\": Object {',\n    '-       \"c\": 5,',\n    '+       \"c\": 6,',\n    '      },',\n    '    },',\n    '  }',\n  ].join('\\n');\n\n  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });\n  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });\n});\n\ntest('numbers', () => {\n  expect(diff(1, 2, optionsBe)).toBe('- 1\\n+ 2');\n});\n\ntest('-0 and 0', () => {\n  expect(diff(-0, 0, optionsBe)).toBe('- -0\\n+ 0');\n});\n\ntest('booleans', () => {\n  expect(diff(false, true, optionsBe)).toBe('- false\\n+ true');\n});\n\ndescribe('multiline string non-snapshot', () => {\n  // For example, CLI output\n  // toBe or toEqual for a string isn’t enclosed in double quotes.\n  const a = `Options:\n--help, -h  Show help                            [boolean]\n--bail, -b  Exit the test suite immediately upon the first\n            failing test.                        [boolean]`;\n  const b = `Options:\n  --help, -h  Show help                            [boolean]\n  --bail, -b  Exit the test suite immediately upon the first\n              failing test.                        [boolean]`;\n  const expected = [\n    '  Options:',\n    '- --help, -h  Show help                            [boolean]',\n    '- --bail, -b  Exit the test suite immediately upon the first',\n    '-             failing test.                        [boolean]',\n    '+   --help, -h  Show help                            [boolean]',\n    '+   --bail, -b  Exit the test suite immediately upon the first',\n    '+               failing test.                        [boolean]',\n  ].join('\\n');\n\n  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });\n  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });\n});\n\ndescribe('multiline string snapshot', () => {\n  // For example, CLI output\n  // A snapshot of a string is enclosed in double quotes.\n  const a = `\"\nOptions:\n--help, -h  Show help                            [boolean]\n--bail, -b  Exit the test suite immediately upon the first\n            failing test.                        [boolean]\"`;\n  const b = `\"\nOptions:\n  --help, -h  Show help                            [boolean]\n  --bail, -b  Exit the test suite immediately upon the first\n              failing test.                        [boolean]\"`;\n  const expected = [\n    '  \"',\n    '  Options:',\n    '- --help, -h  Show help                            [boolean]',\n    '- --bail, -b  Exit the test suite immediately upon the first',\n    '-             failing test.                        [boolean]\"',\n    '+   --help, -h  Show help                            [boolean]',\n    '+   --bail, -b  Exit the test suite immediately upon the first',\n    '+               failing test.                        [boolean]\"',\n  ].join('\\n');\n\n  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });\n  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });\n});\n\ndescribe('React elements', () => {\n  const a = {\n    $$typeof: elementSymbol,\n    props: {\n      children: 'Hello',\n      className: 'fun',\n    },\n    type: 'div',\n  };\n  const b = {\n    $$typeof: elementSymbol,\n    props: {\n      children: 'Goodbye',\n      className: 'fun',\n    },\n    type: 'div',\n  };\n  const expected = [\n    '  <div',\n    '    className=\"fun\"',\n    '  >',\n    '-   Hello',\n    '+   Goodbye',\n    '  </div>',\n  ].join('\\n');\n\n  test('(unexpanded)', () => {\n    expect(diff(a, b, unexpandedBe)).toBe(expected);\n  });\n  test('(expanded)', () => {\n    expect(diff(a, b, expandedBe)).toBe(expected);\n  });\n});\n\ndescribe('multiline string as value of object property', () => {\n  const expected = [\n    '  Object {',\n    '    \"id\": \"J\",',\n    '    \"points\": \"0.5,0.460',\n    '+ 0.5,0.875',\n    '  0.25,0.875\",',\n    '  }',\n  ].join('\\n');\n\n  describe('(non-snapshot)', () => {\n    const a = {\n      id: 'J',\n      points: '0.5,0.460\\n0.25,0.875',\n    };\n    const b = {\n      id: 'J',\n      points: '0.5,0.460\\n0.5,0.875\\n0.25,0.875',\n    };\n    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });\n  });\n\n  describe('(snapshot)', () => {\n    const a = [\n      'Object {',\n      '  \"id\": \"J\",',\n      '  \"points\": \"0.5,0.460',\n      '0.25,0.875\",',\n      '}',\n    ].join('\\n');\n    const b = [\n      'Object {',\n      '  \"id\": \"J\",',\n      '  \"points\": \"0.5,0.460',\n      '0.5,0.875',\n      '0.25,0.875\",',\n      '}',\n    ].join('\\n');\n    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });\n  });\n});\n\ndescribe('indentation in JavaScript structures', () => {\n  const searching = '';\n  const object = {\n    descending: false,\n    fieldKey: 'what',\n  };\n  const a = {\n    searching,\n    sorting: object,\n  };\n  const b = {\n    searching,\n    sorting: [object],\n  };\n\n  describe('from less to more', () => {\n    const expected = [\n      '  Object {',\n      '    \"searching\": \"\",',\n      '-   \"sorting\": Object {',\n      '+   \"sorting\": Array [',\n      '+     Object {',\n      // following 3 lines are unchanged, except for more indentation\n      '        \"descending\": false,',\n      '        \"fieldKey\": \"what\",',\n      '      },',\n      '+   ],',\n      '  }',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });\n  });\n\n  describe('from more to less', () => {\n    const expected = [\n      '  Object {',\n      '    \"searching\": \"\",',\n      '-   \"sorting\": Array [',\n      '-     Object {',\n      '+   \"sorting\": Object {',\n      // following 3 lines are unchanged, except for less indentation\n      '      \"descending\": false,',\n      '      \"fieldKey\": \"what\",',\n      '    },',\n      '-   ],',\n      '  }',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });\n  });\n});\n\ndescribe('color of text', () => {\n  const searching = '';\n  const object = {\n    descending: false,\n    fieldKey: 'what',\n  };\n  const a = {\n    searching,\n    sorting: object,\n  };\n  const b = {\n    searching,\n    sorting: [object],\n  };\n  const received = diff(a, b, expanded);\n\n  test('(expanded)', () => {\n    expect(received).toMatchSnapshot();\n  });\n  test('(unexpanded)', () => {\n    // Expect same result, unless diff is long enough to require patch marks.\n    expect(diff(a, b, unexpanded)).toBe(received);\n  });\n});\n\ndescribe('indentation in React elements (non-snapshot)', () => {\n  const leaf = {\n    $$typeof: elementSymbol,\n    props: {\n      children: ['text'],\n    },\n    type: 'span',\n  };\n  const a = {\n    $$typeof: elementSymbol,\n    props: {\n      children: [leaf],\n    },\n    type: 'span',\n  };\n  const b = {\n    $$typeof: elementSymbol,\n    props: {\n      children: [\n        {\n          $$typeof: elementSymbol,\n          props: {\n            children: [leaf],\n          },\n          type: 'strong',\n        },\n      ],\n    },\n    type: 'span',\n  };\n\n  describe('from less to more', () => {\n    const expected = [\n      '  <span>',\n      '+   <strong>',\n      // following 3 lines are unchanged, except for more indentation\n      '      <span>',\n      '        text',\n      '      </span>',\n      '+   </strong>',\n      '  </span>',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });\n  });\n\n  describe('from more to less', () => {\n    const expected = [\n      '  <span>',\n      '-   <strong>',\n      // following 3 lines are unchanged, except for less indentation\n      '    <span>',\n      '      text',\n      '    </span>',\n      '-   </strong>',\n      '  </span>',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });\n  });\n});\n\ndescribe('indentation in React elements (snapshot)', () => {\n  // prettier-ignore\n  const a = [\n    '<span>',\n    '  <span>',\n    '    text',\n    '  </span>',\n    '</span>',\n  ].join('\\n');\n  const b = [\n    '<span>',\n    '  <strong>',\n    '    <span>',\n    '      text',\n    '    </span>',\n    '  </strong>',\n    '</span>',\n  ].join('\\n');\n\n  describe('from less to more', () => {\n    // We intend to improve snapshot diff in the next version of Jest.\n    const expected = [\n      '  <span>',\n      '-   <span>',\n      '-     text',\n      '-   </span>',\n      '+   <strong>',\n      '+     <span>',\n      '+       text',\n      '+     </span>',\n      '+   </strong>',\n      '  </span>',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });\n  });\n\n  describe('from more to less', () => {\n    // We intend to improve snapshot diff in the next version of Jest.\n    const expected = [\n      '  <span>',\n      '-   <strong>',\n      '-     <span>',\n      '-       text',\n      '-     </span>',\n      '-   </strong>',\n      '+   <span>',\n      '+     text',\n      '+   </span>',\n      '  </span>',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });\n  });\n});\n\ndescribe('outer React element (non-snapshot)', () => {\n  const a = {\n    $$typeof: elementSymbol,\n    props: {\n      children: 'Jest',\n    },\n    type: 'h1',\n  };\n  const b = {\n    $$typeof: elementSymbol,\n    props: {\n      children: [\n        a,\n        {\n          $$typeof: elementSymbol,\n          props: {\n            children: 'Delightful JavaScript Testing',\n          },\n          type: 'h2',\n        },\n      ],\n    },\n    type: 'header',\n  };\n\n  describe('from less to more', () => {\n    const expected = [\n      '+ <header>',\n      // following 3 lines are unchanged, except for more indentation\n      '    <h1>',\n      '      Jest',\n      '    </h1>',\n      '+   <h2>',\n      '+     Delightful JavaScript Testing',\n      '+   </h2>',\n      '+ </header>',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });\n  });\n\n  describe('from more to less', () => {\n    const expected = [\n      '- <header>',\n      // following 3 lines are unchanged, except for less indentation\n      '  <h1>',\n      '    Jest',\n      '  </h1>',\n      '-   <h2>',\n      '-     Delightful JavaScript Testing',\n      '-   </h2>',\n      '- </header>',\n    ].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });\n  });\n});\n\ndescribe('trailing newline in multiline string not enclosed in quotes', () => {\n  const a = ['line 1', 'line 2', 'line 3'].join('\\n');\n  const b = `${a}\\n`;\n\n  describe('from less to more', () => {\n    const expected = ['  line 1', '  line 2', '  line 3', '+'].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(a, b, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(a, b, expandedBe)).toBe(expected);\n    });\n  });\n\n  describe('from more to less', () => {\n    const expected = ['  line 1', '  line 2', '  line 3', '-'].join('\\n');\n\n    test('(unexpanded)', () => {\n      expect(diff(b, a, unexpandedBe)).toBe(expected);\n    });\n    test('(expanded)', () => {\n      expect(diff(b, a, expandedBe)).toBe(expected);\n    });\n  });\n});\n\ntest('collapses big diffs to patch format', () => {\n  const result = diff(\n    {test: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]},\n    {test: [1, 2, 3, 4, 5, 6, 7, 8, 10, 9]},\n    unexpanded,\n  );\n\n  expect(result).toMatchSnapshot();\n});\n\ndescribe('context', () => {\n  const testDiffContextLines = (contextLines?: number) => {\n    const validContextLines =\n      typeof contextLines === 'number' &&\n      Number.isSafeInteger(contextLines) &&\n      contextLines >= 0;\n\n    test(`number of lines: ${\n      typeof contextLines === 'number' ? contextLines : 'undefined'\n    } ${validContextLines ? '' : '(5 default)'}`, () => {\n      const options = {\n        ...optionsCounts,\n        contextLines,\n        expand: false,\n      };\n      if (!validContextLines) {\n        options.patchColor = chalk.dim;\n      }\n\n      const result = diff(\n        {test: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]},\n        {test: [1, 2, 3, 4, 5, 6, 7, 8, 10, 9]},\n        options,\n      );\n      expect(result).toMatchSnapshot();\n    });\n  };\n\n  testDiffContextLines(-1); // (5 default)\n  testDiffContextLines(0);\n  testDiffContextLines(1);\n  testDiffContextLines(2);\n  testDiffContextLines(3.1); // (5 default)\n  testDiffContextLines(); // (5 default)\n});\n\ndescribe('diffLinesUnified edge cases', () => {\n  test('a empty string b empty string', () => {\n    const a = '';\n    const b = '';\n\n    const received = diffLinesUnified(a.split('\\n'), b.split('\\n'), optionsBe);\n    const expected = '';\n\n    expect(received).toBe(expected);\n  });\n\n  test('a empty string b one line', () => {\n    const a = '';\n    const b = 'line 1';\n\n    const received = diffLinesUnified(a.split('\\n'), b.split('\\n'), optionsBe);\n    const expected = '+ line 1';\n\n    expect(received).toBe(expected);\n  });\n\n  test('a multiple lines b empty string', () => {\n    const a = 'line 1\\n\\nline 3';\n    const b = '';\n\n    const received = diffLinesUnified(a.split('\\n'), b.split('\\n'), optionsBe);\n    const expected = '- line 1\\n-\\n- line 3';\n\n    expect(received).toBe(expected);\n  });\n\n  test('a one line b multiple lines', () => {\n    const a = 'line 2';\n    const b = 'line 1\\nline 2\\nline 3';\n\n    const received = diffLinesUnified(a.split('\\n'), b.split('\\n'), optionsBe);\n    const expected = '+ line 1\\n  line 2\\n+ line 3';\n\n    expect(received).toBe(expected);\n  });\n});\n\ndescribe('diffLinesUnified2 edge cases', () => {\n  test('a empty string b empty string', () => {\n    const a = '';\n    const b = '';\n\n    const received = diffLinesUnified2(\n      a.split('\\n'),\n      b.split('\\n'),\n      a.split('\\n'),\n      b.split('\\n'),\n      optionsBe,\n    );\n    const expected = '';\n\n    expect(received).toBe(expected);\n  });\n\n  test('a empty string b one line', () => {\n    const a = '';\n    const b = 'line 1';\n\n    const received = diffLinesUnified2(\n      a.split('\\n'),\n      b.split('\\n'),\n      a.split('\\n'),\n      b.split('\\n'),\n      optionsBe,\n    );\n    const expected = '+ line 1';\n\n    expect(received).toBe(expected);\n  });\n\n  test('a multiple lines b empty string', () => {\n    const a = 'line 1\\n\\nline 3';\n    const b = '';\n\n    const received = diffLinesUnified2(\n      a.split('\\n'),\n      b.split('\\n'),\n      a.split('\\n'),\n      b.split('\\n'),\n      optionsBe,\n    );\n    const expected = '- line 1\\n-\\n- line 3';\n\n    expect(received).toBe(expected);\n  });\n\n  test('a one line b multiple lines', () => {\n    const aDisplay = 'LINE 2';\n    const bDisplay = 'Line 1\\nLine 2\\nLine 3';\n    const aCompare = aDisplay.toLowerCase();\n    const bCompare = bDisplay.toLowerCase();\n\n    const received = diffLinesUnified2(\n      aDisplay.split('\\n'),\n      bDisplay.split('\\n'),\n      aCompare.split('\\n'),\n      bCompare.split('\\n'),\n      optionsBe,\n    );\n    const expected = '+ Line 1\\n  Line 2\\n+ Line 3';\n\n    expect(received).toBe(expected);\n  });\n\n  describe('lengths not equal', () => {\n    // Fall back to diff of display lines.\n\n    test('a', () => {\n      const aDisplay = 'MiXeD cAsE';\n      const bDisplay = 'Mixed case\\nUPPER CASE';\n      const aCompare = `${aDisplay.toLowerCase()}\\nlower case`;\n      const bCompare = bDisplay.toLowerCase();\n\n      const received = diffLinesUnified2(\n        aDisplay.split('\\n'),\n        bDisplay.split('\\n'),\n        aCompare.split('\\n'),\n        bCompare.split('\\n'),\n        optionsBe,\n      );\n      const expected = '- MiXeD cAsE\\n+ Mixed case\\n+ UPPER CASE';\n\n      expect(received).toBe(expected);\n    });\n\n    test('b', () => {\n      const aDisplay = '{\\n  \"key\": \"value\",\\n}';\n      const bDisplay = '{\\n}';\n      const aCompare = '{\\n\"key\": \"value\",\\n}';\n      const bCompare = '{}';\n\n      const expected = '  {\\n-   \"key\": \"value\",\\n  }';\n      const received = diffLinesUnified2(\n        aDisplay.split('\\n'),\n        bDisplay.split('\\n'),\n        aCompare.split('\\n'),\n        bCompare.split('\\n'),\n        optionsBe,\n      );\n\n      expect(received).toBe(expected);\n    });\n  });\n});\n\ndescribe('diffStringsUnified edge cases', () => {\n  test('empty both a and b', () => {\n    const a = '';\n    const b = '';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });\n\n  test('empty only a', () => {\n    const a = '';\n    const b = 'one-line string';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });\n\n  test('empty only b', () => {\n    const a = 'one-line string';\n    const b = '';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });\n\n  test('equal both non-empty', () => {\n    const a = 'one-line string';\n    const b = 'one-line string';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });\n\n  test('multiline has no common after clean up chaff', () => {\n    const a = 'delete\\ntwo';\n    const b = 'insert\\n2';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });\n\n  test('one-line has no common after clean up chaff', () => {\n    const a = 'delete';\n    const b = 'insert';\n\n    expect(diffStringsUnified(a, b, optionsCounts)).toMatchSnapshot();\n  });\n});\n\ndescribe('options 7980', () => {\n  const a =\n    '`${Ti.App.name} ${Ti.App.version} ${Ti.Platform.name} ${Ti.Platform.version}`';\n  const b =\n    '`${Ti.App.getName()} ${Ti.App.getVersion()} ${Ti.Platform.getName()} ${Ti.Platform.getVersion()}`';\n\n  const options = {\n    aAnnotation: 'Original',\n    aColor: chalk.red,\n    bAnnotation: 'Modified',\n    bColor: chalk.green,\n  };\n\n  test('diff', () => {\n    expect(diff(a, b, options)).toMatchSnapshot();\n  });\n\n  test('diffStringsUnified', () => {\n    expect(diffStringsUnified(a, b, options)).toMatchSnapshot();\n  });\n});\n\ndescribe('options', () => {\n  const a = ['delete', 'change from', 'common'];\n  const b = ['change to', 'insert', 'common'];\n\n  const aString = 'change from\\ncommon'; // without delete\n  const bString = 'change to\\ncommon'; // without insert\n\n  describe('change indicators', () => {\n    const options = {\n      aIndicator: '<',\n      bIndicator: '>',\n    };\n\n    test('diff', () => {\n      expect(diff(a, b, options)).toMatchSnapshot();\n    });\n  });\n\n  describe('change color', () => {\n    const options = {\n      changeColor: chalk.bold,\n      commonColor: chalk.yellow,\n    };\n\n    test('diffStringsUnified', () => {\n      const aChanged = a.join('\\n').replace('change', 'changed');\n      const bChanged = b.join('\\n').replace('change', 'changed');\n      expect(diffStringsUnified(aChanged, bChanged, options)).toMatchSnapshot();\n    });\n\n    test('no diff', () => {\n      expect(diff(a, a, options)).toMatchSnapshot();\n    });\n  });\n\n  describe('common', () => {\n    const options = {\n      commonColor: noColor,\n      commonIndicator: '=',\n    };\n\n    test('diff', () => {\n      expect(diff(a, b, options)).toMatchSnapshot();\n    });\n\n    test('no diff', () => {\n      expect(diff(a, a, options)).toBe(NO_DIFF_MESSAGE);\n    });\n  });\n\n  describe('includeChangeCounts false', () => {\n    const options = {\n      includeChangeCounts: false,\n    };\n\n    test('diffLinesUnified', () => {\n      expect(diff(a, b, options)).toMatchSnapshot();\n    });\n\n    test('diffStringsUnified', () => {\n      expect(diffStringsUnified(aString, bString, options)).toMatchSnapshot();\n    });\n  });\n\n  describe('includeChangeCounts true padding', () => {\n    const options = {\n      aAnnotation: 'Before',\n      bAnnotation: 'After',\n      includeChangeCounts: true,\n    };\n\n    test('diffLinesUnified a has 2 digits', () => {\n      const has2 = 'common\\na\\na\\na\\na\\na\\na\\na\\na\\na\\na';\n      const has1 = 'common\\nb';\n      expect(diff(has2, has1, options)).toMatchSnapshot();\n    });\n\n    test('diffLinesUnified b has 2 digits', () => {\n      const has1 = 'common\\na';\n      const has2 = 'common\\nb\\nb\\nb\\nb\\nb\\nb\\nb\\nb\\nb\\nb';\n      expect(diff(has1, has2, options)).toMatchSnapshot();\n    });\n\n    test('diffStringsUnified', () => {\n      expect(diffStringsUnified(aString, bString, options)).toMatchSnapshot();\n    });\n  });\n\n  describe('omitAnnotationLines true', () => {\n    const options = {\n      omitAnnotationLines: true,\n    };\n\n    test('diff', () => {\n      expect(diff(a, b, options)).toMatchSnapshot();\n    });\n\n    test('diffStringsUnified and includeChangeCounts true', () => {\n      const options2 = {...options, includeChangeCounts: true};\n\n      expect(diffStringsUnified(aString, bString, options2)).toMatchSnapshot();\n    });\n\n    test('diffStringsUnified empty strings', () => {\n      expect(diffStringsUnified('', '', options)).toMatchSnapshot();\n    });\n  });\n\n  describe('trailingSpaceFormatter', () => {\n    const aTrailingSpaces = [\n      'delete 1 trailing space: ',\n      'common 2 trailing spaces:  ',\n      'insert 1 trailing space:',\n    ].join('\\n');\n    const bTrailingSpaces = [\n      'delete 1 trailing space:',\n      'common 2 trailing spaces:  ',\n      'insert 1 trailing space: ',\n    ].join('\\n');\n\n    test('diff default no color', () => {\n      expect(diff(aTrailingSpaces, bTrailingSpaces)).toMatchSnapshot();\n    });\n\n    test('diff middle dot', () => {\n      const replaceSpacesWithMiddleDot = (string: string) =>\n        '·'.repeat(string.length);\n      const options = {\n        changeLineTrailingSpaceColor: replaceSpacesWithMiddleDot,\n        commonLineTrailingSpaceColor: replaceSpacesWithMiddleDot,\n      };\n\n      expect(diff(aTrailingSpaces, bTrailingSpaces, options)).toMatchSnapshot();\n    });\n\n    test('diff yellowish common', () => {\n      const options = {\n        commonLineTrailingSpaceColor: chalk.bgYellow,\n      };\n\n      expect(diff(aTrailingSpaces, bTrailingSpaces, options)).toMatchSnapshot();\n    });\n  });\n\n  describe('emptyFirstOrLastLinePlaceholder default empty string', () => {\n    const options = {\n      ...optionsBe,\n      changeColor: noColor,\n    };\n\n    const aEmpty = '\\ncommon\\nchanged from\\n';\n    const bEmpty = '\\ncommon\\nchanged to\\n';\n\n    const expected = [\n      '',\n      '  common',\n      '- changed from',\n      '+ changed to',\n      '',\n    ].join('\\n');\n\n    test('diff', () => {\n      expect(diff(aEmpty, bEmpty, options)).toBe(expected);\n    });\n\n    test('diffStringsUnified', () => {\n      expect(diffStringsUnified(aEmpty, bEmpty, options)).toBe(expected);\n    });\n  });\n\n  describe('compare keys', () => {\n    const a = {a: {d: 1, e: 1, f: 1}, b: 1, c: 1};\n    const b = {a: {d: 1, e: 2, f: 1}, b: 1, c: 1};\n\n    test('keeps the object keys in their original order', () => {\n      const compareKeys = () => 0;\n      const expected = [\n        '  Object {',\n        '    \"a\": Object {',\n        '      \"d\": 1,',\n        '-     \"e\": 1,',\n        '+     \"e\": 2,',\n        '      \"f\": 1,',\n        '    },',\n        '    \"b\": 1,',\n        '    \"c\": 1,',\n        '  }',\n      ].join('\\n');\n      expect(diff(a, b, {...optionsBe, compareKeys})).toBe(expected);\n    });\n\n    test('sorts the object keys in reverse order', () => {\n      const compareKeys = (a: string, b: string) => (a > b ? -1 : 1);\n      const expected = [\n        '  Object {',\n        '    \"c\": 1,',\n        '    \"b\": 1,',\n        '    \"a\": Object {',\n        '      \"f\": 1,',\n        '-     \"e\": 1,',\n        '+     \"e\": 2,',\n        '      \"d\": 1,',\n        '    },',\n        '  }',\n      ].join('\\n');\n      expect(diff(a, b, {...optionsBe, compareKeys})).toBe(expected);\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`collapses big diffs to patch format 1`] = `\n<g>- Expected</>\n<r>+ Received</>\n\n<y>@@ -6,9 +6,9 @@</>\n<d>      4,</>\n<d>      5,</>\n<d>      6,</>\n<d>      7,</>\n<d>      8,</>\n<g>-     9,</>\n<d>      10,</>\n<r>+     9,</>\n<d>    ],</>\n<d>  }</>\n`;\n\nexports[`color of text (expanded) 1`] = `\n<g>- Expected</>\n<r>+ Received</>\n\n<d>  Object {</>\n<d>    \"searching\": \"\",</>\n<g>-   \"sorting\": Object {</>\n<r>+   \"sorting\": Array [</>\n<r>+     Object {</>\n<d>        \"descending\": false,</>\n<d>        \"fieldKey\": \"what\",</>\n<d>      },</>\n<r>+   ],</>\n<d>  }</>\n`;\n\nexports[`context number of lines: -1 (5 default) 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>@@ -6,9 +6,9 @@</>\n<d>      4,</>\n<d>      5,</>\n<d>      6,</>\n<d>      7,</>\n<d>      8,</>\n<g>-     9,</>\n<d>      10,</>\n<r>+     9,</>\n<d>    ],</>\n<d>  }</>\n`;\n\nexports[`context number of lines: 0  1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<y>@@ -11,1 +11,0 @@</>\n<g>-     9,</>\n<y>@@ -13,0 +12,1 @@</>\n<r>+     9,</>\n`;\n\nexports[`context number of lines: 1  1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<y>@@ -10,4 +10,4 @@</>\n<d>      8,</>\n<g>-     9,</>\n<d>      10,</>\n<r>+     9,</>\n<d>    ],</>\n`;\n\nexports[`context number of lines: 2  1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<y>@@ -9,6 +9,6 @@</>\n<d>      7,</>\n<d>      8,</>\n<g>-     9,</>\n<d>      10,</>\n<r>+     9,</>\n<d>    ],</>\n<d>  }</>\n`;\n\nexports[`context number of lines: 3.1 (5 default) 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>@@ -6,9 +6,9 @@</>\n<d>      4,</>\n<d>      5,</>\n<d>      6,</>\n<d>      7,</>\n<d>      8,</>\n<g>-     9,</>\n<d>      10,</>\n<r>+     9,</>\n<d>    ],</>\n<d>  }</>\n`;\n\nexports[`context number of lines: undefined (5 default) 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>@@ -6,9 +6,9 @@</>\n<d>      4,</>\n<d>      5,</>\n<d>      6,</>\n<d>      7,</>\n<d>      8,</>\n<g>-     9,</>\n<d>      10,</>\n<r>+     9,</>\n<d>    ],</>\n<d>  }</>\n`;\n\nexports[`diffStringsUnified edge cases empty both a and b 1`] = `\n<g>- Expected  - 0</>\n<r>+ Received  + 0</>\n\n\n`;\n\nexports[`diffStringsUnified edge cases empty only a 1`] = `\n<g>- Expected  - 0</>\n<r>+ Received  + 1</>\n\n<r>+ one-line string</>\n`;\n\nexports[`diffStringsUnified edge cases empty only b 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 0</>\n\n<g>- one-line string</>\n`;\n\nexports[`diffStringsUnified edge cases equal both non-empty 1`] = `\n<g>- Expected  - 0</>\n<r>+ Received  + 0</>\n\n<d>  one-line string</>\n`;\n\nexports[`diffStringsUnified edge cases multiline has no common after clean up chaff 1`] = `\n<g>- Expected  - 2</>\n<r>+ Received  + 2</>\n\n<g>- delete</>\n<g>- two</>\n<r>+ insert</>\n<r>+ 2</>\n`;\n\nexports[`diffStringsUnified edge cases one-line has no common after clean up chaff 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<g>- delete</>\n<r>+ insert</>\n`;\n\nexports[`falls back to not call toJSON if it throws and then objects have differences 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"line\": 1,</>\n<r>+   \"line\": 2,</>\n<d>    \"toJSON\": [Function toJSON],</>\n<d>  }</>\n`;\n\nexports[`falls back to not call toJSON if serialization has no differences but then objects have differences 1`] = `\n<d>Compared values serialize to the same structure.</>\n<d>Printing internal object structure without calling \\`toJSON\\` instead.</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"line\": 1,</>\n<r>+   \"line\": 2,</>\n<d>    \"toJSON\": [Function toJSON],</>\n<d>  }</>\n`;\n\nexports[`oneline strings 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<g>- ab</>\n<r>+ aa</>\n`;\n\nexports[`oneline strings 2`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<g>- 123456789</>\n<r>+ 234567890</>\n`;\n\nexports[`oneline strings 3`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 2</>\n\n<g>- oneline</>\n<r>+ multi</>\n<r>+ line</>\n`;\n\nexports[`oneline strings 4`] = `\n<g>- Expected  - 2</>\n<r>+ Received  + 1</>\n\n<g>- multi</>\n<g>- line</>\n<r>+ oneline</>\n`;\n\nexports[`options 7980 diff 1`] = `\n<r>- Original</>\n<g>+ Modified</>\n\n<r>- \\`\\${Ti.App.name} \\${Ti.App.version} \\${Ti.Platform.name} \\${Ti.Platform.version}\\`</>\n<g>+ \\`\\${Ti.App.getName()} \\${Ti.App.getVersion()} \\${Ti.Platform.getName()} \\${Ti.Platform.getVersion()}\\`</>\n`;\n\nexports[`options 7980 diffStringsUnified 1`] = `\n<r>- Original</>\n<g>+ Modified</>\n\n<r>- \\`\\${Ti.App.<i>n</i>ame} \\${Ti.App.<i>v</i>ersion} \\${Ti.Platform.<i>n</i>ame} \\${Ti.Platform.<i>v</i>ersion}\\`</>\n<g>+ \\`\\${Ti.App.<i>getN</i>ame<i>()</i>} \\${Ti.App.<i>getV</i>ersion<i>()</i>} \\${Ti.Platform.<i>getN</i>ame<i>()</i>} \\${Ti.Platform.<i>getV</i>ersion<i>()</i>}\\`</>\n`;\n\nexports[`options change color diffStringsUnified 1`] = `\n<g>- Expected</>\n<r>+ Received</>\n\n<g>- delete</>\n<g>- changed <b>from</></>\n<r>+ changed <b>to</></>\n<r>+ insert</>\n<y>  common</>\n`;\n\nexports[`options change color no diff 1`] = `<y>Compared values have no visual difference.</>`;\n\nexports[`options change indicators diff 1`] = `\n<g>< Expected</>\n<r>> Received</>\n\n<d>  Array [</>\n<g><   \"delete\",</>\n<g><   \"change from\",</>\n<r>>   \"change to\",</>\n<r>>   \"insert\",</>\n<d>    \"common\",</>\n<d>  ]</>\n`;\n\nexports[`options common diff 1`] = `\n<g>- Expected</>\n<r>+ Received</>\n\n= Array [\n<g>-   \"delete\",</>\n<g>-   \"change from\",</>\n<r>+   \"change to\",</>\n<r>+   \"insert\",</>\n=   \"common\",\n= ]\n`;\n\nexports[`options includeChangeCounts false diffLinesUnified 1`] = `\n<g>- Expected</>\n<r>+ Received</>\n\n<d>  Array [</>\n<g>-   \"delete\",</>\n<g>-   \"change from\",</>\n<r>+   \"change to\",</>\n<r>+   \"insert\",</>\n<d>    \"common\",</>\n<d>  ]</>\n`;\n\nexports[`options includeChangeCounts false diffStringsUnified 1`] = `\n<g>- Expected</>\n<r>+ Received</>\n\n<g>- change <i>from</i></>\n<r>+ change <i>to</i></>\n<d>  common</>\n`;\n\nexports[`options includeChangeCounts true padding diffLinesUnified a has 2 digits 1`] = `\n<g>- Before  - 10</>\n<r>+ After   +  1</>\n\n<d>  common</>\n<g>- a</>\n<g>- a</>\n<g>- a</>\n<g>- a</>\n<g>- a</>\n<g>- a</>\n<g>- a</>\n<g>- a</>\n<g>- a</>\n<g>- a</>\n<r>+ b</>\n`;\n\nexports[`options includeChangeCounts true padding diffLinesUnified b has 2 digits 1`] = `\n<g>- Before  -  1</>\n<r>+ After   + 10</>\n\n<d>  common</>\n<g>- a</>\n<r>+ b</>\n<r>+ b</>\n<r>+ b</>\n<r>+ b</>\n<r>+ b</>\n<r>+ b</>\n<r>+ b</>\n<r>+ b</>\n<r>+ b</>\n<r>+ b</>\n`;\n\nexports[`options includeChangeCounts true padding diffStringsUnified 1`] = `\n<g>- Before  - 1</>\n<r>+ After   + 1</>\n\n<g>- change <i>from</i></>\n<r>+ change <i>to</i></>\n<d>  common</>\n`;\n\nexports[`options omitAnnotationLines true diff 1`] = `\n<d>  Array [</>\n<g>-   \"delete\",</>\n<g>-   \"change from\",</>\n<r>+   \"change to\",</>\n<r>+   \"insert\",</>\n<d>    \"common\",</>\n<d>  ]</>\n`;\n\nexports[`options omitAnnotationLines true diffStringsUnified and includeChangeCounts true 1`] = `\n<g>- change <i>from</i></>\n<r>+ change <i>to</i></>\n<d>  common</>\n`;\n\nexports[`options omitAnnotationLines true diffStringsUnified empty strings 1`] = ``;\n\nexports[`options trailingSpaceFormatter diff default no color 1`] = `\n<g>- Expected</>\n<r>+ Received</>\n\n<g>- delete 1 trailing space: </>\n<r>+ delete 1 trailing space:</>\n<d>  common 2 trailing spaces:  </>\n<g>- insert 1 trailing space:</>\n<r>+ insert 1 trailing space: </>\n`;\n\nexports[`options trailingSpaceFormatter diff middle dot 1`] = `\n<g>- Expected</>\n<r>+ Received</>\n\n<g>- delete 1 trailing space:·</>\n<r>+ delete 1 trailing space:</>\n<d>  common 2 trailing spaces:··</>\n<g>- insert 1 trailing space:</>\n<r>+ insert 1 trailing space:·</>\n`;\n\nexports[`options trailingSpaceFormatter diff yellowish common 1`] = `\n<g>- Expected</>\n<r>+ Received</>\n\n<g>- delete 1 trailing space: </>\n<r>+ delete 1 trailing space:</>\n<d>  common 2 trailing spaces:<Y>  </></>\n<g>- insert 1 trailing space:</>\n<r>+ insert 1 trailing space: </>\n`;"}
{"prompt":"diffStringsRaw,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff, diffStringsRaw} from '..';\n\ndescribe('diffStringsRaw', () => {\n  test('one-line with cleanup', () => {\n    const expected: Array<Diff> = [\n      new Diff(DIFF_EQUAL, 'change '),\n      new Diff(DIFF_DELETE, 'from'),\n      new Diff(DIFF_INSERT, 'to'),\n    ];\n    const received = diffStringsRaw('change from', 'change to', true);\n\n    expect(received).toEqual(expected);\n  });\n\n  test('one-line without cleanup', () => {\n    const expected: Array<Diff> = [\n      new Diff(DIFF_EQUAL, 'change '),\n      new Diff(DIFF_DELETE, 'fr'),\n      new Diff(DIFF_INSERT, 't'),\n      new Diff(DIFF_EQUAL, 'o'),\n      new Diff(DIFF_DELETE, 'm'),\n    ];\n    const received = diffStringsRaw('change from', 'change to', false);\n\n    expect(received).toEqual(expected);\n  });\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\nimport utils from '../utils';\n\njest.disableAutomock();\n\ntest('original implementation', () => {\n  expect(utils.authorize()).toBe('token');\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\n'use strict';\n\njest.mock('../fetchCurrentUser.js');\n\nit('displays a user after a click', () => {\n  // Set up our document body\n  document.body.innerHTML =\n    '<div>' +\n    '  <span id=\"username\" />' +\n    '  <button id=\"button\" />' +\n    '</div>';\n\n  // This module has a side-effect\n  require('../displayUser');\n\n  const $ = require('jquery');\n  const fetchCurrentUser = require('../fetchCurrentUser');\n\n  // Tell the fetchCurrentUser mock function to automatically invoke\n  // its callback with some data\n  fetchCurrentUser.mockImplementation(cb => {\n    cb({\n      fullName: 'Johnny Cash',\n      loggedIn: true,\n    });\n  });\n\n  // Use jquery to emulate a click on our button\n  $('#button').click();\n\n  // Assert that the fetchCurrentUser function was called, and that the\n  // #username span's inner text was updated as we'd expect it to.\n  expect(fetchCurrentUser).toHaveBeenCalled();\n  expect($('#username').text()).toBe('Johnny Cash - Logged In');\n});"}
{"prompt":"do-no-match-me.txt","test":"// do-no-match-me.txt\n\nrequire('../module.txt');"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment ./DocblockPragmasEnvironment.js\n * @my-custom-pragma pragma-value\n */\n\ntest('docblock pragmas', () => {\n  expect(myCustomPragma).toBe('pragma-value'); // eslint-disable-line no-undef\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/* global document */\n\ntest('use toBe compare two div', () => {\n  const div1 = document.createElement('div');\n  const div2 = document.createElement('div');\n  expect(div1).toBe(div2);\n});\n\ntest('compare span and div', () => {\n  expect(document.createElement('div')).toBe(document.createElement('span'));\n});"}
{"prompt":"/ <reference lib=dom />","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n/// <reference lib=\"dom\" />\n\n/* global document */\n\nimport {plugins} from '..';\nimport setPrettyPrint from './setPrettyPrint';\n\nconst {DOMCollection, DOMElement} = plugins;\n\nsetPrettyPrint([DOMCollection, DOMElement]);\n\ndescribe('DOMCollection plugin for object properties', () => {\n  it('supports DOMStringMap', () => {\n    const el = document.createElement('div');\n    el.dataset.foo = 'bar';\n\n    expect(el.dataset).toPrettyPrintTo('DOMStringMap {\\n  \"foo\": \"bar\",\\n}');\n  });\n\n  it('supports NamedNodeMap', () => {\n    const el = document.createElement('div');\n    el.setAttribute('foo', 'bar');\n\n    expect(el.attributes).toPrettyPrintTo('NamedNodeMap {\\n  \"foo\": \"bar\",\\n}');\n  });\n\n  it('supports config.min option', () => {\n    const el = document.createElement('div');\n    el.setAttribute('name1', 'value1');\n    el.setAttribute('name2', 'value2');\n\n    expect(el.attributes).toPrettyPrintTo(\n      '{\"name1\": \"value1\", \"name2\": \"value2\"}',\n      {min: true},\n    );\n  });\n});\n\ndescribe('DOMCollection plugin for list items', () => {\n  const select = document.createElement('select');\n  select.innerHTML = [\n    '<option value=\"1\">one</option>',\n    '<option value=\"2\">two</option>',\n    '<option value=\"3\">three</option>',\n  ].join('');\n\n  const form = document.createElement('form');\n  form.append(select);\n\n  const expectedOption1 = [\n    '  <option',\n    '    value=\"1\"',\n    '  >',\n    '    one',\n    '  </option>,', // comma because item\n  ].join('\\n');\n  const expectedOption2 = [\n    '  <option',\n    '    value=\"2\"',\n    '  >',\n    '    two',\n    '  </option>,', // comma because item\n  ].join('\\n');\n  const expectedOption3 = [\n    '  <option',\n    '    value=\"3\"',\n    '  >',\n    '    three',\n    '  </option>,', // comma because item\n  ].join('\\n');\n\n  const expectedHTMLCollection = [\n    'HTMLCollection [',\n    expectedOption1,\n    expectedOption2,\n    expectedOption3,\n    ']',\n  ].join('\\n');\n\n  it('supports HTMLCollection for getElementsByTagName', () => {\n    // eslint-disable-next-line unicorn/prefer-query-selector\n    const options = form.getElementsByTagName('option');\n    expect(options).toPrettyPrintTo(expectedHTMLCollection);\n  });\n\n  it('supports HTMLCollection for children', () => {\n    expect(select.children).toPrettyPrintTo(expectedHTMLCollection);\n  });\n\n  it('supports config.maxDepth option', () => {\n    expect(select.children).toPrettyPrintTo('[HTMLCollection]', {maxDepth: 0});\n  });\n\n  const expectedNodeList = [\n    'NodeList [',\n    expectedOption1,\n    expectedOption2,\n    expectedOption3,\n    ']',\n  ].join('\\n');\n\n  it('supports NodeList for querySelectorAll', () => {\n    const options = form.querySelectorAll('option');\n    expect(options).toPrettyPrintTo(expectedNodeList);\n  });\n\n  it('supports NodeList for childNodes', () => {\n    expect(select.childNodes).toPrettyPrintTo(expectedNodeList);\n  });\n\n  const expectedHTMLOptionsCollection = [\n    'HTMLOptionsCollection [',\n    expectedOption1,\n    expectedOption2,\n    expectedOption3,\n    ']',\n  ].join('\\n');\n\n  it('supports HTMLOptionsCollection for select options', () => {\n    expect(select.options).toPrettyPrintTo(expectedHTMLOptionsCollection);\n  });\n\n  const expectedHTMLFormControlsCollection = [\n    'HTMLFormControlsCollection [',\n    '  <select>',\n    '    <option',\n    '      value=\"1\"',\n    '    >',\n    '      one',\n    '    </option>', // no comma because element\n    '    <option',\n    '      value=\"2\"',\n    '    >',\n    '      two',\n    '    </option>', // no comma because element\n    '    <option',\n    '      value=\"3\"',\n    '    >',\n    '      three',\n    '    </option>', // no comma because element\n    '  </select>,', // comma because item\n    ']',\n  ].join('\\n');\n\n  it('supports HTMLCollection for form elements', () => {\n    expect(form.elements).toPrettyPrintTo(expectedHTMLFormControlsCollection);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\ntest('should work without error', () => {\n  const output = runJest('dom-diffing');\n  expect(output.failed).toBe(true);\n  const {rest, summary} = extractSummary(output.stderr);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`should work without error 1`] = `\n\"FAIL __tests__/dom.test.js\n  ✕ use toBe compare two div\n  ✕ compare span and div\n\n  ● use toBe compare two div\n\n    expect(received).toBe(expected) // Object.is equality\n\n    If it should pass with deep equality, replace \"toBe\" with \"toStrictEqual\"\n\n    Expected: <div />\n    Received: serializes to the same string\n\n      12 |   const div1 = document.createElement('div');\n      13 |   const div2 = document.createElement('div');\n    > 14 |   expect(div1).toBe(div2);\n         |                ^\n      15 | });\n      16 |\n      17 | test('compare span and div', () => {\n\n      at Object.toBe (__tests__/dom.test.js:14:16)\n\n  ● compare span and div\n\n    expect(received).toBe(expected) // Object.is equality\n\n    - Expected  - 1\n    + Received  + 1\n\n    - <span />\n    + <div />\n\n      16 |\n      17 | test('compare span and div', () => {\n    > 18 |   expect(document.createElement('div')).toBe(document.createElement('span'));\n         |                                         ^\n      19 | });\n      20 |\n\n      at Object.toBe (__tests__/dom.test.js:18:41)\"\n`;\n\nexports[`should work without error 2`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"/ <reference lib=dom />","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n/// <reference lib=\"dom\" />\n\n/* global document */\n\nimport prettyFormat, {plugins} from '..';\nimport setPrettyPrint from './setPrettyPrint';\n\nconst {DOMElement} = plugins;\n\nsetPrettyPrint([DOMElement]);\n\ndescribe('pretty-format', () => {\n  // Test is not related to plugin but is related to jsdom testing environment.\n  it('prints global window as constructor name alone', () => {\n    expect(prettyFormat(globalThis)).toBe('[Window]');\n  });\n});\n\ndescribe('DOMElement Plugin', () => {\n  it('supports a single HTML element', () => {\n    expect(document.createElement('div')).toPrettyPrintTo('<div />');\n  });\n\n  it('supports an HTML element with a class property', () => {\n    const parent = document.createElement('div');\n    parent.className = 'classy';\n\n    expect(parent).toPrettyPrintTo('<div\\n  class=\"classy\"\\n/>');\n  });\n\n  it('supports an HTML element with a title property', () => {\n    const parent = document.createElement('div');\n    parent.title = 'title text';\n\n    expect(parent).toPrettyPrintTo('<div\\n  title=\"title text\"\\n/>');\n  });\n\n  test('escapes double quote in attribute value', () => {\n    const parent = document.createElement('div');\n    parent.setAttribute('title', '\"escape\"');\n\n    expect(parent).toPrettyPrintTo('<div\\n  title=\"\\\\\"escape\\\\\"\"\\n/>');\n  });\n\n  it('supports an HTML element with a single attribute', () => {\n    const parent = document.createElement('div');\n    parent.setAttribute('class', 'classy');\n\n    expect(parent).toPrettyPrintTo('<div\\n  class=\"classy\"\\n/>');\n  });\n\n  it('supports an HTML element with multiple attributes', () => {\n    const parent = document.createElement('div');\n    // set attributes in unsorted order by name to verify sorting\n    parent.setAttribute('id', '123');\n    parent.setAttribute('class', 'classy');\n\n    expect(parent).toPrettyPrintTo('<div\\n  class=\"classy\"\\n  id=\"123\"\\n/>');\n  });\n\n  it('supports an HTML element with attribute and text content', () => {\n    const parent = document.createElement('div');\n    parent.setAttribute('style', 'color: #99424F');\n    const text = document.createTextNode('Jest');\n    parent.append(text);\n\n    expect(parent).toPrettyPrintTo(\n      '<div\\n  style=\"color: #99424F\"\\n>\\n  Jest\\n</div>',\n    );\n  });\n\n  it('supports an element with text content', () => {\n    const parent = document.createElement('div');\n    const child = document.createTextNode('texty texty');\n    parent.append(child);\n\n    expect(parent).toPrettyPrintTo('<div>\\n  texty texty\\n</div>');\n  });\n\n  it('supports nested elements', () => {\n    const parent = document.createElement('div');\n    const child = document.createElement('span');\n    parent.append(child);\n    expect(parent).toPrettyPrintTo('<div>\\n  <span />\\n</div>');\n  });\n\n  it('supports nested elements with attributes', () => {\n    const parent = document.createElement('div');\n    const child = document.createElement('span');\n    parent.append(child);\n\n    // set attributes in sorted order by name\n    child.setAttribute('class', 'classy');\n    child.setAttribute('id', '123');\n\n    expect(parent).toPrettyPrintTo(\n      '<div>\\n  <span\\n    class=\"classy\"\\n    id=\"123\"\\n  />\\n</div>',\n    );\n  });\n\n  it('supports nested elements with attribute and text content', () => {\n    const parent = document.createElement('div');\n    const child = document.createElement('span');\n    parent.append(child);\n\n    child.setAttribute('style', 'color: #99424F');\n    const text = document.createTextNode('Jest');\n    child.append(text);\n\n    expect(parent).toPrettyPrintTo(\n      '<div>\\n  <span\\n    style=\"color: #99424F\"\\n  >\\n    Jest\\n  </span>\\n</div>',\n    );\n  });\n\n  it('supports nested elements with text content', () => {\n    const parent = document.createElement('div');\n    const child = document.createElement('span');\n    parent.append(child);\n    child.textContent = 'texty texty';\n\n    expect(parent).toPrettyPrintTo(\n      '<div>\\n  <span>\\n    texty texty\\n  </span>\\n</div>',\n    );\n  });\n\n  it('supports siblings', () => {\n    const parent = document.createElement('div');\n    parent.innerHTML = '<span>some </span><span>text</span>';\n\n    expect(parent).toPrettyPrintTo(\n      [\n        '<div>',\n        '  <span>',\n        '    some ',\n        '  </span>',\n        '  <span>',\n        '    text',\n        '  </span>',\n        '</div>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports multiline text node in pre', () => {\n    const parent = document.createElement('pre');\n    parent.innerHTML = [\n      // prettier-ignore\n      'function sum(a, b) {',\n      '  return a + b;',\n      '}',\n    ].join('\\n');\n\n    // Ouch. Two lines of text have same indentation for different reason:\n    // First line of text node because it is at child level.\n    // Second line of text node because they are in its content.\n    expect(parent).toPrettyPrintTo(\n      // prettier-ignore\n      [\n        '<pre>',\n        '  function sum(a, b) {',\n        '  return a + b;',\n        '}',\n        '</pre>'\n      ].join('\\n'),\n    );\n  });\n\n  it('supports multiline text node preceding span in pre', () => {\n    const parent = document.createElement('pre');\n    parent.innerHTML = [\n      '<span class=\"token keyword\">function</span> sum(a, b) {',\n      '  <span class=\"token keyword\">return</span> a + b;',\n      '}',\n    ].join('\\n');\n\n    expect(parent).toPrettyPrintTo(\n      [\n        '<pre>',\n        '  <span',\n        '    class=\"token keyword\"',\n        '  >',\n        '    function',\n        '  </span>',\n        '   sum(a, b) {',\n        '  ',\n        '  <span',\n        '    class=\"token keyword\"',\n        '  >',\n        '    return',\n        '  </span>',\n        '   a + b;',\n        '}',\n        '</pre>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports multiline text node in textarea', () => {\n    const textarea = document.createElement('textarea');\n    textarea.setAttribute('name', 'tagline');\n    textarea.innerHTML = `Painless.\nJavaScript.\nTesting.`;\n\n    expect(textarea).toPrettyPrintTo(\n      [\n        '<textarea',\n        '  name=\"tagline\"',\n        '>',\n        '  Painless.',\n        'JavaScript.',\n        'Testing.',\n        '</textarea>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports empty text node', () => {\n    // React 16 does not render text in comments (see below)\n    const parent = document.createElement('span');\n    const text = document.createTextNode('');\n    parent.append(text);\n    const abbr = document.createElement('abbr');\n    abbr.setAttribute('title', 'meter');\n    abbr.innerHTML = 'm';\n    parent.append(abbr);\n\n    expect(parent).toPrettyPrintTo(\n      [\n        '<span>',\n        '  ',\n        '  <abbr',\n        '    title=\"meter\"',\n        '  >',\n        '    m',\n        '  </abbr>',\n        '</span>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports non-empty text node', () => {\n    // React 16 does not render text in comments (see below)\n    const parent = document.createElement('p');\n    parent.innerHTML = [\n      '<strong>Jest</strong>',\n      ' means ',\n      '<em>painless</em>',\n      ' Javascript testing',\n    ].join('');\n\n    expect(parent).toPrettyPrintTo(\n      [\n        '<p>',\n        '  <strong>',\n        '    Jest',\n        '  </strong>',\n        '   means ',\n        '  <em>',\n        '    painless',\n        '  </em>',\n        '   Javascript testing',\n        '</p>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports comment node', () => {\n    // React 15 does render text in comments\n    const parent = document.createElement('p');\n    parent.innerHTML = [\n      '<strong>Jest</strong>',\n      '<!-- react-text: 3 -->',\n      ' means ',\n      '<!-- /react-text -->',\n      '<em>painless</em>',\n      '<!-- react-text: 5 -->',\n      ' Javascript testing',\n      '<!-- /react-text -->',\n    ].join('');\n\n    expect(parent).toPrettyPrintTo(\n      [\n        '<p>',\n        '  <strong>',\n        '    Jest',\n        '  </strong>',\n        '  <!-- react-text: 3 -->',\n        '   means ',\n        '  <!-- /react-text -->',\n        '  <em>',\n        '    painless',\n        '  </em>',\n        '  <!-- react-text: 5 -->',\n        '   Javascript testing',\n        '  <!-- /react-text -->',\n        '</p>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports fragment node', () => {\n    const fragment = document.createDocumentFragment();\n    const browsers = [\n      'Firefox',\n      'Chrome',\n      'Opera',\n      'Safari',\n      'Internet Explorer',\n    ];\n\n    for (const browser of browsers) {\n      const li = document.createElement('li');\n      li.textContent = browser;\n      fragment.append(li);\n    }\n\n    expect(fragment).toPrettyPrintTo(\n      [\n        '<DocumentFragment>',\n        '  <li>',\n        '    Firefox',\n        '  </li>',\n        '  <li>',\n        '    Chrome',\n        '  </li>',\n        '  <li>',\n        '    Opera',\n        '  </li>',\n        '  <li>',\n        '    Safari',\n        '  </li>',\n        '  <li>',\n        '    Internet Explorer',\n        '  </li>',\n        '</DocumentFragment>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports custom elements', () => {\n    class CustomElement extends HTMLElement {}\n    class CustomParagraphElement extends HTMLParagraphElement {}\n    class CustomExtendedElement extends CustomElement {}\n\n    customElements.define('custom-element', CustomElement);\n    customElements.define('custom-extended-element', CustomExtendedElement);\n    customElements.define('custom-paragraph', CustomParagraphElement, {\n      extends: 'p',\n    });\n    customElements.define('anonymous-element', class extends HTMLElement {});\n\n    const parent = document.createElement('div');\n    parent.innerHTML = [\n      '<custom-element></custom-element>',\n      '<custom-extended-element></custom-extended-element>',\n      '<p is=\"custom-paragraph\"></p>',\n      '<anonymous-element></anonymous-element>',\n    ].join('');\n\n    expect(parent).toPrettyPrintTo(\n      [\n        '<div>',\n        '  <custom-element />',\n        '  <custom-extended-element />',\n        '  <p',\n        '    is=\"custom-paragraph\"',\n        '  />',\n        '  <anonymous-element />',\n        '</div>',\n      ].join('\\n'),\n    );\n  });\n\n  describe('matches constructor name of SVG elements', () => {\n    // Too bad, so sad, element.constructor.name of SVG elements\n    // is HTMLUnknownElement in jsdom v9 and v10\n    // is Element in jsdom v11\n    // instead of SVG…Element in browser DOM\n    const expected = [\n      '<svg',\n      '  viewBox=\"0 0 1 1\"',\n      '>',\n      '  <title>',\n      '    JS community logo',\n      '  </title>',\n      '</svg>',\n    ].join('\\n');\n\n    test('jsdom 9 and 10', () => {\n      // Mock element objects to make sure the plugin really matches them.\n      class SVGSVGElement {\n        childNodes: Array<SVGTitleElement>;\n        nodeType = 1;\n        tagName = 'svg'; // lower case;\n\n        constructor(\n          public attributes: Array<Record<string, string>>,\n          ...children: Array<SVGTitleElement>\n        ) {\n          this.childNodes = children;\n        }\n      }\n\n      class SVGTitleElement {\n        attributes: Array<Record<string, string>> = [];\n        childNodes: Array<ChildNode>;\n        nodeType = 1;\n        tagName = 'title'; // lower case;\n\n        constructor(title: string) {\n          this.childNodes = [document.createTextNode(title)];\n        }\n      }\n\n      const title = new SVGTitleElement('JS community logo');\n      const svg = new SVGSVGElement(\n        [{name: 'viewBox', value: '0 0 1 1'}],\n        title,\n      );\n\n      expect(svg).toPrettyPrintTo(expected);\n    });\n    test('jsdom 11', () => {\n      // Mock element objects to make sure the plugin really matches them.\n      class Element {\n        childNodes: Array<Element | string>;\n        nodeType = 1;\n\n        constructor(\n          public tagName: string,\n          public attributes: Array<Record<string, string>>,\n          ...children: Array<Element | string>\n        ) {\n          this.childNodes = children;\n        }\n      }\n\n      const title = new Element('title', [], 'JS community logo');\n      const svg = new Element(\n        'svg',\n        [{name: 'viewBox', value: '0 0 1 1'}],\n        title,\n      );\n\n      expect(svg).toPrettyPrintTo(expected);\n    });\n  });\n\n  it('supports SVG elements', () => {\n    // In jsdom v9, this is NOT a regression test. See above.\n    const namespace = 'http://www.w3.org/2000/svg';\n\n    const title = document.createElementNS(namespace, 'title');\n    title.append(document.createTextNode('JS community logo'));\n\n    const rect = document.createElementNS(namespace, 'rect');\n    // printProps sorts attributes in order by name\n    rect.setAttribute('width', '1');\n    rect.setAttribute('height', '1');\n    rect.setAttribute('fill', '#f7df1e');\n\n    const polyline = document.createElementNS(namespace, 'polyline');\n    polyline.setAttribute('id', 'J');\n    polyline.setAttribute('points', '0.5,0.460 0.5,0.875 0.25,0.875');\n    const comment = document.createComment('polyline for S');\n\n    const g = document.createElementNS(namespace, 'g');\n    g.setAttribute('fill', 'none');\n    g.setAttribute('stroke', '#000000');\n    g.setAttribute('stroke-width', '0.095');\n    g.append(polyline);\n    g.append(comment);\n\n    const svg = document.createElementNS(namespace, 'svg');\n    svg.setAttribute('viewBox', '0 0 1 1');\n    svg.append(title);\n    svg.append(rect);\n    svg.append(g);\n\n    const parent = document.createElement('div');\n    parent.setAttribute('id', 'JS');\n    parent.append(svg);\n\n    expect(parent).toPrettyPrintTo(\n      [\n        '<div',\n        '  id=\"JS\"',\n        '>',\n        '  <svg',\n        '    viewBox=\"0 0 1 1\"',\n        '  >',\n        '    <title>',\n        '      JS community logo',\n        '    </title>',\n        '    <rect',\n        '      fill=\"#f7df1e\"',\n        '      height=\"1\"',\n        '      width=\"1\"',\n        '    />',\n        '    <g',\n        '      fill=\"none\"',\n        '      stroke=\"#000000\"',\n        '      stroke-width=\"0.095\"',\n        '    >',\n        '      <polyline',\n        '        id=\"J\"',\n        '        points=\"0.5,0.460 0.5,0.875 0.25,0.875\"',\n        '      />',\n        '      <!--polyline for S-->',\n        '    </g>',\n        '  </svg>',\n        '</div>',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports indentation for array of elements', () => {\n    // For example, Array.prototype.slice.call(document.getElementsByTagName(…))\n    const dd1 = document.createElement('dd');\n    dd1.innerHTML = 'to talk in a playful manner';\n\n    const dd2 = document.createElement('dd');\n    dd2.innerHTML = 'painless JavaScript testing';\n    dd2.setAttribute('style', 'color: #99424F');\n\n    expect([dd1, dd2]).toPrettyPrintTo(\n      [\n        'Array [',\n        '  <dd>',\n        '    to talk in a playful manner',\n        '  </dd>,',\n        '  <dd',\n        '    style=\"color: #99424F\"',\n        '  >',\n        '    painless JavaScript testing',\n        '  </dd>,',\n        ']',\n      ].join('\\n'),\n    );\n  });\n\n  it('supports maxDepth option', () => {\n    const dt = document.createElement('dt');\n    dt.innerHTML = 'jest';\n\n    const dd1 = document.createElement('dd');\n    dd1.innerHTML = 'to talk in a <em>playful</em> manner';\n\n    const dd2 = document.createElement('dd');\n    dd2.innerHTML = '<em>painless</em> JavaScript testing';\n    dd2.setAttribute('style', 'color: #99424F');\n\n    const dl = document.createElement('dl');\n    dl.append(dt);\n    dl.append(dd1);\n    dl.append(dd2);\n\n    expect(dl).toPrettyPrintTo(\n      [\n        '<dl>',\n        '  <dt>',\n        '    jest',\n        '  </dt>',\n        '  <dd>',\n        '    to talk in a ',\n        '    <em … />',\n        '     manner',\n        '  </dd>',\n        '  <dd',\n        '    style=\"color: #99424F\"',\n        '  >',\n        '    <em … />',\n        '     JavaScript testing',\n        '  </dd>',\n        '</dl>',\n      ].join('\\n'),\n      {maxDepth: 2},\n    );\n  });\n\n  it('handles `tagName` not being a string', () => {\n    expect({\n      name: 'value',\n      tagName: {text: 'param'},\n      type: 'string',\n    }).toPrettyPrintTo(\n      [\n        'Object {',\n        '  \"name\": \"value\",',\n        '  \"tagName\": Object {',\n        '    \"text\": \"param\",',\n        '  },',\n        '  \"type\": \"string\",',\n        '}',\n      ].join('\\n'),\n    );\n  });\n\n  it('handles jsdom attributes properly', () => {\n    const attributes = require('jsdom/lib/jsdom/living/attributes');\n    expect(DOMElement.test(attributes)).toBe(false);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJasmine();\ntest('`done()` works properly in hooks', () => {\n  const {exitCode} = runJest('done-in-hooks');\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* global window */\n\n'use strict';\n\nconst mockPerformanceMark = jest.fn();\nglobalThis.performance.mark = mockPerformanceMark;\n\ntest('fakes all APIs', () => {\n  jest.useFakeTimers();\n\n  expect(globalThis.performance.mark).not.toBe(mockPerformanceMark);\n});\n\ntest('does not fake `performance` instance', () => {\n  jest.useFakeTimers({doNotFake: ['performance']});\n\n  expect(globalThis.performance.mark).toBe(mockPerformanceMark);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {double} from '../double';\n\ntest('test double', () => {\n  expect(double(2)).toBe(4);\n});\n\ntest('test import.meta', () => {\n  expect(typeof import.meta.url).toBe('string');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst phrase = require('../common-file');\n\ntest('D', () => {\n  expect(phrase).toBe('hello');\n});"}
{"prompt":"isnt actually run,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nit(\"isn't actually run\", () => {\n  // (because it is only used for --listTests)\n  expect(true).toBe(false);\n});"}
{"prompt":"eslint-disable-next-line no-throw-leral","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst deepObject = {\n  notAnError: [{hello: true, tooDeep: {notVisible: true}}],\n};\n\ntest('Promise thrown during test', () => {\n  throw Promise.resolve(5);\n});\n\ntest('Boolean thrown during test', () => {\n  // eslint-disable-next-line no-throw-literal\n  throw false;\n});\n\ntest('undefined thrown during test', () => {\n  // eslint-disable-next-line no-throw-literal\n  throw undefined;\n});\n\ntest('Object thrown during test', () => {\n  throw deepObject;\n});\n\ntest('Object with stack prop thrown during test', () => {\n  // eslint-disable-next-line no-throw-literal\n  throw {stack: 42};\n});\n\ntest('Error during test', () => {\n  // eslint-disable-next-line no-undef\n  doesNotExist.alsoThisNot;\n});\n\ntest('done(Error)', done => {\n  done(new Error('this is an error'));\n});\n\ntest('done(non-error)', done => {\n  done(deepObject);\n});\n\ntest('returned promise rejection', () => Promise.reject(deepObject));"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('loading a file with a dynamic local require should work', () => {\n  const {withStandardResolution} = require('../dynamicRequire');\n  expect(withStandardResolution()).toBe(1);\n});\n\ntest('loading a file with a dynamic require and custom resolve should work', () => {\n  const {withCustomResolution} = require('../dynamicRequire');\n  expect(withCustomResolution()).toBe(1);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {json as runWithJson} from '../runJest';\n\nconst dir = path.resolve(__dirname, '../dynamic-require-dependencies');\n\ntest('successfully runs tests with dynamic dependencies', () => {\n  const {json} = runWithJson(dir, ['--findRelatedTests', 'dynamicRequire.js']);\n  expect(json.success).toBe(true);\n  expect(json.numTotalTests).toBe(2);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ntest('e', () => {});"}
{"prompt":"retries,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst countPath = path.join(__dirname, '.tries');\n\nbeforeAll(() => {\n  fs.writeFileSync(countPath, '0', 'utf8');\n});\n\njest.retryTimes(3);\n\nit('retries', () => {\n  const tries = Number.parseInt(fs.readFileSync(countPath, 'utf8'), 10);\n  fs.writeFileSync(countPath, `${tries + 1}`, 'utf8');\n  expect(tries).toBe(3);\n});\n\nafterAll(() => {\n  // cleanup\n  fs.unlinkSync(countPath);\n});"}
{"prompt":".concurrentretries,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\n\nconst countPath = path.join(__dirname, '.tries');\n\nbeforeAll(() => {\n  fs.writeFileSync(countPath, '0', 'utf8');\n});\n\njest.retryTimes(3);\n\nit.concurrent('retries', () => {\n  const tries = Number.parseInt(fs.readFileSync(countPath, 'utf8'), 10);\n  fs.writeFileSync(countPath, `${tries + 1}`, 'utf8');\n  expect(tries).toBe(3);\n});\n\nafterAll(() => {\n  // cleanup\n  fs.unlinkSync(countPath);\n});"}
{"prompt":".each[1, 2, 3]test%d,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit.each([1, 2, 3])('test%d', () => {\n  expect(true).toBe(true);\n});\n\ndescribe.each([1, 2])('describe%d', () => {\n  it.each([4, 5, 6])('test%d', () => {\n    expect(true).toBe(true);\n  });\n});\n\ndescribe('describe3', () => {\n  it.each([10, 11, 12])('test%d', () => {\n    expect(true).toBe(true);\n  });\n\n  describe('describe4', () => {\n    it.each([13, 14, 15])('test%d', () => {\n      expect(true).toBe(true);\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nconst dir = path.resolve(__dirname, '../each');\n\ntest('works with passing tests', () => {\n  const result = runJest(dir, ['success.test.js']);\n  expect(result.exitCode).toBe(0);\n});\n\ntest('shows error message when not enough arguments are supplied to tests', () => {\n  const result = runJest(dir, ['eachException.test.js']);\n  expect(result.exitCode).toBe(1);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('shows the correct errors in stderr when failing tests', () => {\n  const result = runJest(dir, ['failure.test.js']);\n  expect(result.exitCode).toBe(1);\n  const output = extractSummary(result.stderr)\n    .rest.split('\\n')\n    .map(line => line.trimEnd())\n    .join('\\n');\n  expect(output).toMatchSnapshot();\n});\n\ntest('shows only the tests with .only as being ran', () => {\n  const result = runJest(dir, ['eachOnly.test.js']);\n  expect(result.exitCode).toBe(0);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('shows only the tests without .skip as being ran', () => {\n  const result = runJest(dir, ['eachSkip.test.js']);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n  expect(result.exitCode).toBe(0);\n});\n\ntest('runs only the describe.only.each tests', () => {\n  const result = runJest(dir, ['describeOnly.test.js']);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n  expect(result.exitCode).toBe(0);\n});\n\ntest('formats args with pretty format when given %p', () => {\n  const result = runJest(dir, ['pretty.test.js']);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n  expect(result.exitCode).toBe(0);\n});\n\ntest('allows nullable or undefined args when templating object each args', () => {\n  const result = runJest(dir, ['eachTemplate.test.js']);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`allows nullable or undefined args when templating object each args 1`] = `\n\"PASS __tests__/eachTemplate.test.js\n  ✓ allows templating \"value\"\n  ✓ allows templating \"null\"\n  ✓ allows templating \"undefined\"\n  ✓ allows templating \"1\"\n  ✓ allows templating \"null\"\n  ✓ allows templating \"undefined\"\"\n`;\n\nexports[`formats args with pretty format when given %p 1`] = `\n\"PASS __tests__/pretty.test.js\n  array\n    ✓ \"hello\" == \"hello\"\n    ✓ 1 == 1\n    ✓ null == null\n    ✓ undefined == undefined\n    ✓ 1.2 == 1.2\n    ✓ {\"foo\": \"bar\"} == {\"foo\": \"bar\"}\n    ✓ {\"foo\": [Object]} == {\"foo\": [Object]}\n    ✓ [Function noop] == [Function noop]\n    ✓ [] == []\n    ✓ [[Object]] == [[Object]]\n    ✓ Infinity == Infinity\n    ✓ -Infinity == -Infinity\n    ✓ NaN == NaN\n  template\n    ✓ hello == hello\n    ✓ 1 == 1\n    ✓ null == null\n    ✓ undefined == undefined\n    ✓ 1.2 == 1.2\n    ✓ {\"foo\": \"bar\"} == {\"foo\": \"bar\"}\n    ✓ {\"foo\": [Object]} == {\"foo\": [Object]}\n    ✓ [Function noop] == [Function noop]\n    ✓ [] == []\n    ✓ [[Object]] == [[Object]]\n    ✓ Infinity == Infinity\n    ✓ -Infinity == -Infinity\n    ✓ NaN == NaN\"\n`;\n\nexports[`runs only the describe.only.each tests 1`] = `\n\"PASS __tests__/describeOnly.test.js\n  passes all rows expected true == true\n    ✓ passes\n    ✓ passes\n  fails all rows expected false == true\n    ○ skipped fails\"\n`;\n\nexports[`shows error message when not enough arguments are supplied to tests 1`] = `\n\"FAIL __tests__/eachException.test.js\n  ✕ throws exception when one argument too few are supplied $left == $right\n  ✕ throws exception when not enough arguments are supplied $left == $right\n\n  ● throws exception when one argument too few are supplied $left == $right\n\n    Not enough arguments supplied for given headings:\n    left | right\n\n    Received:\n    Array [\n      true,\n      true,\n      true,\n    ]\n\n    Missing 1 argument\n\n       6 |  */\n       7 |\n    >  8 | it.each\\`\n         |        ^\n       9 |   left    | right\n      10 |   \\${true} | \\${true}\n      11 |   \\${true}\n\n      at Object.<anonymous> (__tests__/eachException.test.js:8:8)\n\n  ● throws exception when not enough arguments are supplied $left == $right\n\n    Not enough arguments supplied for given headings:\n    left | right | up | down\n\n    Received:\n    Array [\n      true,\n      true,\n    ]\n\n    Missing 2 arguments\n\n      17 | );\n      18 |\n    > 19 | it.each\\`\n         |        ^\n      20 |   left    | right   | up | down\n      21 |   \\${true} | \\${true}\n      22 | \\`(\n\n      at Object.<anonymous> (__tests__/eachException.test.js:19:8)\"\n`;\n\nexports[`shows only the tests with .only as being ran 1`] = `\n\"PASS __tests__/eachOnly.test.js\n  ✓ passes one row expected true == true\n  ✓ passes one row expected true == true\n  ✓ passes one row expected true == true\n  ✓ passes one row expected true == true\n  ○ skipped Should not be ran: fails all rows expected true == false\n  ○ skipped Should not be ran: fails all rows expected true == true\n  ○ skipped Should not be ran: fails all rows expected true == false\n  ○ skipped Should not be ran: fails all rows expected true == false\"\n`;\n\nexports[`shows only the tests without .skip as being ran 1`] = `\n\"PASS __tests__/eachSkip.test.js\n  ✓ passes one row expected true == true\n  ✓ passes one row expected true == true\n  ✓ passes one row expected true == true\n  ✓ passes one row expected true == true\n  ○ skipped Should not be ran: fails all rows expected true == false\n  ○ skipped Should not be ran: fails all rows expected true == true\n  ○ skipped Should not be ran: fails all rows expected true == false\n  ○ skipped Should not be ran: fails all rows expected true == false\n  passes all rows expected true == true\n    ○ skipped passes\n    ○ skipped passes\"\n`;\n\nexports[`shows the correct errors in stderr when failing tests 1`] = `\n\"FAIL __tests__/failure.test.js\n  ✓ array table fails on one row: expected true == true\n  ✕ array table fails on one row: expected true == false\n  ✕ array table fails on all rows expected 1 == 2\n  ✕ array table fails on all rows expected 3 == 4\n  ✕ template table fails on one row expected: true == false\n  ✓ template table fails on one row expected: true == true\n  ✕ template table fails on all rows expected: 1 == 2\n  ✕ template table fails on all rows expected: 3 == 4\n  ✕ The word red contains the letter 'z'\n  ✕ The word green contains the letter 'z'\n  ✕ The word bean contains the letter 'z'\n  template table describe fails on all rows expected \"a\" == \"b\"\n    ✕ fails\n  template table describe fails on all rows expected \"c\" == \"d\"\n    ✕ fails\n  array table describe fails on all rows expected a == b\n    ✕ fails\n  array table describe fails on all rows expected c == d\n    ✕ fails\n\n  ● array table fails on one row: expected true == false\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: false\n    Received: true\n\n      10 |   [true, false],\n      11 | ])('array table fails on one row: expected %s == %s', (left, right) => {\n    > 12 |   expect(left).toBe(right);\n         |                ^\n      13 | });\n      14 |\n      15 | it.each([\n\n      at toBe (__tests__/failure.test.js:12:16)\n\n  ● array table fails on all rows expected 1 == 2\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 2\n    Received: 1\n\n      17 |   [3, 4],\n      18 | ])('array table fails on all rows expected %s == %s', (left, right) => {\n    > 19 |   expect(left).toBe(right);\n         |                ^\n      20 | });\n      21 |\n      22 | it.each\\`\n\n      at toBe (__tests__/failure.test.js:19:16)\n\n  ● array table fails on all rows expected 3 == 4\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 4\n    Received: 3\n\n      17 |   [3, 4],\n      18 | ])('array table fails on all rows expected %s == %s', (left, right) => {\n    > 19 |   expect(left).toBe(right);\n         |                ^\n      20 | });\n      21 |\n      22 | it.each\\`\n\n      at toBe (__tests__/failure.test.js:19:16)\n\n  ● template table fails on one row expected: true == false\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: false\n    Received: true\n\n      27 |   'template table fails on one row expected: $left == $right',\n      28 |   ({left, right}) => {\n    > 29 |     expect(left).toBe(right);\n         |                  ^\n      30 |   },\n      31 | );\n      32 |\n\n      at toBe (__tests__/failure.test.js:29:18)\n\n  ● template table fails on all rows expected: 1 == 2\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 2\n    Received: 1\n\n      38 |   'template table fails on all rows expected: $left == $right',\n      39 |   ({left, right}) => {\n    > 40 |     expect(left).toBe(right);\n         |                  ^\n      41 |   },\n      42 | );\n      43 |\n\n      at toBe (__tests__/failure.test.js:40:18)\n\n  ● template table fails on all rows expected: 3 == 4\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 4\n    Received: 3\n\n      38 |   'template table fails on all rows expected: $left == $right',\n      39 |   ({left, right}) => {\n    > 40 |     expect(left).toBe(right);\n         |                  ^\n      41 |   },\n      42 | );\n      43 |\n\n      at toBe (__tests__/failure.test.js:40:18)\n\n  ● The word red contains the letter 'z'\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: true\n    Received: false\n\n      45 |   \"The word %s contains the letter 'z'\",\n      46 |   word => {\n    > 47 |     expect(/z/.test(word)).toBe(true);\n         |                            ^\n      48 |   },\n      49 | );\n      50 |\n\n      at toBe (__tests__/failure.test.js:47:28)\n\n  ● The word green contains the letter 'z'\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: true\n    Received: false\n\n      45 |   \"The word %s contains the letter 'z'\",\n      46 |   word => {\n    > 47 |     expect(/z/.test(word)).toBe(true);\n         |                            ^\n      48 |   },\n      49 | );\n      50 |\n\n      at toBe (__tests__/failure.test.js:47:28)\n\n  ● The word bean contains the letter 'z'\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: true\n    Received: false\n\n      45 |   \"The word %s contains the letter 'z'\",\n      46 |   word => {\n    > 47 |     expect(/z/.test(word)).toBe(true);\n         |                            ^\n      48 |   },\n      49 | );\n      50 |\n\n      at toBe (__tests__/failure.test.js:47:28)\n\n  ● template table describe fails on all rows expected \"a\" == \"b\" › fails\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: \"b\"\n    Received: \"a\"\n\n      57 |   ({left, right}) => {\n      58 |     it('fails ', () => {\n    > 59 |       expect(left).toBe(right);\n         |                    ^\n      60 |     });\n      61 |   },\n      62 | );\n\n      at Object.toBe (__tests__/failure.test.js:59:20)\n\n  ● template table describe fails on all rows expected \"c\" == \"d\" › fails\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: \"d\"\n    Received: \"c\"\n\n      57 |   ({left, right}) => {\n      58 |     it('fails ', () => {\n    > 59 |       expect(left).toBe(right);\n         |                    ^\n      60 |     });\n      61 |   },\n      62 | );\n\n      at Object.toBe (__tests__/failure.test.js:59:20)\n\n  ● array table describe fails on all rows expected a == b › fails\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: \"b\"\n    Received: \"a\"\n\n      69 |   (left, right) => {\n      70 |     it('fails', () => {\n    > 71 |       expect(left).toBe(right);\n         |                    ^\n      72 |     });\n      73 |   },\n      74 | );\n\n      at Object.toBe (__tests__/failure.test.js:71:20)\n\n  ● array table describe fails on all rows expected c == d › fails\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: \"d\"\n    Received: \"c\"\n\n      69 |   (left, right) => {\n      70 |     it('fails', () => {\n    > 71 |       expect(left).toBe(right);\n         |                    ^\n      72 |     });\n      73 |   },\n      74 | );\n\n      at Object.toBe (__tests__/failure.test.js:71:20)\"\n`;"}
{"prompt":".each","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit.each`\n  left    | right\n  ${true} | ${true}\n  ${true}\n`(\n  'throws exception when one argument too few are supplied $left == $right',\n  ({left, right}) => {\n    expect(left).toBe(right);\n  },\n);\n\nit.each`\n  left    | right   | up | down\n  ${true} | ${true}\n`(\n  'throws exception when not enough arguments are supplied $left == $right',\n  ({left, right}) => {\n    expect(left).toBe(right);\n  },\n);"}
{"prompt":".only.each[","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable jest/no-focused-tests */\n\nit.only.each([\n  [true, true],\n  [true, true],\n])('passes one row expected %s == %s', (left, right) => {\n  expect(left).toBe(right);\n});\n\nit.each([\n  [true, false],\n  [true, true],\n])('Should not be ran: fails all rows expected %s == %s', (left, right) => {\n  expect(left).toBe(right);\n});\n\nit.only.each`\n  left    | right\n  ${true} | ${true}\n  ${true} | ${true}\n`('passes one row expected $left == $right', ({left, right}) => {\n  expect(left).toBe(right);\n});\n\nit.each`\n  left    | right\n  ${true} | ${false}\n  ${true} | ${false}\n`(\n  'Should not be ran: fails all rows expected $left == $right',\n  ({left, right}) => {\n    expect(left).toBe(right);\n  },\n);"}
{"prompt":".each[","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit.each([\n  [true, true],\n  [true, true],\n])('passes one row expected %s == %s', (left, right) => {\n  expect(left).toBe(right);\n});\n\nit.skip.each([\n  [true, false],\n  [true, true],\n])('Should not be ran: fails all rows expected %s == %s', (left, right) => {\n  expect(left).toBe(right);\n});\n\nit.each`\n  left    | right\n  ${true} | ${true}\n  ${true} | ${true}\n`('passes one row expected $left == $right', ({left, right}) => {\n  expect(left).toBe(right);\n});\n\nit.skip.each`\n  left    | right\n  ${true} | ${false}\n  ${true} | ${false}\n`(\n  'Should not be ran: fails all rows expected $left == $right',\n  ({left, right}) => {\n    expect(left).toBe(right);\n  },\n);\n\ndescribe.skip.each([\n  [true, true],\n  [true, true],\n])('passes all rows expected %s == %s', (left, right) => {\n  it('passes', () => {\n    expect(left).toBe(right);\n  });\n});"}
{"prompt":".each[","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit.each([\n  {something: {nested: 'value'}},\n  {something: null},\n  {something: undefined},\n])('allows templating \"$something.nested\"', value => {\n  expect(value).toBe(value);\n});\n\nit.each([{array: ['some value']}, {array: null}, {array: undefined}])(\n  'allows templating \"$array.length\"',\n  value => {\n    expect(value).toBe(value);\n  },\n);"}
{"prompt":"can be used with mjs files using babel-jest,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nimport {foo} from '../src/module';\n\nit('can be used with mjs files using babel-jest', () => {\n  expect(foo()).toBe('a');\n});"}
{"prompt":"Doesnt do anything.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst leakStore = [];\n\n/**\n * This exists to force a memory leak in the worker tests.\n */\nasync function leakMemory() {\n  console.log(\n    `Intentionally leaking memory: ${(\n      process.memoryUsage().heapUsed /\n      1024 /\n      1024\n    ).toFixed(2)}MB at start`,\n  );\n\n  let i = Number.MAX_SAFE_INTEGER / 2;\n  while (true) {\n    i++;\n\n    leakStore.push(i);\n  }\n}\n\nfunction fatalExitCode() {\n  process.exit(134);\n}\n\nfunction safeFunction() {\n  // Doesn't do anything.\n}\n\nmodule.exports = {\n  fatalExitCode,\n  leakMemory,\n  safeFunction,\n};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nconst dir = path.resolve(__dirname, '../empty-describe-with-hooks');\n\nskipSuiteOnJasmine();\n\ntest('hook in empty describe', () => {\n  const result = runJest(dir, ['hookInEmptyDescribe.test.js']);\n  expect(result.exitCode).toBe(1);\n  expect(extractSummary(result.stderr)).toMatchSnapshot();\n});\n\ntest('hook in describe with skipped test', () => {\n  const result = runJest(dir, ['hookInDescribeWithSkippedTest.test.js']);\n  expect(result.exitCode).toBe(0);\n  expect(extractSummary(result.stderr)).toMatchSnapshot();\n});\n\ntest('hook in empty nested describe', () => {\n  const result = runJest(dir, ['hookInEmptyNestedDescribe.test.js']);\n  expect(result.exitCode).toBe(1);\n  expect(extractSummary(result.stderr)).toMatchSnapshot();\n});\n\ntest('multiple hooks in empty describe', () => {\n  const result = runJest(dir, ['multipleHooksInEmptyDescribe.test.js']);\n  expect(result.exitCode).toBe(1);\n  expect(extractSummary(result.stderr)).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`hook in describe with skipped test 1`] = `\nObject {\n  \"rest\": \"\",\n  \"summary\": \"Test Suites: 1 skipped, 0 of 1 total\nTests:       1 skipped, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching hookInDescribeWithSkippedTest.test.js.\",\n}\n`;\n\nexports[`hook in empty describe 1`] = `\nObject {\n  \"rest\": \"FAIL __tests__/hookInEmptyDescribe.test.js\n\n\n  ● Test suite failed to run\n\n    Invalid: beforeEach() may not be used in a describe block containing no tests.\n\n       7 |\n       8 | describe('a block', () => {\n    >  9 |   beforeEach(() => {});\n         |   ^\n      10 | });\n      11 |\n      12 | describe('another block with tests', () => {\n\n      at beforeEach (__tests__/hookInEmptyDescribe.test.js:9:3)\n      at Object.describe (__tests__/hookInEmptyDescribe.test.js:8:1)\",\n  \"summary\": \"Test Suites: 1 failed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching hookInEmptyDescribe.test.js.\",\n}\n`;\n\nexports[`hook in empty nested describe 1`] = `\nObject {\n  \"rest\": \"FAIL __tests__/hookInEmptyNestedDescribe.test.js\n\n\n  ● Test suite failed to run\n\n    Invalid: beforeEach() may not be used in a describe block containing no tests.\n\n       7 |\n       8 | describe('a block', () => {\n    >  9 |   beforeEach(() => {});\n         |   ^\n      10 |   describe('another block', () => {});\n      11 | });\n      12 |\n\n      at beforeEach (__tests__/hookInEmptyNestedDescribe.test.js:9:3)\n      at Object.describe (__tests__/hookInEmptyNestedDescribe.test.js:8:1)\",\n  \"summary\": \"Test Suites: 1 failed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching hookInEmptyNestedDescribe.test.js.\",\n}\n`;\n\nexports[`multiple hooks in empty describe 1`] = `\nObject {\n  \"rest\": \"FAIL __tests__/multipleHooksInEmptyDescribe.test.js\n\n\n  ● Test suite failed to run\n\n    Invalid: beforeEach() may not be used in a describe block containing no tests.\n\n       7 |\n       8 | describe('a block', () => {\n    >  9 |   beforeEach(() => {});\n         |   ^\n      10 |   afterEach(() => {});\n      11 |   afterAll(() => {});\n      12 |   beforeAll(() => {});\n\n      at beforeEach (__tests__/multipleHooksInEmptyDescribe.test.js:9:3)\n      at Object.describe (__tests__/multipleHooksInEmptyDescribe.test.js:8:1)\n\n  ● Test suite failed to run\n\n    Invalid: afterEach() may not be used in a describe block containing no tests.\n\n       8 | describe('a block', () => {\n       9 |   beforeEach(() => {});\n    > 10 |   afterEach(() => {});\n         |   ^\n      11 |   afterAll(() => {});\n      12 |   beforeAll(() => {});\n      13 | });\n\n      at afterEach (__tests__/multipleHooksInEmptyDescribe.test.js:10:3)\n      at Object.describe (__tests__/multipleHooksInEmptyDescribe.test.js:8:1)\n\n  ● Test suite failed to run\n\n    Invalid: afterAll() may not be used in a describe block containing no tests.\n\n       9 |   beforeEach(() => {});\n      10 |   afterEach(() => {});\n    > 11 |   afterAll(() => {});\n         |   ^\n      12 |   beforeAll(() => {});\n      13 | });\n      14 |\n\n      at afterAll (__tests__/multipleHooksInEmptyDescribe.test.js:11:3)\n      at Object.describe (__tests__/multipleHooksInEmptyDescribe.test.js:8:1)\n\n  ● Test suite failed to run\n\n    Invalid: beforeAll() may not be used in a describe block containing no tests.\n\n      10 |   afterEach(() => {});\n      11 |   afterAll(() => {});\n    > 12 |   beforeAll(() => {});\n         |   ^\n      13 | });\n      14 |\n      15 | describe('another block with tests', () => {\n\n      at beforeAll (__tests__/multipleHooksInEmptyDescribe.test.js:12:3)\n      at Object.describe (__tests__/multipleHooksInEmptyDescribe.test.js:8:1)\",\n  \"summary\": \"Test Suites: 1 failed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching multipleHooksInEmptyDescribe.test.js.\",\n}\n`;"}
{"prompt":"sum,  => {};","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ndescribe('sum', () => {});"}
{"prompt":"JSON Reporter,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../empty-suite-error');\n\ndescribe('JSON Reporter', () => {\n  it('fails the test suite if it contains no tests', () => {\n    const {stderr} = runJest(DIR, []);\n    expect(stderr).toMatch('Test suite failed to run');\n    expect(stderr).toMatch('Your test suite must contain at least one test.');\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ntest('getRealSystemTime', () => {\n  expect(() => jest.getRealSystemTime()).toThrow(\n    '`jest.getRealSystemTime()` is not available when using legacy fake timers.',\n  );\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n'use strict';\n/* global document */\n\ntest('stub', () => {\n  const element = document.createElement('div');\n  expect(element).not.toBeNull();\n});"}
{"prompt":"Environment override,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest, {type RunJestResult} from '../runJest';\n\nconst getLog = (result: RunJestResult) => result.stdout.split('\\n')[1].trim();\n\ndescribe('Environment override', () => {\n  it('uses jsdom when specified', () => {\n    const result = runJest('env-test', ['--env=jsdom', 'env.test.js']);\n    expect(result.exitCode).toBe(0);\n    expect(getLog(result)).toBe('WINDOW');\n  });\n\n  it('uses node as default from package.json', () => {\n    const result = runJest('env-test', ['env.test.js']);\n    expect(result.exitCode).toBe(0);\n    expect(getLog(result)).toBe('NO WINDOW');\n  });\n\n  it('uses node when specified', () => {\n    const result = runJest('env-test', ['--env=node', 'env.test.js']);\n    expect(result.exitCode).toBe(0);\n    expect(getLog(result)).toBe('NO WINDOW');\n  });\n\n  it('fails when the env is not available', () => {\n    const result = runJest('env-test', ['--env=banana', 'env.test.js']);\n    expect(result.exitCode).toBe(1);\n  });\n});\n\ndescribe('Environment equivalent', () => {\n  it('uses jsdom', () => {\n    const result = runJest('env-test', ['--env=jsdom', 'equivalent.test.js']);\n    expect(result.exitCode).toBe(0);\n  });\n\n  it('uses node', () => {\n    const result = runJest('env-test', ['--env=node', 'equivalent.test.js']);\n    expect(result.exitCode).toBe(0);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJasmine();\n\ntest('prints useful error for environment methods after test is done w/o `waitNextEventLoopTurnForUnhandledRejectionEvents`', () => {\n  const {stderr} = runJest('environment-after-teardown');\n  const interestingLines = stderr.split('\\n').slice(9, 18).join('\\n');\n\n  expect(interestingLines).toMatchSnapshot();\n  expect(stderr.split('\\n')[9]).toBe(\n    'ReferenceError: You are trying to access a property or method of the Jest environment after it has been torn down. From __tests__/afterTeardown.test.js.',\n  );\n});\n\ntest('prints useful error for environment methods after test is done w/ `waitNextEventLoopTurnForUnhandledRejectionEvents`', () => {\n  const {stderr} = runJest('environment-after-teardown', [\n    '--waitNextEventLoopTurnForUnhandledRejectionEvents',\n  ]);\n  const interestingLines = stderr.split('\\n').slice(5, 14).join('\\n');\n\n  expect(interestingLines).toMatchSnapshot();\n  expect(stderr.split('\\n')[5]).toMatch(\n    'ReferenceError: You are trying to access a property or method of the Jest environment outside of the scope of the test code.',\n  );\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`prints useful error for environment methods after test is done w/ \\`waitNextEventLoopTurnForUnhandledRejectionEvents\\` 1`] = `\n\"    ReferenceError: You are trying to access a property or method of the Jest environment outside of the scope of the test code.\n\n       9 | test('access environment methods after done', () => {\n      10 |   setTimeout(() => {\n    > 11 |     jest.clearAllTimers();\n         |          ^\n      12 |   }, 0);\n      13 | });\n      14 |\"\n`;\n\nexports[`prints useful error for environment methods after test is done w/o \\`waitNextEventLoopTurnForUnhandledRejectionEvents\\` 1`] = `\n\"ReferenceError: You are trying to access a property or method of the Jest environment after it has been torn down. From __tests__/afterTeardown.test.js.\n\n       9 | test('access environment methods after done', () => {\n      10 |   setTimeout(() => {\n    > 11 |     jest.clearAllTimers();\n         |          ^\n      12 |   }, 0);\n      13 | });\n      14 |\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {skipSuiteOnJestCircus} from '@jest/test-utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJestCircus();\n\ntest.each`\n  jestArgs\n  ${[]}\n  ${['--waitNextEventLoopTurnForUnhandledRejectionEvents']}\n`(\n  'prints useful error for environment methods after test is done',\n  ({jestArgs}) => {\n    const {stderr} = runJest('environment-after-teardown', jestArgs);\n    const interestingLines = stderr.split('\\n').slice(9, 18).join('\\n');\n\n    expect(interestingLines).toMatchSnapshot();\n    expect(stderr.split('\\n')[9]).toBe(\n      'ReferenceError: You are trying to access a property or method of the Jest environment after it has been torn down. From __tests__/afterTeardown.test.js.',\n    );\n  },\n);"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`prints useful error for environment methods after test is done 1`] = `\n\"ReferenceError: You are trying to access a property or method of the Jest environment after it has been torn down. From __tests__/afterTeardown.test.js.\n\n       9 | test('access environment methods after done', () => {\n      10 |   setTimeout(() => {\n    > 11 |     jest.clearAllTimers();\n         |          ^\n      12 |   }, 0);\n      13 | });\n      14 |\"\n`;\n\nexports[`prints useful error for environment methods after test is done 2`] = `\n\"ReferenceError: You are trying to access a property or method of the Jest environment after it has been torn down. From __tests__/afterTeardown.test.js.\n\n       9 | test('access environment methods after done', () => {\n      10 |   setTimeout(() => {\n    > 11 |     jest.clearAllTimers();\n         |          ^\n      12 |   }, 0);\n      13 | });\n      14 |\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('found url jestjs.io', () => {\n  expect(globalThis.location.href).toBe('https://jestjs.io/');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n * @jest-environment-options {\"url\": \"https://jestjs.io/\"}\n */\n'use strict';\n\ntest('use jsdom and set the URL in this test file', () => {\n  expect(globalThis.location.href).toBe('https://jestjs.io/');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('dummy', () => {\n  throw new Error('nothing to see here');\n});"}
{"prompt":"eslint-disable-next-line unicorn/prefer-global-this","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst {isArrayBuffer} = require('util').types;\nconst isJSDOM =\n  // eslint-disable-next-line unicorn/prefer-global-this\n  typeof window !== 'undefined' && typeof document !== 'undefined';\n\nconst skipTestJSDOM = isJSDOM ? test.skip : test;\n\nskipTestJSDOM('Buffer', () => {\n  const bufFromArray = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);\n  expect(isArrayBuffer(bufFromArray.buffer)).toBeTruthy();\n  const bufFromArrayBuffer = Buffer.from(new ArrayBuffer(6));\n  expect(bufFromArrayBuffer.buffer instanceof ArrayBuffer).toBeTruthy();\n});\n\ntest.each([\n  ['Int8Array', Int8Array, isJSDOM],\n  ['Int16Array', Int16Array, isJSDOM],\n  ['Int32Array', Int32Array, isJSDOM],\n  ['Uint8Array', Uint8Array],\n  ['Uint8ClampedArray', Uint8ClampedArray, isJSDOM],\n  ['Uint16Array', Uint16Array, isJSDOM],\n  ['Uint32Array', Uint32Array, isJSDOM],\n  ['Float32Array', Float32Array, isJSDOM],\n  ['Float64Array', Float64Array, isJSDOM],\n])('%s', (name, ctor, testInstanceof = true) => {\n  const typedArray = ctor.of();\n  expect(isArrayBuffer(typedArray.buffer)).toBeTruthy();\n  if (testInstanceof) {\n    expect(typedArray.buffer instanceof ArrayBuffer).toBeTruthy();\n  }\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\ntest('a failing test', done => {\n  setTimeout(() => done('fail async'), 5);\n  done();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {skipSuiteOnJestCircus} from '@jest/test-utils';\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJestCircus();\n\nconst testFiles = [\n  'fail.test.js',\n  'jasmine.addMatchers.test.js',\n  'jasmine.any.test.js',\n  'jasmine.anything.test.js',\n  'jasmine.arrayContaining.test.js',\n  'jasmine.createSpy.test.js',\n  'jasmine.objectContaining.test.js',\n  'jasmine.stringMatching.test.js',\n  'pending.test.js',\n  'spyOn.test.js',\n  'spyOnProperty.test.js',\n  'defaultTimeoutInterval.test.js',\n];\n\nconst SHOULD_NOT_PASS_IN_JEST = new Set([\n  'fail.test.js',\n  'spyOnProperty.test.js',\n]);\n\nfor (const testFile of testFiles) {\n  test(`${testFile} errors in errorOnDeprecated mode`, () => {\n    const result = runJest('error-on-deprecated', [\n      testFile,\n      '--errorOnDeprecated',\n    ]);\n    expect(result.exitCode).toBe(1);\n    const {rest} = extractSummary(result.stderr);\n\n    expect(rest).toMatchSnapshot();\n  });\n}\n\nfor (const testFile of testFiles) {\n  const shouldPass = SHOULD_NOT_PASS_IN_JEST.has(testFile);\n\n  const expectation = `${testFile} ${shouldPass ? 'errors' : 'passes'}`;\n  const testName = `${expectation} when not in errorOnDeprecated mode`;\n\n  test(testName, () => {\n    const result = runJest('error-on-deprecated', [testFile]);\n    expect(result.exitCode).toBe(shouldPass ? 1 : 0);\n  });\n}"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`defaultTimeoutInterval.test.js errors in errorOnDeprecated mode 1`] = `\n\"FAIL __tests__/defaultTimeoutInterval.test.js\n  ✕ Default Timeout Interval\n\n  ● Default Timeout Interval\n\n    Illegal usage of \\`jasmine.DEFAULT_TIMEOUT_INTERVAL\\`, prefer \\`jest.setTimeout\\`.\n\n       8 |\n       9 | test('Default Timeout Interval', () => {\n    > 10 |   jasmine.DEFAULT_TIMEOUT_INTERVAL = 1000;\n         |                                   ^\n      11 |   expect(true).toBe(true);\n      12 | });\n      13 |\n\n      at Object.<anonymous> (__tests__/defaultTimeoutInterval.test.js:10:35)\"\n`;\n\nexports[`fail.test.js errors in errorOnDeprecated mode 1`] = `\n\"FAIL __tests__/fail.test.js\n  ✕ fail\n\n  ● fail\n\n    Illegal usage of global \\`fail\\`, prefer throwing an error, or the \\`done.fail\\` callback.\n\n      10 |   // eslint-disable-next-line no-constant-condition\n      11 |   if (true) {\n    > 12 |     fail('The truth hurts!');\n         |     ^\n      13 |   }\n      14 | });\n      15 |\n\n      at Object.fail (__tests__/fail.test.js:12:5)\"\n`;\n\nexports[`jasmine.addMatchers.test.js errors in errorOnDeprecated mode 1`] = `\n\"FAIL __tests__/jasmine.addMatchers.test.js\n  ● Test suite failed to run\n\n    Illegal usage of \\`jasmine.addMatchers\\`, prefer \\`expect.extends\\`.\n\n       7 | 'use strict';\n       8 |\n    >  9 | jasmine.addMatchers({\n         |         ^\n      10 |   theSpanishInquisition: () => ({\n      11 |     compare: (actual, expected) => ({\n      12 |       message: 'Nobdy expects the Spanish Inquisition!',\n\n      at Object.addMatchers (__tests__/jasmine.addMatchers.test.js:9:9)\"\n`;\n\nexports[`jasmine.any.test.js errors in errorOnDeprecated mode 1`] = `\n\"FAIL __tests__/jasmine.any.test.js\n  ✕ jasmine.any\n\n  ● jasmine.any\n\n    Illegal usage of \\`jasmine.any\\`, prefer \\`expect.any\\`.\n\n       8 |\n       9 | test('jasmine.any', () => {\n    > 10 |   expect({name: 'Jessie'}).toEqual({name: jasmine.any(String)});\n         |                                                   ^\n      11 | });\n      12 |\n\n      at Object.any (__tests__/jasmine.any.test.js:10:51)\"\n`;\n\nexports[`jasmine.anything.test.js errors in errorOnDeprecated mode 1`] = `\n\"FAIL __tests__/jasmine.anything.test.js\n  ✕ jasmine.anything\n\n  ● jasmine.anything\n\n    Illegal usage of \\`jasmine.anything\\`, prefer \\`expect.anything\\`.\n\n       8 |\n       9 | test('jasmine.anything', () => {\n    > 10 |   expect({input: ['some', 'stuff']}).toEqual({input: jasmine.anything()});\n         |                                                              ^\n      11 | });\n      12 |\n\n      at Object.anything (__tests__/jasmine.anything.test.js:10:62)\"\n`;\n\nexports[`jasmine.arrayContaining.test.js errors in errorOnDeprecated mode 1`] = `\n\"FAIL __tests__/jasmine.arrayContaining.test.js\n  ✕ jasmine.arrayContaining\n\n  ● jasmine.arrayContaining\n\n    Illegal usage of \\`jasmine.arrayContaining\\`, prefer \\`expect.arrayContaining\\`.\n\n       8 |\n       9 | test('jasmine.arrayContaining', () => {\n    > 10 |   expect(['some', 'stuff']).toEqual(jasmine.arrayContaining(['stuff']));\n         |                                             ^\n      11 | });\n      12 |\n\n      at Object.arrayContaining (__tests__/jasmine.arrayContaining.test.js:10:45)\"\n`;\n\nexports[`jasmine.createSpy.test.js errors in errorOnDeprecated mode 1`] = `\n\"FAIL __tests__/jasmine.createSpy.test.js\n  ✕ jasmine.createSpy\n\n  ● jasmine.createSpy\n\n    Illegal usage of \\`jasmine.createSpy\\`, prefer \\`jest.fn\\`.\n\n       8 |\n       9 | test('jasmine.createSpy', () => {\n    > 10 |   const mySpy = jasmine.createSpy();\n         |                         ^\n      11 |   mySpy('hello?');\n      12 |   expect(mySpy).toHaveBeenCalledWith('hello?');\n      13 | });\n\n      at Object.createSpy (__tests__/jasmine.createSpy.test.js:10:25)\"\n`;\n\nexports[`jasmine.objectContaining.test.js errors in errorOnDeprecated mode 1`] = `\n\"FAIL __tests__/jasmine.objectContaining.test.js\n  ✕ jasmine.objectContaining\n\n  ● jasmine.objectContaining\n\n    Illegal usage of \\`jasmine.objectContaining\\`, prefer \\`expect.objectContaining\\`.\n\n       9 | test('jasmine.objectContaining', () => {\n      10 |   expect({input: 'trash', output: 'trash'}).toEqual(\n    > 11 |     jasmine.objectContaining({output: 'trash'}),\n         |             ^\n      12 |   );\n      13 | });\n      14 |\n\n      at Object.objectContaining (__tests__/jasmine.objectContaining.test.js:11:13)\"\n`;\n\nexports[`jasmine.stringMatching.test.js errors in errorOnDeprecated mode 1`] = `\n\"FAIL __tests__/jasmine.stringMatching.test.js\n  ✕ jasmine.stringMatching\n\n  ● jasmine.stringMatching\n\n    Illegal usage of \\`jasmine.stringMatching\\`, prefer \\`expect.stringMatching\\`.\n\n       8 |\n       9 | test('jasmine.stringMatching', () => {\n    > 10 |   expect('Greetings Earthling!').toEqual(jasmine.stringMatching(/^Greetings/));\n         |                                                  ^\n      11 | });\n      12 |\n\n      at Object.stringMatching (__tests__/jasmine.stringMatching.test.js:10:50)\"\n`;\n\nexports[`pending.test.js errors in errorOnDeprecated mode 1`] = `\n\"FAIL __tests__/pending.test.js\n  ✕ pending\n\n  ● pending\n\n    Illegal usage of global \\`pending\\`, prefer explicitly skipping a test using \\`test.skip\\`\n\n      10 |   // eslint-disable-next-line no-constant-condition\n      11 |   if (true) {\n    > 12 |     pending('This test is pending.');\n         |     ^\n      13 |   }\n      14 |   expect(false).toBe(true);\n      15 | });\n\n      at Object.pending (__tests__/pending.test.js:12:5)\"\n`;\n\nexports[`spyOn.test.js errors in errorOnDeprecated mode 1`] = `\n\"FAIL __tests__/spyOn.test.js\n  ✕ spyOn\n\n  ● spyOn\n\n    Illegal usage of global \\`spyOn\\`, prefer \\`jest.spyOn\\`.\n\n      13 |\n      14 | test('spyOn', () => {\n    > 15 |   spyOn(subject, 'func').and.returnValue('bar');\n         |   ^\n      16 |   expect(subject.func()).toBe('bar');\n      17 | });\n      18 |\n\n      at Object.spyOn (__tests__/spyOn.test.js:15:3)\"\n`;\n\nexports[`spyOnProperty.test.js errors in errorOnDeprecated mode 1`] = `\n\"FAIL __tests__/spyOnProperty.test.js\n  ✕ spyOnProperty\n\n  ● spyOnProperty\n\n    Illegal usage of global \\`spyOnProperty\\`, prefer \\`jest.spyOn\\`.\n\n      22 |   };\n      23 |\n    > 24 |   const spy = spyOnProperty(obj, 'method', 'get');\n         |               ^\n      25 |\n      26 |   obj.method();\n      27 |\n\n      at Object.spyOnProperty (__tests__/spyOnProperty.test.js:24:15)\"\n`;"}
{"prompt":"Error wh cause not supported in legacy versions of node, we just polyfill it","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nfunction buildErrorWithCause(message: string, opts: {cause: unknown}): Error {\n  const error = new Error(message, opts);\n  if (opts.cause !== error.cause) {\n    // Error with cause not supported in legacy versions of node, we just polyfill it\n    Object.assign(error, opts);\n  }\n  return error;\n}\n\nfunction g() {\n  throw new Error('error during g');\n}\nfunction f() {\n  try {\n    g();\n  } catch (error) {\n    throw buildErrorWithCause('error during f', {cause: error});\n  }\n}\n\ntest('error with cause in test', () => {\n  f();\n});\n\ndescribe('describe block', () => {\n  it('error with cause in describe/it', () => {\n    f();\n  });\n\n  it('error with string cause in describe/it', () => {\n    throw buildErrorWithCause('with string cause', {\n      cause: 'here is the cause',\n    });\n  });\n});"}
{"prompt":"Error wh cause not supported in legacy versions of node, we just polyfill it","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nfunction buildErrorWithCause(message: string, opts: {cause: unknown}): Error {\n  const error = new Error(message, opts);\n  if (opts.cause !== error.cause) {\n    // Error with cause not supported in legacy versions of node, we just polyfill it\n    Object.assign(error, opts);\n  }\n  return error;\n}\n\nfunction g() {\n  throw new Error('error during g');\n}\nfunction f() {\n  try {\n    g();\n  } catch (error) {\n    throw buildErrorWithCause('error during f', {cause: error});\n  }\n}\n\ndescribe('error with cause in describe', () => {\n  f();\n});"}
{"prompt":"ErrorWithStack,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport ErrorWithStack from '../ErrorWithStack';\n\ndescribe('ErrorWithStack', () => {\n  const message = '💩 something went wrong';\n  const callsite = () => {};\n\n  it('calls Error.captureStackTrace with given callsite when capture exists', () => {\n    jest.spyOn(Error, 'captureStackTrace');\n\n    const actual = new ErrorWithStack(message, callsite);\n\n    expect(actual).toBeInstanceOf(Error);\n    expect(actual.message).toBe(message);\n    expect(Error.captureStackTrace).toHaveBeenCalledWith(actual, callsite);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {getConfig} from '../runJest';\n\ntest('reads config from cjs file', () => {\n  const {configs} = getConfig('esm-config/cjs', [], {\n    skipPkgJsonCheck: true,\n  });\n\n  expect(configs).toHaveLength(1);\n  expect(configs[0].displayName).toEqual({\n    color: 'white',\n    name: 'Config from cjs file',\n  });\n});\n\ntest('reads config from mjs file', () => {\n  const {configs} = getConfig('esm-config/mjs', [], {\n    skipPkgJsonCheck: true,\n  });\n\n  expect(configs).toHaveLength(1);\n  expect(configs[0].displayName).toEqual({\n    color: 'white',\n    name: 'Config from mjs file',\n  });\n});\n\ntest('reads config from js file when package.json#type=module', () => {\n  const {configs} = getConfig('esm-config/js', [], {\n    skipPkgJsonCheck: true,\n  });\n\n  expect(configs).toHaveLength(1);\n  expect(configs[0].displayName).toEqual({\n    color: 'white',\n    name: 'Config from js file',\n  });\n});\n\ntest('reads config from ts file when package.json#type=module', () => {\n  const {configs} = getConfig('esm-config/ts', [], {\n    skipPkgJsonCheck: true,\n  });\n\n  expect(configs).toHaveLength(1);\n  expect(configs[0].displayName).toEqual({\n    color: 'white',\n    name: 'Config from ts file',\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment ./EsmDefaultEnvironment.js\n */\n'use strict';\n\ntest('access env', () => {\n  expect(property).toBe('value'); // eslint-disable-line no-undef\n  expect(var1).toBe(false); // eslint-disable-line no-undef\n  expect(var2).toBe(true); // eslint-disable-line no-undef\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nexports.isExclusivelyManualMockModule = true;"}
{"prompt":"Make a global config that ignores all sub-projects.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {cleanup, extractSummary, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../execute-tests-once-in-mpr');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('Tests are executed only once even in an MPR', () => {\n  // Make a global config that ignores all sub-projects.\n  const config = {\n    jest: {\n      projects: ['<rootDir>', '<rootDir>/foo/*/'],\n      testPathIgnorePatterns: ['/foo/'],\n      testRegex: /my-test-.*\\.js/.source,\n    },\n  };\n\n  // Make a child config with a special regexp to ensure we execute the tests.\n  const childConfig = {\n    jest: {\n      testRegex: /my-test-.*\\.js/.source,\n    },\n  };\n\n  /* eslint-disable sort-keys */\n  writeFiles(DIR, {\n    'foo/folder/my-test-bar.js': \"test('bar', () => console.log('Bar!'));\",\n    'foo/folder/package.json': JSON.stringify(childConfig, null, 2),\n\n    'foo/directory/my-test-baz.js': \"test('baz', () => console.log('Baz!'));\",\n    'foo/directory/package.json': JSON.stringify(childConfig, null, 2),\n\n    'foo/whatever/my-test-qux.js': \"test('qux', () => console.log('Qux!'));\",\n    'foo/whatever/package.json': JSON.stringify(childConfig, null, 2),\n\n    'package.json': JSON.stringify(config, null, 2),\n  });\n  /* eslint-enable sort-keys */\n\n  const {stderr, exitCode} = runJest(DIR, ['my-test-bar.js']);\n\n  expect(exitCode).toBe(0);\n\n  const {rest, summary} = extractSummary(stderr);\n\n  // We have only one test passed, so total should equal to one, despite we have\n  // three projects.\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatch(/1 total/);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Tests are executed only once even in an MPR 1`] = `\n\"PASS foo/folder/my-test-bar.js\n  ✓ bar\"\n`;"}
{"prompt":"Replace tmpdir wh its realpath as Windows uses the 8.3 path","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {tryRealpath} from 'jest-util';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'existent-roots');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\nfunction writeConfig(rootDir: string, roots?: Array<string>) {\n  writeFiles(DIR, {\n    'jest.config.js': `\n      module.exports = ${JSON.stringify({rootDir, roots}, null, 2)};\n    `,\n    'package.json': '{}',\n  });\n}\n\ntest('error when rootDir does not exist', () => {\n  const fakeRootDir = path.join(DIR, 'foobar');\n  writeConfig(fakeRootDir);\n\n  const {exitCode, stderr} = runJest(DIR);\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toContain(\n    `Directory ${fakeRootDir} in the rootDir option was not found.`,\n  );\n});\n\ntest('error when rootDir is a file', () => {\n  // Replace tmpdir with its realpath as Windows uses the 8.3 path\n  const fakeRootDir = path\n    .join(DIR, 'jest.config.js')\n    .replace(tmpdir(), tryRealpath(tmpdir()));\n\n  writeConfig(fakeRootDir);\n\n  const {exitCode, stderr} = runJest(DIR);\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toContain(\n    `${fakeRootDir} in the rootDir option is not a directory.`,\n  );\n});\n\ntest('error when roots directory does not exist', () => {\n  const fakeRootDir = path.join(DIR, 'foobar');\n  writeConfig(DIR, ['<rootDir>', fakeRootDir]);\n\n  const {exitCode, stderr} = runJest(DIR);\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toContain(\n    `Directory ${fakeRootDir} in the roots[1] option was not found.`,\n  );\n});\n\ntest('error when roots is a file', () => {\n  const fakeRootDir = path.join(DIR, 'jest.config.js');\n  writeConfig(DIR, ['<rootDir>', fakeRootDir]);\n\n  const {exitCode, stderr} = runJest(DIR);\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toContain(\n    `${fakeRootDir} in the roots[1] option is not a directory.`,\n  );\n});"}
{"prompt":"correctly expects RegExp inside a new VM context,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst vm = require('vm');\n\nit('correctly expects RegExp inside a new VM context', () => {\n  const fn = vm.runInNewContext(\n    `(function(require, module, exports, __dirname, __filename, expect) {\n  expect('ab12cd').toMatch(/ab12cd/);\n})`,\n    globalThis,\n  );\n\n  const module = {\n    exports: {},\n  };\n\n  fn.call(\n    module.exports,\n    require,\n    module,\n    module.exports,\n    __dirname,\n    __filename,\n    expect,\n  );\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {extractSummary, runYarnInstall} from '../Utils';\nimport runJest from '../runJest';\n\nconst dir = path.resolve(__dirname, '../expect-async-matcher');\n\nbeforeAll(() => {\n  runYarnInstall(dir);\n});\n\ntest('works with passing tests', () => {\n  const result = runJest(dir, ['success.test.js']);\n  expect(result.exitCode).toBe(0);\n});\n\ntest('shows the correct errors in stderr when failing tests', () => {\n  const result = runJest(dir, ['failure.test.js']);\n\n  expect(result.exitCode).toBe(1);\n\n  const rest = extractSummary(result.stderr)\n    .rest.split('\\n')\n    .filter(line => !line.includes('packages/expect/build/index.js'))\n    .join('\\n');\n\n  expect(rest).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`shows the correct errors in stderr when failing tests 1`] = `\n\"FAIL __tests__/failure.test.js\n  ✕ fail with expected non promise values\n  ✕ fail with expected non promise values and not\n  ✕ fail with expected promise values\n  ✕ fail with expected promise values and not\n\n  ● fail with expected non promise values\n\n    Expected value to have length:\n      2\n    Received:\n      1\n    received.length:\n      1\n\n      11 |\n      12 | it('fail with expected non promise values', () =>\n    > 13 |   expect([1]).toHaveLengthAsync(Promise.resolve(2)));\n         |               ^\n      14 |\n      15 | it('fail with expected non promise values and not', () =>\n      16 |   expect([1, 2]).not.toHaveLengthAsync(Promise.resolve(2)));\n\n      at Object.toHaveLengthAsync (__tests__/failure.test.js:13:15)\n\n  ● fail with expected non promise values and not\n\n    Expected value to not have length:\n      2\n    Received:\n      1,2\n    received.length:\n      2\n\n      14 |\n      15 | it('fail with expected non promise values and not', () =>\n    > 16 |   expect([1, 2]).not.toHaveLengthAsync(Promise.resolve(2)));\n         |                      ^\n      17 |\n      18 | it('fail with expected promise values', () =>\n      19 |   expect(Promise.resolve([1])).resolves.toHaveLengthAsync(Promise.resolve(2)));\n\n      at Object.toHaveLengthAsync (__tests__/failure.test.js:16:22)\n\n  ● fail with expected promise values\n\n    Expected value to have length:\n      2\n    Received:\n      1\n    received.length:\n      1\n\n      17 |\n      18 | it('fail with expected promise values', () =>\n    > 19 |   expect(Promise.resolve([1])).resolves.toHaveLengthAsync(Promise.resolve(2)));\n         |                                         ^\n      20 |\n      21 | it('fail with expected promise values and not', () =>\n      22 |   expect(Promise.resolve([1, 2])).resolves.not.toHaveLengthAsync(\n\n      at Object.toHaveLengthAsync (__tests__/failure.test.js:19:41)\n\n  ● fail with expected promise values and not\n\n    Expected value to not have length:\n      2\n    Received:\n      1,2\n    received.length:\n      2\n\n      20 |\n      21 | it('fail with expected promise values and not', () =>\n    > 22 |   expect(Promise.resolve([1, 2])).resolves.not.toHaveLengthAsync(\n         |                                                ^\n      23 |     Promise.resolve(2),\n      24 |   ));\n      25 |\n\n      at Object.toHaveLengthAsync (__tests__/failure.test.js:22:48)\"\n`;"}
{"prompt":"expectationResultFactory,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport expectationResultFactory from '../expectationResultFactory';\n\ndescribe('expectationResultFactory', () => {\n  it('returns the result if passed.', () => {\n    const options = {\n      matcherName: 'testMatcher',\n      passed: true,\n    };\n    const result = expectationResultFactory(options);\n    expect(result).toMatchSnapshot();\n  });\n\n  it('returns the result if failed.', () => {\n    const options = {\n      actual: 'Fail',\n      expected: 'Pass',\n      matcherName: 'testMatcher',\n      passed: false,\n    };\n    const result = expectationResultFactory(options);\n    expect(result.message).toBe('thrown: undefined');\n  });\n\n  it('returns the result if failed (with `message`).', () => {\n    const message = 'This message is not \"Expected `Pass`, received `Fail`.\"';\n    const options = {\n      actual: 'Fail',\n      error: new Error('This will be ignored in `message`.'),\n      expected: 'Pass',\n      matcherName: 'testMatcher',\n      message,\n      passed: false,\n    };\n    const result = expectationResultFactory(options);\n    expect(result.message).toEqual(message);\n  });\n\n  it('returns the result if failed (with `error`).', () => {\n    const options = {\n      actual: 'Fail',\n      error: new Error('Expected `Pass`, received `Fail`.'),\n      expected: 'Pass',\n      matcherName: 'testMatcher',\n      passed: false,\n    };\n    const result = expectationResultFactory(options);\n    expect(result.message).toBe('Error: Expected `Pass`, received `Fail`.');\n  });\n\n  it('returns the error name if the error message is empty', () => {\n    const options = {\n      actual: 'Fail',\n      error: new Error(),\n      expected: 'Pass',\n      matcherName: 'testMatcher',\n      passed: false,\n    };\n    const result = expectationResultFactory(options);\n    expect(result.message).toBe('Error');\n  });\n\n  it('returns the result if failed (with `error` as a string).', () => {\n    const options = {\n      actual: 'Fail',\n      error: 'Expected `Pass`, received `Fail`.',\n      expected: 'Pass',\n      matcherName: 'testMatcher',\n      passed: false,\n    };\n    const result = expectationResultFactory(options);\n    expect(result.message).toBe('Expected `Pass`, received `Fail`.');\n  });\n\n  it('returns the result if failed (with `error.stack` not as a string).', () => {\n    const options = {\n      actual: 'Fail',\n      error: {stack: 42},\n      expected: 'Pass',\n      matcherName: 'testMatcher',\n      passed: false,\n    };\n    const result = expectationResultFactory(options);\n    expect(result.message).toMatchSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`expectationResultFactory returns the result if failed (with \\`error.stack\\` not as a string). 1`] = `\n\"thrown: Object {\n  \"stack\": 42,\n}\"\n`;\n\nexports[`expectationResultFactory returns the result if passed. 1`] = `\nObject {\n  \"error\": undefined,\n  \"matcherName\": \"testMatcher\",\n  \"message\": \"Passed.\",\n  \"passed\": true,\n  \"stack\": \"\",\n}\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('expect works correctly with RegExps created inside a VM', () => {\n  const result = runJest('expect-in-vm');\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {resolve} from 'path';\nimport {onNodeVersions} from '@jest/test-utils';\nimport {runYarnInstall} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = resolve(__dirname, '../explicit-resource-management');\n\nbeforeAll(() => {\n  runYarnInstall(DIR);\n});\n\nonNodeVersions('^18.18.0 || >=20.4.0', () => {\n  test('Explicit resource management is supported', () => {\n    const result = runJest(DIR);\n    expect(result.exitCode).toBe(0);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports = require.main;"}
{"prompt":"is available globally when matcher is unary,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {equals, iterableEquality, subsetEquality} from '@jest/expect-utils';\nimport {alignedAnsiStyleSerializer} from '@jest/test-utils';\nimport * as matcherUtils from 'jest-matcher-utils';\nimport jestExpect from '..';\n\nexpect.addSnapshotSerializer(alignedAnsiStyleSerializer);\n\njestExpect.extend({\n  toBeDivisibleBy(actual: number, expected: number) {\n    const pass = actual % expected === 0;\n    const message: () => string = pass\n      ? () =>\n          `expected ${this.utils.printReceived(\n            actual,\n          )} not to be divisible by ${expected}`\n      : () =>\n          `expected ${this.utils.printReceived(\n            actual,\n          )} to be divisible by ${expected}`;\n\n    return {message, pass};\n  },\n  toBeSymbol(actual: symbol, expected: symbol) {\n    const pass = actual === expected;\n    const message = () =>\n      `expected ${actual.toString()} to be Symbol ${expected.toString()}`;\n\n    return {message, pass};\n  },\n  toBeWithinRange(actual: number, floor: number, ceiling: number) {\n    const pass = actual >= floor && actual <= ceiling;\n    const message = pass\n      ? () =>\n          `expected ${this.utils.printReceived(\n            actual,\n          )} not to be within range ${floor} - ${ceiling}`\n      : () =>\n          `expected ${this.utils.printReceived(\n            actual,\n          )} to be within range ${floor} - ${ceiling}`;\n\n    return {message, pass};\n  },\n});\n\ndeclare module '../types' {\n  interface AsymmetricMatchers {\n    toBeDivisibleBy(expected: number): void;\n    toBeSymbol(expected: symbol): void;\n    toBeWithinRange(floor: number, ceiling: number): void;\n  }\n  interface Matchers<R> {\n    toBeDivisibleBy(expected: number): R;\n    toBeSymbol(expected: symbol): R;\n    toBeWithinRange(floor: number, ceiling: number): R;\n\n    shouldNotError(): R;\n    toFailWithoutMessage(): R;\n    toBeOne(): R;\n    toAllowOverridingExistingMatcher(): R;\n  }\n}\n\nit('is available globally when matcher is unary', () => {\n  jestExpect(15).toBeDivisibleBy(5);\n  jestExpect(15).toBeDivisibleBy(3);\n  jestExpect(15).not.toBeDivisibleBy(6);\n\n  expect(() =>\n    jestExpect(15).toBeDivisibleBy(2),\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('is available globally when matcher is variadic', () => {\n  jestExpect(15).toBeWithinRange(10, 20);\n  jestExpect(15).not.toBeWithinRange(6, 10);\n\n  expect(() =>\n    jestExpect(15).toBeWithinRange(1, 3),\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('exposes matcherUtils in context', () => {\n  jestExpect.extend({\n    shouldNotError(_actual: unknown) {\n      const pass: boolean = this.equals(\n        this.utils,\n        Object.assign(matcherUtils, {\n          iterableEquality,\n          subsetEquality,\n        }),\n      );\n      const message = pass\n        ? () => 'expected this.utils to be defined in an extend call'\n        : () => 'expected this.utils not to be defined in an extend call';\n\n      return {message, pass};\n    },\n  });\n\n  jestExpect('test').shouldNotError();\n});\n\nit('is ok if there is no message specified', () => {\n  jestExpect.extend({\n    toFailWithoutMessage(_expected: unknown) {\n      return {message: () => '', pass: false};\n    },\n  });\n\n  expect(() =>\n    jestExpect(true).toFailWithoutMessage(),\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('exposes an equality function to custom matchers', () => {\n  // jestExpect and expect share the same global state\n  expect.assertions(3);\n  jestExpect.extend({\n    toBeOne(_expected: unknown) {\n      expect(this.equals).toBe(equals);\n      return {message: () => '', pass: !!this.equals(1, 1)};\n    },\n  });\n\n  expect(() => jestExpect('test').toBeOne()).not.toThrow();\n});\n\nit('defines asymmetric unary matchers', () => {\n  expect(() =>\n    jestExpect({value: 2}).toEqual({value: jestExpect.toBeDivisibleBy(2)}),\n  ).not.toThrow();\n  expect(() =>\n    jestExpect({value: 3}).toEqual({value: jestExpect.toBeDivisibleBy(2)}),\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('defines asymmetric unary matchers that can be prefixed by not', () => {\n  expect(() =>\n    jestExpect({value: 2}).toEqual({value: jestExpect.not.toBeDivisibleBy(2)}),\n  ).toThrowErrorMatchingSnapshot();\n  expect(() =>\n    jestExpect({value: 3}).toEqual({value: jestExpect.not.toBeDivisibleBy(2)}),\n  ).not.toThrow();\n});\n\nit('defines asymmetric variadic matchers', () => {\n  expect(() =>\n    jestExpect({value: 2}).toEqual({value: jestExpect.toBeWithinRange(1, 3)}),\n  ).not.toThrow();\n  expect(() =>\n    jestExpect({value: 3}).toEqual({value: jestExpect.toBeWithinRange(4, 11)}),\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('defines asymmetric variadic matchers that can be prefixed by not', () => {\n  expect(() =>\n    jestExpect({value: 2}).toEqual({\n      value: jestExpect.not.toBeWithinRange(1, 3),\n    }),\n  ).toThrowErrorMatchingSnapshot();\n  expect(() =>\n    jestExpect({value: 3}).toEqual({\n      value: jestExpect.not.toBeWithinRange(5, 7),\n    }),\n  ).not.toThrow();\n});\n\nit('prints the Symbol into the error message', () => {\n  const foo = Symbol('foo');\n  const bar = Symbol('bar');\n\n  expect(() =>\n    jestExpect({a: foo}).toEqual({\n      a: jestExpect.toBeSymbol(bar),\n    }),\n  ).toThrowErrorMatchingSnapshot();\n});\n\nit('allows overriding existing extension', () => {\n  jestExpect.extend({\n    toAllowOverridingExistingMatcher(_expected: unknown) {\n      return {message: () => '', pass: _expected === 'bar'};\n    },\n  });\n\n  jestExpect('foo').not.toAllowOverridingExistingMatcher();\n\n  jestExpect.extend({\n    toAllowOverridingExistingMatcher(_expected: unknown) {\n      return {message: () => '', pass: _expected === 'foo'};\n    },\n  });\n\n  jestExpect('foo').toAllowOverridingExistingMatcher();\n});\n\nit('throws descriptive errors for invalid matchers', () => {\n  expect(() =>\n    jestExpect.extend({\n      // @ts-expect-error: Testing runtime error\n      default: undefined,\n    }),\n  ).toThrow(\n    'expect.extend: `default` is not a valid matcher. Must be a function, is \"undefined\"',\n  );\n  expect(() =>\n    jestExpect.extend({\n      // @ts-expect-error: Testing runtime error\n      default: 42,\n    }),\n  ).toThrow(\n    'expect.extend: `default` is not a valid matcher. Must be a function, is \"number\"',\n  );\n  expect(() =>\n    jestExpect.extend({\n      // @ts-expect-error: Testing runtime error\n      default: 'foobar',\n    }),\n  ).toThrow(\n    'expect.extend: `default` is not a valid matcher. Must be a function, is \"string\"',\n  );\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`defines asymmetric unary matchers 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"value\": toBeDivisibleBy<2>,</>\n<r>+   \"value\": 3,</>\n<d>  }</>\n`;\n\nexports[`defines asymmetric unary matchers that can be prefixed by not 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"value\": not.toBeDivisibleBy<2>,</>\n<r>+   \"value\": 2,</>\n<d>  }</>\n`;\n\nexports[`defines asymmetric variadic matchers 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"value\": toBeWithinRange<4, 11>,</>\n<r>+   \"value\": 3,</>\n<d>  }</>\n`;\n\nexports[`defines asymmetric variadic matchers that can be prefixed by not 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"value\": not.toBeWithinRange<1, 3>,</>\n<r>+   \"value\": 2,</>\n<d>  }</>\n`;\n\nexports[`is available globally when matcher is unary 1`] = `expected <r>15</> to be divisible by 2`;\n\nexports[`is available globally when matcher is variadic 1`] = `expected <r>15</> to be within range 1 - 3`;\n\nexports[`is ok if there is no message specified 1`] = `<r>No message was specified for this matcher.</>`;\n\nexports[`prints the Symbol into the error message 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": toBeSymbol<Symbol(bar)>,</>\n<r>+   \"a\": Symbol(foo),</>\n<d>  }</>\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst vm = require('vm');\nconst filePath = path.resolve(__dirname, '../package/vmscript.js');\n\ntest('extract coverage', () => {\n  const content = fs.readFileSync(filePath, {encoding: 'utf8'});\n\n  const case1 = vm.runInNewContext(\n    content,\n    {\n      inputObject: {\n        number: 0,\n      },\n    },\n    {\n      filename: filePath,\n    },\n  );\n\n  const case2 = vm.runInNewContext(\n    content,\n    {\n      inputObject: {\n        number: 7,\n      },\n    },\n    {\n      filename: filePath,\n    },\n  );\n\n  expect(case1).toBe(false);\n  expect(case2).toBe(true);\n});"}
{"prompt":"eslint-disable-next-line no-constant-condion","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('fail', () => {\n  // eslint-disable-next-line no-constant-condition\n  if (true) {\n    fail('The truth hurts!');\n  }\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* global document */\n\ntest('a failed assertion comparing a DOM node does not crash Jest', () => {\n  expect(document.body).toBeNull();\n});"}
{"prompt":"FailedTestsCache,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport FailedTestsCache from '../FailedTestsCache';\n\ndescribe('FailedTestsCache', () => {\n  test('should filter tests', () => {\n    const failedTestsCache = new FailedTestsCache();\n    failedTestsCache.setTestResults([\n      {\n        numFailingTests: 0,\n        testFilePath: '/path/to/passing.js',\n        testResults: [\n          {fullName: 'test 1', status: 'passed'},\n          {fullName: 'test 2', status: 'passed'},\n        ],\n      },\n      {\n        numFailingTests: 2,\n        testFilePath: '/path/to/failed_1.js',\n        testResults: [\n          {fullName: 'test 3', status: 'failed'},\n          {fullName: 'test 4', status: 'failed'},\n        ],\n      },\n      {\n        numFailingTests: 1,\n        testFilePath: '/path/to/failed_2.js',\n        testResults: [\n          {fullName: 'test 5', status: 'failed'},\n          {fullName: 'test 6', status: 'passed'},\n        ],\n      },\n    ]);\n\n    const result = failedTestsCache.filterTests([\n      {\n        path: '/path/to/passing.js',\n      },\n      {\n        path: '/path/to/failed_1.js',\n      },\n      {\n        path: '/path/to/failed_2.js',\n      },\n      {\n        path: '/path/to/unknown.js',\n      },\n    ]);\n    expect(result).toMatchObject([\n      {\n        path: '/path/to/failed_1.js',\n      },\n      {\n        path: '/path/to/failed_2.js',\n      },\n    ]);\n  });\n});"}
{"prompt":"FailedTestsInteractive,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport FailedTestsInteractivePlugin from '../FailedTestsInteractive';\n\ndescribe('FailedTestsInteractive', () => {\n  it('returns usage info when failing tests are present', () => {\n    expect(new FailedTestsInteractivePlugin({}).getUsageInfo()).toBeNull();\n\n    const mockUpdate = jest.fn();\n    const activateablePlugin = new FailedTestsInteractivePlugin({});\n    const testAggregate = {\n      snapshot: {},\n      testResults: [\n        {\n          testFilePath: '/tmp/mock-path',\n          testResults: [{fullName: 'test-name', status: 'failed'}],\n        },\n      ],\n    };\n    let mockCallback;\n\n    activateablePlugin.apply({\n      onTestRunComplete: callback => {\n        mockCallback = callback;\n      },\n    });\n\n    mockCallback(testAggregate);\n    activateablePlugin.run(null, mockUpdate);\n\n    expect(activateablePlugin.getUsageInfo()).toEqual({\n      key: 'i',\n      prompt: 'run failing tests interactively',\n    });\n    expect(mockUpdate).toHaveBeenCalledWith({\n      mode: 'watch',\n      testNamePattern: `^${testAggregate.testResults[0].testResults[0].fullName}$`,\n      testPathPatterns: [testAggregate.testResults[0].testFilePath],\n    });\n  });\n});"}
{"prompt":"FailedTestsInteractiveMode,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport {specialChars} from 'jest-util';\nimport FailedTestsInteractiveMode from '../FailedTestsInteractiveMode';\n\nconst {ARROW} = specialChars;\n\ndescribe('FailedTestsInteractiveMode', () => {\n  describe('updateWithResults', () => {\n    it('renders usage information when all failures resolved', () => {\n      const mockWrite = jest.fn();\n\n      new FailedTestsInteractiveMode({write: mockWrite}).updateWithResults({\n        numFailedTests: 1,\n        snapshot: {},\n      });\n\n      expect(mockWrite).toHaveBeenCalledWith(\n        `${chalk.bold('Watch Usage')}\\n${chalk.dim(\n          `${ARROW}Press`,\n        )} Enter ${chalk.dim('to return to watch mode.')}\\n`,\n      );\n    });\n  });\n\n  it('is inactive at construction', () => {\n    expect(new FailedTestsInteractiveMode().isActive()).toBeFalsy();\n  });\n\n  it('skips activation when no failed tests are present', () => {\n    const plugin = new FailedTestsInteractiveMode();\n\n    plugin.run([]);\n    expect(plugin.isActive()).toBeFalsy();\n\n    plugin.run([{}]);\n    expect(plugin.isActive()).toBeTruthy();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`snapshot this one makes not toMatchSnapshot assertion, but has a .snap file 1`] = `\"normal\"`;"}
{"prompt":"fails,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {error} from '../lib';\n\nit('fails', () => {\n  error();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`snapshot this one makes not toMatchSnapshot assertion, but has a .snap file 1`] = `\"normal\"`;"}
{"prompt":"fails because there is no strip-flow-types transform","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n// fails because there is no `strip-flow-types` transform\nconst thisFunctionIsNeverInstrumented = (a: string) => null;\n\ntest('this is never called', () => {\n  thisFunctionIsNeverInstrumented();\n});"}
{"prompt":"fail with expected non promise values,  =>","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {toHaveLengthAsync} from '../matchers';\n\nexpect.extend({toHaveLengthAsync});\n\nit('fail with expected non promise values', () =>\n  expect([1]).toHaveLengthAsync(Promise.resolve(2)));\n\nit('fail with expected non promise values and not', () =>\n  expect([1, 2]).not.toHaveLengthAsync(Promise.resolve(2)));\n\nit('fail with expected promise values', () =>\n  expect(Promise.resolve([1])).resolves.toHaveLengthAsync(Promise.resolve(2)));\n\nit('fail with expected promise values and not', () =>\n  expect(Promise.resolve([1, 2])).resolves.not.toHaveLengthAsync(\n    Promise.resolve(2),\n  ));"}
{"prompt":"safety check: if the reporter errors ll show up here","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {isJestJasmineRun} from '@jest/test-utils';\nimport runJest from '../runJest';\n\nconst removeStackTraces = (stdout: string) =>\n  stdout.replaceAll(\n    /at (new Promise \\(<anonymous>\\)|.+:\\d+:\\d+\\)?)/g,\n    'at <stacktrace>',\n  );\n\ntest('that the failureDetails property is set', () => {\n  const {stdout, stderr} = runJest('failureDetails-property', [\n    'tests.test.js',\n  ]);\n\n  // safety check: if the reporter errors it'll show up here\n  expect(stderr).toBe('');\n\n  const output = JSON.parse(removeStackTraces(stdout));\n\n  if (isJestJasmineRun()) {\n    expect(output).toMatchInlineSnapshot(`\n      Array [\n        Array [\n          Object {\n            \"actual\": \"\",\n            \"error\": Object {\n              \"matcherResult\": Object {\n                \"actual\": true,\n                \"expected\": false,\n                \"message\": \"expect(received).toBe(expected) // Object.is equality\n\n      Expected: false\n      Received: true\",\n                \"name\": \"toBe\",\n                \"pass\": false,\n              },\n            },\n            \"expected\": \"\",\n            \"matcherName\": \"\",\n            \"message\": \"Error: expect(received).toBe(expected) // Object.is equality\n\n      Expected: false\n      Received: true\",\n            \"passed\": false,\n            \"stack\": \"Error: expect(received).toBe(expected) // Object.is equality\n\n      Expected: false\n      Received: true\n          at <stacktrace>\",\n          },\n        ],\n        Array [\n          Object {\n            \"actual\": \"\",\n            \"error\": Object {\n              \"matcherResult\": Object {\n                \"actual\": true,\n                \"expected\": false,\n                \"message\": \"expect(received).toBe(expected) // Object.is equality\n\n      Expected: false\n      Received: true\",\n                \"name\": \"toBe\",\n                \"pass\": false,\n              },\n            },\n            \"expected\": \"\",\n            \"matcherName\": \"\",\n            \"message\": \"Error: expect(received).toBe(expected) // Object.is equality\n\n      Expected: false\n      Received: true\",\n            \"passed\": false,\n            \"stack\": \"Error: expect(received).toBe(expected) // Object.is equality\n\n      Expected: false\n      Received: true\n          at <stacktrace>\",\n          },\n        ],\n        Array [\n          Object {\n            \"actual\": \"\",\n            \"error\": Object {\n              \"matcherResult\": Object {\n                \"actual\": \"{\n        \"p1\": \"hello\",\n        \"p2\": \"world\",\n      }\",\n                \"expected\": \"{\n        \"p1\": \"hello\",\n        \"p2\": \"sunshine\",\n      }\",\n                \"message\": \"expect(received).toMatchInlineSnapshot(snapshot)\n\n      Snapshot name: \\`my test a snapshot failure 1\\`\n\n      - Snapshot  - 1\n      + Received  + 1\n\n        {\n          \"p1\": \"hello\",\n      -   \"p2\": \"sunshine\",\n      +   \"p2\": \"world\",\n        }\",\n                \"name\": \"toMatchInlineSnapshot\",\n                \"pass\": false,\n              },\n            },\n            \"expected\": \"\",\n            \"matcherName\": \"\",\n            \"message\": \"expect(received).toMatchInlineSnapshot(snapshot)\n\n      Snapshot name: \\`my test a snapshot failure 1\\`\n\n      - Snapshot  - 1\n      + Received  + 1\n\n        {\n          \"p1\": \"hello\",\n      -   \"p2\": \"sunshine\",\n      +   \"p2\": \"world\",\n        }\",\n            \"passed\": false,\n            \"stack\": \"Error: expect(received).toMatchInlineSnapshot(snapshot)\n\n      Snapshot name: \\`my test a snapshot failure 1\\`\n\n      - Snapshot  - 1\n      + Received  + 1\n\n        {\n          \"p1\": \"hello\",\n      -   \"p2\": \"sunshine\",\n      +   \"p2\": \"world\",\n        }\n          at <stacktrace>\",\n          },\n        ],\n        Array [\n          Object {\n            \"actual\": \"\",\n            \"error\": Object {},\n            \"expected\": \"\",\n            \"matcherName\": \"\",\n            \"message\": \"Error\",\n            \"passed\": false,\n            \"stack\": \"Error: \n          at <stacktrace>\",\n          },\n        ],\n        Array [\n          Object {\n            \"actual\": \"\",\n            \"error\": Object {\n              \"message\": \"expect(received).rejects.toThrow()\n\n      Received promise resolved instead of rejected\n      Resolved to value: 1\",\n            },\n            \"expected\": \"\",\n            \"matcherName\": \"\",\n            \"message\": \"Error: expect(received).rejects.toThrow()\n\n      Received promise resolved instead of rejected\n      Resolved to value: 1\",\n            \"passed\": false,\n            \"stack\": \"Error: expect(received).rejects.toThrow()\n\n      Received promise resolved instead of rejected\n      Resolved to value: 1\n          at <stacktrace>\",\n          },\n        ],\n      ]\n    `);\n  } else {\n    expect(output).toMatchInlineSnapshot(`\n      Array [\n        Array [\n          Object {\n            \"matcherResult\": Object {\n              \"actual\": true,\n              \"expected\": false,\n              \"message\": \"expect(received).toBe(expected) // Object.is equality\n\n      Expected: false\n      Received: true\",\n              \"name\": \"toBe\",\n              \"pass\": false,\n            },\n          },\n        ],\n        Array [\n          Object {\n            \"matcherResult\": Object {\n              \"actual\": true,\n              \"expected\": false,\n              \"message\": \"expect(received).toBe(expected) // Object.is equality\n\n      Expected: false\n      Received: true\",\n              \"name\": \"toBe\",\n              \"pass\": false,\n            },\n          },\n        ],\n        Array [\n          Object {\n            \"matcherResult\": Object {\n              \"actual\": \"{\n        \"p1\": \"hello\",\n        \"p2\": \"world\",\n      }\",\n              \"expected\": \"{\n        \"p1\": \"hello\",\n        \"p2\": \"sunshine\",\n      }\",\n              \"message\": \"expect(received).toMatchInlineSnapshot(snapshot)\n\n      Snapshot name: \\`my test a snapshot failure 1\\`\n\n      - Snapshot  - 1\n      + Received  + 1\n\n        {\n          \"p1\": \"hello\",\n      -   \"p2\": \"sunshine\",\n      +   \"p2\": \"world\",\n        }\",\n              \"name\": \"toMatchInlineSnapshot\",\n              \"pass\": false,\n            },\n          },\n        ],\n        Array [\n          Object {},\n        ],\n        Array [\n          Object {\n            \"message\": \"expect(received).rejects.toThrow()\n\n      Received promise resolved instead of rejected\n      Resolved to value: 1\",\n          },\n        ],\n      ]\n    `);\n  }\n});"}
{"prompt":"Remove replacements when jasmine is gone","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {extractSummary, runYarnInstall} from '../Utils';\nimport runJest from '../runJest';\n\nconst dir = path.resolve(__dirname, '../failures');\n\nconst normalizeDots = (text: string) => text.replaceAll(/\\.+$/gm, '.');\n\nfunction cleanStderr(stderr: string) {\n  const {rest} = extractSummary(stderr);\n  return rest\n    .replaceAll(/.*(jest-jasmine2|jest-circus).*\\n/g, '')\n    .replaceAll(new RegExp('Failed: Object {', 'g'), 'thrown: Object {');\n}\n\nbeforeAll(() => {\n  runYarnInstall(dir);\n});\n\ntest('not throwing Error objects', () => {\n  let stderr;\n  stderr = runJest(dir, ['throwNumber.test.js']).stderr;\n  expect(cleanStderr(stderr)).toMatchSnapshot();\n  stderr = runJest(dir, ['throwString.test.js']).stderr;\n  expect(cleanStderr(stderr)).toMatchSnapshot();\n  stderr = runJest(dir, ['throwObject.test.js']).stderr;\n  expect(cleanStderr(stderr)).toMatchSnapshot();\n  stderr = runJest(dir, ['assertionCount.test.js']).stderr;\n  expect(cleanStderr(stderr)).toMatchSnapshot();\n  stderr = runJest(dir, ['duringTests.test.js']).stderr;\n  expect(cleanStderr(stderr)).toMatchSnapshot();\n  stderr = runJest(dir, ['throwObjectWithStackProp.test.js']).stderr;\n  expect(cleanStderr(stderr)).toMatchSnapshot();\n});\n\ntest('works with node assert', () => {\n  const {stderr} = runJest(dir, ['assertionError.test.js']);\n  const summary = normalizeDots(cleanStderr(stderr));\n\n  expect(summary).toMatchSnapshot();\n});\n\ntest('works with assertions in separate files', () => {\n  const {stderr} = runJest(dir, ['testMacro.test.js']);\n\n  expect(normalizeDots(cleanStderr(stderr))).toMatchSnapshot();\n});\n\ntest('works with async failures', () => {\n  const {stderr} = runJest(dir, ['asyncFailures.test.js']);\n\n  const rest = cleanStderr(stderr)\n    .split('\\n')\n    .filter(line => !line.includes('packages/expect/build/index.js'))\n    .join('\\n');\n\n  // Remove replacements when jasmine is gone\n  const result = normalizeDots(rest)\n    .replace(/.*thrown:.*\\n/, '')\n    .replace(\n      /.*Add a timeout value to this test to increase the timeout, if this is a long-running test. See https:\\/\\/jestjs.io\\/docs\\/api#testname-fn-timeout.+/,\n      '<REPLACED>',\n    )\n    .replace(/.*Timeout - Async callback was not.*/, '<REPLACED>');\n\n  expect(result).toMatchSnapshot();\n});\n\ntest('works with snapshot failures', () => {\n  const {stderr} = runJest(dir, ['snapshot.test.js']);\n\n  const result = normalizeDots(cleanStderr(stderr));\n\n  expect(result.slice(0, result.indexOf('Snapshot Summary'))).toMatchSnapshot();\n});\n\ntest('works with snapshot failures with hint', () => {\n  const {stderr} = runJest(dir, ['snapshotWithHint.test.js']);\n\n  const result = normalizeDots(cleanStderr(stderr));\n\n  expect(result.slice(0, result.indexOf('Snapshot Summary'))).toMatchSnapshot();\n});\n\ntest('works with error with cause', () => {\n  const {stderr} = runJest(dir, ['errorWithCause.test.js']);\n  const summary = normalizeDots(cleanStderr(stderr));\n\n  expect(summary).toMatchSnapshot();\n});\n\ntest('works with error with cause thrown outside tests', () => {\n  const {stderr} = runJest(dir, ['errorWithCauseInDescribe.test.js']);\n  const summary = normalizeDots(cleanStderr(stderr));\n\n  const sanitizedSummary = summary\n    .replaceAll(' Suite.f ', ' f ') // added by jasmine runner\n    .split('\\n')\n    .map(line => line.trim()) // jasmine runner does not come with the same indentation\n    .join('\\n');\n\n  expect(\n    // jasmine runner differ from circus one in this case, we just start\n    // the comparison when the stack starts to be reported\n    sanitizedSummary.slice(sanitizedSummary.indexOf('error during f')),\n  ).toMatchSnapshot();\n});\n\ntest('errors after test has completed', () => {\n  const {stderr} = runJest(dir, ['errorAfterTestComplete.test.js']);\n\n  expect(stderr).toMatch(\n    /Error(WithStack)?: Caught error after test environment was torn down/,\n  );\n  expect(stderr).toMatch(/Failed: \"fail async\"/);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`not throwing Error objects 1`] = `\n\"FAIL __tests__/throwNumber.test.js\n  ● Test suite failed to run\n\n    Expected an Error, but \"1\" was thrown\"\n`;\n\nexports[`not throwing Error objects 2`] = `\n\"FAIL __tests__/throwString.test.js\n  ● Test suite failed to run\n\n    banana\"\n`;\n\nexports[`not throwing Error objects 3`] = `\n\"FAIL __tests__/throwObject.test.js\n  ● Test suite failed to run\n\n    thrown: Object {}\"\n`;\n\nexports[`not throwing Error objects 4`] = `\n\"FAIL __tests__/assertionCount.test.js\n  .assertions()\n    ✕ throws\n    ✕ throws on redeclare of assertion count\n    ✕ throws on assertion\n  .hasAssertions()\n    ✕ throws when there are not assertions\n\n  ● .assertions() › throws\n\n    expect(received).toBeTruthy()\n\n    Received: false\n\n      10 | const throws = () => {\n      11 |   expect.assertions(2);\n    > 12 |   expect(false).toBeTruthy();\n         |                 ^\n      13 | };\n      14 | const redeclare = () => {\n      15 |   expect.assertions(1);\n\n      at Object.toBeTruthy (__tests__/assertionCount.test.js:12:17)\n\n  ● .assertions() › throws\n\n    expect.assertions(2)\n\n    Expected two assertions to be called but received one assertion call.\n\n       9 |\n      10 | const throws = () => {\n    > 11 |   expect.assertions(2);\n         |          ^\n      12 |   expect(false).toBeTruthy();\n      13 | };\n      14 | const redeclare = () => {\n\n      at Object.assertions (__tests__/assertionCount.test.js:11:10)\n\n  ● .assertions() › throws on redeclare of assertion count\n\n    expect(received).toBeTruthy()\n\n    Received: false\n\n      14 | const redeclare = () => {\n      15 |   expect.assertions(1);\n    > 16 |   expect(false).toBeTruthy();\n         |                 ^\n      17 |   expect.assertions(2);\n      18 | };\n      19 |\n\n      at Object.toBeTruthy (__tests__/assertionCount.test.js:16:17)\n\n  ● .assertions() › throws on assertion\n\n    expect.assertions(0)\n\n    Expected zero assertions to be called but received one assertion call.\n\n      19 |\n      20 | const noAssertions = () => {\n    > 21 |   expect.assertions(0);\n         |          ^\n      22 |   expect(true).toBeTruthy();\n      23 | };\n      24 |\n\n      at Object.assertions (__tests__/assertionCount.test.js:21:10)\n\n  ● .hasAssertions() › throws when there are not assertions\n\n    expect.hasAssertions()\n\n    Expected at least one assertion to be called but received none.\n\n      24 |\n      25 | const hasNoAssertions = () => {\n    > 26 |   expect.hasAssertions();\n         |          ^\n      27 | };\n      28 |\n      29 | describe('.assertions()', () => {\n\n      at Object.hasAssertions (__tests__/assertionCount.test.js:26:10)\"\n`;\n\nexports[`not throwing Error objects 5`] = `\n\"FAIL __tests__/duringTests.test.js\n  ✕ Promise thrown during test\n  ✕ Boolean thrown during test\n  ✕ undefined thrown during test\n  ✕ Object thrown during test\n  ✕ Object with stack prop thrown during test\n  ✕ Error during test\n  ✕ done(Error)\n  ✕ done(non-error)\n  ✕ returned promise rejection\n\n  ● Promise thrown during test\n\n    thrown: Promise {}\n\n      12 | };\n      13 |\n    > 14 | test('Promise thrown during test', () => {\n         | ^\n      15 |   throw Promise.resolve(5);\n      16 | });\n      17 |\n\n      at Object.test (__tests__/duringTests.test.js:14:1)\n\n  ● Boolean thrown during test\n\n    thrown: false\n\n      16 | });\n      17 |\n    > 18 | test('Boolean thrown during test', () => {\n         | ^\n      19 |   // eslint-disable-next-line no-throw-literal\n      20 |   throw false;\n      21 | });\n\n      at Object.test (__tests__/duringTests.test.js:18:1)\n\n  ● undefined thrown during test\n\n    thrown: undefined\n\n      21 | });\n      22 |\n    > 23 | test('undefined thrown during test', () => {\n         | ^\n      24 |   // eslint-disable-next-line no-throw-literal\n      25 |   throw undefined;\n      26 | });\n\n      at Object.test (__tests__/duringTests.test.js:23:1)\n\n  ● Object thrown during test\n\n    thrown: Object {\n      \"notAnError\": Array [\n        Object {\n          \"hello\": true,\n          \"tooDeep\": [Object],\n        },\n      ],\n    }\n\n      26 | });\n      27 |\n    > 28 | test('Object thrown during test', () => {\n         | ^\n      29 |   throw deepObject;\n      30 | });\n      31 |\n\n      at Object.test (__tests__/duringTests.test.js:28:1)\n\n  ● Object with stack prop thrown during test\n\n    thrown: Object {\n      \"stack\": 42,\n    }\n\n      30 | });\n      31 |\n    > 32 | test('Object with stack prop thrown during test', () => {\n         | ^\n      33 |   // eslint-disable-next-line no-throw-literal\n      34 |   throw {stack: 42};\n      35 | });\n\n      at Object.test (__tests__/duringTests.test.js:32:1)\n\n  ● Error during test\n\n    ReferenceError: doesNotExist is not defined\n\n      37 | test('Error during test', () => {\n      38 |   // eslint-disable-next-line no-undef\n    > 39 |   doesNotExist.alsoThisNot;\n         |   ^\n      40 | });\n      41 |\n      42 | test('done(Error)', done => {\n\n      at Object.doesNotExist (__tests__/duringTests.test.js:39:3)\n\n  ● done(Error)\n\n    this is an error\n\n      41 |\n      42 | test('done(Error)', done => {\n    > 43 |   done(new Error('this is an error'));\n         |        ^\n      44 | });\n      45 |\n      46 | test('done(non-error)', done => {\n\n      at Object.<anonymous> (__tests__/duringTests.test.js:43:8)\n\n  ● done(non-error)\n\n    thrown: Object {\n      \"notAnError\": Array [\n        Object {\n          \"hello\": true,\n          \"tooDeep\": [Object],\n        },\n      ],\n    }\n\n      45 |\n      46 | test('done(non-error)', done => {\n    > 47 |   done(deepObject);\n         |   ^\n      48 | });\n      49 |\n      50 | test('returned promise rejection', () => Promise.reject(deepObject));\n\n      at Object.done (__tests__/duringTests.test.js:47:3)\n\n  ● returned promise rejection\n\n    thrown: Object {\n      \"notAnError\": Array [\n        Object {\n          \"hello\": true,\n          \"tooDeep\": [Object],\n        },\n      ],\n    }\n\n      48 | });\n      49 |\n    > 50 | test('returned promise rejection', () => Promise.reject(deepObject));\n         | ^\n      51 |\n\n      at Object.test (__tests__/duringTests.test.js:50:1)\"\n`;\n\nexports[`not throwing Error objects 6`] = `\n\"FAIL __tests__/throwObjectWithStackProp.test.js\n  ● Test suite failed to run\n\n    thrown: Object {\n\n        \"stack\": 42,\n      }\"\n`;\n\nexports[`works with assertions in separate files 1`] = `\n\"FAIL __tests__/testMacro.test.js\n  ✕ use some imported macro to make assertion\n\n  ● use some imported macro to make assertion\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: 2\n    Received: 1\n\n       8 |\n       9 | module.exports = (one: any, two: any) => {\n    > 10 |   expect(one).toEqual(two);\n         |               ^\n      11 | };\n      12 |\n\n      at toEqual (macros.js:10:15)\n      at Object.shouldEqual (__tests__/testMacro.test.js:13:3)\"\n`;\n\nexports[`works with async failures 1`] = `\n\"FAIL __tests__/asyncFailures.test.js\n  ✕ resolve, but fail\n  ✕ reject, but fail\n  ✕ expect reject\n  ✕ expect resolve\n  ✕ timeout\n\n  ● resolve, but fail\n\n    expect(received).resolves.toEqual(expected) // deep equality\n\n    - Expected  - 1\n    + Received  + 1\n\n      Object {\n    -   \"baz\": \"bar\",\n    +   \"foo\": \"bar\",\n      }\n\n       9 |\n      10 | test('resolve, but fail', () =>\n    > 11 |   expect(Promise.resolve({foo: 'bar'})).resolves.toEqual({baz: 'bar'}));\n         |                                                  ^\n      12 |\n      13 | test('reject, but fail', () =>\n      14 |   expect(Promise.reject({foo: 'bar'})).rejects.toEqual({baz: 'bar'}));\n\n      at Object.toEqual (__tests__/asyncFailures.test.js:11:50)\n\n  ● reject, but fail\n\n    expect(received).rejects.toEqual(expected) // deep equality\n\n    - Expected  - 1\n    + Received  + 1\n\n      Object {\n    -   \"baz\": \"bar\",\n    +   \"foo\": \"bar\",\n      }\n\n      12 |\n      13 | test('reject, but fail', () =>\n    > 14 |   expect(Promise.reject({foo: 'bar'})).rejects.toEqual({baz: 'bar'}));\n         |                                                ^\n      15 |\n      16 | test('expect reject', () =>\n      17 |   expect(Promise.resolve({foo: 'bar'})).rejects.toEqual({foo: 'bar'}));\n\n      at Object.toEqual (__tests__/asyncFailures.test.js:14:48)\n\n  ● expect reject\n\n    expect(received).rejects.toEqual()\n\n    Received promise resolved instead of rejected\n    Resolved to value: {\"foo\": \"bar\"}\n\n      15 |\n      16 | test('expect reject', () =>\n    > 17 |   expect(Promise.resolve({foo: 'bar'})).rejects.toEqual({foo: 'bar'}));\n         |   ^\n      18 |\n      19 | test('expect resolve', () =>\n      20 |   expect(Promise.reject({foo: 'bar'})).resolves.toEqual({foo: 'bar'}));\n\n      at Object.expect (__tests__/asyncFailures.test.js:17:3)\n\n  ● expect resolve\n\n    expect(received).resolves.toEqual()\n\n    Received promise rejected instead of resolved\n    Rejected to value: {\"foo\": \"bar\"}\n\n      18 |\n      19 | test('expect resolve', () =>\n    > 20 |   expect(Promise.reject({foo: 'bar'})).resolves.toEqual({foo: 'bar'}));\n         |   ^\n      21 |\n      22 | test('timeout', done => {\n      23 |   setTimeout(done, 50);\n\n      at Object.expect (__tests__/asyncFailures.test.js:20:3)\n\n  ● timeout\n\n<REPLACED>\n\n      20 |   expect(Promise.reject({foo: 'bar'})).resolves.toEqual({foo: 'bar'}));\n      21 |\n    > 22 | test('timeout', done => {\n         | ^\n      23 |   setTimeout(done, 50);\n      24 | }, 5);\n      25 |\n\n      at Object.test (__tests__/asyncFailures.test.js:22:1)\"\n`;\n\nexports[`works with error with cause 1`] = `\n\"FAIL __tests__/errorWithCause.test.js\n  ✕ error with cause in test\n  describe block\n    ✕ error with cause in describe/it\n    ✕ error with string cause in describe/it\n\n  ● error with cause in test\n\n    error during f\n\n      10 |\n      11 | function buildErrorWithCause(message: string, opts: {cause: unknown}): Error {\n    > 12 |   const error = new Error(message, opts);\n         |                 ^\n      13 |   if (opts.cause !== error.cause) {\n      14 |     // Error with cause not supported in legacy versions of node, we just polyfill it\n      15 |     Object.assign(error, opts);\n\n      at buildErrorWithCause (__tests__/errorWithCause.test.js:12:17)\n      at buildErrorWithCause (__tests__/errorWithCause.test.js:27:11)\n      at Object.f (__tests__/errorWithCause.test.js:32:3)\n\n    Cause:\n    error during g\n\n      19 |\n      20 | function g() {\n    > 21 |   throw new Error('error during g');\n         |         ^\n      22 | }\n      23 | function f() {\n      24 |   try {\n\n      at g (__tests__/errorWithCause.test.js:21:9)\n      at g (__tests__/errorWithCause.test.js:25:5)\n      at Object.f (__tests__/errorWithCause.test.js:32:3)\n\n  ● describe block › error with cause in describe/it\n\n    error during f\n\n      10 |\n      11 | function buildErrorWithCause(message: string, opts: {cause: unknown}): Error {\n    > 12 |   const error = new Error(message, opts);\n         |                 ^\n      13 |   if (opts.cause !== error.cause) {\n      14 |     // Error with cause not supported in legacy versions of node, we just polyfill it\n      15 |     Object.assign(error, opts);\n\n      at buildErrorWithCause (__tests__/errorWithCause.test.js:12:17)\n      at buildErrorWithCause (__tests__/errorWithCause.test.js:27:11)\n      at Object.f (__tests__/errorWithCause.test.js:37:5)\n\n    Cause:\n    error during g\n\n      19 |\n      20 | function g() {\n    > 21 |   throw new Error('error during g');\n         |         ^\n      22 | }\n      23 | function f() {\n      24 |   try {\n\n      at g (__tests__/errorWithCause.test.js:21:9)\n      at g (__tests__/errorWithCause.test.js:25:5)\n      at Object.f (__tests__/errorWithCause.test.js:37:5)\n\n  ● describe block › error with string cause in describe/it\n\n    with string cause\n\n      10 |\n      11 | function buildErrorWithCause(message: string, opts: {cause: unknown}): Error {\n    > 12 |   const error = new Error(message, opts);\n         |                 ^\n      13 |   if (opts.cause !== error.cause) {\n      14 |     // Error with cause not supported in legacy versions of node, we just polyfill it\n      15 |     Object.assign(error, opts);\n\n      at buildErrorWithCause (__tests__/errorWithCause.test.js:12:17)\n      at Object.buildErrorWithCause (__tests__/errorWithCause.test.js:41:11)\n\n    Cause:\n    here is the cause\"\n`;\n\nexports[`works with error with cause thrown outside tests 1`] = `\n\"error during f\n\n10 |\n11 | function buildErrorWithCause(message: string, opts: {cause: unknown}): Error {\n> 12 |   const error = new Error(message, opts);\n|                 ^\n13 |   if (opts.cause !== error.cause) {\n14 |     // Error with cause not supported in legacy versions of node, we just polyfill it\n15 |     Object.assign(error, opts);\n\nat buildErrorWithCause (__tests__/errorWithCauseInDescribe.test.js:12:17)\nat buildErrorWithCause (__tests__/errorWithCauseInDescribe.test.js:27:11)\nat f (__tests__/errorWithCauseInDescribe.test.js:32:3)\nat Object.describe (__tests__/errorWithCauseInDescribe.test.js:31:1)\n\nCause:\nerror during g\n\n19 |\n20 | function g() {\n> 21 |   throw new Error('error during g');\n|         ^\n22 | }\n23 | function f() {\n24 |   try {\n\nat g (__tests__/errorWithCauseInDescribe.test.js:21:9)\nat g (__tests__/errorWithCauseInDescribe.test.js:25:5)\nat f (__tests__/errorWithCauseInDescribe.test.js:32:3)\nat Object.describe (__tests__/errorWithCauseInDescribe.test.js:31:1)\"\n`;\n\nexports[`works with node assert 1`] = `\n\"FAIL __tests__/assertionError.test.js\n  ✕ assert\n  ✕ assert with a message\n  ✕ assert.ok\n  ✕ assert.ok with a message\n  ✕ assert.equal\n  ✕ assert.notEqual\n  ✕ assert.deepEqual\n  ✕ assert.deepEqual with a message\n  ✕ assert.notDeepEqual\n  ✕ assert.strictEqual\n  ✕ assert.notStrictEqual\n  ✕ assert.deepStrictEqual\n  ✕ assert.notDeepStrictEqual\n  ✕ assert.ifError\n  ✕ assert.doesNotThrow\n  ✕ assert.throws\n  ✕ assert.throws with different error messages\n  ✕ assert.throws with different error types\n  ✕ async\n  ✕ assert.fail\n  ✕ assert.fail with a message\n\n  ● assert\n\n    assert(received)\n\n    Expected value to be equal to:\n      true\n    Received:\n      false\n\n      12 |\n      13 | test('assert', () => {\n    > 14 |   assert(false);\n         |   ^\n      15 | });\n      16 |\n      17 | test('assert with a message', () => {\n\n      at Object.assert (__tests__/assertionError.test.js:14:3)\n\n  ● assert with a message\n\n    assert(received)\n\n    Expected value to be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      this is a message\n\n      16 |\n      17 | test('assert with a message', () => {\n    > 18 |   assert(false, 'this is a message');\n         |   ^\n      19 | });\n      20 |\n      21 | test('assert.ok', () => {\n\n      at Object.assert (__tests__/assertionError.test.js:18:3)\n\n  ● assert.ok\n\n    assert(received)\n\n    Expected value to be equal to:\n      true\n    Received:\n      false\n\n      20 |\n      21 | test('assert.ok', () => {\n    > 22 |   assert.ok(false);\n         |          ^\n      23 | });\n      24 |\n      25 | test('assert.ok with a message', () => {\n\n      at Object.ok (__tests__/assertionError.test.js:22:10)\n\n  ● assert.ok with a message\n\n    assert(received)\n\n    Expected value to be equal to:\n      true\n    Received:\n      false\n\n    Message:\n      this is a message\n\n      24 |\n      25 | test('assert.ok with a message', () => {\n    > 26 |   assert.ok(false, 'this is a message');\n         |          ^\n      27 | });\n      28 |\n      29 | test('assert.equal', () => {\n\n      at Object.ok (__tests__/assertionError.test.js:26:10)\n\n  ● assert.equal\n\n    assert.equal(received, expected)\n\n    Expected value to be equal to:\n      2\n    Received:\n      1\n\n      28 |\n      29 | test('assert.equal', () => {\n    > 30 |   assert.equal(1, 2);\n         |          ^\n      31 | });\n      32 |\n      33 | test('assert.notEqual', () => {\n\n      at Object.equal (__tests__/assertionError.test.js:30:10)\n\n  ● assert.notEqual\n\n    assert.notEqual(received, expected)\n\n    Expected value to not be equal to:\n      1\n    Received:\n      1\n\n      32 |\n      33 | test('assert.notEqual', () => {\n    > 34 |   assert.notEqual(1, 1);\n         |          ^\n      35 | });\n      36 |\n      37 | test('assert.deepEqual', () => {\n\n      at Object.notEqual (__tests__/assertionError.test.js:34:10)\n\n  ● assert.deepEqual\n\n    assert.deepEqual(received, expected)\n\n    Expected value to deeply equal to:\n      {\"a\": {\"b\": {\"c\": 6}}}\n    Received:\n      {\"a\": {\"b\": {\"c\": 5}}}\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Object {\n        \"a\": Object {\n          \"b\": Object {\n    -       \"c\": 6,\n    +       \"c\": 5,\n          },\n        },\n      }\n\n      36 |\n      37 | test('assert.deepEqual', () => {\n    > 38 |   assert.deepEqual({a: {b: {c: 5}}}, {a: {b: {c: 6}}});\n         |          ^\n      39 | });\n      40 |\n      41 | test('assert.deepEqual with a message', () => {\n\n      at Object.deepEqual (__tests__/assertionError.test.js:38:10)\n\n  ● assert.deepEqual with a message\n\n    assert.deepEqual(received, expected)\n\n    Expected value to deeply equal to:\n      {\"a\": {\"b\": {\"c\": 7}}}\n    Received:\n      {\"a\": {\"b\": {\"c\": 5}}}\n\n    Message:\n      this is a message\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Object {\n        \"a\": Object {\n          \"b\": Object {\n    -       \"c\": 7,\n    +       \"c\": 5,\n          },\n        },\n      }\n\n      40 |\n      41 | test('assert.deepEqual with a message', () => {\n    > 42 |   assert.deepEqual({a: {b: {c: 5}}}, {a: {b: {c: 7}}}, 'this is a message');\n         |          ^\n      43 | });\n      44 |\n      45 | test('assert.notDeepEqual', () => {\n\n      at Object.deepEqual (__tests__/assertionError.test.js:42:10)\n\n  ● assert.notDeepEqual\n\n    assert.notDeepEqual(received, expected)\n\n    Expected value not to deeply equal to:\n      {\"a\": 1}\n    Received:\n      {\"a\": 1}\n\n    Difference:\n\n    Compared values have no visual difference.\n\n      44 |\n      45 | test('assert.notDeepEqual', () => {\n    > 46 |   assert.notDeepEqual({a: 1}, {a: 1});\n         |          ^\n      47 | });\n      48 |\n      49 | test('assert.strictEqual', () => {\n\n      at Object.notDeepEqual (__tests__/assertionError.test.js:46:10)\n\n  ● assert.strictEqual\n\n    assert.strictEqual(received, expected)\n\n    Expected value to strictly be equal to:\n      NaN\n    Received:\n      1\n\n      48 |\n      49 | test('assert.strictEqual', () => {\n    > 50 |   assert.strictEqual(1, Number.NaN);\n         |          ^\n      51 | });\n      52 |\n      53 | test('assert.notStrictEqual', () => {\n\n      at Object.strictEqual (__tests__/assertionError.test.js:50:10)\n\n  ● assert.notStrictEqual\n\n    assert.notStrictEqual(received, expected)\n\n    Expected value not be strictly equal to:\n      1\n    Received:\n      1\n\n    Message:\n      My custom error message\n\n      52 |\n      53 | test('assert.notStrictEqual', () => {\n    > 54 |   assert.notStrictEqual(1, 1, 'My custom error message');\n         |          ^\n      55 | });\n      56 |\n      57 | test('assert.deepStrictEqual', () => {\n\n      at Object.notStrictEqual (__tests__/assertionError.test.js:54:10)\n\n  ● assert.deepStrictEqual\n\n    assert.deepStrictEqual(received, expected)\n\n    Expected value to deeply and strictly equal to:\n      {\"a\": 2}\n    Received:\n      {\"a\": 1}\n\n    Difference:\n\n    - Expected\n    + Received\n\n      Object {\n    -   \"a\": 2,\n    +   \"a\": 1,\n      }\n\n      56 |\n      57 | test('assert.deepStrictEqual', () => {\n    > 58 |   assert.deepStrictEqual({a: 1}, {a: 2});\n         |          ^\n      59 | });\n      60 |\n      61 | test('assert.notDeepStrictEqual', () => {\n\n      at Object.deepStrictEqual (__tests__/assertionError.test.js:58:10)\n\n  ● assert.notDeepStrictEqual\n\n    assert.notDeepStrictEqual(received, expected)\n\n    Expected value not to deeply and strictly equal to:\n      {\"a\": 1}\n    Received:\n      {\"a\": 1}\n\n    Difference:\n\n    Compared values have no visual difference.\n\n      60 |\n      61 | test('assert.notDeepStrictEqual', () => {\n    > 62 |   assert.notDeepStrictEqual({a: 1}, {a: 1});\n         |          ^\n      63 | });\n      64 |\n      65 | test('assert.ifError', () => {\n\n      at Object.notDeepStrictEqual (__tests__/assertionError.test.js:62:10)\n\n  ● assert.ifError\n\n    assert.ifError(received, expected)\n\n    Expected value ifError to:\n      null\n    Received:\n      1\n\n    Message:\n      ifError got unwanted exception: 1\n\n    Difference:\n\n      Comparing two different types of values. Expected null but received number.\n\n      64 |\n      65 | test('assert.ifError', () => {\n    > 66 |   assert.ifError(1);\n         |          ^\n      67 | });\n      68 |\n      69 | test('assert.doesNotThrow', () => {\n\n      at Object.ifError (__tests__/assertionError.test.js:66:10)\n\n  ● assert.doesNotThrow\n\n    assert.doesNotThrow(function)\n\n    Expected the function not to throw an error.\n    Instead, it threw:\n      [Error: err!]\n\n    Message:\n      Got unwanted exception.\n    Actual message: \"err!\"\n\n      68 |\n      69 | test('assert.doesNotThrow', () => {\n    > 70 |   assert.doesNotThrow(() => {\n         |          ^\n      71 |     throw new Error('err!');\n      72 |   });\n      73 | });\n\n      at Object.doesNotThrow (__tests__/assertionError.test.js:70:10)\n\n  ● assert.throws\n\n    assert.throws(function)\n\n    Expected the function to throw an error.\n    But it didn't throw anything.\n\n    Message:\n      Missing expected exception.\n\n      74 |\n      75 | test('assert.throws', () => {\n    > 76 |   assert.throws(() => {});\n         |          ^\n      77 | });\n      78 |\n      79 | test('assert.throws with different error messages', () => {\n\n      at Object.throws (__tests__/assertionError.test.js:76:10)\n\n  ● assert.throws with different error messages\n\n    assert.throws(function)\n\n    Expected values to be strictly deep-equal:\n    + actual - expected\n\n      Comparison {\n    +   message: 'message 1'\n    -   message: 'message 2'\n      }\n\n      78 |\n      79 | test('assert.throws with different error messages', () => {\n    > 80 |   assert.throws(\n         |          ^\n      81 |     () => {\n      82 |       throw new Error('message 1');\n      83 |     },\n\n      at Object.throws (__tests__/assertionError.test.js:80:10)\n\n  ● assert.throws with different error types\n\n    assert.throws(function)\n\n    The \"TypeError\" validation function is expected to return \"true\". Received TypeError: SyntaxError: message 1\n\n      89 |\n      90 | test('assert.throws with different error types', () => {\n    > 91 |   assert.throws(() => {\n         |          ^\n      92 |     throw new SyntaxError('message 1');\n      93 |   }, TypeError);\n      94 | });\n\n      at Object.throws (__tests__/assertionError.test.js:91:10)\n      Caught error:\n      SyntaxError: message 1\n      at Object.throws (__tests__/assertionError.test.js:91:10)\n\n  ● async\n\n    assert.equal(received, expected)\n\n    Expected value to be equal to:\n      \"hello\"\n    Received:\n      \"hello\n    goodbye\"\n\n    Message:\n      hmmm\n\n    Difference:\n\n    - Expected\n    + Received\n\n      hello\n    + goodbye\n\n       95 |\n       96 | test('async', async () => {\n    >  97 |   assert.equal('hello\\\\ngoodbye', 'hello', 'hmmm');\n          |          ^\n       98 | });\n       99 |\n      100 | test('assert.fail', () => {\n\n      at Object.equal (__tests__/assertionError.test.js:97:10)\n\n  ● assert.fail\n\n    assert.fail(received, expected)\n\n       99 |\n      100 | test('assert.fail', () => {\n    > 101 |   assert.fail();\n          |          ^\n      102 | });\n      103 |\n      104 | test('assert.fail with a message', () => {\n\n      at Object.fail (__tests__/assertionError.test.js:101:10)\n\n  ● assert.fail with a message\n\n    assert.fail(received, expected)\n\n    Message:\n      error!\n\n      103 |\n      104 | test('assert.fail with a message', () => {\n    > 105 |   assert.fail('error!');\n          |          ^\n      106 | });\n      107 |\n\n      at Object.fail (__tests__/assertionError.test.js:105:10)\"\n`;\n\nexports[`works with snapshot failures 1`] = `\n\"FAIL __tests__/snapshot.test.js\n  ✕ failing snapshot\n\n  ● failing snapshot\n\n    expect(received).toMatchSnapshot()\n\n    Snapshot name: \\`failing snapshot 1\\`\n\n    Snapshot: \"bar\"\n    Received: \"foo\"\n\n       9 |\n      10 | test('failing snapshot', () => {\n    > 11 |   expect('foo').toMatchSnapshot();\n         |                 ^\n      12 | });\n      13 |\n\n      at Object.toMatchSnapshot (__tests__/snapshot.test.js:11:17)\n\n › 1 snapshot failed.\n\"\n`;\n\nexports[`works with snapshot failures with hint 1`] = `\n\"FAIL __tests__/snapshotWithHint.test.js\n  ✕ failing snapshot with hint\n\n  ● failing snapshot with hint\n\n    expect(received).toMatchSnapshot(hint)\n\n    Snapshot name: \\`failing snapshot with hint: descriptive hint 1\\`\n\n    Snapshot: \"bar\"\n    Received: \"foo\"\n\n       9 |\n      10 | test('failing snapshot with hint', () => {\n    > 11 |   expect('foo').toMatchSnapshot('descriptive hint');\n         |                 ^\n      12 | });\n      13 |\n\n      at Object.toMatchSnapshot (__tests__/snapshotWithHint.test.js:11:17)\n\n › 1 snapshot failed.\n\"\n`;"}
{"prompt":"Fake promises,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ndescribe('Fake promises', () => {\n  it('should be possible to resolve with fake timers using immediates', () => {\n    const result = runJest('fake-promises/immediate');\n    expect(result.exitCode).toBe(0);\n  });\n\n  it('should be possible to resolve with fake timers using asap', () => {\n    const result = runJest('fake-promises/asap');\n    expect(result.exitCode).toBe(0);\n  });\n});"}
{"prompt":"enableGlobally,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ndescribe('enableGlobally', () => {\n  test('enables fake timers from Jest config', () => {\n    const result = runJest('fake-timers/enable-globally');\n    expect(result.exitCode).toBe(0);\n  });\n});\n\ndescribe('useFakeTimers', () => {\n  test('enables fake timers from Jest object', () => {\n    const result = runJest('fake-timers/use-fake-timers');\n    expect(result.exitCode).toBe(0);\n  });\n\n  test('allows to pass advanceTimers option', () => {\n    const result = runJest('fake-timers/advance-timers');\n    expect(result.exitCode).toBe(0);\n  });\n\n  test('allows to pass doNotFake option', () => {\n    const result = runJest('fake-timers/do-not-fake');\n    expect(result.exitCode).toBe(0);\n  });\n\n  test('allows to pass timerLimit option', () => {\n    const result = runJest('fake-timers/timer-limit');\n    expect(result.exitCode).toBe(0);\n  });\n\n  test('allows clearing not faked timers', () => {\n    const result = runJest('fake-timers/clear-real-timers');\n    expect(result.exitCode).toBe(0);\n  });\n});\n\ndescribe('setImmediate', () => {\n  test('fakes setImmediate', () => {\n    const result = runJest('fake-timers/set-immediate');\n\n    expect(result.stderr).toMatch('setImmediate test');\n    expect(result.exitCode).toBe(0);\n  });\n});\n\ndescribe('requestAnimationFrame', () => {\n  test('fakes requestAnimationFrame', () => {\n    const result = runJest('fake-timers/request-animation-frame');\n\n    expect(result.stderr).toMatch('requestAnimationFrame test');\n    expect(result.exitCode).toBe(0);\n  });\n});\n\ndescribe('useRealTimers', () => {\n  test('restores timers to the native implementation', () => {\n    const result = runJest('fake-timers/use-real-timers');\n    expect(result.stdout).toMatch('APIs are not replaced with fake timers.');\n    expect(result.exitCode).toBe(0);\n  });\n});"}
{"prompt":"enableGlobally,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {isJestJasmineRun} from '@jest/test-utils';\nimport runJest from '../runJest';\n\ndescribe('enableGlobally', () => {\n  test('enables legacy fake timers from Jest config', () => {\n    const result = runJest('fake-timers-legacy/enable-globally');\n    expect(result.exitCode).toBe(0);\n  });\n});\n\ndescribe('legacyFakeTimers', () => {\n  test('toggles legacy fake timers from Jest config', () => {\n    const result = runJest('fake-timers-legacy/enable-legacy-fake-timers');\n    expect(result.exitCode).toBe(0);\n  });\n});\n\ndescribe('useFakeTimers', () => {\n  test('enables legacy fake timers from Jest object', () => {\n    const result = runJest('fake-timers-legacy/use-legacy-fake-timers');\n    expect(result.exitCode).toBe(0);\n  });\n});\n\ndescribe('requestAnimationFrame', () => {\n  test('fakes requestAnimationFrame', () => {\n    const result = runJest('fake-timers-legacy/request-animation-frame');\n\n    expect(result.stderr).toMatch('requestAnimationFrame test');\n    expect(result.exitCode).toBe(0);\n  });\n});\n\ndescribe('setImmediate', () => {\n  test('fakes setImmediate w/o `waitNextEventLoopTurnForUnhandledRejectionEvents`', () => {\n    const result = runJest('fake-timers-legacy/set-immediate');\n\n    expect(result.stderr).toMatch('setImmediate test');\n    expect(result.exitCode).toBe(0);\n  });\n\n  test('fakes setImmediate w/ `waitNextEventLoopTurnForUnhandledRejectionEvents`', () => {\n    // Jasmine runner does not handle unhandled promise rejections that are causing the test to fail in Jest circus\n    const expectedExitCode = isJestJasmineRun() ? 0 : 1;\n\n    const result = runJest('fake-timers-legacy/set-immediate', [\n      '--waitNextEventLoopTurnForUnhandledRejectionEvents',\n    ]);\n\n    expect(result.stderr).toMatch('setImmediate test');\n    expect(result.exitCode).toBe(expectedExitCode);\n  });\n});\n\ndescribe('useRealTimers', () => {\n  test('restores timers to the native implementation', () => {\n    const result = runJest('fake-timers-legacy/use-real-timers');\n    expect(result.stdout).toMatch('APIs are not mocked with fake timers.');\n    expect(result.exitCode).toBe(0);\n  });\n});\n\ndescribe('when mocks are reset', () => {\n  test('calling resetAllMocks does not break tests', () => {\n    const result = runJest('fake-timers-legacy/reset-all-mocks');\n    expect(result.exitCode).toBe(0);\n  });\n\n  test('setting resetMocks in Jest config does not break tests', () => {\n    const result = runJest('fake-timers-legacy/reset-mocks');\n    expect(result.exitCode).toBe(0);\n  });\n});"}
{"prompt":"Farm,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport Farm from '../Farm';\nimport type {\n  ChildMessage,\n  OnCustomMessage,\n  OnEnd,\n  OnStart,\n  WorkerCallback,\n  WorkerInterface,\n} from '../types';\n\nlet mockWorkerCalls: Array<{\n  onCustomMessage: OnCustomMessage;\n  onEnd: OnEnd;\n  onStart: OnStart;\n  passed: ChildMessage;\n  workerId: number;\n}>;\n\nlet callback: WorkerCallback;\n\nfunction workerReplyStart(i: number) {\n  mockWorkerCalls[i].onStart({\n    getWorkerId: () => mockWorkerCalls[i].workerId,\n  } as WorkerInterface);\n}\n\nfunction workerReplyEnd(i: number, error: Error | null, result?: unknown) {\n  mockWorkerCalls[i].onEnd(error, result);\n}\n\nfunction workerReply(i: number, error: Error | null = null, result?: unknown) {\n  workerReplyStart(i);\n  workerReplyEnd(i, error, result);\n}\n\nfunction workerReplyCustomMessage(i: number, message: unknown) {\n  mockWorkerCalls[i].onCustomMessage(message);\n}\n\ndescribe('Farm', () => {\n  beforeEach(() => {\n    mockWorkerCalls = [];\n    callback = jest.fn<WorkerCallback>(\n      (workerId, request, onStart, onEnd, onCustomMessage) => {\n        mockWorkerCalls.push({\n          onCustomMessage,\n          onEnd,\n          onStart,\n          passed: request,\n          workerId,\n        });\n      },\n    );\n  });\n\n  it('sends a request to one worker', () => {\n    const farm = new Farm(4, callback);\n\n    farm.doWork('foo', 42);\n\n    expect(callback).toHaveBeenCalledTimes(1);\n    expect(callback).toHaveBeenCalledWith(\n      0,\n      [1, true, 'foo', [42]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n  });\n\n  it('sends four requests to four unique workers', () => {\n    const farm = new Farm(4, callback);\n\n    farm.doWork('foo', 42);\n    farm.doWork('foo1', 43);\n    farm.doWork('foo2', 44);\n    farm.doWork('foo3', 45);\n\n    expect(callback).toHaveBeenCalledTimes(4);\n    expect(callback).toHaveBeenNthCalledWith(\n      1,\n      0, // first worker\n      [1, true, 'foo', [42]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n    expect(callback).toHaveBeenNthCalledWith(\n      2,\n      1, // second worker\n      [1, true, 'foo1', [43]],\n      expect.any(Function),\n      expect.any(Function),\n\n      expect.any(Function),\n    );\n    expect(callback).toHaveBeenNthCalledWith(\n      3,\n      2, // third worker\n      [1, true, 'foo2', [44]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n    expect(callback).toHaveBeenNthCalledWith(\n      4,\n      3, // fourth worker\n      [1, true, 'foo3', [45]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n  });\n\n  it('handles null computeWorkerKey, sending to first worker', async () => {\n    const computeWorkerKey = jest.fn<\n      (method: string, ...args: Array<unknown>) => string | null\n    >(() => null);\n\n    const farm = new Farm(4, callback, {computeWorkerKey});\n\n    const p0 = farm.doWork('foo', 42);\n    workerReply(0);\n    await p0;\n\n    expect(computeWorkerKey).toHaveBeenCalledTimes(1);\n    expect(computeWorkerKey).toHaveBeenNthCalledWith(1, 'foo', 42);\n\n    expect(callback).toHaveBeenCalledTimes(1);\n    expect(callback).toHaveBeenNthCalledWith(\n      1,\n      0, // first worker\n      [1, true, 'foo', [42]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n  });\n\n  it('sends the same worker key to the same worker', async () => {\n    const computeWorkerKey = jest\n      .fn<(method: string, ...args: Array<unknown>) => string | null>()\n      .mockReturnValueOnce('one')\n      .mockReturnValueOnce('two')\n      .mockReturnValueOnce('one');\n\n    const farm = new Farm(4, callback, {computeWorkerKey});\n\n    const p0 = farm.doWork('foo', 42);\n    workerReply(0);\n    await p0;\n\n    const p1 = farm.doWork('foo1', 43);\n    workerReply(1);\n    await p1;\n\n    const p2 = farm.doWork('foo2', 44);\n    workerReply(2);\n    await p2;\n\n    expect(computeWorkerKey).toHaveBeenCalledTimes(3);\n    expect(computeWorkerKey).toHaveBeenNthCalledWith(1, 'foo', 42);\n    expect(computeWorkerKey).toHaveBeenNthCalledWith(2, 'foo1', 43);\n    expect(computeWorkerKey).toHaveBeenNthCalledWith(3, 'foo2', 44);\n\n    expect(callback).toHaveBeenCalledTimes(3);\n    expect(callback).toHaveBeenNthCalledWith(\n      1,\n      0, // first worker\n      [1, true, 'foo', [42]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n    expect(callback).toHaveBeenNthCalledWith(\n      2,\n      1, // second worker\n      [1, true, 'foo1', [43]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n    expect(callback).toHaveBeenNthCalledWith(\n      3,\n      0, // first worker again\n      [1, true, 'foo2', [44]],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n  });\n\n  it('returns the result if the call worked', async () => {\n    const farm = new Farm(4, callback);\n\n    const promise = farm.doWork('car', 'plane');\n\n    workerReply(0, null, 34);\n    const result = await promise;\n\n    expect(result).toBe(34);\n  });\n\n  it('throws if the call failed', async () => {\n    const farm = new Farm(4, callback);\n\n    const promise = farm.doWork('car', 'plane');\n    let thrownError = null;\n\n    workerReply(0, new TypeError('Massively broken'));\n\n    try {\n      await promise;\n    } catch (error) {\n      thrownError = error;\n    }\n\n    expect(thrownError).not.toBeNull();\n    expect(thrownError).toBeInstanceOf(TypeError);\n  });\n\n  it('checks that once a sticked task finishes, next time is sent to that worker', async () => {\n    const farm = new Farm(4, callback, {\n      computeWorkerKey: () => '1234567890abcdef',\n    });\n\n    // Worker 1 successfully replies with \"17\" as a result.\n    const p0 = farm.doWork('car', 'plane');\n    workerReply(0, null, 17);\n    await p0;\n\n    // Note that the stickiness is not created by the method name or the\n    // arguments it is solely controlled by the provided \"computeWorkerKey\"\n    // method, which in the test example always returns the same key, so all\n    // calls should be redirected to worker 1 (which is the one that resolved\n    // the first call).\n    const p1 = farm.doWork('foo', 'bar');\n    workerReply(1, null, 17);\n    await p1;\n\n    // The first time, a call with a \"1234567890abcdef\" hash had never been\n    // done earlier (\"foo\" call), so it got queued to all workers. Later, since\n    // the one that resolved the call was the one in position 1, all subsequent\n    // calls are only redirected to that worker.\n    expect(callback).toHaveBeenCalledTimes(2); // Only \"foo\".\n    expect(callback).toHaveBeenNthCalledWith(\n      1,\n      0, // first worker\n      [1, true, 'car', ['plane']],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n    expect(callback).toHaveBeenNthCalledWith(\n      2,\n      0, // first worker\n      [1, true, 'foo', ['bar']],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n  });\n\n  it('checks that even before a sticked task finishes, next time is sent to that worker', async () => {\n    const farm = new Farm(4, callback, {\n      computeWorkerKey: () => '1234567890abcdef',\n    });\n\n    // Note that the worker is sending a start response synchronously.\n    const p0 = farm.doWork('car', 'plane');\n    workerReplyStart(0);\n\n    // Note that the worker is sending a start response synchronously.\n    const p1 = farm.doWork('foo', 'bar');\n\n    // The first call is sent the worker, the second is queued\n    expect(callback).toHaveBeenCalledTimes(1);\n\n    // Flush the queue\n    workerReplyEnd(0, null, 17);\n    await p0;\n    workerReply(1, null, 17);\n    await p1;\n\n    // Both requests are send to the same worker.  The first time, a call with\n    // a \"1234567890abcdef\" hash had never been done earlier (\"foo\" call), so\n    // it got queued to all workers. Later, since the one that resolved the\n    // call was the one in position 1, all subsequent calls are only redirected\n    // to that worker.\n    expect(callback).toHaveBeenCalledTimes(2);\n    expect(callback).toHaveBeenNthCalledWith(\n      1,\n      0, // first worker\n      [1, true, 'car', ['plane']],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n    expect(callback).toHaveBeenNthCalledWith(\n      2,\n      0, // first worker\n      [1, true, 'foo', ['bar']],\n      expect.any(Function),\n      expect.any(Function),\n      expect.any(Function),\n    );\n  });\n\n  it('checks that locking works, and jobs are never lost', async () => {\n    const hash = jest\n      .fn<() => string>()\n      // This will go to both queues, but picked by the first worker.\n      .mockReturnValueOnce('0')\n      // This will go to both queues too, but picked by the second worker.\n      .mockReturnValueOnce('1')\n      // This will go to worker '0', now only assigned to it.\n      .mockReturnValueOnce('0')\n      // This will go to worker '1', now only assigned to it.\n      .mockReturnValueOnce('1')\n      // This will go to both queues too, but will wait, since workers are busy.\n      .mockReturnValueOnce('2')\n      // This will only go to the first queue.\n      .mockReturnValueOnce('0')\n      // This will be gone if the queue implementation is wrong.\n      .mockReturnValueOnce('0')\n      // Push onto the second queue; potentially wiping the earlier job.\n      .mockReturnValueOnce('1');\n\n    const farm = new Farm(2, callback, {computeWorkerKey: hash});\n\n    // First and second jobs get resolved, so that their hash is sticked to\n    // the right worker: worker assignment is performed when workers reply, not\n    // when the call is made.\n    const p0 = farm.doWork('work-0');\n    const p1 = farm.doWork('work-1');\n    workerReply(0, null, 'response-0');\n    await p0;\n    workerReply(1, null, 'response-1');\n    await p1;\n\n    // Now we perform the rest of the calls (7 resolves before 5 and 6, since 4\n    // is in both queues, and as soon as you resolve 4, 7 will be picked).\n    const p2 = farm.doWork('work-2');\n    const p3 = farm.doWork('work-3');\n    const p4 = farm.doWork('work-4');\n    const p5 = farm.doWork('work-5');\n    const p6 = farm.doWork('work-6');\n    const p7 = farm.doWork('work-7');\n    workerReply(2, null, 'response-2');\n    await p2;\n    workerReply(3, null, 'response-3');\n    await p3;\n    workerReply(4, null, 'response-4');\n    await p4;\n    workerReply(5, null, 'response-7');\n    await p7;\n    workerReply(6, null, 'response-5');\n    await p5;\n    workerReply(7, null, 'response-6');\n    await p6;\n\n    await expect(p0).resolves.toBe('response-0');\n    await expect(p1).resolves.toBe('response-1');\n    await expect(p2).resolves.toBe('response-2');\n    await expect(p3).resolves.toBe('response-3');\n    await expect(p4).resolves.toBe('response-4');\n    await expect(p5).resolves.toBe('response-5');\n    await expect(p6).resolves.toBe('response-6');\n    await expect(p7).resolves.toBe('response-7');\n  });\n\n  it('can receive custom messages from workers', async () => {\n    expect.assertions(2);\n    const farm = new Farm(2, callback);\n\n    const p0 = farm.doWork('work-0');\n    const p1 = farm.doWork('work-1');\n\n    const unsubscribe = p0.UNSTABLE_onCustomMessage!(message => {\n      expect(message).toEqual({key: 0, message: 'foo'});\n    });\n\n    p1.UNSTABLE_onCustomMessage!(message => {\n      expect(message).toEqual({key: 1, message: 'bar'});\n    });\n\n    workerReplyStart(0);\n    workerReplyStart(1);\n    workerReplyCustomMessage(0, {key: 0, message: 'foo'});\n    workerReplyCustomMessage(1, {key: 1, message: 'bar'});\n\n    unsubscribe();\n    // This message will not received because the listener already\n    // unsubscribed.\n    workerReplyCustomMessage(0, {key: 0, message: 'baz'});\n\n    workerReply(0, null, 17);\n    workerReply(1, null, 17);\n    await p0;\n    await p1;\n  });\n});"}
{"prompt":"fastPath.relative,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {relative, resolve} from '../fast_path';\n\ndescribe('fastPath.relative', () => {\n  it('should get relative paths inside the root', () => {\n    const root = path.join(__dirname, 'foo', 'bar');\n    const filename = path.join(__dirname, 'foo', 'bar', 'baz', 'foobar');\n    const relativeFilename = path.join('baz', 'foobar');\n    expect(relative(root, filename)).toBe(relativeFilename);\n  });\n\n  it('should get relative paths outside the root', () => {\n    const root = path.join(__dirname, 'foo', 'bar');\n    const filename = path.join(__dirname, 'foo', 'baz', 'foobar');\n    const relativeFilename = path.join('..', 'baz', 'foobar');\n    expect(relative(root, filename)).toBe(relativeFilename);\n  });\n\n  it('should get relative paths outside the root when start with same word', () => {\n    const root = path.join(__dirname, 'foo', 'bar');\n    const filename = path.join(__dirname, 'foo', 'barbaz', 'foobar');\n    const relativeFilename = path.join('..', 'barbaz', 'foobar');\n    expect(relative(root, filename)).toBe(relativeFilename);\n  });\n});\n\ndescribe('fastPath.resolve', () => {\n  it('should get the absolute path for paths inside the root', () => {\n    const root = path.join(__dirname, 'foo', 'bar');\n    const relativeFilename = path.join('baz', 'foobar');\n    const filename = path.join(__dirname, 'foo', 'bar', 'baz', 'foobar');\n    expect(resolve(root, relativeFilename)).toBe(filename);\n  });\n\n  it('should get the absolute path for paths outside the root', () => {\n    const root = path.join(__dirname, 'foo', 'bar');\n    const relativeFilename = path.join('..', 'baz', 'foobar');\n    const filename = path.join(__dirname, 'foo', 'baz', 'foobar');\n    expect(resolve(root, relativeFilename)).toBe(filename);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {\n  cleanup,\n  generateTestFilesToForceUsingWorkers,\n  writeFiles,\n} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'fatal-worker-error');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('fails a test that terminates the worker with a fatal error', () => {\n  const testFiles = {\n    ...generateTestFilesToForceUsingWorkers(),\n    '__tests__/fatalWorkerError.test.js': `\n      test('fatal worker error', () => {\n        process.exit(134);\n      });\n    `,\n  };\n\n  writeFiles(DIR, {\n    ...testFiles,\n    'package.json': '{}',\n  });\n\n  const {exitCode, stderr} = runJest(DIR, ['--maxWorkers=2']);\n\n  const numberOfTestsPassed = (stderr.match(/\\bPASS\\b/g) || []).length;\n\n  expect(exitCode).not.toBe(0);\n  expect(numberOfTestsPassed).toBe(Object.keys(testFiles).length - 1);\n  expect(stderr).toContain('FAIL __tests__/fatalWorkerError.test.js');\n  expect(stderr).toContain(\n    'Jest worker encountered 4 child process exceptions, exceeding retry limit',\n  );\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\njest.mock('jquery');\n\nbeforeEach(() => jest.resetModules());\n\nit('calls into $.ajax with the correct params', () => {\n  const $ = require('jquery');\n  const fetchCurrentUser = require('../fetchCurrentUser');\n\n  // Call into the function we want to test\n  const dummyCallback = () => {};\n  fetchCurrentUser(dummyCallback);\n\n  // Now make sure that $.ajax was properly called during the previous\n  // 2 lines\n  expect($.ajax).toHaveBeenCalledWith({\n    success: expect.any(Function),\n    type: 'GET',\n    url: 'http://example.com/currentUser',\n  });\n});\n\nit('calls the callback when $.ajax requests are finished', () => {\n  const $ = require('jquery');\n  const fetchCurrentUser = require('../fetchCurrentUser');\n\n  // Create a mock function for our callback\n  const callback = jest.fn();\n  fetchCurrentUser(callback);\n\n  // Now we emulate the process by which `$.ajax` would execute its own\n  // callback\n  $.ajax.mock.calls[0 /*first call*/][0 /*first argument*/].success({\n    firstName: 'Bobby',\n    lastName: 'Marley',\n  });\n\n  // And finally we assert that this emulated call by `$.ajax` incurred a\n  // call back into the mock function we provided as a callback\n  expect(callback.mock.calls[0 /*first call*/][0 /*first arg*/]).toEqual({\n    fullName: 'Bobby Marley',\n    loggedIn: true,\n  });\n});"}
{"prompt":"returns the shared tasks in FIFO ordering,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport FifoQueue from '../FifoQueue';\nimport {\n  CHILD_MESSAGE_CALL,\n  type ChildMessageCall,\n  type QueueChildMessage,\n} from '../types';\n\nit('returns the shared tasks in FIFO ordering', () => {\n  const queue = new FifoQueue();\n\n  const task1 = createQueueChildMessage();\n  const task2 = createQueueChildMessage();\n  const task3 = createQueueChildMessage();\n\n  queue.enqueue(task1);\n  queue.enqueue(task2);\n  queue.enqueue(task3);\n\n  expect(queue.dequeue(1)).toBe(task1);\n  expect(queue.dequeue(2)).toBe(task2);\n  expect(queue.dequeue(3)).toBe(task3);\n\n  expect(queue.dequeue(1)).toBeNull();\n  expect(queue.dequeue(2)).toBeNull();\n  expect(queue.dequeue(3)).toBeNull();\n});\n\nit('returns the worker specific tasks in FIFO ordering', () => {\n  const queue = new FifoQueue();\n\n  const task1 = createQueueChildMessage();\n  const task2 = createQueueChildMessage();\n  const task3 = createQueueChildMessage();\n\n  queue.enqueue(task1, 1);\n  queue.enqueue(task2, 1);\n  queue.enqueue(task3, 1);\n\n  expect(queue.dequeue(1)).toBe(task1);\n  expect(queue.dequeue(1)).toBe(task2);\n  expect(queue.dequeue(1)).toBe(task3);\n\n  expect(queue.dequeue(1)).toBeNull();\n});\n\nit('maintains global FIFO ordering between worker specific and shared tasks', () => {\n  const queue = new FifoQueue();\n\n  const sharedTask1 = createQueueChildMessage({name: 'sharedTask1'});\n  const sharedTask2 = createQueueChildMessage({name: 'sharedTask2'});\n  const sharedTask3 = createQueueChildMessage({name: 'sharedTask3'});\n  const worker1Task1 = createQueueChildMessage({name: 'worker1Task1'});\n  const worker1Task2 = createQueueChildMessage({name: 'worker1Task2'});\n  const worker2Task2 = createQueueChildMessage({name: 'worker2Task1'});\n\n  queue.enqueue(worker1Task1, 1);\n  queue.enqueue(sharedTask1);\n  queue.enqueue(sharedTask2);\n  queue.enqueue(worker1Task2, 1);\n  queue.enqueue(worker2Task2, 2);\n  queue.enqueue(sharedTask3);\n\n  expect(queue.dequeue(1)).toBe(worker1Task1);\n  expect(queue.dequeue(2)).toBe(sharedTask1);\n  sharedTask1.request[1] = true;\n\n  expect(queue.dequeue(1)).toBe(sharedTask2);\n  sharedTask2.request[1] = true;\n\n  expect(queue.dequeue(1)).toBe(worker1Task2);\n  expect(queue.dequeue(1)).toBe(sharedTask3);\n  sharedTask3.request[1] = true;\n\n  expect(queue.dequeue(2)).toBe(worker2Task2);\n\n  expect(queue.dequeue(1)).toBeNull();\n  expect(queue.dequeue(2)).toBeNull();\n});\n\nfunction createQueueChildMessage(...args: Array<unknown>): QueueChildMessage {\n  const request: ChildMessageCall = [CHILD_MESSAGE_CALL, false, 'test', args];\n\n  return {\n    onCustomMessage: () => {},\n    onEnd: () => {},\n    onStart: () => {},\n    request,\n  };\n}"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nmodule.exports = jest.fn();"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nrequire('./file');\nrequire('fake-node-module');"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\n'use strict';\n\njest.mock('fs');\n\ndescribe('listFilesInDirectorySync', () => {\n  const MOCK_FILE_INFO = {\n    '/path/to/file1.js': 'console.log(\"file1 contents\");',\n    '/path/to/file2.txt': 'file2 contents',\n  };\n\n  beforeEach(() => {\n    // Set up some mocked out file info before each test\n    require('fs').__setMockFiles(MOCK_FILE_INFO);\n  });\n\n  it('includes all files in the directory in the summary', () => {\n    const FileSummarizer = require('../FileSummarizer');\n    const fileSummary =\n      FileSummarizer.summarizeFilesInDirectorySync('/path/to');\n\n    expect(fileSummary).toHaveLength(2);\n  });\n});"}
{"prompt":"Dynamic test filtering,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ndescribe('Dynamic test filtering', () => {\n  it('uses the default JSON option', () => {\n    const result = runJest('filter', []);\n\n    expect(result.exitCode).toBe(0);\n    expect(result.stderr).toContain('1 total');\n  });\n\n  it('uses the CLI option', () => {\n    const result = runJest('filter', [\n      '--filter=<rootDir>/my-secondary-filter.js',\n    ]);\n\n    expect(result.exitCode).toBe(0);\n    expect(result.stderr).toContain('1 total');\n  });\n\n  it('ignores the filter if requested to do so', () => {\n    const result = runJest('filter', [\n      '--filter=<rootDir>/my-secondary-filter.js',\n      '--skipFilter',\n    ]);\n\n    expect(result.exitCode).toBe(0);\n    expect(result.stderr).toContain('2 total');\n  });\n\n  it('throws when you return clowny stuff', () => {\n    const result = runJest('filter', [\n      '--filter=<rootDir>/my-clowny-filter.js',\n    ]);\n\n    expect(result.exitCode).toBe(1);\n    expect(result.stderr).toContain('did not return a valid test list');\n    expect(result.stderr).toContain('my-clowny-filter');\n  });\n\n  it('will call setup on filter before filtering', () => {\n    const result = runJest('filter', ['--filter=<rootDir>/my-setup-filter.js']);\n\n    expect(result.exitCode).toBe(0);\n    expect(result.stderr).toContain('1 total');\n  });\n\n  it('will print error when filter throws', () => {\n    const result = runJest('filter', [\n      '--filter=<rootDir>/my-broken-filter.js',\n    ]);\n\n    expect(result.exitCode).toBe(1);\n    expect(result.stderr).toContain('Error: My broken filter error.');\n  });\n\n  it('will return no results when setup hook throws', () => {\n    const result = runJest('filter', [\n      '--filter=<rootDir>/my-broken-setup-filter.js',\n    ]);\n\n    expect(result.exitCode).toBe(1);\n    expect(result.stderr).toContain('Error: My broken setup filter error.');\n  });\n});"}
{"prompt":"--findRelatedTests flag,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, extractSummary, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'find-related-tests-test');\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ndescribe('--findRelatedTests flag', () => {\n  test('runs tests related to filename', () => {\n    writeFiles(DIR, {\n      '.watchmanconfig': '{}',\n      '__tests__/test.test.js': `\n      const a = require('../a');\n      test('a', () => {});\n    `,\n      'a.js': 'module.exports = {};',\n      'package.json': JSON.stringify({jest: {testEnvironment: 'node'}}),\n    });\n\n    const {stdout} = runJest(DIR, ['a.js']);\n    expect(stdout).toMatch('');\n\n    const {stderr} = runJest(DIR, ['--findRelatedTests', 'a.js']);\n    expect(stderr).toMatch('PASS __tests__/test.test.js');\n\n    const summaryMsg = 'Ran all test suites related to files matching a.js.';\n    expect(stderr).toMatch(summaryMsg);\n  });\n\n  test('runs tests related to uppercased filename on case-insensitive os', () => {\n    if (process.platform !== 'win32') {\n      // This test is Windows specific, skip it on other platforms.\n      return;\n    }\n\n    writeFiles(DIR, {\n      '.watchmanconfig': '{}',\n      '__tests__/test.test.js': `\n      const a = require('../a');\n      test('a', () => {});\n    `,\n      'a.js': 'module.exports = {};',\n      'package.json': JSON.stringify({jest: {testEnvironment: 'node'}}),\n    });\n\n    const {stdout} = runJest(DIR, ['A.JS']);\n    expect(stdout).toMatch('');\n\n    const {stderr} = runJest(DIR, ['--findRelatedTests', 'A.JS']);\n    expect(stderr).toMatch('PASS __tests__/test.test.js');\n\n    const summaryMsg = 'Ran all test suites related to files matching A.JS.';\n    expect(stderr).toMatch(summaryMsg);\n  });\n\n  test('runs tests related to filename with a custom dependency extractor', () => {\n    writeFiles(DIR, {\n      '.watchmanconfig': '{}',\n      '__tests__/test-skip-deps.test.js': `\n      const dynamicImport = path => Promise.resolve(require(path));\n      test('a', () => dynamicImport('../a').then(a => {\n        expect(a.foo).toBe(5);\n      }));\n      `,\n      '__tests__/test.test.js': `\n        const dynamicImport = path => Promise.resolve(require(path));\n        test('a', () => dynamicImport('../a').then(a => {\n          expect(a.foo).toBe(5);\n        }));\n      `,\n      'a.js': 'module.exports = {foo: 5};',\n      'dependencyExtractor.js': `\n        const DYNAMIC_IMPORT_RE = /(?:^|[^.]\\\\s*)(\\\\bdynamicImport\\\\s*?\\\\(\\\\s*?)([\\`'\"])([^\\`'\"]+)(\\\\2\\\\s*?\\\\))/g;\n        module.exports = {\n          extract(code, filePath) {\n            const dependencies = new Set();\n            if (filePath.includes('skip-deps')) {\n              return dependencies;\n            }\n\n            const addDependency = (match, pre, quot, dep, post) => {\n              dependencies.add(dep);\n              return match;\n            };\n            code.replace(DYNAMIC_IMPORT_RE, addDependency);\n            return dependencies;\n          },\n        };\n      `,\n      'package.json': JSON.stringify({\n        jest: {\n          dependencyExtractor: '<rootDir>/dependencyExtractor.js',\n          testEnvironment: 'node',\n        },\n      }),\n    });\n\n    const {stdout} = runJest(DIR, ['a.js']);\n    expect(stdout).toMatch('');\n\n    const {stderr} = runJest(DIR, ['--findRelatedTests', 'a.js']);\n    expect(stderr).toMatch('PASS __tests__/test.test.js');\n    expect(stderr).not.toMatch('PASS __tests__/test-skip-deps.test.js');\n\n    const summaryMsg = 'Ran all test suites related to files matching a.js.';\n    expect(stderr).toMatch(summaryMsg);\n  });\n\n  test('runs tests related to filename with a custom dependency extractor written in ESM', () => {\n    writeFiles(DIR, {\n      '.watchmanconfig': '{}',\n      '__tests__/test-skip-deps.test.js': `\n      const dynamicImport = path => Promise.resolve(require(path));\n      test('a', () => dynamicImport('../a').then(a => {\n        expect(a.foo).toBe(5);\n      }));\n      `,\n      '__tests__/test.test.js': `\n        const dynamicImport = path => Promise.resolve(require(path));\n        test('a', () => dynamicImport('../a').then(a => {\n          expect(a.foo).toBe(5);\n        }));\n      `,\n      'a.js': 'module.exports = {foo: 5};',\n      'dependencyExtractor.mjs': `\n        const DYNAMIC_IMPORT_RE = /(?:^|[^.]\\\\s*)(\\\\bdynamicImport\\\\s*?\\\\(\\\\s*?)([\\`'\"])([^\\`'\"]+)(\\\\2\\\\s*?\\\\))/g;\n        export function extract(code, filePath) {\n          const dependencies = new Set();\n          if (filePath.includes('skip-deps')) {\n            return dependencies;\n          }\n          const addDependency = (match, pre, quot, dep, post) => {\n            dependencies.add(dep);\n            return match;\n          };\n          code.replace(DYNAMIC_IMPORT_RE, addDependency);\n          return dependencies;\n        };\n      `,\n      'package.json': JSON.stringify({\n        jest: {\n          dependencyExtractor: '<rootDir>/dependencyExtractor.mjs',\n          testEnvironment: 'node',\n        },\n      }),\n    });\n\n    const {stdout} = runJest(DIR, ['a.js']);\n    expect(stdout).toMatch('');\n\n    const {stderr} = runJest(DIR, ['--findRelatedTests', 'a.js']);\n    expect(stderr).toMatch('PASS __tests__/test.test.js');\n    expect(stderr).not.toMatch('PASS __tests__/test-skip-deps.test.js');\n\n    const summaryMsg = 'Ran all test suites related to files matching a.js.';\n    expect(stderr).toMatch(summaryMsg);\n  });\n\n  test('generates coverage report for filename', () => {\n    writeFiles(DIR, {\n      '.watchmanconfig': '{}',\n      '__tests__/a.test.js': `\n        require('../a');\n        require('../b');\n        test('a', () => expect(1).toBe(1));\n      `,\n      '__tests__/b.test.js': `\n        require('../b');\n        test('b', () => expect(1).toBe(1));\n      `,\n      'a.js': 'module.exports = {}',\n      'b.js': 'module.exports = {}',\n      'package.json': JSON.stringify({\n        jest: {collectCoverage: true, testEnvironment: 'node'},\n      }),\n    });\n\n    let stdout;\n    let stderr;\n\n    ({stdout, stderr} = runJest(DIR, [], {stripAnsi: true}));\n    let summary;\n    let rest;\n    ({summary, rest} = extractSummary(stderr));\n    expect(summary).toMatchSnapshot();\n    expect(\n      rest\n        .split('\\n')\n        .map(s => s.trim())\n        .sort()\n        .join('\\n'),\n    ).toMatchSnapshot();\n\n    // both a.js and b.js should be in the coverage\n    expect(stdout).toMatchSnapshot();\n\n    ({stdout, stderr} = runJest(DIR, ['--findRelatedTests', 'a.js'], {\n      stripAnsi: true,\n    }));\n\n    ({summary, rest} = extractSummary(stderr));\n\n    expect(summary).toMatchSnapshot();\n    // should only run a.js\n    expect(rest).toMatchSnapshot();\n    // coverage should be collected only for a.js\n    expect(stdout).toMatchSnapshot();\n  });\n\n  test('coverage configuration is applied correctly', () => {\n    writeFiles(DIR, {\n      '.watchmanconfig': '{}',\n      '__tests__/a.test.js': `\n        require('../a');\n        test('a', () => expect(1).toBe(1));\n      `,\n      'a.js': 'module.exports = {}',\n      'b.js': 'module.exports = {}',\n      'package.json': JSON.stringify({\n        jest: {\n          collectCoverage: true,\n          collectCoverageFrom: ['!b.js', 'a.js'],\n          testEnvironment: 'node',\n        },\n      }),\n    });\n\n    let stdout;\n    let stderr;\n    ({stdout, stderr} = runJest(DIR, ['--findRelatedTests', 'a.js', 'b.js'], {\n      stripAnsi: true,\n    }));\n\n    const {summary, rest} = extractSummary(stderr);\n    expect(summary).toMatchSnapshot();\n    expect(\n      rest\n        .split('\\n')\n        .map(s => s.trim())\n        .sort()\n        .join('\\n'),\n    ).toMatchSnapshot();\n\n    // Only a.js should be in the report\n    expect(stdout).toMatchSnapshot();\n    expect(stdout).toMatch('a.js');\n    expect(stdout).not.toMatch('b.js');\n\n    ({stdout, stderr} = runJest(DIR, ['--findRelatedTests', 'b.js']));\n\n    // Neither a.js or b.js should be in the report\n    expect(stdout).toMatch('No tests found');\n    expect(stderr).toBe('');\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`--findRelatedTests flag coverage configuration is applied correctly 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites related to files matching a.js|b.js.\"\n`;\n\nexports[`--findRelatedTests flag coverage configuration is applied correctly 2`] = `\n\"PASS __tests__/a.test.js\n✓ a\"\n`;\n\nexports[`--findRelatedTests flag coverage configuration is applied correctly 3`] = `\n\"----------|---------|----------|---------|---------|-------------------\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n----------|---------|----------|---------|---------|-------------------\nAll files |     100 |      100 |     100 |     100 |                   \n a.js     |     100 |      100 |     100 |     100 |                   \n----------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`--findRelatedTests flag generates coverage report for filename 1`] = `\n\"Test Suites: 2 passed, 2 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`--findRelatedTests flag generates coverage report for filename 2`] = `\n\"PASS __tests__/a.test.js\nPASS __tests__/b.test.js\"\n`;\n\nexports[`--findRelatedTests flag generates coverage report for filename 3`] = `\n\"----------|---------|----------|---------|---------|-------------------\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n----------|---------|----------|---------|---------|-------------------\nAll files |     100 |      100 |     100 |     100 |                   \n a.js     |     100 |      100 |     100 |     100 |                   \n b.js     |     100 |      100 |     100 |     100 |                   \n----------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`--findRelatedTests flag generates coverage report for filename 4`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites related to files matching a.js.\"\n`;\n\nexports[`--findRelatedTests flag generates coverage report for filename 5`] = `\n\"PASS __tests__/a.test.js\n  ✓ a\"\n`;\n\nexports[`--findRelatedTests flag generates coverage report for filename 6`] = `\n\"----------|---------|----------|---------|---------|-------------------\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n----------|---------|----------|---------|---------|-------------------\nAll files |     100 |      100 |     100 |     100 |                   \n a.js     |     100 |      100 |     100 |     100 |                   \n----------|---------|----------|---------|---------|-------------------\"\n`;"}
{"prompt":"should run when first-project appears in selectProjects,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit('should run when first-project appears in selectProjects', () => {\n  expect(true).toBe(true);\n});"}
{"prompt":"runs only it.only tests,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {json} from '../runJest';\n\nit('runs only \"it.only\" tests', () => {\n  const {\n    json: {numPassedTests, numPendingTests},\n  } = json('focused-tests');\n  expect(numPassedTests).toBe(1);\n  expect(numPendingTests).toBe(2);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nmodule.exports = Symbol();"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nconst FooRenderUtil = require('FooRenderUtil');\n\nclass Foo {\n  render() {\n    return `\n      <div>\n        <div height={${FooRenderUtil.getHeaderHeight()}} />\n        <div height={${FooRenderUtil.getBodyHeight()}} />\n      </div>\n    `;\n  }\n}\n\nmodule.exports = Foo;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('stub', () => expect(1).toBe(1));"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nconst Foo = require('Foo.react');\n\nclass FooContainer {\n  render() {\n    return `<div>${new Foo().render()}</div>`;\n  }\n}\n\nmodule.exports = FooContainer;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nmodule.exports = {\n  getBodyHeight() {\n    return 5;\n  },\n\n  getHeaderHeight() {\n    return 5;\n  },\n};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'force-exit-test');\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ntest('exits the process after test are done but before timers complete', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    '__tests__/test.test.js': `\n      test('finishes before the timer is complete', () => {\n        setTimeout(() => console.log('TIMER_DONE'), 500);\n      });\n    `,\n    'package.json': JSON.stringify({jest: {testEnvironment: 'node'}}),\n  });\n\n  let output;\n  let stdout;\n  let stderr;\n  ({stdout, stderr} = runJest(DIR));\n\n  output = `${stdout}\\n${stderr}`;\n\n  expect(output).toMatch(/PASS.*test\\.test\\.js/);\n  expect(output).toMatch(/TIMER_DONE/);\n  writeFiles(DIR, {\n    'package.json': JSON.stringify({\n      jest: {forceExit: true, testEnvironment: 'node'},\n    }),\n  });\n\n  ({stdout, stderr} = runJest(DIR));\n\n  output = `${stdout}\\n${stderr}`;\n\n  expect(output).toMatch(/PASS.*test\\.test\\.js/);\n  expect(output).not.toMatch(/TIMER_DONE/);\n});"}
{"prompt":"for multiline test name returns,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport formatTestNameByPattern from '../formatTestNameByPattern';\n\ndescribe('for multiline test name returns', () => {\n  const testNames = [\n    'should\\n name the \\nfunction you attach',\n    'should\\r\\n name the \\r\\nfunction you attach',\n    'should\\r name the \\rfunction you attach',\n  ];\n\n  it('test name with highlighted pattern and replaced line breaks', () => {\n    const pattern = 'name';\n\n    for (const testName of testNames) {\n      expect(formatTestNameByPattern(testName, pattern, 36)).toMatchSnapshot();\n    }\n  });\n});\n\ndescribe('for one line test name', () => {\n  const testName = 'should name the function you attach';\n\n  describe('with pattern in the head returns', () => {\n    const pattern = 'should';\n\n    it('test name with highlighted pattern', () => {\n      expect(formatTestNameByPattern(testName, pattern, 35)).toMatchSnapshot();\n    });\n\n    it('test name with cutted tail and highlighted pattern', () => {\n      expect(formatTestNameByPattern(testName, pattern, 30)).toMatchSnapshot();\n    });\n\n    it('test name with cutted tail and cutted highlighted pattern', () => {\n      expect(formatTestNameByPattern(testName, pattern, 8)).toMatchSnapshot();\n    });\n  });\n\n  describe('pattern in the middle', () => {\n    const pattern = 'name';\n\n    it('test name with highlighted pattern returns', () => {\n      expect(formatTestNameByPattern(testName, pattern, 35)).toMatchSnapshot();\n    });\n\n    it('test name with cutted tail and highlighted pattern', () => {\n      expect(formatTestNameByPattern(testName, pattern, 25)).toMatchSnapshot();\n    });\n\n    it('test name with cutted tail and cutted highlighted pattern', () => {\n      expect(formatTestNameByPattern(testName, pattern, 13)).toMatchSnapshot();\n    });\n\n    it('test name with highlighted cutted', () => {\n      expect(formatTestNameByPattern(testName, pattern, 6)).toMatchSnapshot();\n    });\n  });\n\n  describe('pattern in the tail returns', () => {\n    const pattern = 'attach';\n\n    it('test name with highlighted pattern', () => {\n      expect(formatTestNameByPattern(testName, pattern, 35)).toMatchSnapshot();\n    });\n\n    it('test name with cutted tail and cutted highlighted pattern', () => {\n      expect(formatTestNameByPattern(testName, pattern, 33)).toMatchSnapshot();\n    });\n\n    it('test name with highlighted cutted', () => {\n      expect(formatTestNameByPattern(testName, pattern, 6)).toMatchSnapshot();\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`for multiline test name returns test name with highlighted pattern and replaced line breaks 1`] = `\"<dim>should⏎ </intensity></>name</><dim> the ⏎function you at...</intensity>\"`;\n\nexports[`for multiline test name returns test name with highlighted pattern and replaced line breaks 2`] = `\"<dim>should⏎ </intensity></>name</><dim> the ⏎function you at...</intensity>\"`;\n\nexports[`for multiline test name returns test name with highlighted pattern and replaced line breaks 3`] = `\"<dim>should⏎ </intensity></>name</><dim> the ⏎function you at...</intensity>\"`;\n\nexports[`for one line test name pattern in the middle test name with cutted tail and cutted highlighted pattern 1`] = `\"<dim>should </intensity></>nam...</>\"`;\n\nexports[`for one line test name pattern in the middle test name with cutted tail and highlighted pattern 1`] = `\"<dim>should </intensity></>name</><dim> the functi...</intensity>\"`;\n\nexports[`for one line test name pattern in the middle test name with highlighted cutted 1`] = `\"<dim>sho</intensity></>...</>\"`;\n\nexports[`for one line test name pattern in the middle test name with highlighted pattern returns 1`] = `\"<dim>should </intensity></>name</><dim> the function you attach</intensity>\"`;\n\nexports[`for one line test name pattern in the tail returns test name with cutted tail and cutted highlighted pattern 1`] = `\"<dim>should name the function you </intensity></>a...</>\"`;\n\nexports[`for one line test name pattern in the tail returns test name with highlighted cutted 1`] = `\"<dim>sho</intensity></>...</>\"`;\n\nexports[`for one line test name pattern in the tail returns test name with highlighted pattern 1`] = `\"<dim>should name the function you </intensity></>attach</>\"`;\n\nexports[`for one line test name with pattern in the head returns test name with cutted tail and cutted highlighted pattern 1`] = `\"</>shoul...</>\"`;\n\nexports[`for one line test name with pattern in the head returns test name with cutted tail and highlighted pattern 1`] = `\"</>should</><dim> name the function yo...</intensity>\"`;\n\nexports[`for one line test name with pattern in the head returns test name with highlighted pattern 1`] = `\"</>should</><dim> name the function you attach</intensity>\"`;"}
{"prompt":"formatTestResults,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport formatTestResults from '../formatTestResults';\nimport type {AggregatedResult, AssertionResult} from '../types';\n\ndescribe('formatTestResults', () => {\n  it('includes test full name', () => {\n    const assertion = {\n      fullName: 'TestedModule#aMethod when some condition is met returns true',\n      status: 'passed',\n      title: 'returns true',\n    } as AssertionResult;\n\n    const results = {\n      testResults: [\n        {\n          numFailingTests: 0,\n          perfStats: {end: 2, runtime: 1, slow: false, start: 1},\n          testResults: [assertion],\n        },\n      ],\n    } as AggregatedResult;\n\n    const result = formatTestResults(results, undefined, null);\n    expect(result.testResults[0].assertionResults[0].fullName).toEqual(\n      assertion.fullName,\n    );\n  });\n\n  it('should mark result status to skipped', () => {\n    const skippedAssertion = {\n      fullName: 'Pending test',\n      status: 'pending',\n      title: 'is still pending',\n    } as AssertionResult;\n\n    const skippedResults = {\n      testResults: [\n        {\n          numFailingTests: 0,\n          numPassingTests: 0,\n          numPendingTests: 2,\n          numTodoTests: 2,\n          perfStats: {end: 2, runtime: 1, slow: false, start: 1},\n          testResults: [skippedAssertion],\n        },\n      ],\n    } as AggregatedResult;\n\n    const result = formatTestResults(skippedResults, undefined, null);\n    expect(result.testResults[0].assertionResults[0].status).toEqual(\n      skippedAssertion.status,\n    );\n  });\n\n  it('should mark result status to focused', () => {\n    const focusedAssertion = {\n      fullName: 'Focused test',\n      status: 'focused',\n      title: 'focused test',\n    } as AssertionResult;\n\n    const focusedResults = {\n      testResults: [\n        {\n          numFailingTests: 0,\n          numPassingTests: 1,\n          numPendingTests: 1,\n          numTodoTests: 2,\n          perfStats: {end: 2, runtime: 1, slow: false, start: 1},\n          testResults: [focusedAssertion],\n        },\n      ],\n    } as AggregatedResult;\n\n    const result = formatTestResults(focusedResults, undefined, null);\n    expect(result.testResults[0].assertionResults[0].status).toEqual(\n      focusedAssertion.status,\n    );\n  });\n});"}
{"prompt":"defaults to milliseconds,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport formatTime from '../formatTime';\n\nit('defaults to milliseconds', () => {\n  expect(formatTime(42)).toBe('42 ms');\n});\n\nit('formats seconds properly', () => {\n  expect(formatTime(42, 0)).toBe('42 s');\n});\n\nit('formats milliseconds properly', () => {\n  expect(formatTime(42, -3)).toBe('42 ms');\n});\n\nit('formats microseconds properly', () => {\n  expect(formatTime(42, -6)).toBe('42 μs');\n});\n\nit('formats nanoseconds properly', () => {\n  expect(formatTime(42, -9)).toBe('42 ns');\n});\n\nit('interprets lower than lowest powers as nanoseconds', () => {\n  expect(formatTime(42, -12)).toBe('42 ns');\n});\n\nit('interprets higher than highest powers as seconds', () => {\n  expect(formatTime(42, 3)).toBe('42 s');\n});\n\nit('interprets non-multiple-of-3 powers as next higher prefix', () => {\n  expect(formatTime(42, -4)).toBe('42 ms');\n});\n\nit('formats the quantity properly when pad length is lower', () => {\n  expect(formatTime(42, -3, 1)).toBe('42 ms');\n});\n\nit('formats the quantity properly when pad length is equal', () => {\n  expect(formatTime(42, -3, 2)).toBe('42 ms');\n});\n\nit('left pads the quantity properly when pad length is higher', () => {\n  expect(formatTime(42, -3, 5)).toBe('   42 ms');\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\nimport defaultExport, {apple, strawberry} from '../fruit';\n\n/**\n * This file illustrates a full mock of a module.\n */\njest.mock('../fruit');\n\nit('does a full mock', () => {\n  expect(defaultExport()).toBeUndefined();\n  expect(apple).toBe('apple');\n  expect(strawberry()).toBeUndefined();\n});"}
{"prompt":"generateEmptyCoverage,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as os from 'os';\nimport * as path from 'path';\nimport istanbulCoverage from 'istanbul-lib-coverage';\nimport libSourceMaps from 'istanbul-lib-source-maps';\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport {shouldInstrument} from '@jest/transform';\nimport generateEmptyCoverage from '../generateEmptyCoverage';\n\njest.mock('@jest/transform', () => ({\n  ...jest.requireActual('@jest/transform'),\n  shouldInstrument: jest.fn(),\n}));\n\ndescribe('generateEmptyCoverage', () => {\n  const coverageMap = istanbulCoverage.createCoverageMap({});\n  const sourceMapStore = libSourceMaps.createSourceMapStore();\n  const rootDir = __dirname;\n  const filepath = path.join(rootDir, './sum.js');\n\n  it('generates an empty coverage object for a file without running it', async () => {\n    const src = `\n    throw new Error('this should not be thrown');\n\n    const a = (b, c) => {\n      if (b) {\n        return c;\n      } else {\n        return b;\n      }\n    };\n\n    module.exports = {\n      a,\n    };`;\n\n    shouldInstrument.mockReturnValueOnce(true);\n\n    const emptyCoverage = await generateEmptyCoverage(\n      src,\n      filepath,\n      makeGlobalConfig(),\n      makeProjectConfig({\n        cacheDirectory: os.tmpdir(),\n        cwd: rootDir,\n        rootDir,\n        transform: [['\\\\.js$', require.resolve('babel-jest')]],\n      }),\n    );\n\n    expect(emptyCoverage).not.toBeNull();\n    expect(typeof emptyCoverage).toBe('object');\n\n    let coverage = emptyCoverage.coverage;\n\n    if (emptyCoverage.sourceMapPath) {\n      coverageMap.addFileCoverage(emptyCoverage.coverage);\n      sourceMapStore.registerURL(filepath, emptyCoverage.sourceMapPath);\n\n      coverage = sourceMapStore.transformCoverage(coverageMap).map;\n    }\n\n    expect(coverage.data).toMatchSnapshot({\n      path: expect.any(String),\n    });\n  });\n\n  it('generates a null coverage result when using /* istanbul ignore file */', async () => {\n    const src = `\n    /* istanbul ignore file */\n    const a = (b, c) => {\n      if (b) {\n        return c;\n      } else {\n        return b;\n      }\n    };\n    module.exports = { a };\n    `;\n\n    shouldInstrument.mockReturnValueOnce(true);\n\n    const nullCoverage = await generateEmptyCoverage(\n      src,\n      filepath,\n      makeGlobalConfig(),\n      makeProjectConfig({\n        cacheDirectory: os.tmpdir(),\n        cwd: rootDir,\n        rootDir,\n        transform: [['\\\\.js$', require.resolve('babel-jest')]],\n      }),\n    );\n\n    expect(nullCoverage).toBeNull();\n  });\n\n  it('generates a null coverage result when collectCoverage global config is false', async () => {\n    const src = `\n    const a = (b, c) => {\n      if (b) {\n        return c;\n      } else {\n        return b;\n      }\n    };\n    module.exports = { a };\n    `;\n\n    shouldInstrument.mockReturnValueOnce(false);\n\n    const nullCoverage = await generateEmptyCoverage(\n      src,\n      filepath,\n      makeGlobalConfig(),\n      makeProjectConfig({\n        cacheDirectory: os.tmpdir(),\n        cwd: rootDir,\n        rootDir,\n        transform: [['\\\\.js$', require.resolve('babel-jest')]],\n      }),\n    );\n\n    expect(nullCoverage).toBeNull();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`generateEmptyCoverage generates an empty coverage object for a file without running it 1`] = `\nObject {\n  \"b\": Object {\n    \"0\": Array [\n      0,\n      0,\n    ],\n  },\n  \"branchMap\": Object {\n    \"0\": Object {\n      \"line\": 5,\n      \"loc\": Object {\n        \"end\": Object {\n          \"column\": 7,\n          \"line\": 9,\n        },\n        \"start\": Object {\n          \"column\": 6,\n          \"line\": 5,\n        },\n      },\n      \"locations\": Array [\n        Object {\n          \"end\": Object {\n            \"column\": 7,\n            \"line\": 9,\n          },\n          \"start\": Object {\n            \"column\": 6,\n            \"line\": 5,\n          },\n        },\n        Object {\n          \"end\": Object {\n            \"column\": 7,\n            \"line\": 9,\n          },\n          \"start\": Object {\n            \"column\": 13,\n            \"line\": 7,\n          },\n        },\n      ],\n      \"type\": \"if\",\n    },\n  },\n  \"f\": Object {\n    \"0\": 0,\n  },\n  \"fnMap\": Object {\n    \"0\": Object {\n      \"decl\": Object {\n        \"end\": Object {\n          \"column\": 15,\n          \"line\": 4,\n        },\n        \"start\": Object {\n          \"column\": 14,\n          \"line\": 4,\n        },\n      },\n      \"line\": 4,\n      \"loc\": Object {\n        \"end\": Object {\n          \"column\": 5,\n          \"line\": 10,\n        },\n        \"start\": Object {\n          \"column\": 24,\n          \"line\": 4,\n        },\n      },\n      \"name\": \"(anonymous_0)\",\n    },\n  },\n  \"path\": Any<String>,\n  \"s\": Object {\n    \"0\": 0,\n    \"1\": 0,\n    \"2\": 0,\n    \"3\": 0,\n    \"4\": 0,\n    \"5\": 0,\n  },\n  \"statementMap\": Object {\n    \"0\": Object {\n      \"end\": Object {\n        \"column\": 49,\n        \"line\": 2,\n      },\n      \"start\": Object {\n        \"column\": 4,\n        \"line\": 2,\n      },\n    },\n    \"1\": Object {\n      \"end\": Object {\n        \"column\": 5,\n        \"line\": 10,\n      },\n      \"start\": Object {\n        \"column\": 14,\n        \"line\": 4,\n      },\n    },\n    \"2\": Object {\n      \"end\": Object {\n        \"column\": 7,\n        \"line\": 9,\n      },\n      \"start\": Object {\n        \"column\": 6,\n        \"line\": 5,\n      },\n    },\n    \"3\": Object {\n      \"end\": Object {\n        \"column\": 17,\n        \"line\": 6,\n      },\n      \"start\": Object {\n        \"column\": 8,\n        \"line\": 6,\n      },\n    },\n    \"4\": Object {\n      \"end\": Object {\n        \"column\": 17,\n        \"line\": 8,\n      },\n      \"start\": Object {\n        \"column\": 8,\n        \"line\": 8,\n      },\n    },\n    \"5\": Object {\n      \"end\": Object {\n        \"column\": 6,\n        \"line\": 14,\n      },\n      \"start\": Object {\n        \"column\": 4,\n        \"line\": 12,\n      },\n    },\n  },\n}\n`;"}
{"prompt":"generators,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nfunction* someFunc() {\n  return 3;\n}\n\ndescribe('generators', () => {\n  beforeEach(function* () {\n    // This shouldn't throw\n    yield someFunc();\n  });\n\n  it('in spec', function* () {\n    const data = yield someFunc();\n\n    expect(data).toBe(3);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\njest.mock('../index');\n\nconst methods = require('../index');\n\ntest('mock works with generator', () => {\n  expect(methods.generatorMethod).toBeDefined();\n});\n\ntest('mock works with asyncGenerator', () => {\n  expect(methods.asyncGeneratorMethod).toBeDefined();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('mock works with generator', () => {\n  const {exitCode} = runJest('generator-mock');\n\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('getSeed', () => {\n  expect(jest.getSeed()).toBe(1234);\n});"}
{"prompt":"To align columns so people can review snapshots confidently:","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {diffStringsUnified} from '../printDiffs';\n\n// To align columns so people can review snapshots confidently:\n\n// 1. Use options to omit line colors.\nconst identity = (string: string) => string;\nconst changeColor = (string: string) => `<i>${string}</i>`;\nconst options = {\n  aColor: identity,\n  bColor: identity,\n  changeColor,\n  commonColor: identity,\n  omitAnnotationLines: true,\n  patchColor: identity,\n};\n\nconst testAlignedDiffs = (a: string, b: string): string =>\n  diffStringsUnified(a, b, options);\n\n// 2. Add string serializer to omit double quote marks.\nexpect.addSnapshotSerializer({\n  serialize: (val: string) => val,\n  test: (val: unknown) => typeof val === 'string',\n});\n\ndescribe('getAlignedDiffs', () => {\n  describe('lines', () => {\n    test('change preceding and following common', () => {\n      const a = 'delete\\ncommon between changes\\nprev';\n      const b = 'insert\\ncommon between changes\\nnext';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('common preceding and following change', () => {\n      const a = 'common preceding\\ndelete\\ncommon following';\n      const b = 'common preceding\\ninsert\\ncommon following';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('common at end when both current change lines are empty', () => {\n      const a = 'delete\\ncommon at end';\n      const b = 'common at end';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('common between delete and insert', () => {\n      const a = 'delete\\ncommon between changes';\n      const b = 'common between changes\\ninsert';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('common between insert and delete', () => {\n      const a = 'common between changes\\ndelete';\n      const b = 'insert\\ncommon between changes';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n  });\n\n  describe('newline', () => {\n    test('delete only', () => {\n      const a = 'preceding\\nfollowing';\n      const b = 'precedingfollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('insert only', () => {\n      const a = 'precedingfollowing';\n      const b = 'preceding\\nfollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('delete with adjacent change', () => {\n      const a = 'preceding\\nfollowing';\n      const b = 'precededfollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('insert with adjacent changes', () => {\n      const a = 'precededfollowing';\n      const b = 'preceding\\nFollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('change from space', () => {\n      const a = 'preceding following';\n      const b = 'preceding\\nfollowing';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('change to space', () => {\n      const a = 'preceding\\nfollowing';\n      const b = 'preceding following';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n  });\n\n  describe('substrings first', () => {\n    test('common when both current change lines are empty', () => {\n      const a = 'first\\nmiddle\\nlast prev';\n      const b = 'insert\\nfirst\\nmiddle\\nlast next';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('common when either current change line is non-empty', () => {\n      const a = 'expected first\\n\\nlast';\n      const b = 'first\\n\\nlast';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('delete completes the current line', () => {\n      const a = 'common preceding first\\nmiddle\\nlast and following';\n      const b = 'common preceding and following';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('insert completes the current line', () => {\n      const a = 'common preceding';\n      const b = 'common preceding first\\nmiddle\\n';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n  });\n\n  describe('substrings middle', () => {\n    test('is empty in delete between common', () => {\n      const a = 'common at start precedes delete\\n\\nexpected common at end';\n      const b = 'common at start precedes received common at end';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('is empty in insert at start', () => {\n      const a = 'expected common at end';\n      const b = 'insert line\\n\\nreceived common at end';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('is non-empty in delete at end', () => {\n      const a = 'common at start precedes delete\\nnon-empty line\\nnext';\n      const b = 'common at start precedes prev';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('is non-empty in insert between common', () => {\n      const a = 'common at start precedes delete expected';\n      const b = 'common at start precedes insert\\nnon-empty\\nreceived';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n  });\n\n  describe('substrings last', () => {\n    test('is empty in delete at end', () => {\n      const a = 'common string preceding prev\\n';\n      const b = 'common string preceding next';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('is empty in insert at end', () => {\n      const a = 'common string preceding prev';\n      const b = 'common string preceding next\\n';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('is non-empty in common not at end', () => {\n      const a = 'common first\\nlast expected';\n      const b = 'common first\\nlast received';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n  });\n\n  describe('strings', () => {\n    test('change at start and delete or insert at end', () => {\n      const a = 'prev change common delete\\nunchanged\\nexpected change common';\n      const b = 'next change common\\nunchanged\\nreceived change common insert';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n\n    test('delete or insert at start and change at end', () => {\n      const a = 'common change prev\\nunchanged\\ndelete common change this';\n      const b = 'insert common change next\\nunchanged\\ncommon change that';\n      expect(testAlignedDiffs(a, b)).toMatchSnapshot();\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`getAlignedDiffs lines change preceding and following common 1`] = `\n- delete\n+ insert\n  common between changes\n- prev\n+ next\n`;\n\nexports[`getAlignedDiffs lines common at end when both current change lines are empty 1`] = `\n- delete\n  common at end\n`;\n\nexports[`getAlignedDiffs lines common between delete and insert 1`] = `\n- delete\n  common between changes\n+ insert\n`;\n\nexports[`getAlignedDiffs lines common between insert and delete 1`] = `\n+ insert\n  common between changes\n- delete\n`;\n\nexports[`getAlignedDiffs lines common preceding and following change 1`] = `\n  common preceding\n- delete\n+ insert\n  common following\n`;\n\nexports[`getAlignedDiffs newline change from space 1`] = `\n- preceding<i> </i>following\n+ preceding\n+ following\n`;\n\nexports[`getAlignedDiffs newline change to space 1`] = `\n- preceding\n- following\n+ preceding<i> </i>following\n`;\n\nexports[`getAlignedDiffs newline delete only 1`] = `\n- preceding\n- following\n+ precedingfollowing\n`;\n\nexports[`getAlignedDiffs newline delete with adjacent change 1`] = `\n- preced<i>ing</i>\n- following\n+ preced<i>ed</i>following\n`;\n\nexports[`getAlignedDiffs newline insert only 1`] = `\n- precedingfollowing\n+ preceding\n+ following\n`;\n\nexports[`getAlignedDiffs newline insert with adjacent changes 1`] = `\n- preced<i>edf</i>ollowing\n+ preced<i>ing</i>\n+ <i>F</i>ollowing\n`;\n\nexports[`getAlignedDiffs strings change at start and delete or insert at end 1`] = `\n- <i>prev</i> change common<i> delete</i>\n+ <i>next</i> change common\n  unchanged\n- <i>expect</i>ed change common\n+ <i>receiv</i>ed change common<i> insert</i>\n`;\n\nexports[`getAlignedDiffs strings delete or insert at start and change at end 1`] = `\n- common change <i>prev</i>\n+ <i>insert </i>common change <i>next</i>\n  unchanged\n- <i>delete </i>common change th<i>is</i>\n+ common change th<i>at</i>\n`;\n\nexports[`getAlignedDiffs substrings first common when both current change lines are empty 1`] = `\n+ insert\n  first\n  middle\n- last <i>prev</i>\n+ last <i>next</i>\n`;\n\nexports[`getAlignedDiffs substrings first common when either current change line is non-empty 1`] = `\n- <i>expected </i>first\n+ first\n\n  last\n`;\n\nexports[`getAlignedDiffs substrings first delete completes the current line 1`] = `\n- common preceding <i>first</i>\n- middle\n- <i>last </i>and following\n+ common preceding and following\n`;\n\nexports[`getAlignedDiffs substrings first insert completes the current line 1`] = `\n- common preceding\n+ common preceding<i> first</i>\n+ middle\n+\n`;\n\nexports[`getAlignedDiffs substrings last is empty in delete at end 1`] = `\n- common string preceding <i>prev</i>\n-\n+ common string preceding <i>next</i>\n`;\n\nexports[`getAlignedDiffs substrings last is empty in insert at end 1`] = `\n- common string preceding <i>prev</i>\n+ common string preceding <i>next</i>\n+\n`;\n\nexports[`getAlignedDiffs substrings last is non-empty in common not at end 1`] = `\n  common first\n- last <i>expect</i>ed\n+ last <i>receiv</i>ed\n`;\n\nexports[`getAlignedDiffs substrings middle is empty in delete between common 1`] = `\n- common at start precedes <i>delete</i>\n-\n- <i>expect</i>ed common at end\n+ common at start precedes <i>receiv</i>ed common at end\n`;\n\nexports[`getAlignedDiffs substrings middle is empty in insert at start 1`] = `\n- <i>expect</i>ed common at end\n+ insert line\n+\n+ <i>receiv</i>ed common at end\n`;\n\nexports[`getAlignedDiffs substrings middle is non-empty in delete at end 1`] = `\n- common at start precedes <i>delete</i>\n- non-empty line\n- next\n+ common at start precedes <i>prev</i>\n`;\n\nexports[`getAlignedDiffs substrings middle is non-empty in insert between common 1`] = `\n- common at start precedes <i>delete expect</i>ed\n+ common at start precedes <i>insert</i>\n+ non-empty\n+ <i>receiv</i>ed\n`;"}
{"prompt":"@ts-expect-error: Testing purpose","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {TransformOptions as BabelTransformOptions} from '@babel/core';\nimport type {SyncTransformer, TransformOptions} from '@jest/transform';\nimport babelJest from '../index';\n\nconst {getCacheKey} =\n  babelJest.createTransformer() as SyncTransformer<BabelTransformOptions>;\n\nconst processVersion = process.version;\nconst nodeEnv = process.env.NODE_ENV;\nconst babelEnv = process.env.BABEL_ENV;\n\nafterEach(() => {\n  jest.resetModules();\n\n  if (process.version === 'new-node-version') {\n    // @ts-expect-error: Testing purpose\n    process.version = processVersion;\n  }\n\n  if (process.env.NODE_ENV === 'NEW_NODE_ENV') {\n    process.env.NODE_ENV = nodeEnv;\n  }\n\n  if (process.env.BABEL_ENV === 'NEW_BABEL_ENV') {\n    process.env.BABEL_ENV = babelEnv;\n  }\n});\n\ndescribe('getCacheKey', () => {\n  const sourceText = 'mock source';\n  const sourcePath = 'mock-source-path.js';\n\n  const transformOptions = {\n    config: {rootDir: 'mock-root-dir'},\n    configString: 'mock-config-string',\n    instrument: true,\n  } as TransformOptions<BabelTransformOptions>;\n\n  const oldCacheKey = getCacheKey!(sourceText, sourcePath, transformOptions);\n\n  test('returns cache key hash', () => {\n    expect(oldCacheKey).toHaveLength(32);\n  });\n\n  test('if `THIS_FILE` value is changing', async () => {\n    jest.doMock('graceful-fs', () => ({\n      readFileSync: () => 'new this file',\n    }));\n\n    const {createTransformer} =\n      require('../index') as typeof import('../index');\n\n    const newCacheKey = (await createTransformer()).getCacheKey!(\n      sourceText,\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `babelOptions.options` value is changing', async () => {\n    jest.doMock('../loadBabelConfig', () => {\n      const babel = require('@babel/core') as typeof import('@babel/core');\n\n      return {\n        loadPartialConfig: (options: BabelTransformOptions) => ({\n          ...babel.loadPartialConfig(options),\n          options: 'new-options',\n        }),\n      };\n    });\n\n    const {createTransformer} =\n      require('../index') as typeof import('../index');\n\n    const newCacheKey = (await createTransformer()).getCacheKey!(\n      sourceText,\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `sourceText` value is changing', () => {\n    const newCacheKey = getCacheKey!(\n      'new source text',\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `sourcePath` value is changing', () => {\n    const newCacheKey = getCacheKey!(\n      sourceText,\n      'new-source-path.js',\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `configString` value is changing', () => {\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, {\n      ...transformOptions,\n      configString: 'new-config-string',\n    });\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `babelOptions.config` value is changing', async () => {\n    jest.doMock('../loadBabelConfig', () => {\n      const babel = require('@babel/core') as typeof import('@babel/core');\n\n      return {\n        loadPartialConfig: (options: BabelTransformOptions) => ({\n          ...babel.loadPartialConfig(options),\n          config: 'new-config',\n        }),\n      };\n    });\n\n    const {createTransformer} =\n      require('../index') as typeof import('../index');\n\n    const newCacheKey = (await createTransformer()).getCacheKey!(\n      sourceText,\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `babelOptions.babelrc` value is changing', async () => {\n    jest.doMock('../loadBabelConfig', () => {\n      const babel = require('@babel/core') as typeof import('@babel/core');\n\n      return {\n        loadPartialConfig: (options: BabelTransformOptions) => ({\n          ...babel.loadPartialConfig(options),\n          babelrc: 'new-babelrc',\n        }),\n      };\n    });\n\n    const {createTransformer} =\n      require('../index') as typeof import('../index');\n\n    const newCacheKey = (await createTransformer()).getCacheKey!(\n      sourceText,\n      sourcePath,\n      transformOptions,\n    );\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `instrument` value is changing', () => {\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, {\n      ...transformOptions,\n      instrument: false,\n    });\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `process.env.NODE_ENV` value is changing', () => {\n    process.env.NODE_ENV = 'NEW_NODE_ENV';\n\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, transformOptions);\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if `process.env.BABEL_ENV` value is changing', () => {\n    process.env.BABEL_ENV = 'NEW_BABEL_ENV';\n\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, transformOptions);\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n\n  test('if node version is changing', () => {\n    // @ts-expect-error: Testing purpose\n    delete process.version;\n    // @ts-expect-error: Testing purpose\n    process.version = 'new-node-version';\n\n    const newCacheKey = getCacheKey!(sourceText, sourcePath, transformOptions);\n\n    expect(oldCacheKey).not.toEqual(newCacheKey);\n  });\n});"}
{"prompt":"getCallsite,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {originalPositionFor} from '@jridgewell/trace-mapping';\nimport * as fs from 'graceful-fs';\nimport getCallsite from '../getCallsite';\n\njest.mock('graceful-fs');\njest.mock('@jridgewell/trace-mapping', () => {\n  const actual = jest.requireActual<typeof import('@jridgewell/trace-mapping')>(\n    '@jridgewell/trace-mapping',\n  );\n\n  return {\n    ...actual,\n    originalPositionFor: jest.fn(actual.originalPositionFor),\n  };\n});\n\ndescribe('getCallsite', () => {\n  test('without source map', () => {\n    const site = getCallsite(0);\n\n    expect(site.getFileName()).toEqual(__filename);\n    expect(site.getColumnNumber()).toEqual(expect.any(Number));\n    expect(site.getLineNumber()).toEqual(expect.any(Number));\n    expect(fs.readFileSync).not.toHaveBeenCalled();\n  });\n\n  test('ignores errors when fs throws', () => {\n    jest.mocked(fs.readFileSync).mockImplementation(() => {\n      throw new Error('Mock error');\n    });\n\n    const site = getCallsite(0, new Map([[__filename, 'mockedSourceMapFile']]));\n\n    expect(site.getFileName()).toEqual(__filename);\n    expect(site.getColumnNumber()).toEqual(expect.any(Number));\n    expect(site.getLineNumber()).toEqual(expect.any(Number));\n    expect(fs.readFileSync).toHaveBeenCalledWith('mockedSourceMapFile', 'utf8');\n  });\n\n  test('reads source map file to determine line and column', () => {\n    jest.mocked(fs.readFileSync).mockImplementation(() =>\n      JSON.stringify({\n        file: 'file.js',\n        mappings: 'AAAA,OAAO,MAAM,KAAK,GAAG,QAAd',\n        names: [],\n        sources: ['file.js'],\n        sourcesContent: [\"export const hello = 'foobar';\\\\n\"],\n        version: 3,\n      }),\n    );\n\n    const sourceMapColumn = 1;\n    const sourceMapLine = 2;\n\n    jest.mocked(originalPositionFor).mockImplementation(() => ({\n      column: sourceMapColumn,\n      line: sourceMapLine,\n    }));\n\n    const site = getCallsite(0, new Map([[__filename, 'mockedSourceMapFile']]));\n\n    expect(site.getFileName()).toEqual(__filename);\n    expect(site.getColumnNumber()).toEqual(sourceMapColumn);\n    expect(site.getLineNumber()).toEqual(sourceMapLine);\n    expect(originalPositionFor).toHaveBeenCalledTimes(1);\n    expect(originalPositionFor).toHaveBeenCalledWith(expect.anything(), {\n      column: expect.any(Number),\n      line: expect.any(Number),\n    });\n    expect(fs.readFileSync).toHaveBeenCalledWith('mockedSourceMapFile', 'utf8');\n  });\n});"}
{"prompt":"getConsoleOutput,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {makeGlobalConfig} from '@jest/test-utils';\nimport {formatStackTrace} from 'jest-message-util';\nimport BufferedConsole from '../BufferedConsole';\nimport getConsoleOutput from '../getConsoleOutput';\n\njest.mock('jest-message-util', () => ({\n  formatStackTrace: jest.fn(),\n}));\n\ndescribe('getConsoleOutput', () => {\n  const globalConfig = makeGlobalConfig({noStackTrace: true});\n  jest\n    .mocked(formatStackTrace)\n    .mockImplementation(() => 'throw new Error(\"Whoops!\");');\n\n  it.each([\n    'assert',\n    'count',\n    'debug',\n    'dir',\n    'dirxml',\n    'error',\n    'group',\n    'groupCollapsed',\n    'info',\n    'log',\n    'time',\n    'warn',\n  ] as const)('takes noStackTrace and pass it on for %s', logType => {\n    getConsoleOutput(\n      BufferedConsole.write([], logType, 'message', 4),\n      {\n        rootDir: 'root',\n        testMatch: [],\n      },\n      globalConfig,\n    );\n    expect(formatStackTrace).toHaveBeenCalled();\n    expect(formatStackTrace).toHaveBeenCalledWith(\n      expect.anything(),\n      expect.anything(),\n      expect.objectContaining({\n        noCodeFrame: expect.anything(),\n        noStackTrace: true,\n      }),\n    );\n  });\n});"}
{"prompt":"getMaxWorkers,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport getMaxWorkers from '../getMaxWorkers';\n\njest.mock('os');\n\ndescribe('getMaxWorkers', () => {\n  beforeEach(() => {\n    require('os').__setCpus({length: 4});\n  });\n\n  it('Returns 1 when runInBand', () => {\n    const argv = {runInBand: true};\n    expect(getMaxWorkers(argv)).toBe(1);\n  });\n\n  it('Returns 1 when the OS CPUs are not available', () => {\n    require('os').__setCpus(undefined);\n    expect(getMaxWorkers({})).toBe(1);\n  });\n\n  it('Returns the `maxWorkers` when specified', () => {\n    const argv = {maxWorkers: 8};\n    expect(getMaxWorkers(argv)).toBe(8);\n  });\n\n  it('Returns based on the number of cpus', () => {\n    expect(getMaxWorkers({})).toBe(3);\n    expect(getMaxWorkers({watch: true})).toBe(2);\n    expect(getMaxWorkers({watchAll: true})).toBe(2);\n  });\n\n  describe('% based', () => {\n    it('50% = 2 workers', () => {\n      const argv = {maxWorkers: '50%'};\n      expect(getMaxWorkers(argv)).toBe(2);\n    });\n\n    it('< 0 workers should become 1', () => {\n      const argv = {maxWorkers: '1%'};\n      expect(getMaxWorkers(argv)).toBe(1);\n    });\n\n    it(\"0% shouldn't break\", () => {\n      const argv = {maxWorkers: '0%'};\n      expect(getMaxWorkers(argv)).toBe(1);\n    });\n  });\n});"}
{"prompt":"getNoTestsFoundMessage,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {TestPathPatterns} from '@jest/pattern';\nimport {makeGlobalConfig} from '@jest/test-utils';\nimport type {Config} from '@jest/types';\nimport getNoTestsFoundMessage from '../getNoTestsFoundMessage';\n\njest.mock('jest-util', () => ({\n  ...jest.requireActual<typeof import('jest-util')>('jest-util'),\n  isInteractive: true,\n}));\n\ndescribe('getNoTestsFoundMessage', () => {\n  function createGlobalConfig(options?: Partial<Config.GlobalConfig>) {\n    return makeGlobalConfig({\n      rootDir: '/root/dir',\n      testPathPatterns: new TestPathPatterns(['/path/pattern']),\n      ...options,\n    });\n  }\n\n  test('returns correct message when monitoring only failures', () => {\n    const config = createGlobalConfig({onlyFailures: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });\n\n  test('returns correct message when monitoring only changed', () => {\n    const config = createGlobalConfig({onlyChanged: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });\n\n  test('returns correct message with verbose option', () => {\n    const config = createGlobalConfig({verbose: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });\n\n  test('returns correct message without options', () => {\n    const config = createGlobalConfig();\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });\n\n  test('returns correct message with passWithNoTests', () => {\n    const config = createGlobalConfig({passWithNoTests: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n  });\n\n  test('returns correct message with findRelatedTests', () => {\n    const config = createGlobalConfig({findRelatedTests: true});\n    expect(getNoTestsFoundMessage([], config)).toMatchSnapshot();\n    expect(\n      getNoTestsFoundMessage([], {...config, passWithNoTests: true}),\n    ).toMatchSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`getNoTestsFoundMessage returns correct message when monitoring only changed 1`] = `\nObject {\n  \"exitWith0\": true,\n  \"message\": \"<bold>No tests found related to files changed since last commit.</intensity><dim></intensity>\n<dim>Run Jest without \\`-o\\` or with \\`--all\\` to run all tests.</intensity>\",\n}\n`;\n\nexports[`getNoTestsFoundMessage returns correct message when monitoring only failures 1`] = `\nObject {\n  \"exitWith0\": false,\n  \"message\": \"<bold>No failed test found.</intensity><dim></intensity>\n<dim>Run Jest without \\`--onlyFailures\\` or with \\`--all\\` to run all tests.</intensity>\",\n}\n`;\n\nexports[`getNoTestsFoundMessage returns correct message with findRelatedTests 1`] = `\nObject {\n  \"exitWith0\": false,\n  \"message\": \"<bold>No tests found, exiting with code 1</intensity>\nRun with \\`--passWithNoTests\\` to exit with code 0\nIn <bold>/root/dir</intensity>\n  0 files checked across 0 projects. Run with \\`--verbose\\` for more details.\nPattern: <yellow>/path/pattern</color> - 0 matches\",\n}\n`;\n\nexports[`getNoTestsFoundMessage returns correct message with findRelatedTests 2`] = `\nObject {\n  \"exitWith0\": true,\n  \"message\": \"<bold>No tests found, exiting with code 0</intensity>\",\n}\n`;\n\nexports[`getNoTestsFoundMessage returns correct message with passWithNoTests 1`] = `\nObject {\n  \"exitWith0\": true,\n  \"message\": \"<bold>No tests found, exiting with code 0</intensity>\",\n}\n`;\n\nexports[`getNoTestsFoundMessage returns correct message with verbose option 1`] = `\nObject {\n  \"exitWith0\": false,\n  \"message\": \"<bold>No tests found, exiting with code 1</intensity>\nRun with \\`--passWithNoTests\\` to exit with code 0\n\nPattern: <yellow>/path/pattern</color> - 0 matches\",\n}\n`;\n\nexports[`getNoTestsFoundMessage returns correct message without options 1`] = `\nObject {\n  \"exitWith0\": false,\n  \"message\": \"<bold>No tests found, exiting with code 1</intensity>\nRun with \\`--passWithNoTests\\` to exit with code 0\nIn <bold>/root/dir</intensity>\n  0 files checked across 0 projects. Run with \\`--verbose\\` for more details.\nPattern: <yellow>/path/pattern</color> - 0 matches\",\n}\n`;"}
{"prompt":"getPlatformExtension,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport getPlatformExtension from '../getPlatformExtension';\n\ndescribe('getPlatformExtension', () => {\n  it('should get platform ext', () => {\n    expect(getPlatformExtension('a.ios.js')).toBe('ios');\n    expect(getPlatformExtension('a.android.js')).toBe('android');\n    expect(getPlatformExtension('/b/c/a.ios.js')).toBe('ios');\n    expect(getPlatformExtension('/b/c.android/a.ios.js')).toBe('ios');\n    expect(getPlatformExtension('/b/c/a@1.5x.ios.png')).toBe('ios');\n    expect(getPlatformExtension('/b/c/a@1.5x.lol.png')).toBeNull();\n    expect(getPlatformExtension('/b/c/a.lol.png')).toBeNull();\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {makeGlobalConfig} from '@jest/test-utils';\nimport getResultHeader from '../getResultHeader';\n\nconst endTime = 1_577_717_671_160;\nconst testTime = 5500;\n\nconst testResult = {\n  testFilePath: '/foo',\n};\nconst testResultSlow = {\n  perfStats: {\n    end: endTime,\n    runtime: testTime,\n    slow: true,\n    start: endTime - testTime,\n  },\n  testFilePath: '/foo',\n};\nconst testResultFast = {\n  perfStats: {\n    end: endTime,\n    runtime: testTime,\n    slow: false,\n    start: endTime - testTime,\n  },\n  testFilePath: '/foo',\n};\n\nconst globalConfig = makeGlobalConfig();\n\ntest('should display test time for slow test', () => {\n  const result = getResultHeader(testResultSlow, globalConfig);\n\n  expect(result).toContain(`${testTime / 1000} s`);\n});\n\ntest('should not display test time for fast test ', () => {\n  const result = getResultHeader(testResultFast, globalConfig);\n\n  expect(result).not.toContain(`${testTime / 1000} s`);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nimport getSnapshotStatus from '../getSnapshotStatus';\n\ntest('Retrieves the snapshot status', () => {\n  const snapshotResult = {\n    added: 1,\n    fileDeleted: false,\n    matched: 1,\n    unchecked: 1,\n    uncheckedKeys: ['test suite with unchecked snapshot'],\n    unmatched: 1,\n    updated: 1,\n  };\n\n  expect(getSnapshotStatus(snapshotResult, false)).toMatchSnapshot();\n});\n\ntest('Shows no snapshot updates if all snapshots matched', () => {\n  const snapshotResult = {\n    added: 0,\n    fileDeleted: false,\n    matched: 1,\n    unchecked: 0,\n    uncheckedKeys: [],\n    unmatched: 0,\n    updated: 0,\n  };\n\n  expect(getSnapshotStatus(snapshotResult, true)).toMatchSnapshot();\n});\n\ntest('Retrieves the snapshot status after a snapshot update', () => {\n  const snapshotResult = {\n    added: 2,\n    fileDeleted: true,\n    matched: 2,\n    unchecked: 2,\n    uncheckedKeys: [\n      'first test suite with unchecked snapshot',\n      'second test suite with unchecked snapshot',\n    ],\n    unmatched: 2,\n    updated: 2,\n  };\n\n  expect(getSnapshotStatus(snapshotResult, true)).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Retrieves the snapshot status 1`] = `\nArray [\n  \"<bold><green> › 1 snapshot written.</color></intensity>\",\n  \"<bold><green> › 1 snapshot updated.</color></intensity>\",\n  \"<bold><red> › 1 snapshot failed.</color></intensity>\",\n  \"<bold><yellow> › 1 snapshot obsolete</color></intensity>.\",\n  \"   • test suite with unchecked snapshot\",\n]\n`;\n\nexports[`Retrieves the snapshot status after a snapshot update 1`] = `\nArray [\n  \"<bold><green> › 2 snapshots written.</color></intensity>\",\n  \"<bold><green> › 2 snapshots updated.</color></intensity>\",\n  \"<bold><red> › 2 snapshots failed.</color></intensity>\",\n  \"<bold><green> › 2 snapshots removed.</color></intensity>\",\n  \"   • first test suite with unchecked snapshot\",\n  \"   • second test suite with unchecked snapshot\",\n  \"<bold><green> › snapshot file removed.</color></intensity>\",\n]\n`;\n\nexports[`Shows no snapshot updates if all snapshots matched 1`] = `Array []`;"}
{"prompt":"creates a snapshot summary with multiple snapshot being written/updated,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nimport getSnapshotSummary from '../getSnapshotSummary';\n\nconst UPDATE_COMMAND = 'press --u';\n\nconst globalConfig = {\n  rootDir: 'root',\n};\n\ntest('creates a snapshot summary', () => {\n  const snapshots = {\n    added: 1,\n    didUpdate: false,\n    filesAdded: 1,\n    filesRemoved: 1,\n    filesRemovedList: [],\n    filesUnmatched: 1,\n    filesUpdated: 1,\n    matched: 2,\n    total: 2,\n    unchecked: 1,\n    uncheckedKeysByFile: [\n      {\n        filePath: 'path/to/suite_one',\n        keys: ['unchecked snapshot 1'],\n      },\n    ],\n    unmatched: 1,\n    updated: 1,\n  };\n\n  expect(\n    getSnapshotSummary(snapshots, globalConfig, UPDATE_COMMAND)\n      .join('\\n')\n      .replaceAll('\\\\', '/'),\n  ).toMatchSnapshot();\n});\n\ntest('creates a snapshot summary after an update', () => {\n  const snapshots = {\n    added: 1,\n    didUpdate: true,\n    filesAdded: 1,\n    filesRemoved: 1,\n    filesRemovedList: [],\n    filesUnmatched: 1,\n    filesUpdated: 1,\n    unchecked: 1,\n    uncheckedKeysByFile: [\n      {\n        filePath: 'path/to/suite_one',\n        keys: ['unchecked snapshot 1'],\n      },\n    ],\n    unmatched: 1,\n    updated: 1,\n  };\n\n  expect(\n    getSnapshotSummary(snapshots, globalConfig, UPDATE_COMMAND)\n      .join('\\n')\n      .replaceAll('\\\\', '/'),\n  ).toMatchSnapshot();\n});\n\nit('creates a snapshot summary with multiple snapshot being written/updated', () => {\n  const snapshots = {\n    added: 2,\n    didUpdate: false,\n    filesAdded: 2,\n    filesRemoved: 2,\n    filesRemovedList: [],\n    filesUnmatched: 2,\n    filesUpdated: 2,\n    unchecked: 2,\n    uncheckedKeysByFile: [\n      {\n        filePath: 'path/to/suite_one',\n        keys: ['unchecked snapshot 1'],\n      },\n      {\n        filePath: 'path/to/suite_two',\n        keys: ['unchecked snapshot 2'],\n      },\n    ],\n    unmatched: 2,\n    updated: 2,\n  };\n\n  expect(\n    getSnapshotSummary(snapshots, globalConfig, UPDATE_COMMAND)\n      .join('\\n')\n      .replaceAll('\\\\', '/'),\n  ).toMatchSnapshot();\n});\n\nit('returns nothing if there are no updates', () => {\n  const snapshots = {\n    added: 0,\n    didUpdate: false,\n    filesAdded: 0,\n    filesRemoved: 0,\n    filesRemovedList: [],\n    filesUnmatched: 0,\n    filesUpdated: 0,\n    unchecked: 0,\n    uncheckedKeysByFile: [],\n    unmatched: 0,\n    updated: 0,\n  };\n  expect(\n    getSnapshotSummary(snapshots, globalConfig, UPDATE_COMMAND).join('\\n'),\n  ).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`creates a snapshot summary 1`] = `\n\"<bold>Snapshot Summary</intensity>\n<bold><green> › 1 snapshot written </color></intensity>from 1 test suite.\n<bold><red> › 1 snapshot failed</color></intensity> from 1 test suite. <dim>Inspect your code changes or press --u to update them.</intensity>\n<bold><green> › 1 snapshot updated </color></intensity>from 1 test suite.\n<bold><yellow> › 1 snapshot file obsolete </color></intensity>from 1 test suite. <dim>To remove it, press --u.</intensity>\n<bold><yellow> › 1 snapshot obsolete </color></intensity>from 1 test suite. <dim>To remove it, press --u.</intensity>\n   ↳ <dim>../path/to/</intensity><bold>suite_one</intensity>\n       • unchecked snapshot 1\"\n`;\n\nexports[`creates a snapshot summary after an update 1`] = `\n\"<bold>Snapshot Summary</intensity>\n<bold><green> › 1 snapshot written </color></intensity>from 1 test suite.\n<bold><red> › 1 snapshot failed</color></intensity> from 1 test suite. <dim>Inspect your code changes or press --u to update them.</intensity>\n<bold><green> › 1 snapshot updated </color></intensity>from 1 test suite.\n<bold><green> › 1 snapshot file removed </color></intensity>from 1 test suite.\n<bold><green> › 1 snapshot removed </color></intensity>from 1 test suite.\n   ↳ <dim>../path/to/</intensity><bold>suite_one</intensity>\n       • unchecked snapshot 1\"\n`;\n\nexports[`creates a snapshot summary with multiple snapshot being written/updated 1`] = `\n\"<bold>Snapshot Summary</intensity>\n<bold><green> › 2 snapshots written </color></intensity>from 2 test suites.\n<bold><red> › 2 snapshots failed</color></intensity> from 2 test suites. <dim>Inspect your code changes or press --u to update them.</intensity>\n<bold><green> › 2 snapshots updated </color></intensity>from 2 test suites.\n<bold><yellow> › 2 snapshot files obsolete </color></intensity>from 2 test suites. <dim>To remove them all, press --u.</intensity>\n<bold><yellow> › 2 snapshots obsolete </color></intensity>from 2 test suites. <dim>To remove them all, press --u.</intensity>\n   ↳ <dim>../path/to/</intensity><bold>suite_one</intensity>\n       • unchecked snapshot 1\n   ↳ <dim>../path/to/</intensity><bold>suite_two</intensity>\n       • unchecked snapshot 2\"\n`;\n\nexports[`returns nothing if there are no updates 1`] = `\"<bold>Snapshot Summary</intensity>\"`;"}
{"prompt":"getSummary,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {makeEmptyAggregatedTestResult} from '@jest/test-result';\nimport getSummary from '../getSummary';\n\njest.useFakeTimers().setSystemTime(10);\n\ndescribe('getSummary', () => {\n  test('does not print seed value when showSeed is false', () => {\n    const summary = getSummary(makeEmptyAggregatedTestResult(), {\n      estimatedTime: 0,\n      showSeed: false,\n    });\n\n    expect(summary).toMatchSnapshot();\n  });\n\n  test('does print seed value when showSeed is true', () => {\n    const summary = getSummary(makeEmptyAggregatedTestResult(), {\n      estimatedTime: 0,\n      seed: 55_555,\n      showSeed: true,\n    });\n\n    expect(summary).toMatchSnapshot();\n  });\n\n  test('throws error is showSeed is true but seed is not present', () => {\n    expect.assertions(1);\n\n    try {\n      getSummary(makeEmptyAggregatedTestResult(), {\n        estimatedTime: 0,\n        showSeed: true,\n      });\n    } catch (error) {\n      expect(error).toBeInstanceOf(Error);\n    }\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`getSummary does not print seed value when showSeed is false 1`] = `\n\"<bold>Test Suites: </intensity>0 total\n<bold>Tests:       </intensity>0 total\n<bold>Snapshots:   </intensity>0 total\n<bold>Time:</intensity>        0.01 s\"\n`;\n\nexports[`getSummary does print seed value when showSeed is true 1`] = `\n\"<bold>Seed:        </intensity>55555\n<bold>Test Suites: </intensity>0 total\n<bold>Tests:       </intensity>0 total\n<bold>Snapshots:   </intensity>0 total\n<bold>Time:</intensity>        0.01 s\"\n`;"}
{"prompt":".getType,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {getType} from '..';\n\ndescribe('.getType()', () => {\n  test('null', () => expect(getType(null)).toBe('null'));\n  test('undefined', () => expect(getType(undefined)).toBe('undefined'));\n  test('object', () => expect(getType({})).toBe('object'));\n  test('array', () => expect(getType([])).toBe('array'));\n  test('number', () => expect(getType(1)).toBe('number'));\n  test('string', () => expect(getType('oi')).toBe('string'));\n  test('function', () => expect(getType(() => {})).toBe('function'));\n  test('boolean', () => expect(getType(true)).toBe('boolean'));\n  test('symbol', () => expect(getType(Symbol.for('a'))).toBe('symbol'));\n  test('regexp', () => expect(getType(/abc/)).toBe('regexp'));\n  test('map', () => expect(getType(new Map())).toBe('map'));\n  test('set', () => expect(getType(new Set())).toBe('set'));\n  test('date', () => expect(getType(new Date())).toBe('date'));\n  test('bigint', () => expect(getType(BigInt(1))).toBe('bigint'));\n});"}
{"prompt":"getWatermarks,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {makeGlobalConfig} from '@jest/test-utils';\nimport getWatermarks from '../getWatermarks';\n\ndescribe('getWatermarks', () => {\n  test('that watermarks use thresholds as upper target', () => {\n    const watermarks = getWatermarks(\n      makeGlobalConfig({\n        coverageThreshold: {\n          global: {\n            branches: 100,\n            functions: 100,\n            lines: 100,\n            statements: 100,\n          },\n        },\n      }),\n    );\n\n    expect(watermarks).toEqual({\n      branches: [expect.any(Number), 100],\n      functions: [expect.any(Number), 100],\n      lines: [expect.any(Number), 100],\n      statements: [expect.any(Number), 100],\n    });\n  });\n\n  test('that watermarks are created always created', () => {\n    const watermarks = getWatermarks(makeGlobalConfig());\n\n    expect(watermarks).toEqual({\n      branches: [expect.any(Number), expect.any(Number)],\n      functions: [expect.any(Number), expect.any(Number)],\n      lines: [expect.any(Number), expect.any(Number)],\n      statements: [expect.any(Number), expect.any(Number)],\n    });\n  });\n});"}
{"prompt":"getMockName,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nimport * as path from 'path';\nimport getMockName from '../getMockName';\n\ndescribe('getMockName', () => {\n  it('extracts mock name from file path', () => {\n    expect(getMockName(path.join('a', '__mocks__', 'c.js'))).toBe('c');\n\n    expect(getMockName(path.join('a', '__mocks__', 'c', 'd.js'))).toBe(\n      path.join('c', 'd').replaceAll('\\\\', '/'),\n    );\n  });\n});"}
{"prompt":"annotations,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {\n  AggregatedResult,\n  AssertionResult,\n  Status,\n  Test,\n  TestCaseResult,\n  TestResult,\n} from '@jest/test-result';\nimport {normalizeIcons} from '@jest/test-utils';\nimport type {Config} from '@jest/types';\nimport BaseGitHubActionsReporter from '../GitHubActionsReporter';\n\nafterEach(() => {\n  jest.clearAllMocks();\n});\n\nclass GitHubActionsReporter extends BaseGitHubActionsReporter {\n  override log(message: string): void {\n    super.log(normalizeIcons(message));\n  }\n}\n\nconst mockedStderrWrite = jest\n  .spyOn(process.stderr, 'write')\n  .mockImplementation(() => true);\n\ndescribe('annotations', () => {\n  const reporter = new GitHubActionsReporter({} as Config.GlobalConfig);\n\n  const testMeta = {\n    context: {config: {rootDir: '/user/project'}},\n  } as Test;\n\n  const expectationsErrorMessage =\n    'Error: \\u001B[2mexpect(\\u001B[22m\\u001B[31mreceived\\u001B[39m\\u001B[2m).\\u001B[22mtoBe\\u001B[2m(\\u001B[22m\\u001B[32mexpected\\u001B[39m\\u001B[2m) // Object.is equality\\u001B[22m\\n' +\n    '\\n' +\n    'Expected: \\u001B[32m1\\u001B[39m\\n' +\n    'Received: \\u001B[31m10\\u001B[39m\\n' +\n    '    at Object.toBe (/user/project/__tests__/example.test.js:20:14)\\n' +\n    '    at Promise.then.completed (/user/project/jest/packages/jest-circus/build/utils.js:333:28)\\n' +\n    '    at new Promise (<anonymous>)\\n' +\n    '    at callAsyncCircusFn (/user/project/jest/packages/jest-circus/build/utils.js:259:10)\\n' +\n    '    at _callCircusTest (/user/project/jest/packages/jest-circus/build/run.js:276:40)\\n' +\n    '    at processTicksAndRejections (node:internal/process/task_queues:95:5)\\n' +\n    '    at _runTest (/user/project/jest/packages/jest-circus/build/run.js:208:3)\\n' +\n    '    at _runTestsForDescribeBlock (/user/project/jest/packages/jest-circus/build/run.js:96:9)\\n' +\n    '    at run (/user/project/jest/packages/jest-circus/build/run.js:31:3)\\n' +\n    '    at runAndTransformResultsToJestFormat (/user/project/jest/packages/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:135:21)';\n\n  const referenceErrorMessage =\n    'ReferenceError: abc is not defined\\n' +\n    '    at Object.abc (/user/project/__tests__/example.test.js:25:12)\\n' +\n    '    at Promise.then.completed (/user/project/jest/packages/jest-circus/build/utils.js:333:28)\\n' +\n    '    at new Promise (<anonymous>)\\n' +\n    '    at callAsyncCircusFn (/user/project/jest/packages/jest-circus/build/utils.js:259:10)\\n' +\n    '    at _callCircusTest (/user/project/jest/packages/jest-circus/build/run.js:276:40)\\n' +\n    '    at processTicksAndRejections (node:internal/process/task_queues:95:5)\\n' +\n    '    at _runTest (/user/project/jest/packages/jest-circus/build/run.js:208:3)\\n' +\n    '    at _runTestsForDescribeBlock (/user/project/jest/packages/jest-circus/build/run.js:96:9)\\n' +\n    '    at _runTestsForDescribeBlock (/user/project/jest/packages/jest-circus/build/run.js:90:9)\\n' +\n    '    at run (/user/project/jest/packages/jest-circus/build/run.js:31:3)';\n\n  const retryErrorMessage =\n    'Error: \\u001B[2mexpect(\\u001B[22m\\u001B[31mreceived\\u001B[39m\\u001B[2m).\\u001B[22mtoBeFalsy\\u001B[2m()\\u001B[22m\\n' +\n    '\\n' +\n    'Received: \\u001B[31mtrue\\u001B[39m\\n' +\n    '    at Object.toBeFalsy (/user/project/__tests__/example.test.js:19:20)\\n' +\n    '    at Promise.then.completed (/user/project/jest/packages/jest-circus/build/utils.js:333:28)\\n' +\n    '    at new Promise (<anonymous>)\\n' +\n    '    at callAsyncCircusFn (/user/project/jest/packages/jest-circus/build/utils.js:259:10)\\n' +\n    '    at _callCircusTest (/user/project/jest/packages/jest-circus/build/run.js:276:40)\\n' +\n    '    at _runTest (/user/project/jest/packages/jest-circus/build/run.js:208:3)\\n' +\n    '    at _runTestsForDescribeBlock (/user/project/jest/packages/jest-circus/build/run.js:96:9)\\n' +\n    '    at _runTestsForDescribeBlock (/user/project/jest/packages/jest-circus/build/run.js:90:9)\\n' +\n    '    at run (/user/project/jest/packages/jest-circus/build/run.js:31:3)\\n' +\n    '    at runAndTransformResultsToJestFormat (/user/project/jest/packages/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:135:21)';\n\n  const testCaseResult = {\n    ancestorTitles: [] as Array<string>,\n    failureMessages: [expectationsErrorMessage],\n    title: 'example test',\n  } as TestCaseResult;\n\n  describe('logs error annotation', () => {\n    test('when an expectation fails to pass', () => {\n      reporter.generateAnnotations(testMeta, {\n        testResults: [\n          {\n            ...testCaseResult,\n            failureMessages: [expectationsErrorMessage],\n          },\n        ],\n      } as TestResult);\n\n      expect(mockedStderrWrite).toHaveBeenCalledTimes(1);\n      expect(mockedStderrWrite.mock.calls[0]).toMatchSnapshot();\n    });\n\n    test('when a test has reference error', () => {\n      reporter.generateAnnotations(\n        {...testMeta, path: '/user/project/__tests__/example.test.js:25:12'},\n        {\n          testResults: [\n            {\n              ...testCaseResult,\n              failureMessages: [referenceErrorMessage],\n            },\n          ],\n        } as TestResult,\n      );\n\n      expect(mockedStderrWrite).toHaveBeenCalledTimes(1);\n      expect(mockedStderrWrite.mock.calls[0]).toMatchSnapshot();\n    });\n\n    test('when test is wrapped in describe block', () => {\n      reporter.generateAnnotations(testMeta, {\n        testResults: [\n          {\n            ...testCaseResult,\n            ancestorTitles: ['describe'],\n          },\n        ],\n      } as TestResult);\n\n      expect(mockedStderrWrite).toHaveBeenCalledTimes(1);\n      expect(mockedStderrWrite.mock.calls[0]).toMatchSnapshot();\n    });\n  });\n\n  describe('logs warning annotation before logging errors', () => {\n    test('when test result includes retry reasons', () => {\n      reporter.generateAnnotations(testMeta, {\n        testResults: [\n          {\n            ...testCaseResult,\n            failureMessages: [retryErrorMessage],\n            retryReasons: [retryErrorMessage],\n          },\n        ],\n      } as TestResult);\n\n      expect(mockedStderrWrite).toHaveBeenCalledTimes(2);\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n  });\n});\n\ndescribe('logs', () => {\n  test('can be instantiated', () => {\n    const gha = new GitHubActionsReporter({} as Config.GlobalConfig);\n    expect(gha).toBeTruthy();\n    expect(gha).toBeInstanceOf(GitHubActionsReporter);\n  });\n\n  describe('Result tree generation', () => {\n    test('failed single test without describe', () => {\n      const testResults = [\n        {\n          ancestorTitles: [],\n          duration: 10,\n          status: 'failed',\n          title: 'test',\n        },\n      ] as unknown as Array<AssertionResult>;\n      const suitePerf = {\n        end: 30,\n        runtime: 20,\n        slow: false,\n        start: 10,\n      };\n      const expectedResults = {\n        children: [\n          {\n            children: [],\n            duration: 10,\n            name: 'test',\n            status: 'failed',\n          },\n        ],\n        name: '/',\n        passed: false,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      const generated = gha.getResultTree(testResults, '/', suitePerf);\n\n      expect(mockedStderrWrite).not.toHaveBeenCalled();\n      expect(generated).toEqual(expectedResults);\n    });\n\n    test('passed single test without describe', () => {\n      const testResults = [\n        {\n          ancestorTitles: [],\n          duration: 10,\n          status: 'passed',\n          title: 'test',\n        },\n      ] as unknown as Array<AssertionResult>;\n      const suitePerf = {\n        end: 30,\n        runtime: 20,\n        slow: false,\n        start: 10,\n      };\n      const expectedResults = {\n        children: [\n          {\n            children: [],\n            duration: 10,\n            name: 'test',\n            status: 'passed',\n          },\n        ],\n        name: '/',\n        passed: true,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      const generated = gha.getResultTree(testResults, '/', suitePerf);\n\n      expect(mockedStderrWrite).not.toHaveBeenCalled();\n      expect(generated).toEqual(expectedResults);\n    });\n\n    test('failed single test inside describe', () => {\n      const testResults = [\n        {\n          ancestorTitles: ['Test describe'],\n          duration: 10,\n          status: 'failed',\n          title: 'test',\n        },\n      ] as unknown as Array<AssertionResult>;\n      const suitePerf = {\n        end: 30,\n        runtime: 20,\n        slow: false,\n        start: 10,\n      };\n      const expectedResults = {\n        children: [\n          {\n            children: [\n              {\n                children: [],\n                duration: 10,\n                name: 'test',\n                status: 'failed',\n              },\n            ],\n            name: 'Test describe',\n            passed: false,\n          },\n        ],\n        name: '/',\n        passed: false,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      const generated = gha.getResultTree(testResults, '/', suitePerf);\n\n      expect(mockedStderrWrite).not.toHaveBeenCalled();\n      expect(generated).toEqual(expectedResults);\n    });\n\n    test('passed single test inside describe', () => {\n      const testResults = [\n        {\n          ancestorTitles: ['Test describe'],\n          duration: 10,\n          status: 'passed',\n          title: 'test',\n        },\n      ] as unknown as Array<AssertionResult>;\n      const suitePerf = {\n        end: 30,\n        runtime: 20,\n        slow: false,\n        start: 10,\n      };\n      const expectedResults = {\n        children: [\n          {\n            children: [\n              {\n                children: [],\n                duration: 10,\n                name: 'test',\n                status: 'passed',\n              },\n            ],\n            name: 'Test describe',\n            passed: true,\n          },\n        ],\n        name: '/',\n        passed: true,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      const generated = gha.getResultTree(testResults, '/', suitePerf);\n\n      expect(mockedStderrWrite).not.toHaveBeenCalled();\n      expect(generated).toEqual(expectedResults);\n    });\n\n    test('skipped single test and todo single test inside describe', () => {\n      const testResults = [\n        {\n          ancestorTitles: ['Test describe'],\n          duration: 10,\n          status: 'skipped',\n          title: 'test',\n        },\n        {\n          ancestorTitles: ['Test describe'],\n          duration: 14,\n          status: 'todo',\n          title: 'test2',\n        },\n      ] as unknown as Array<AssertionResult>;\n      const suitePerf = {\n        end: 30,\n        runtime: 20,\n        slow: false,\n        start: 10,\n      };\n      const expectedResults = {\n        children: [\n          {\n            children: [\n              {\n                children: [],\n                duration: 10,\n                name: 'test',\n                status: 'skipped',\n              },\n              {\n                children: [],\n                duration: 14,\n                name: 'test2',\n                status: 'todo',\n              },\n            ],\n            name: 'Test describe',\n            passed: true,\n          },\n        ],\n        name: '/',\n        passed: true,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      const generated = gha.getResultTree(testResults, '/', suitePerf);\n\n      expect(mockedStderrWrite).not.toHaveBeenCalled();\n      expect(generated).toEqual(expectedResults);\n    });\n  });\n\n  describe('Result tree output', () => {\n    test('failed single test without describe', () => {\n      const generatedTree = {\n        children: [\n          {\n            children: [],\n            duration: 10,\n            name: 'test',\n            status: 'failed' as Status,\n          },\n        ],\n        name: '/',\n        passed: false,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      gha.printResultTree(generatedTree);\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n\n    test('passed single test without describe', () => {\n      const generatedTree = {\n        children: [\n          {\n            children: [],\n            duration: 10,\n            name: 'test',\n            status: 'passed' as Status,\n          },\n        ],\n        name: '/',\n        passed: true,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      gha.printResultTree(generatedTree);\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n\n    test('failed single test inside describe', () => {\n      const generatedTree = {\n        children: [\n          {\n            children: [\n              {\n                children: [],\n                duration: 10,\n                name: 'test',\n                status: 'failed' as Status,\n              },\n            ],\n            name: 'Test describe',\n            passed: false,\n          },\n        ],\n        name: '/',\n        passed: false,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      gha.printResultTree(generatedTree);\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n\n    test('passed single test inside describe', () => {\n      const generatedTree = {\n        children: [\n          {\n            children: [\n              {\n                children: [],\n                duration: 10,\n                name: 'test',\n                status: 'passed' as Status,\n              },\n            ],\n            name: 'Test describe',\n            passed: true,\n          },\n        ],\n        name: '/',\n        passed: true,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      gha.printResultTree(generatedTree);\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n\n    test('todo single test inside describe', () => {\n      const generatedTree = {\n        children: [\n          {\n            children: [\n              {\n                children: [],\n                duration: 10,\n                name: 'test',\n                status: 'todo' as Status,\n              },\n            ],\n            name: 'Test describe',\n            passed: true,\n          },\n        ],\n        name: '/',\n        passed: true,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      gha.printResultTree(generatedTree);\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n\n    test('skipped single test inside describe', () => {\n      const generatedTree = {\n        children: [\n          {\n            children: [\n              {\n                children: [],\n                duration: 10,\n                name: 'test',\n                status: 'skipped' as Status,\n              },\n            ],\n            name: 'Test describe',\n            passed: true,\n          },\n        ],\n        name: '/',\n        passed: true,\n        performanceInfo: {\n          end: 30,\n          runtime: 20,\n          slow: false,\n          start: 10,\n        },\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n\n      gha.printResultTree(generatedTree);\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n  });\n\n  describe('Reporter interface', () => {\n    test('onTestResult not last', () => {\n      const mockTest = {\n        context: {\n          config: {\n            rootDir: '/testDir',\n          },\n        },\n      };\n      const mockTestResult = {\n        perfStats: {\n          runtime: 20,\n          slow: false,\n        },\n        testFilePath: '/testDir/test1.js',\n        testResults: [\n          {\n            ancestorTitles: [],\n            duration: 10,\n            status: 'passed',\n            title: 'test1',\n          },\n        ],\n      };\n      const mockResults = {\n        numFailedTestSuites: 1,\n        numPassedTestSuites: 1,\n        numTotalTestSuites: 3,\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n      gha.generateAnnotations = jest.fn();\n\n      gha.onTestResult(\n        mockTest as Test,\n        mockTestResult as unknown as TestResult,\n        mockResults as AggregatedResult,\n      );\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n\n    test('onTestResult last', () => {\n      const mockTest = {\n        context: {\n          config: {\n            rootDir: '/testDir',\n          },\n        },\n      };\n      const mockTestResult = {\n        failureMessage: 'Failure message',\n        perfStats: {\n          runtime: 20,\n          slow: false,\n        },\n        testFilePath: '/testDir/test1.js',\n        testResults: [\n          {\n            ancestorTitles: [],\n            duration: 10,\n            status: 'passed',\n            title: 'test1',\n          },\n        ],\n      };\n      const mockResults = {\n        numFailedTestSuites: 1,\n        numPassedTestSuites: 2,\n        numTotalTestSuites: 3,\n        testResults: [mockTestResult],\n      };\n      const gha = new GitHubActionsReporter({} as Config.GlobalConfig, {\n        silent: false,\n      });\n      gha.generateAnnotations = jest.fn();\n\n      gha.onTestResult(\n        mockTest as Test,\n        mockTestResult as unknown as TestResult,\n        mockResults as unknown as AggregatedResult,\n      );\n\n      expect(mockedStderrWrite.mock.calls).toMatchSnapshot();\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`annotations logs error annotation when a test has reference error 1`] = `\nArray [\n  \"\n::error file=/user/project/__tests__/example.test.js,line=25,title=example test::ReferenceError: abc is not defined%0A%0A    at Object.abc (__tests__/example.test.js:25:12)\n\",\n]\n`;\n\nexports[`annotations logs error annotation when an expectation fails to pass 1`] = `\nArray [\n  \"\n::error file=/user/project/__tests__/example.test.js,line=20,title=example test::expect(received).toBe(expected) // Object.is equality%0A%0AExpected: 1%0AReceived: 10%0A%0A    at Object.toBe (__tests__/example.test.js:20:14)\n\",\n]\n`;\n\nexports[`annotations logs error annotation when test is wrapped in describe block 1`] = `\nArray [\n  \"\n::error file=/user/project/__tests__/example.test.js,line=20,title=describe › example test::expect(received).toBe(expected) // Object.is equality%0A%0AExpected: 1%0AReceived: 10%0A%0A    at Object.toBe (__tests__/example.test.js:20:14)\n\",\n]\n`;\n\nexports[`annotations logs warning annotation before logging errors when test result includes retry reasons 1`] = `\nArray [\n  Array [\n    \"\n::warning file=/user/project/__tests__/example.test.js,line=19,title=RETRY 1: example test::expect(received).toBeFalsy()%0A%0AReceived: true%0A%0A    at Object.toBeFalsy (__tests__/example.test.js:19:20)\n\",\n  ],\n  Array [\n    \"\n::error file=/user/project/__tests__/example.test.js,line=19,title=example test::expect(received).toBeFalsy()%0A%0AReceived: true%0A%0A    at Object.toBeFalsy (__tests__/example.test.js:19:20)\n\",\n  ],\n]\n`;\n\nexports[`logs Reporter interface onTestResult last 1`] = `\nArray [\n  Array [\n    \"::group::<bold><green><inverse>PASS</inverse></color></intensity> test1.js (20 ms)\n\",\n  ],\n  Array [\n    \"  <green>✓</color> test1 (10 ms)\n\",\n  ],\n  Array [\n    \"::endgroup::\n\",\n  ],\n  Array [\n    \"\n\",\n  ],\n  Array [\n    \"::group::Errors thrown in test1.js\n\",\n  ],\n  Array [\n    \"Failure message\n\",\n  ],\n  Array [\n    \"::endgroup::\n\",\n  ],\n]\n`;\n\nexports[`logs Reporter interface onTestResult not last 1`] = `\nArray [\n  Array [\n    \"::group::<bold><green><inverse>PASS</inverse></color></intensity> test1.js (20 ms)\n\",\n  ],\n  Array [\n    \"  <green>✓</color> test1 (10 ms)\n\",\n  ],\n  Array [\n    \"::endgroup::\n\",\n  ],\n]\n`;\n\nexports[`logs Result tree output failed single test inside describe 1`] = `\nArray [\n  Array [\n    \"  <bold><red><inverse>FAIL</inverse></color></intensity> / (20 ms)\n\",\n  ],\n  Array [\n    \"    Test describe\n\",\n  ],\n  Array [\n    \"      <red>✕</color> test (10 ms)\n\",\n  ],\n]\n`;\n\nexports[`logs Result tree output failed single test without describe 1`] = `\nArray [\n  Array [\n    \"  <bold><red><inverse>FAIL</inverse></color></intensity> / (20 ms)\n\",\n  ],\n  Array [\n    \"    <red>✕</color> test (10 ms)\n\",\n  ],\n]\n`;\n\nexports[`logs Result tree output passed single test inside describe 1`] = `\nArray [\n  Array [\n    \"::group::<bold><green><inverse>PASS</inverse></color></intensity> / (20 ms)\n\",\n  ],\n  Array [\n    \"  Test describe\n\",\n  ],\n  Array [\n    \"    <green>✓</color> test (10 ms)\n\",\n  ],\n  Array [\n    \"::endgroup::\n\",\n  ],\n]\n`;\n\nexports[`logs Result tree output passed single test without describe 1`] = `\nArray [\n  Array [\n    \"::group::<bold><green><inverse>PASS</inverse></color></intensity> / (20 ms)\n\",\n  ],\n  Array [\n    \"  <green>✓</color> test (10 ms)\n\",\n  ],\n  Array [\n    \"::endgroup::\n\",\n  ],\n]\n`;\n\nexports[`logs Result tree output skipped single test inside describe 1`] = `\nArray [\n  Array [\n    \"::group::<bold><green><inverse>PASS</inverse></color></intensity> / (20 ms)\n\",\n  ],\n  Array [\n    \"  Test describe\n\",\n  ],\n  Array [\n    \"    <yellow>○</color> test (10 ms)\n\",\n  ],\n  Array [\n    \"::endgroup::\n\",\n  ],\n]\n`;\n\nexports[`logs Result tree output todo single test inside describe 1`] = `\nArray [\n  Array [\n    \"::group::<bold><green><inverse>PASS</inverse></color></intensity> / (20 ms)\n\",\n  ],\n  Array [\n    \"  Test describe\n\",\n  ],\n  Array [\n    \"    <magenta>✎</color> test (10 ms)\n\",\n  ],\n  Array [\n    \"::endgroup::\n\",\n  ],\n]\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst global = 'woo!';\n\ntest('can redefine global', () => {\n  expect(global).toBe('woo!');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('globals are properly defined', () => {\n  expect(globalThis.Object).toBe(Object);\n});"}
{"prompt":"Common globals,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('Common globals', () => {\n  it('check process', () => {\n    if (Symbol && Symbol.toStringTag) {\n      expect(Object.prototype.toString.call(process)).toBe('[object process]');\n    }\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`basic test constructs 1`] = `\n\"PASS __tests__/basic.testConstructs.test.js\n  ✓ it\n  ✓ test\n  describe\n    ✓ it\n    ✓ test\"\n`;\n\nexports[`basic test constructs 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       4 passed, 4 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`cannot have describe with no implementation 1`] = `\n\"FAIL __tests__/onlyConstructs.test.js\n  ● Test suite failed to run\n\n    Missing second argument. It must be a callback function.\n\n    > 1 | describe('describe, no implementation');\n        |                                        ^\n\n      at Object.<anonymous> (__tests__/onlyConstructs.test.js:1:40)\"\n`;\n\nexports[`cannot have describe with no implementation 2`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       0 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`cannot test with no implementation 1`] = `\n\"FAIL __tests__/onlyConstructs.test.js\n  ● Test suite failed to run\n\n    Missing second argument. It must be a callback function. Perhaps you want to use \\`test.todo\\` for a test placeholder.\n\n      1 | it('it', () => {});\n    > 2 | it('it, no implementation');\n        | ^\n      3 | test('test, no implementation');\n\n      at Object.it (__tests__/onlyConstructs.test.js:2:1)\"\n`;\n\nexports[`cannot test with no implementation 2`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       0 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`cannot test with no implementation with expand arg 1`] = `\n\"FAIL __tests__/onlyConstructs.test.js\n  ● Test suite failed to run\n\n    Missing second argument. It must be a callback function. Perhaps you want to use \\`test.todo\\` for a test placeholder.\n\n      1 | it('it', () => {});\n    > 2 | it('it, no implementation');\n        | ^\n      3 | test('test, no implementation');\n\n      at Object.it (__tests__/onlyConstructs.test.js:2:1)\"\n`;\n\nexports[`cannot test with no implementation with expand arg 2`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       0 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`function as describe() descriptor 1`] = `\n\"PASS __tests__/functionAsDescriptor.test.js\n  Foo\n    ✓ it\"\n`;\n\nexports[`function as describe() descriptor 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`function as it() descriptor 1`] = `\n\"PASS __tests__/functionAsDescriptor.test.js\n  ✓ Foo\"\n`;\n\nexports[`function as it() descriptor 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`interleaved describe and test children order 1`] = `\n\"PASS __tests__/interleaved.test.js\n  ✓ above\n  ✓ below\n  describe\n    ✓ inside\"\n`;\n\nexports[`interleaved describe and test children order 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       3 passed, 3 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`on node ^18.18.0 || >=20.4.0 Symbol's \\`dispose\\` are available 1`] = `\n\"PASS __tests__/symbolDispose.test.js\n  ✓ test\"\n`;\n\nexports[`on node ^18.18.0 || >=20.4.0 Symbol's \\`dispose\\` are available 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`only 1`] = `\n\"PASS __tests__/onlyConstructs.test.js\n  ✓ test.only\n  ✓ it.only\n  ✓ fit\n  ○ skipped it\n  fdescribe\n    ✓ it\n    ✓ test\n  describe.only\n    ✓ test\n    describe\n      ✓ test\"\n`;\n\nexports[`only 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 skipped, 7 passed, 8 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`only with expand arg 1`] = `\n\"PASS __tests__/onlyConstructs.test.js\n  ○ it\n  ✓ test.only\n  ✓ it.only\n  ✓ fit\n  fdescribe\n    ✓ it\n    ✓ test\n  describe.only\n    ✓ test\n    describe\n      ✓ test\"\n`;\n\nexports[`only with expand arg 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 skipped, 7 passed, 8 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`skips 1`] = `\n\"PASS __tests__/skipsConstructs.test.js\n  ✓ it\n  ○ skipped xtest\n  ○ skipped xit\n  ○ skipped it.skip\n  ○ skipped test.skip\n  xdescribe\n    ○ skipped it\n    ○ skipped test\n  describe.skip\n    ○ skipped test\n    describe\n      ○ skipped test\"\n`;\n\nexports[`skips 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       8 skipped, 1 passed, 9 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`skips with expand arg 1`] = `\n\"PASS __tests__/skipsConstructs.test.js\n  ✓ it\n  ○ xtest\n  ○ xit\n  ○ it.skip\n  ○ test.skip\n  xdescribe\n    ○ it\n    ○ test\n  describe.skip\n    ○ test\n    describe\n      ○ test\"\n`;\n\nexports[`skips with expand arg 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       8 skipped, 1 passed, 9 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"onlyChanged ensures there are no tests to run","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {\n  cleanup,\n  createEmptyPackage,\n  runYarnInstall,\n  writeFiles,\n} from '../Utils';\nimport runJest, {json as runWithJson} from '../runJest';\n\nconst DIR = path.join(tmpdir(), 'jest-global-setup');\nconst project1DIR = path.join(tmpdir(), 'jest-global-setup-project-1');\nconst project2DIR = path.join(tmpdir(), 'jest-global-setup-project-2');\nconst customTransformDIR = path.join(\n  tmpdir(),\n  'jest-global-setup-custom-transform',\n);\nconst nodeModulesDIR = path.join(tmpdir(), 'jest-global-setup-node-modules');\nconst rejectionDir = path.join(tmpdir(), 'jest-global-setup-rejection');\nconst e2eDir = path.resolve(__dirname, '../global-setup');\nconst esmTmpDir = path.join(tmpdir(), 'jest-global-setup-esm');\n\nbeforeAll(() => {\n  runYarnInstall(e2eDir);\n});\n\nbeforeEach(() => {\n  cleanup(DIR);\n  cleanup(project1DIR);\n  cleanup(project2DIR);\n  cleanup(customTransformDIR);\n  cleanup(nodeModulesDIR);\n  cleanup(rejectionDir);\n  cleanup(esmTmpDir);\n});\n\nafterAll(() => {\n  cleanup(DIR);\n  cleanup(project1DIR);\n  cleanup(project2DIR);\n  cleanup(customTransformDIR);\n  cleanup(nodeModulesDIR);\n  cleanup(rejectionDir);\n  cleanup(esmTmpDir);\n});\n\ntest('globalSetup is triggered once before all test suites', () => {\n  const setupPath = path.join(e2eDir, 'setup.js');\n  const result = runWithJson(e2eDir, [\n    `--globalSetup=${setupPath}`,\n    '--testPathPatterns=__tests__',\n  ]);\n\n  expect(result.exitCode).toBe(0);\n  const files = fs.readdirSync(DIR);\n  expect(files).toHaveLength(1);\n  const setup = fs.readFileSync(path.join(DIR, files[0]), 'utf8');\n  expect(setup).toBe('setup');\n});\n\ntest('jest throws an error when globalSetup does not export a function', () => {\n  const setupPath = path.resolve(__dirname, '../global-setup/invalidSetup.js');\n  const {exitCode, stderr} = runJest(e2eDir, [\n    `--globalSetup=${setupPath}`,\n    '--testPathPatterns=__tests__',\n  ]);\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toContain('Jest: Got error running globalSetup');\n  expect(stderr).toContain(\n    `globalSetup file must export a function at ${setupPath}`,\n  );\n});\n\ntest('globalSetup function gets global config object and project config as parameters', () => {\n  const setupPath = path.resolve(e2eDir, 'setupWithConfig.js');\n\n  const result = runJest(e2eDir, [\n    `--globalSetup=${setupPath}`,\n    '--testPathPatterns=pass',\n    '--cache=true',\n  ]);\n\n  expect(result.stdout).toBe(\"[ 'pass' ]\\ntrue\");\n});\n\ntest('should call globalSetup function of multiple projects', () => {\n  const configPath = path.resolve(e2eDir, 'projects.jest.config.js');\n\n  const result = runWithJson(e2eDir, [`--config=${configPath}`]);\n\n  expect(result.exitCode).toBe(0);\n\n  expect(fs.existsSync(DIR)).toBe(true);\n  expect(fs.existsSync(project1DIR)).toBe(true);\n  expect(fs.existsSync(project2DIR)).toBe(true);\n});\n\ntest('should not call a globalSetup of a project if there are no tests to run from this project', () => {\n  const configPath = path.resolve(e2eDir, 'projects.jest.config.js');\n\n  const result = runWithJson(e2eDir, [\n    `--config=${configPath}`,\n    '--testPathPatterns=setup1',\n  ]);\n\n  expect(result.exitCode).toBe(0);\n\n  expect(fs.existsSync(DIR)).toBe(true);\n  expect(fs.existsSync(project1DIR)).toBe(true);\n  expect(fs.existsSync(project2DIR)).toBe(false);\n});\n\ntest('should not call any globalSetup if there are no tests to run', () => {\n  const configPath = path.resolve(e2eDir, 'projects.jest.config.js');\n\n  const result = runWithJson(e2eDir, [\n    `--config=${configPath}`,\n    // onlyChanged ensures there are no tests to run\n    '--onlyChanged',\n  ]);\n\n  expect(result.exitCode).toBe(0);\n\n  expect(fs.existsSync(DIR)).toBe(false);\n  expect(fs.existsSync(project1DIR)).toBe(false);\n  expect(fs.existsSync(project2DIR)).toBe(false);\n});\n\ntest('globalSetup works with default export', () => {\n  const setupPath = path.resolve(e2eDir, 'setupWithDefaultExport.js');\n\n  const result = runJest(e2eDir, [\n    `--globalSetup=${setupPath}`,\n    '--testPathPatterns=pass',\n    '--cache=true',\n  ]);\n\n  expect(result.stdout).toBe(\"[ 'pass' ]\\ntrue\");\n});\n\ntest('globalSetup throws with named export', () => {\n  const setupPath = path.resolve(e2eDir, 'invalidSetupWithNamedExport.js');\n\n  const {exitCode, stderr} = runJest(e2eDir, [\n    `--globalSetup=${setupPath}`,\n    '--testPathPatterns=__tests__',\n  ]);\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toContain('Jest: Got error running globalSetup');\n  expect(stderr).toContain(\n    `globalSetup file must export a function at ${setupPath}`,\n  );\n});\n\ntest('should not transpile the transformer', () => {\n  const {exitCode} = runJest('global-setup-custom-transform', ['--no-cache']);\n\n  expect(exitCode).toBe(0);\n});\n\ntest('should transform node_modules if configured by transformIgnorePatterns', () => {\n  const {exitCode} = runJest('global-setup-node-modules', ['--no-cache']);\n\n  expect(exitCode).toBe(0);\n});\n\ntest('properly handle rejections', () => {\n  createEmptyPackage(rejectionDir, {jest: {globalSetup: '<rootDir>/setup.js'}});\n  writeFiles(rejectionDir, {\n    'setup.js': `\n      module.exports = () => Promise.reject();\n    `,\n    'test.js': `\n      test('dummy', () => {\n        expect(true).toBe(true);\n      });\n    `,\n  });\n\n  const {exitCode, stderr} = runJest(rejectionDir, ['--no-cache']);\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toContain('Error: Jest: Got error running globalSetup');\n  expect(stderr).toContain('reason: undefined');\n});\n\ntest('globalSetup works with ESM modules', () => {\n  const {exitCode} = runJest('global-setup-esm', ['--no-cache'], {\n    nodeOptions: '--experimental-vm-modules --no-warnings',\n  });\n\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {createDirectory} from 'jest-util';\nimport {cleanup, runYarnInstall} from '../Utils';\nimport runJest, {json as runWithJson} from '../runJest';\n\nconst DIR = path.join(tmpdir(), 'jest-global-teardown');\nconst project1DIR = path.join(tmpdir(), 'jest-global-teardown-project-1');\nconst project2DIR = path.join(tmpdir(), 'jest-global-teardown-project-2');\nconst e2eDir = path.resolve(__dirname, '../global-teardown');\nconst esmTmpDir = path.join(tmpdir(), 'jest-global-teardown-esm');\n\nbeforeAll(() => {\n  runYarnInstall(e2eDir);\n});\n\nbeforeEach(() => {\n  cleanup(DIR);\n  cleanup(project1DIR);\n  cleanup(project2DIR);\n  cleanup(esmTmpDir);\n});\nafterAll(() => {\n  cleanup(DIR);\n  cleanup(project1DIR);\n  cleanup(project2DIR);\n  cleanup(esmTmpDir);\n});\n\ntest('globalTeardown is triggered once after all test suites', () => {\n  createDirectory(DIR);\n  const teardownPath = path.resolve(e2eDir, 'teardown.js');\n  const result = runWithJson('global-teardown', [\n    `--globalTeardown=${teardownPath}`,\n    '--testPathPatterns=__tests__',\n  ]);\n\n  expect(result.exitCode).toBe(0);\n  const files = fs.readdirSync(DIR);\n  expect(files).toHaveLength(1);\n  const teardown = fs.readFileSync(path.join(DIR, files[0]), 'utf8');\n  expect(teardown).toBe('teardown');\n});\n\ntest('jest throws an error when globalTeardown does not export a function', () => {\n  const teardownPath = path.resolve(e2eDir, 'invalidTeardown.js');\n  const {exitCode, stderr} = runJest(e2eDir, [\n    `--globalTeardown=${teardownPath}`,\n    '--testPathPatterns=__tests__',\n  ]);\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toContain('Jest: Got error running globalTeardown');\n  expect(stderr).toContain(\n    `globalTeardown file must export a function at ${teardownPath}`,\n  );\n});\n\ntest('globalSetup function gets global config object and project config as parameters', () => {\n  const teardownPath = path.resolve(e2eDir, 'teardownWithConfig.js');\n\n  const result = runJest(e2eDir, [\n    `--globalTeardown=${teardownPath}`,\n    '--testPathPatterns=pass',\n    '--cache=true',\n  ]);\n\n  expect(result.stdout).toBe(\"[ 'pass' ]\\ntrue\");\n});\n\ntest('should call globalTeardown function of multiple projects', () => {\n  const configPath = path.resolve(e2eDir, 'projects.jest.config.js');\n\n  const result = runWithJson('global-teardown', [`--config=${configPath}`]);\n\n  expect(result.exitCode).toBe(0);\n\n  expect(fs.existsSync(DIR)).toBe(true);\n  expect(fs.existsSync(project1DIR)).toBe(true);\n  expect(fs.existsSync(project2DIR)).toBe(true);\n});\n\ntest('should not call a globalTeardown of a project if there are no tests to run from this project', () => {\n  const configPath = path.resolve(e2eDir, 'projects.jest.config.js');\n\n  const result = runWithJson('global-teardown', [\n    `--config=${configPath}`,\n    '--testPathPatterns=teardown1',\n  ]);\n\n  expect(result.exitCode).toBe(0);\n\n  expect(fs.existsSync(DIR)).toBe(true);\n  expect(fs.existsSync(project1DIR)).toBe(true);\n  expect(fs.existsSync(project2DIR)).toBe(false);\n});\n\ntest('globalTeardown works with default export', () => {\n  const teardownPath = path.resolve(e2eDir, 'teardownWithDefaultExport.js');\n\n  const result = runJest(e2eDir, [\n    `--globalTeardown=${teardownPath}`,\n    '--testPathPatterns=pass',\n    '--cache=true',\n  ]);\n\n  expect(result.stdout).toBe(\"[ 'pass' ]\\ntrue\");\n});\n\ntest('globalTeardown throws with named export', () => {\n  const teardownPath = path.resolve(\n    e2eDir,\n    'invalidTeardownWithNamedExport.js',\n  );\n\n  const {exitCode, stderr} = runJest(e2eDir, [\n    `--globalTeardown=${teardownPath}`,\n    '--testPathPatterns=__tests__',\n  ]);\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toContain('Jest: Got error running globalTeardown');\n  expect(stderr).toContain(\n    `globalTeardown file must export a function at ${teardownPath}`,\n  );\n});\n\ntest('globalTeardown works with ESM modules', () => {\n  const {exitCode} = runJest('global-teardown-esm', ['--no-cache'], {\n    nodeOptions: '--experimental-vm-modules --no-warnings',\n  });\n\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nexports.isGlobalImageStub = true;"}
{"prompt":"works like micromatch with only positive globs,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport micromatch = require('micromatch');\nimport globsToMatcher from '../globsToMatcher';\n\nit('works like micromatch with only positive globs', () => {\n  const globs = ['**/*.test.js', '**/*.test.jsx'];\n  const matcher = globsToMatcher(globs);\n\n  expect(matcher('some-module.js')).toBe(\n    micromatch(['some-module.js'], globs).length > 0,\n  );\n\n  expect(matcher('some-module.test.js')).toBe(\n    micromatch(['some-module.test.js'], globs).length > 0,\n  );\n});\n\nit('works like micromatch with a mix of overlapping positive and negative globs', () => {\n  const globs = ['**/*.js', '!**/*.test.js', '**/*.test.js'];\n  const matcher = globsToMatcher(globs);\n\n  expect(matcher('some-module.js')).toBe(\n    micromatch(['some-module.js'], globs).length > 0,\n  );\n\n  expect(matcher('some-module.test.js')).toBe(\n    micromatch(['some-module.test.js'], globs).length > 0,\n  );\n\n  const globs2 = ['**/*.js', '!**/*.test.js', '**/*.test.js', '!**/*.test.js'];\n  const matcher2 = globsToMatcher(globs2);\n\n  expect(matcher2('some-module.js')).toBe(\n    micromatch(['some-module.js'], globs2).length > 0,\n  );\n\n  expect(matcher2('some-module.test.js')).toBe(\n    micromatch(['some-module.test.js'], globs2).length > 0,\n  );\n});\n\nit('works like micromatch with only negative globs', () => {\n  const globs = ['!**/*.test.js', '!**/*.test.jsx'];\n  const matcher = globsToMatcher(globs);\n\n  expect(matcher('some-module.js')).toBe(\n    micromatch(['some-module.js'], globs).length > 0,\n  );\n\n  expect(matcher('some-module.test.js')).toBe(\n    micromatch(['some-module.test.js'], globs).length > 0,\n  );\n});\n\nit('works like micromatch with empty globs', () => {\n  const globs: Array<string> = [];\n  const matcher = globsToMatcher(globs);\n\n  expect(matcher('some-module.js')).toBe(\n    micromatch(['some-module.js'], globs).length > 0,\n  );\n\n  expect(matcher('some-module.test.js')).toBe(\n    micromatch(['some-module.test.js'], globs).length > 0,\n  );\n});\n\nit('works like micromatch with pure negated extglobs', () => {\n  const globs = ['**/*.js', '!(some-module.test.js)'];\n  const matcher = globsToMatcher(globs);\n\n  expect(matcher('some-module.js')).toBe(\n    micromatch(['some-module.js'], globs).length > 0,\n  );\n\n  expect(matcher('some-module.test.js')).toBe(\n    micromatch(['some-module.test.js'], globs).length > 0,\n  );\n});\n\nit('works like micromatch with negated extglobs', () => {\n  const globs = ['**/*.js', '!(tests|coverage)/*.js'];\n  const matcher = globsToMatcher(globs);\n\n  expect(matcher('some-module.js')).toBe(\n    micromatch(['some-module.js'], globs).length > 0,\n  );\n\n  expect(matcher('tests/some-module.test.js')).toBe(\n    micromatch(['tests/some-module.test.js'], globs).length > 0,\n  );\n});"}
{"prompt":"Test generated from existing file","test":"/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst greet = require('../greet.hbs');\n\ntest('am', () => {\n  expect(greet({am: true, name: 'Joe'}).replaceAll('\\r\\n', '\\n')).toBe(\n    '<p>Good\\n  morning\\nJoe!</p>\\n',\n  );\n});"}
{"prompt":"Custom Haste,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nconst add = require('fakeModuleName');\n\ndescribe('Custom Haste', () => {\n  test('adds ok', () => {\n    expect(true).toBe(true);\n    expect(add(1, 2)).toBe(3);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nfunction add(a, b) {\n  return a + b;\n}\n\nmodule.exports = add;"}
{"prompt":"Directory must be here for Watchman to be enabled.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport JestHasteMap from 'jest-haste-map';\nimport {cleanup, writeFiles} from '../Utils';\n\n// Directory must be here for Watchman to be enabled.\nconst DIR = path.resolve(__dirname, 'haste_map_mock_changed');\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ntest('should not warn when a mock file changes', async () => {\n  const hasteConfig = {\n    computeSha1: false,\n    extensions: ['js', 'json', 'png'],\n    forceNodeFilesystemAPI: false,\n    id: `tmp_${Date.now()}`,\n    ignorePattern: / ^/,\n    maxWorkers: 2,\n    mocksPattern: '__mocks__',\n    platforms: [],\n    retainAllFiles: false,\n    rootDir: DIR,\n    roots: [DIR],\n    throwOnModuleCollision: true,\n    useWatchman: true,\n    watch: false,\n  };\n\n  // Populate the cache.\n  writeFiles(DIR, {\n    '__mocks__/fs.js': '\"foo fs\"',\n  });\n  await (await JestHasteMap.create(hasteConfig)).build();\n\n  // This will throw if the mock file being updated triggers a warning.\n  writeFiles(DIR, {\n    '__mocks__/fs.js': '\"foo fs!\"',\n  });\n  await (await JestHasteMap.create(hasteConfig)).build();\n});"}
{"prompt":"Ignored files do not get the SHA-1 computed.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport JestHasteMap from 'jest-haste-map';\nimport {cleanup, writeFiles} from '../Utils';\n\nconst DIR = path.resolve(tmpdir(), 'haste_map_sha1');\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ntest('exits the process after test are done but before timers complete', async () => {\n  writeFiles(DIR, {\n    'file.android.js': '\"foo android\"',\n    'file.ios.js': '\"foo ios\"',\n    'file.js': '\"foo default\"',\n    'fileWithExtension.ignored': '\"ignored file\"',\n    'node_modules/bar/fileWithExtension.ignored': '\"ignored node modules\"',\n    'node_modules/bar/image.png': '\"an image\"',\n    'node_modules/bar/index.js': '\"node modules bar\"',\n  });\n\n  const haste = await JestHasteMap.create({\n    computeSha1: true,\n    extensions: ['js', 'json', 'png'],\n    forceNodeFilesystemAPI: true,\n    id: 'tmp',\n    ignorePattern: / ^/,\n    maxWorkers: 2,\n    mocksPattern: '',\n    platforms: ['ios', 'android'],\n    retainAllFiles: true,\n    rootDir: DIR,\n    roots: [DIR],\n    useWatchman: false,\n    watch: false,\n  });\n\n  const {hasteFS} = await haste.build();\n\n  expect(hasteFS.getSha1(path.join(DIR, 'file.android.js'))).toBe(\n    'e376f9fd9a96d000fa019020159f996a8855f8bc',\n  );\n\n  expect(hasteFS.getSha1(path.join(DIR, 'file.ios.js'))).toBe(\n    '1271b4db2a5f47ae46cb01a1d0604a94d401e8f7',\n  );\n\n  expect(hasteFS.getSha1(path.join(DIR, 'file.js'))).toBe(\n    'c26c852220977244418f17a9fdc4ae9c192b3188',\n  );\n\n  expect(hasteFS.getSha1(path.join(DIR, 'node_modules/bar/image.png'))).toBe(\n    '8688f7e11f63d8a7eac7cb87af850337fabbd400',\n  );\n\n  expect(hasteFS.getSha1(path.join(DIR, 'node_modules/bar/index.js'))).toBe(\n    'ee245b9fbd45e1f6ad300eb2f5484844f6b5a34c',\n  );\n\n  // Ignored files do not get the SHA-1 computed.\n\n  expect(\n    hasteFS.getSha1(path.join(DIR, 'fileWithExtension.ignored')),\n  ).toBeNull();\n\n  expect(\n    hasteFS.getSha1(\n      path.join(DIR, 'node_modules/bar/fileWithExtension.ignored'),\n    ),\n  ).toBeNull();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {realpathSync} from 'graceful-fs';\nimport HasteMap from 'jest-haste-map';\nimport {cleanup, writeFiles} from '../Utils';\n\nconst DIR = path.resolve(realpathSync.native(tmpdir()), 'haste_map_size');\n\nbeforeEach(() => {\n  cleanup(DIR);\n  writeFiles(DIR, {\n    'file.js': '\"abc\"',\n  });\n});\nafterEach(() => cleanup(DIR));\n\nconst options = {\n  extensions: ['js'],\n  forceNodeFilesystemAPI: true,\n  id: 'tmp',\n  ignorePattern: / ^/,\n  maxWorkers: 2,\n  mocksPattern: '',\n  platforms: [],\n  retainAllFiles: true,\n  rootDir: DIR,\n  roots: [DIR],\n  useWatchman: false,\n  watch: false,\n};\n\ntest('reports the correct file size', async () => {\n  const hasteMap = await HasteMap.create(options);\n  const {hasteFS} = await hasteMap.build();\n  expect(hasteFS.getSize(path.join(DIR, 'file.js'))).toBe(5);\n});\n\ntest('updates the file size when a file changes', async () => {\n  const hasteMap = await HasteMap.create({...options, watch: true});\n  await hasteMap.build();\n\n  writeFiles(DIR, {\n    'file.js': '\"asdf\"',\n  });\n  const {hasteFS} = await new Promise(resolve =>\n    hasteMap.once('change', resolve),\n  );\n  hasteMap.end();\n  expect(hasteFS.getSize(path.join(DIR, 'file.js'))).toBe(6);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst path = require('path');\nlet cacheKey;\n\nmodule.exports = {\n  getCacheKey() {\n    return cacheKey;\n  },\n\n  getHasteName(filename) {\n    if (\n      filename.includes('__mocks__') ||\n      filename.includes('NoHaste') ||\n      filename.includes(`${path.sep}module_dir${path.sep}`) ||\n      filename.includes(`${path.sep}sourcemaps${path.sep}`)\n    ) {\n      return undefined;\n    }\n\n    return filename\n      .slice(filename.lastIndexOf(path.sep) + 1)\n      .replace(/(\\.(android|ios|native))?\\.js$/, '');\n  },\n\n  setCacheKey(key) {\n    cacheKey = key;\n  },\n};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst {monitorEventLoopDelay} = require('perf_hooks');\n\ntest('something', () => {\n  const histogram = monitorEventLoopDelay();\n  histogram.enable();\n  expect(true).toBe(true);\n});"}
{"prompt":"replace the filename wh something that will be the same across OSes and machine","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as path from 'path';\nimport {format as formatCode, resolveConfig} from '@prettier/sync';\nimport pluginTester from 'babel-plugin-tester';\nimport type {Options} from 'prettier';\nimport babelPluginJestHoist from '..';\n\nconst prettierOptions: Options = {\n  ...resolveConfig(__filename),\n  filepath: __filename,\n  parser: 'babel-ts',\n};\n\nconst formatResult = (code: string) => formatCode(code, prettierOptions);\n\npluginTester({\n  plugin: babelPluginJestHoist,\n  pluginName: 'babel-plugin-jest-hoist',\n  tests: {\n    /* eslint-disable sort-keys */\n    'automatic react runtime': {\n      babelOptions: {\n        babelrc: false,\n        configFile: false,\n        filename: path.resolve(__dirname, '../file.js'),\n        presets: [\n          [\n            require.resolve('@babel/preset-react'),\n            {development: true, runtime: 'automatic'},\n          ],\n        ],\n      },\n      code: formatResult(`\n        jest.mock('./App', () => () => <div>Hello world</div>);\n      `),\n      formatResult(code) {\n        // replace the filename with something that will be the same across OSes and machine\n        const codeWithoutSystemPath = code.replace(\n          /var _jsxFileName = \".*\";/,\n          'var _jsxFileName = \"/root/project/src/file.js\";',\n        );\n\n        return formatResult(codeWithoutSystemPath);\n      },\n      snapshot: true,\n    },\n    'top level mocking': {\n      code: formatResult(`\n        require('x');\n\n        jest.enableAutomock();\n        jest.disableAutomock();\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'within a block': {\n      code: formatResult(`\n        beforeEach(() => {\n          require('x')\n          jest.mock('someNode')\n        })\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'within a block with no siblings': {\n      code: formatResult(`\n        beforeEach(() => {\n          jest.mock('someNode')\n        })\n      `),\n      formatResult,\n      snapshot: true,\n    },\n\n    'required `jest` within `jest`': {\n      code: formatResult(`\n        const {jest} = require('@jest/globals');\n\n        jest.mock('some-module', () => {\n          jest.requireActual('some-module');\n        });\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'imported jest.mock within jest.mock': {\n      code: formatResult(`\n        import {jest} from '@jest/globals';\n\n        jest.mock('some-module', () => {\n          jest.mock('some-module');\n        });\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'global jest.mock within jest.mock': {\n      code: formatResult(`\n        jest.mock('some-module', () => {\n          jest.mock('some-module');\n        });\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'imported jest.requireActual in jest.mock': {\n      code: formatResult(`\n        import {jest} from '@jest/globals';\n\n        jest.mock('some-module', () => {\n          jest.requireActual('some-module');\n        });\n\n        jest.requireActual('some-module');\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'global jest.requireActual in jest.mock': {\n      code: formatResult(`\n        jest.mock('some-module', () => {\n          jest.requireActual('some-module');\n        });\n\n        jest.requireActual('some-module');\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'TS typeof usage in jest.mock': {\n      babelOptions: {\n        babelrc: false,\n        configFile: false,\n        filename: path.resolve(__dirname, '../file.ts'),\n        presets: [[require.resolve('@babel/preset-typescript')]],\n      },\n      code: formatResult(`\n        jest.mock('some-module', () => {\n          const actual = jest.requireActual('some-module');\n\n          return jest.fn<typeof actual.method>();\n        });\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'jest.spyOn call on the imported module': {\n      code: formatResult(`\n        jest.mock('some-module', () => {\n          const module = jest.requireActual('some-module');\n          jest.spyOn(module, 'add');\n          return module;\n        });\n      `),\n      formatResult,\n      snapshot: true,\n    },\n    'jest.spyOn call in class constructor': {\n      code: formatResult(`\n        jest.mock('some-module', () => {\n          const Actual = jest.requireActual('some-module');\n          return class Mocked extends Actual {\n            constructor() {\n              super();\n              jest.spyOn(this, 'add');\n            }\n          };\n        });\n      `),\n      formatResult,\n      snapshot: true,\n    },\n  },\n  /* eslint-enable */\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`babel-plugin-jest-hoist 1. automatic react runtime: 1. automatic react runtime 1`] = `\n\njest.mock('./App', () => () => <div>Hello world</div>);\n\n\n      ↓ ↓ ↓ ↓ ↓ ↓\n\nvar _jsxFileName = '/root/project/src/file.js';\n_getJestObj().mock(\n  './App',\n  () => () =>\n    /*#__PURE__*/ _jsxDEV(\n      'div',\n      {\n        children: 'Hello world',\n      },\n      void 0,\n      false,\n      {\n        fileName: _jsxFileName,\n        lineNumber: 1,\n        columnNumber: 32,\n      },\n      this,\n    ),\n);\nimport {jsxDEV as _jsxDEV} from 'react/jsx-dev-runtime';\nfunction _getJestObj() {\n  const {jest} = require('@jest/globals');\n  _getJestObj = () => jest;\n  return jest;\n}\n\n`;\n\nexports[`babel-plugin-jest-hoist 2. top level mocking: 2. top level mocking 1`] = `\n\nrequire('x');\n\njest.enableAutomock();\njest.disableAutomock();\n\n\n      ↓ ↓ ↓ ↓ ↓ ↓\n\n_getJestObj().enableAutomock();\n_getJestObj().disableAutomock();\nfunction _getJestObj() {\n  const {jest} = require('@jest/globals');\n  _getJestObj = () => jest;\n  return jest;\n}\nrequire('x');\n\n`;\n\nexports[`babel-plugin-jest-hoist 3. within a block: 3. within a block 1`] = `\n\nbeforeEach(() => {\n  require('x');\n  jest.mock('someNode');\n});\n\n\n      ↓ ↓ ↓ ↓ ↓ ↓\n\nfunction _getJestObj() {\n  const {jest} = require('@jest/globals');\n  _getJestObj = () => jest;\n  return jest;\n}\nbeforeEach(() => {\n  _getJestObj().mock('someNode');\n  require('x');\n});\n\n`;\n\nexports[`babel-plugin-jest-hoist 4. within a block with no siblings: 4. within a block with no siblings 1`] = `\n\nbeforeEach(() => {\n  jest.mock('someNode');\n});\n\n\n      ↓ ↓ ↓ ↓ ↓ ↓\n\nfunction _getJestObj() {\n  const {jest} = require('@jest/globals');\n  _getJestObj = () => jest;\n  return jest;\n}\nbeforeEach(() => {\n  _getJestObj().mock('someNode');\n});\n\n`;\n\nexports[`babel-plugin-jest-hoist 5. required \\`jest\\` within \\`jest\\`: 5. required \\`jest\\` within \\`jest\\` 1`] = `\n\nconst {jest} = require('@jest/globals');\n\njest.mock('some-module', () => {\n  jest.requireActual('some-module');\n});\n\n\n      ↓ ↓ ↓ ↓ ↓ ↓\n\nconst {jest} = require('@jest/globals');\njest.mock('some-module', () => {\n  jest.requireActual('some-module');\n});\n\n`;\n\nexports[`babel-plugin-jest-hoist 6. imported jest.mock within jest.mock: 6. imported jest.mock within jest.mock 1`] = `\n\nimport {jest} from '@jest/globals';\n\njest.mock('some-module', () => {\n  jest.mock('some-module');\n});\n\n\n      ↓ ↓ ↓ ↓ ↓ ↓\n\n_getJestObj().mock('some-module', () => {\n  _getJestObj().mock('some-module');\n});\nfunction _getJestObj() {\n  const {jest} = require('@jest/globals');\n  _getJestObj = () => jest;\n  return jest;\n}\nimport {jest} from '@jest/globals';\n\n`;\n\nexports[`babel-plugin-jest-hoist 7. global jest.mock within jest.mock: 7. global jest.mock within jest.mock 1`] = `\n\njest.mock('some-module', () => {\n  jest.mock('some-module');\n});\n\n\n      ↓ ↓ ↓ ↓ ↓ ↓\n\n_getJestObj().mock('some-module', () => {\n  _getJestObj().mock('some-module');\n});\nfunction _getJestObj() {\n  const {jest} = require('@jest/globals');\n  _getJestObj = () => jest;\n  return jest;\n}\n\n`;\n\nexports[`babel-plugin-jest-hoist 8. imported jest.requireActual in jest.mock: 8. imported jest.requireActual in jest.mock 1`] = `\n\nimport {jest} from '@jest/globals';\n\njest.mock('some-module', () => {\n  jest.requireActual('some-module');\n});\n\njest.requireActual('some-module');\n\n\n      ↓ ↓ ↓ ↓ ↓ ↓\n\n_getJestObj().mock('some-module', () => {\n  _getJestObj().requireActual('some-module');\n});\nfunction _getJestObj() {\n  const {jest} = require('@jest/globals');\n  _getJestObj = () => jest;\n  return jest;\n}\nimport {jest} from '@jest/globals';\njest.requireActual('some-module');\n\n`;\n\nexports[`babel-plugin-jest-hoist 9. global jest.requireActual in jest.mock: 9. global jest.requireActual in jest.mock 1`] = `\n\njest.mock('some-module', () => {\n  jest.requireActual('some-module');\n});\n\njest.requireActual('some-module');\n\n\n      ↓ ↓ ↓ ↓ ↓ ↓\n\n_getJestObj().mock('some-module', () => {\n  _getJestObj().requireActual('some-module');\n});\nfunction _getJestObj() {\n  const {jest} = require('@jest/globals');\n  _getJestObj = () => jest;\n  return jest;\n}\njest.requireActual('some-module');\n\n`;\n\nexports[`babel-plugin-jest-hoist 10. TS typeof usage in jest.mock: 10. TS typeof usage in jest.mock 1`] = `\n\njest.mock('some-module', () => {\n  const actual = jest.requireActual('some-module');\n\n  return jest.fn<typeof actual.method>();\n});\n\n\n      ↓ ↓ ↓ ↓ ↓ ↓\n\n_getJestObj().mock('some-module', () => {\n  const actual = jest.requireActual('some-module');\n  return jest.fn();\n});\nfunction _getJestObj() {\n  const {jest} = require('@jest/globals');\n  _getJestObj = () => jest;\n  return jest;\n}\n\n`;\n\nexports[`babel-plugin-jest-hoist 11. jest.spyOn call on the imported module: 11. jest.spyOn call on the imported module 1`] = `\n\njest.mock('some-module', () => {\n  const module = jest.requireActual('some-module');\n  jest.spyOn(module, 'add');\n  return module;\n});\n\n\n      ↓ ↓ ↓ ↓ ↓ ↓\n\n_getJestObj().mock('some-module', () => {\n  const module = jest.requireActual('some-module');\n  _getJestObj().spyOn(module, 'add');\n  return module;\n});\nfunction _getJestObj() {\n  const {jest} = require('@jest/globals');\n  _getJestObj = () => jest;\n  return jest;\n}\n\n`;\n\nexports[`babel-plugin-jest-hoist 12. jest.spyOn call in class constructor: 12. jest.spyOn call in class constructor 1`] = `\n\njest.mock('some-module', () => {\n  const Actual = jest.requireActual('some-module');\n  return class Mocked extends Actual {\n    constructor() {\n      super();\n      jest.spyOn(this, 'add');\n    }\n  };\n});\n\n\n      ↓ ↓ ↓ ↓ ↓ ↓\n\n_getJestObj().mock('some-module', () => {\n  const Actual = jest.requireActual('some-module');\n  return class Mocked extends Actual {\n    constructor() {\n      super();\n      _getJestObj().spyOn(this, 'add');\n    }\n  };\n});\nfunction _getJestObj() {\n  const {jest} = require('@jest/globals');\n  _getJestObj = () => jest;\n  return jest;\n}\n\n`;"}
{"prompt":"a block,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('a block', () => {\n  beforeEach(() => {});\n  test.skip('skipped test', () => {});\n});"}
{"prompt":"a block,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('a block', () => {\n  beforeEach(() => {});\n});\n\ndescribe('another block with tests', () => {\n  test('this test prevents us from failing due to zero tests', () => {});\n});"}
{"prompt":"a block,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('a block', () => {\n  beforeEach(() => {});\n  describe('another block', () => {});\n});\n\ndescribe('another block with tests', () => {\n  test('this test prevents us from failing due to zero tests', () => {});\n});"}
{"prompt":"test1,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nbeforeAll(() => {\n  process.stdout.write('This is before all\\n');\n});\n\nbeforeEach(() => {\n  process.stdout.write('This is before each\\n');\n});\n\nafterEach(() => {\n  process.stdout.write('This is after each\\n');\n});\n\nafterAll(() => {\n  process.stdout.write('This is after all\\n');\n});\n\nit('test1', () => {\n  process.stdout.write('test1\\n');\n});\n\nit('test2', () => {\n  process.stdout.write('test2\\n');\n});\n\nit('test3', () => {\n  process.stdout.write('test3\\n');\n});\n\ndescribe('describe1', () => {\n  it('test4', () => {\n    process.stdout.write('test4\\n');\n  });\n\n  it('test5', () => {\n    process.stdout.write('test5\\n');\n  });\n\n  it('test6', () => {\n    process.stdout.write('test6\\n');\n  });\n});\n\ndescribe('describe2', () => {\n  afterAll(() => {\n    process.stdout.write('This is after all describe2\\n');\n  });\n\n  it('test7', () => {\n    process.stdout.write('test7\\n');\n  });\n\n  it('test8', () => {\n    process.stdout.write('test8\\n');\n  });\n\n  it('test9', () => {\n    process.stdout.write('test9\\n');\n  });\n});\n\ndescribe('describe3', () => {\n  beforeEach(() => {\n    process.stdout.write('This is before each describe3\\n');\n  });\n\n  it('test10', () => {\n    process.stdout.write('test10\\n');\n  });\n\n  it('test11', () => {\n    process.stdout.write('test11\\n');\n  });\n\n  it('test12', () => {\n    process.stdout.write('test12\\n');\n  });\n\n  describe('describe4', () => {\n    it('test13', () => {\n      process.stdout.write('test13\\n');\n    });\n\n    it('test14', () => {\n      process.stdout.write('test14\\n');\n    });\n\n    it('test15', () => {\n      process.stdout.write('test15\\n');\n    });\n  });\n});"}
{"prompt":"describe,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {runTest} from '../__mocks__/testUtils';\n\ntest('beforeEach is executed before each test in current/child describe blocks', () => {\n  const {stdout} = runTest(`\n    describe('describe', () => {\n      beforeEach(() => console.log('> describe beforeEach'));\n      test('one', () => {});\n      test('two', () => {});\n      describe('2nd level describe', () => {\n        beforeEach(() => console.log('> 2nd level describe beforeEach'));\n        test('2nd level test', () => {});\n\n        describe('3rd level describe', () => {\n          test('3rd level test', () => {});\n          test('3rd level test#2', () => {});\n        });\n      });\n    })\n\n    describe('2nd describe', () => {\n      beforeEach(() => {\n        console.log('> 2nd describe beforeEach that throws')\n        throw new Error('alabama');\n      });\n      test('2nd describe test', () => {});\n    })\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('multiple before each hooks in one describe are executed in the right order', () => {\n  const {stdout} = runTest(`\n    describe('describe 1', () => {\n      beforeEach(() => {\n        console.log('before each 1');\n      });\n      beforeEach(() => {\n        console.log('before each 2');\n      });\n\n      describe('2nd level describe', () => {\n        test('test', () => {});\n      });\n    });\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('beforeAll is executed correctly', () => {\n  const {stdout} = runTest(`\n    describe('describe 1', () => {\n      beforeAll(() => console.log('> beforeAll 1'));\n      test('test 1', () => console.log('> test 1'));\n\n      describe('2nd level describe', () => {\n        beforeAll(() => console.log('> beforeAll 2'));\n        test('test 2', () => console.log('> test 2'));\n        test('test 3', () => console.log('> test 3'));\n      });\n    });\n  `);\n\n  expect(stdout).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`beforeAll is executed correctly 1`] = `\n\"start_describe_definition: describe 1\nadd_hook: beforeAll\nadd_test: test 1\nstart_describe_definition: 2nd level describe\nadd_hook: beforeAll\nadd_test: test 2\nadd_test: test 3\nfinish_describe_definition: 2nd level describe\nfinish_describe_definition: describe 1\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe 1\nhook_start: beforeAll\n> beforeAll 1\nhook_success: beforeAll\ntest_start: test 1\ntest_started: test 1\ntest_fn_start: test 1\n> test 1\ntest_fn_success: test 1\ntest_done: test 1\nrun_describe_start: 2nd level describe\nhook_start: beforeAll\n> beforeAll 2\nhook_success: beforeAll\ntest_start: test 2\ntest_started: test 2\ntest_fn_start: test 2\n> test 2\ntest_fn_success: test 2\ntest_done: test 2\ntest_start: test 3\ntest_started: test 3\ntest_fn_start: test 3\n> test 3\ntest_fn_success: test 3\ntest_done: test 3\nrun_describe_finish: 2nd level describe\nrun_describe_finish: describe 1\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;\n\nexports[`beforeEach is executed before each test in current/child describe blocks 1`] = `\n\"start_describe_definition: describe\nadd_hook: beforeEach\nadd_test: one\nadd_test: two\nstart_describe_definition: 2nd level describe\nadd_hook: beforeEach\nadd_test: 2nd level test\nstart_describe_definition: 3rd level describe\nadd_test: 3rd level test\nadd_test: 3rd level test#2\nfinish_describe_definition: 3rd level describe\nfinish_describe_definition: 2nd level describe\nfinish_describe_definition: describe\nstart_describe_definition: 2nd describe\nadd_hook: beforeEach\nadd_test: 2nd describe test\nfinish_describe_definition: 2nd describe\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe\ntest_start: one\ntest_started: one\nhook_start: beforeEach\n> describe beforeEach\nhook_success: beforeEach\ntest_fn_start: one\ntest_fn_success: one\ntest_done: one\ntest_start: two\ntest_started: two\nhook_start: beforeEach\n> describe beforeEach\nhook_success: beforeEach\ntest_fn_start: two\ntest_fn_success: two\ntest_done: two\nrun_describe_start: 2nd level describe\ntest_start: 2nd level test\ntest_started: 2nd level test\nhook_start: beforeEach\n> describe beforeEach\nhook_success: beforeEach\nhook_start: beforeEach\n> 2nd level describe beforeEach\nhook_success: beforeEach\ntest_fn_start: 2nd level test\ntest_fn_success: 2nd level test\ntest_done: 2nd level test\nrun_describe_start: 3rd level describe\ntest_start: 3rd level test\ntest_started: 3rd level test\nhook_start: beforeEach\n> describe beforeEach\nhook_success: beforeEach\nhook_start: beforeEach\n> 2nd level describe beforeEach\nhook_success: beforeEach\ntest_fn_start: 3rd level test\ntest_fn_success: 3rd level test\ntest_done: 3rd level test\ntest_start: 3rd level test#2\ntest_started: 3rd level test#2\nhook_start: beforeEach\n> describe beforeEach\nhook_success: beforeEach\nhook_start: beforeEach\n> 2nd level describe beforeEach\nhook_success: beforeEach\ntest_fn_start: 3rd level test#2\ntest_fn_success: 3rd level test#2\ntest_done: 3rd level test#2\nrun_describe_finish: 3rd level describe\nrun_describe_finish: 2nd level describe\nrun_describe_finish: describe\nrun_describe_start: 2nd describe\ntest_start: 2nd describe test\ntest_started: 2nd describe test\nhook_start: beforeEach\n> 2nd describe beforeEach that throws\nhook_failure: beforeEach\ntest_fn_start: 2nd describe test\ntest_done: 2nd describe test\nrun_describe_finish: 2nd describe\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;\n\nexports[`multiple before each hooks in one describe are executed in the right order 1`] = `\n\"start_describe_definition: describe 1\nadd_hook: beforeEach\nadd_hook: beforeEach\nstart_describe_definition: 2nd level describe\nadd_test: test\nfinish_describe_definition: 2nd level describe\nfinish_describe_definition: describe 1\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe 1\nrun_describe_start: 2nd level describe\ntest_start: test\ntest_started: test\nhook_start: beforeEach\nbefore each 1\nhook_success: beforeEach\nhook_start: beforeEach\nbefore each 2\nhook_success: beforeEach\ntest_fn_start: test\ntest_fn_success: test\ntest_done: test\nrun_describe_finish: 2nd level describe\nrun_describe_finish: describe 1\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;"}
{"prompt":".each[beforeEach, beforeAll, afterEach, afterAll] as const","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe.each(['beforeEach', 'beforeAll', 'afterEach', 'afterAll'] as const)(\n  '%s hooks error throwing',\n  fn => {\n    test.each([\n      ['String'],\n      [1],\n      [[]],\n      [{}],\n      [Symbol('hello')],\n      [true],\n      [null],\n      [undefined],\n    ])(\n      `${fn} throws an error when %p is provided as a first argument to it`,\n      el => {\n        expect(() => {\n          // @ts-expect-error: Testing runtime errors\n          globalThis[fn](el);\n        }).toThrow('Invalid first argument. It must be a callback function.');\n      },\n    );\n  },\n);"}
{"prompt":"sum,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst {sum} = require('../identical');\n\ndescribe('sum', () => {\n  it('adds numbers', () => {\n    expect(sum(1, 2)).toBe(3);\n  });\n});"}
{"prompt":"should not run since the file is ignored by babel config,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nit('should not run since the file is ignored by babel config', () => {\n  expect(true).toBe(true);\n});"}
{"prompt":"does not incorrectly match identity-obj-proxy as Immutable object,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/prefer-rest-params-eventually */\n\nimport * as Immutable from 'immutable';\nimport * as React from 'react';\nimport {plugins} from '..';\nimport setPrettyPrint from './setPrettyPrint';\n\nconst {Immutable: ImmutablePlugin, ReactElement} = plugins;\n\nsetPrettyPrint([ReactElement, ImmutablePlugin]);\n\nit('does not incorrectly match identity-obj-proxy as Immutable object', () => {\n  // SENTINEL constant is from https://github.com/immutable-js/immutable-js\n  const IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  const val: any = {};\n  val[IS_ITERABLE_SENTINEL] = IS_ITERABLE_SENTINEL; // mock the mock object :)\n  const expected = `{\"${IS_ITERABLE_SENTINEL}\": \"${IS_ITERABLE_SENTINEL}\"}`;\n  expect(val).toPrettyPrintTo(expected, {min: true});\n});\n\ndescribe('Immutable.OrderedSet', () => {\n  it('supports an empty collection {min: true}', () => {\n    expect(Immutable.OrderedSet([])).toPrettyPrintTo(\n      'Immutable.OrderedSet []',\n      {min: true},\n    );\n  });\n\n  it('supports an empty collection {min: false}', () => {\n    expect(Immutable.OrderedSet([])).toPrettyPrintTo(\n      'Immutable.OrderedSet []',\n      {min: false},\n    );\n  });\n\n  it('supports a single string element', () => {\n    expect(Immutable.OrderedSet(['foo'])).toPrettyPrintTo(\n      'Immutable.OrderedSet [\"foo\"]',\n      {min: true},\n    );\n  });\n\n  it('supports a single integer element', () => {\n    expect(Immutable.OrderedSet([1])).toPrettyPrintTo(\n      'Immutable.OrderedSet [1]',\n      {min: true},\n    );\n  });\n\n  it('supports multiple string elements {min: true}', () => {\n    expect(Immutable.OrderedSet(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.OrderedSet [\"jhon\", \"mike\", \"cristian\"]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports multiple string elements {min: false}', () => {\n    expect(Immutable.OrderedSet(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.OrderedSet [\\n  \"jhon\",\\n  \"mike\",\\n  \"cristian\",\\n]',\n      {min: false},\n    );\n  });\n\n  it('supports multiple integer elements {min: true}', () => {\n    expect(Immutable.OrderedSet([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.OrderedSet [1, 2, 3]',\n      {min: true},\n    );\n  });\n\n  it('supports multiple integer elements {min: false}', () => {\n    expect(Immutable.OrderedSet([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.OrderedSet [\\n  1,\\n  2,\\n  3,\\n]',\n      {\n        min: false,\n      },\n    );\n  });\n\n  it('supports object elements {min: true}', () => {\n    expect(Immutable.OrderedSet([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.OrderedSet [{\"a\": 1, \"b\": 2, \"c\": 3}]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports object elements {min: false}', () => {\n    expect(Immutable.OrderedSet([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.OrderedSet [\\n  Object {\\n    \"a\": 1,\\n    \"b\": 2,\\n    \"c\": 3,\\n  },\\n]',\n      {min: false},\n    );\n  });\n\n  it('supports React elements {min: true}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.OrderedSet([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.OrderedSet [<Mouse>Hello World</Mouse>]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports React elements {min: false}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.OrderedSet([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.OrderedSet [\\n  <Mouse>\\n    Hello World\\n  </Mouse>,\\n]',\n      {min: false},\n    );\n  });\n});\n\ndescribe('Immutable.List', () => {\n  it('supports an empty collection {min: true}', () => {\n    expect(Immutable.List([])).toPrettyPrintTo('Immutable.List []', {\n      min: true,\n    });\n  });\n\n  it('supports an empty collection {min: false}', () => {\n    expect(Immutable.List([])).toPrettyPrintTo('Immutable.List []', {\n      min: false,\n    });\n  });\n\n  it('supports a single string element', () => {\n    expect(Immutable.List(['foo'])).toPrettyPrintTo('Immutable.List [\"foo\"]', {\n      min: true,\n    });\n  });\n\n  it('supports a single integer element', () => {\n    expect(Immutable.List([1])).toPrettyPrintTo('Immutable.List [1]', {\n      min: true,\n    });\n  });\n\n  it('supports multiple string elements {min: true}', () => {\n    expect(Immutable.List(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.List [\"jhon\", \"mike\", \"cristian\"]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports multiple string elements {min: false}', () => {\n    expect(Immutable.List(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.List [\\n  \"jhon\",\\n  \"mike\",\\n  \"cristian\",\\n]',\n    );\n  });\n\n  it('supports multiple integer elements {min: true}', () => {\n    expect(Immutable.List([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.List [1, 2, 3]',\n      {min: true},\n    );\n  });\n\n  it('supports multiple integer elements {min: false}', () => {\n    expect(Immutable.List([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.List [\\n  1,\\n  2,\\n  3,\\n]',\n    );\n  });\n\n  it('supports object elements {min: true}', () => {\n    expect(Immutable.List([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.List [{\"a\": 1, \"b\": 2, \"c\": 3}]',\n      {min: true},\n    );\n  });\n\n  it('supports object elements {min: false}', () => {\n    expect(Immutable.List([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.List [\\n  Object {\\n    \"a\": 1,\\n    \"b\": 2,\\n    \"c\": 3,\\n  },\\n]',\n    );\n  });\n\n  it('supports React elements {min: true}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.List([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.List [<Mouse>Hello World</Mouse>, <Mouse>Hello World</Mouse>]',\n      {min: true},\n    );\n  });\n\n  it('supports React elements {min: false}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.List([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.List [\\n  <Mouse>\\n    Hello World\\n  </Mouse>,\\n  <Mouse>\\n    Hello World\\n  </Mouse>,\\n]',\n    );\n  });\n});\n\ndescribe('Immutable.Stack', () => {\n  it('supports an empty collection {min: true}', () => {\n    expect(Immutable.Stack([])).toPrettyPrintTo('Immutable.Stack []', {\n      min: true,\n    });\n  });\n\n  it('supports an empty collection {min: false}', () => {\n    expect(Immutable.Stack([])).toPrettyPrintTo('Immutable.Stack []', {\n      min: false,\n    });\n  });\n\n  it('supports a single string element', () => {\n    expect(Immutable.Stack(['foo'])).toPrettyPrintTo(\n      'Immutable.Stack [\"foo\"]',\n      {min: true},\n    );\n  });\n\n  it('supports a single integer element', () => {\n    expect(Immutable.Stack([1])).toPrettyPrintTo('Immutable.Stack [1]', {\n      min: true,\n    });\n  });\n\n  it('supports multiple string elements {min: true}', () => {\n    expect(Immutable.Stack(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.Stack [\"jhon\", \"mike\", \"cristian\"]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports multiple string elements {min: false}', () => {\n    expect(Immutable.Stack(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.Stack [\\n  \"jhon\",\\n  \"mike\",\\n  \"cristian\",\\n]',\n    );\n  });\n\n  it('supports multiple integer elements {min: true}', () => {\n    expect(Immutable.Stack([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.Stack [1, 2, 3]',\n      {min: true},\n    );\n  });\n\n  it('supports multiple integer elements {min: false}', () => {\n    expect(Immutable.Stack([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.Stack [\\n  1,\\n  2,\\n  3,\\n]',\n    );\n  });\n\n  it('supports object elements {min: true}', () => {\n    expect(Immutable.Stack([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.Stack [{\"a\": 1, \"b\": 2, \"c\": 3}]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports object elements {min: false}', () => {\n    expect(Immutable.Stack([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.Stack [\\n  Object {\\n    \"a\": 1,\\n    \"b\": 2,\\n    \"c\": 3,\\n  },\\n]',\n    );\n  });\n\n  it('supports React elements {min: true}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.Stack([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.Stack [<Mouse>Hello World</Mouse>, <Mouse>Hello World</Mouse>]',\n      {min: true},\n    );\n  });\n\n  it('supports React elements {min: false}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.Stack([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.Stack [\\n  <Mouse>\\n    Hello World\\n  </Mouse>,\\n  <Mouse>\\n    Hello World\\n  </Mouse>,\\n]',\n    );\n  });\n});\n\ndescribe('Immutable.Set', () => {\n  it('supports an empty collection {min: true}', () => {\n    expect(Immutable.Set([])).toPrettyPrintTo('Immutable.Set []', {min: true});\n  });\n\n  it('supports an empty collection {min: false}', () => {\n    expect(Immutable.Set([])).toPrettyPrintTo('Immutable.Set []', {\n      min: false,\n    });\n  });\n\n  it('supports a single string element', () => {\n    expect(Immutable.Set(['foo'])).toPrettyPrintTo('Immutable.Set [\"foo\"]', {\n      min: true,\n    });\n  });\n\n  it('supports a single integer element', () => {\n    expect(Immutable.Set([1])).toPrettyPrintTo('Immutable.Set [1]', {\n      min: true,\n    });\n  });\n\n  it('supports multiple string elements {min: true}', () => {\n    expect(Immutable.Set(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.Set [\"jhon\", \"mike\", \"cristian\"]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports multiple string elements {min: false}', () => {\n    expect(Immutable.Set(['jhon', 'mike', 'cristian'])).toPrettyPrintTo(\n      'Immutable.Set [\\n  \"jhon\",\\n  \"mike\",\\n  \"cristian\",\\n]',\n    );\n  });\n\n  it('supports multiple integer elements {min: true}', () => {\n    expect(Immutable.Set([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.Set [1, 2, 3]',\n      {min: true},\n    );\n  });\n\n  it('supports multiple integer elements {min: false}', () => {\n    expect(Immutable.Set([1, 2, 3])).toPrettyPrintTo(\n      'Immutable.Set [\\n  1,\\n  2,\\n  3,\\n]',\n    );\n  });\n\n  it('supports object elements {min: true}', () => {\n    expect(Immutable.Set([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.Set [{\"a\": 1, \"b\": 2, \"c\": 3}]',\n      {min: true},\n    );\n  });\n\n  it('supports object elements {min: false}', () => {\n    expect(Immutable.Set([{a: 1, b: 2, c: 3}])).toPrettyPrintTo(\n      'Immutable.Set [\\n  Object {\\n    \"a\": 1,\\n    \"b\": 2,\\n    \"c\": 3,\\n  },\\n]',\n    );\n  });\n\n  it('supports React elements {min: true}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.Set([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.Set [<Mouse>Hello World</Mouse>]',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports React elements {min: false}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.Set([reactElement, reactElement])).toPrettyPrintTo(\n      'Immutable.Set [\\n  <Mouse>\\n    Hello World\\n  </Mouse>,\\n]',\n    );\n  });\n});\n\ndescribe('Immutable.Map', () => {\n  it('supports an empty collection {min: true}', () => {\n    expect(Immutable.Map({})).toPrettyPrintTo('Immutable.Map {}', {min: true});\n  });\n\n  it('supports an empty collection {min: false}', () => {\n    expect(Immutable.Map({})).toPrettyPrintTo('Immutable.Map {}', {\n      min: false,\n    });\n  });\n\n  it('supports an object with single key', () => {\n    expect(Immutable.Map({a: 1})).toPrettyPrintTo('Immutable.Map {\"a\": 1}', {\n      min: true,\n    });\n  });\n\n  it('supports an object with multiple keys {min: true}', () => {\n    expect(Immutable.Map({a: 1, b: 2, c: 3})).toPrettyPrintTo(\n      'Immutable.Map {\"a\": 1, \"b\": 2, \"c\": 3}',\n      {min: true},\n    );\n  });\n\n  it('supports an object with multiple keys {min: false}', () => {\n    expect(Immutable.Map({a: 1, b: 2, c: 3})).toPrettyPrintTo(\n      'Immutable.Map {\\n  \"a\": 1,\\n  \"b\": 2,\\n  \"c\": 3,\\n}',\n    );\n  });\n\n  it('supports object elements {min: true}', () => {\n    expect(Immutable.Map({key: {a: 1, b: 2, c: 3}})).toPrettyPrintTo(\n      'Immutable.Map {\"key\": {\"a\": 1, \"b\": 2, \"c\": 3}}',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports object elements {min: false}', () => {\n    expect(Immutable.Map({key: {a: 1, b: 2, c: 3}})).toPrettyPrintTo(\n      'Immutable.Map {\\n  \"key\": Object {\\n    \"a\": 1,\\n    \"b\": 2,\\n    \"c\": 3,\\n  },\\n}',\n    );\n  });\n\n  it('supports React elements {min: true}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.Map({a: reactElement, b: reactElement})).toPrettyPrintTo(\n      'Immutable.Map {\"a\": <Mouse>Hello World</Mouse>, \"b\": <Mouse>Hello World</Mouse>}',\n      {min: true},\n    );\n  });\n\n  it('supports React elements {min: false}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(Immutable.Map({a: reactElement, b: reactElement})).toPrettyPrintTo(\n      'Immutable.Map {\\n  \"a\": <Mouse>\\n    Hello World\\n  </Mouse>,\\n  \"b\": <Mouse>\\n    Hello World\\n  </Mouse>,\\n}',\n    );\n  });\n});\n\ndescribe('Immutable.OrderedMap', () => {\n  it('supports an empty collection {min: true}', () => {\n    expect(Immutable.OrderedMap({})).toPrettyPrintTo(\n      'Immutable.OrderedMap {}',\n      {min: true},\n    );\n  });\n\n  it('supports an empty collection {min: false}', () => {\n    expect(Immutable.OrderedMap({})).toPrettyPrintTo(\n      'Immutable.OrderedMap {}',\n      {min: false},\n    );\n  });\n\n  it('supports an object with single key', () => {\n    expect(Immutable.OrderedMap({a: 1})).toPrettyPrintTo(\n      'Immutable.OrderedMap {\"a\": 1}',\n      {min: true},\n    );\n  });\n\n  it('supports an object with multiple keys {min: true}', () => {\n    expect(Immutable.OrderedMap({a: 1, b: 2, c: 3})).toPrettyPrintTo(\n      'Immutable.OrderedMap {\"a\": 1, \"b\": 2, \"c\": 3}',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports an object with multiple keys {min: false}', () => {\n    expect(Immutable.OrderedMap({a: 1, b: 2, c: 3})).toPrettyPrintTo(\n      'Immutable.OrderedMap {\\n  \"a\": 1,\\n  \"b\": 2,\\n  \"c\": 3,\\n}',\n    );\n  });\n\n  it('supports object elements {min: true}', () => {\n    expect(Immutable.OrderedMap({key: {a: 1, b: 2, c: 3}})).toPrettyPrintTo(\n      'Immutable.OrderedMap {\"key\": {\"a\": 1, \"b\": 2, \"c\": 3}}',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports object elements {min: false}', () => {\n    expect(Immutable.OrderedMap({key: {a: 1, b: 2, c: 3}})).toPrettyPrintTo(\n      'Immutable.OrderedMap {\\n  \"key\": Object {\\n    \"a\": 1,\\n    \"b\": 2,\\n    \"c\": 3,\\n  },\\n}',\n    );\n  });\n\n  it('supports React elements {min: true}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(\n      Immutable.OrderedMap({a: reactElement, b: reactElement}),\n    ).toPrettyPrintTo(\n      'Immutable.OrderedMap {\"a\": <Mouse>Hello World</Mouse>, \"b\": <Mouse>Hello World</Mouse>}',\n      {min: true},\n    );\n  });\n\n  it('supports React elements {min: false}', () => {\n    const reactElement = React.createElement('Mouse', null, 'Hello World');\n    expect(\n      Immutable.OrderedMap({a: reactElement, b: reactElement}),\n    ).toPrettyPrintTo(\n      'Immutable.OrderedMap {\\n  \"a\": <Mouse>\\n    Hello World\\n  </Mouse>,\\n  \"b\": <Mouse>\\n    Hello World\\n  </Mouse>,\\n}',\n    );\n  });\n\n  it('supports non-string keys', () => {\n    const val = Immutable.OrderedMap<unknown, unknown>([\n      [false, 'boolean'],\n      ['false', 'string'],\n      [0, 'number'],\n      ['0', 'string'],\n      [null, 'null'],\n      ['null', 'string'],\n      [undefined, 'undefined'],\n      ['undefined', 'string'],\n      [Symbol('description'), 'symbol'],\n      ['Symbol(description)', 'string'],\n      [['array', 'key'], 'array'],\n      [{key: 'value'}, 'object'],\n      [Immutable.Map({key: 'value'}), 'immutable map'],\n    ]);\n    const expected = [\n      'Immutable.OrderedMap {',\n      '  false: \"boolean\",',\n      '  \"false\": \"string\",',\n      '  0: \"number\",',\n      '  \"0\": \"string\",',\n      '  null: \"null\",',\n      '  \"null\": \"string\",',\n      '  undefined: \"undefined\",',\n      '  \"undefined\": \"string\",',\n      '  Symbol(description): \"symbol\",',\n      '  \"Symbol(description)\": \"string\",',\n      '  Array [',\n      '    \"array\",',\n      '    \"key\",',\n      '  ]: \"array\",',\n      '  Object {',\n      '    \"key\": \"value\",',\n      '  }: \"object\",',\n      '  Immutable.Map {',\n      '    \"key\": \"value\",',\n      '  }: \"immutable map\",',\n      '}',\n    ].join('\\n');\n    expect(val).toPrettyPrintTo(expected);\n  });\n});\n\ndescribe('Immutable.Record', () => {\n  it('supports an empty record {min: true}', () => {\n    const ABRecord = Immutable.Record({}, 'ABRecord');\n\n    expect(ABRecord()).toPrettyPrintTo('Immutable.ABRecord {}', {\n      min: true,\n    });\n  });\n\n  it('supports an empty record {min: false}', () => {\n    const ABRecord = Immutable.Record({}, 'ABRecord');\n\n    expect(ABRecord()).toPrettyPrintTo('Immutable.ABRecord {}', {\n      min: false,\n    });\n  });\n\n  it('supports a record with descriptive name', () => {\n    const ABRecord = Immutable.Record({a: 1, b: 2}, 'ABRecord');\n\n    expect(ABRecord()).toPrettyPrintTo('Immutable.ABRecord {\"a\": 1, \"b\": 2}', {\n      min: true,\n    });\n  });\n\n  it('supports a record without descriptive name', () => {\n    const ABRecord = Immutable.Record({a: 1, b: 2});\n\n    expect(ABRecord()).toPrettyPrintTo('Immutable.Record {\"a\": 1, \"b\": 2}', {\n      min: true,\n    });\n  });\n\n  it('supports a record with values {min: true}', () => {\n    const ABRecord = Immutable.Record({a: 1, b: 2}, 'ABRecord');\n\n    expect(ABRecord({a: 3, b: 4})).toPrettyPrintTo(\n      'Immutable.ABRecord {\"a\": 3, \"b\": 4}',\n      {min: true},\n    );\n  });\n\n  it('supports a record with values {min: false}', () => {\n    const ABRecord = Immutable.Record({a: 1, b: 2}, 'ABRecord');\n\n    expect(ABRecord({a: 3, b: 4})).toPrettyPrintTo(\n      'Immutable.ABRecord {\\n  \"a\": 3,\\n  \"b\": 4,\\n}',\n    );\n  });\n\n  it('supports a record with Map value {min: true}', () => {\n    const ABRecord = Immutable.Record(\n      {a: Immutable.Map({c: 1}), b: 2},\n      'ABRecord',\n    );\n\n    expect(ABRecord()).toPrettyPrintTo(\n      'Immutable.ABRecord {\"a\": Immutable.Map {\"c\": 1}, \"b\": 2}',\n      {\n        min: true,\n      },\n    );\n  });\n\n  it('supports a record with Map value {min: false}', () => {\n    const ABRecord = Immutable.Record(\n      {a: Immutable.Map({c: 1}), b: 2},\n      'ABRecord',\n    );\n\n    expect(ABRecord()).toPrettyPrintTo(\n      'Immutable.ABRecord {\\n  \"a\": Immutable.Map {\\n    \"c\": 1,\\n  },\\n  \"b\": 2,\\n}',\n    );\n  });\n\n  it('supports imbricated Record {min: true}', () => {\n    const CDRecord = Immutable.Record({c: 3, d: 4}, 'CDRecord');\n    const ABRecord = Immutable.Record({a: CDRecord(), b: 2}, 'ABRecord');\n\n    expect(ABRecord()).toPrettyPrintTo(\n      'Immutable.ABRecord {\"a\": Immutable.CDRecord {\"c\": 3, \"d\": 4}, \"b\": 2}',\n      {min: true},\n    );\n  });\n\n  it('supports imbricated Record {min: false}', () => {\n    const CDRecord = Immutable.Record({c: 3, d: 4}, 'CDRecord');\n    const ABRecord = Immutable.Record({a: CDRecord(), b: 2}, 'ABRecord');\n\n    expect(ABRecord()).toPrettyPrintTo(\n      'Immutable.ABRecord {\\n  \"a\": Immutable.CDRecord {\\n    \"c\": 3,\\n    \"d\": 4,\\n  },\\n  \"b\": 2,\\n}',\n    );\n  });\n});\n\ndescribe('indentation of heterogeneous collections', () => {\n  // Don’t interpret tests that pretty-format and plugins are compatible\n  // as recommendation to compose immutable and non-immutable collections.\n  test('empty Immutable.List as child of Object', () => {\n    const val = {\n      filter: 'all',\n      todos: Immutable.List([]),\n    };\n    expect(val).toPrettyPrintTo(\n      [\n        'Object {',\n        '  \"filter\": \"all\",',\n        '  \"todos\": Immutable.List [],',\n        '}',\n      ].join('\\n'),\n    );\n  });\n  test('empty Immutable.Map as child of Array', () => {\n    const val = [Immutable.Map({})];\n    expect(val).toPrettyPrintTo(\n      ['Array [', '  Immutable.Map {},', ']'].join('\\n'),\n    );\n  });\n\n  test('non-empty Array as child of Immutable.Map', () => {\n    const val = Immutable.Map({\n      filter: 'completed',\n      todos: [\n        Immutable.Map({\n          completed: true,\n          text: 'Replace print with serialize',\n        }),\n      ],\n    });\n    expect(val).toPrettyPrintTo(\n      [\n        'Immutable.Map {',\n        '  \"filter\": \"completed\",',\n        '  \"todos\": Array [',\n        '    Immutable.Map {',\n        '      \"completed\": true,',\n        '      \"text\": \"Replace print with serialize\",',\n        '    },',\n        '  ],',\n        '}',\n      ].join('\\n'),\n    );\n  });\n  test('non-empty Object as child of Immutable.List', () => {\n    const val = Immutable.List([\n      {\n        completed: true,\n        text: 'Replace print with serialize',\n      },\n    ]);\n    expect(val).toPrettyPrintTo(\n      [\n        'Immutable.List [',\n        '  Object {',\n        '    \"completed\": true,',\n        '    \"text\": \"Replace print with serialize\",',\n        '  },',\n        ']',\n      ].join('\\n'),\n    );\n  });\n});\n\ndescribe('indent option', () => {\n  const val = Immutable.Map({\n    filter: 'completed',\n    todos: Immutable.List([\n      Immutable.Map({\n        completed: true,\n        text: 'Replace print with serialize',\n      }),\n      Immutable.Map({\n        completed: false,\n        text: 'Return if depth exceeds max',\n      }),\n    ]),\n  });\n  const expected = [\n    'Immutable.Map {',\n    '  \"filter\": \"completed\",',\n    '  \"todos\": Immutable.List [',\n    '    Immutable.Map {',\n    '      \"completed\": true,',\n    '      \"text\": \"Replace print with serialize\",',\n    '    },',\n    '    Immutable.Map {',\n    '      \"completed\": false,',\n    '      \"text\": \"Return if depth exceeds max\",',\n    '    },',\n    '  ],',\n    '}',\n  ].join('\\n');\n  test('default implicit: 2 spaces', () => {\n    expect(val).toPrettyPrintTo(expected);\n  });\n  test('default explicit: 2 spaces', () => {\n    expect(val).toPrettyPrintTo(expected, {indent: 2});\n  });\n\n  // Tests assume that no strings in val contain multiple adjacent spaces!\n  test('non-default: 0 spaces', () => {\n    const indent = 0;\n    expect(val).toPrettyPrintTo(\n      expected.replaceAll(/ {2}/g, ' '.repeat(indent)),\n      {\n        indent,\n      },\n    );\n  });\n  test('non-default: 4 spaces', () => {\n    const indent = 4;\n    expect(val).toPrettyPrintTo(\n      expected.replaceAll(/ {2}/g, ' '.repeat(indent)),\n      {\n        indent,\n      },\n    );\n  });\n});\n\ndescribe('maxDepth option', () => {\n  // Don’t interpret tests that pretty-format and plugins are compatible\n  // as recommendation to compose immutable and non-immutable collections.\n  test('Immutable.List as child of Object', () => {\n    const val = {\n      // ++depth === 1\n      filter: 'all',\n      todos: Immutable.List([\n        Immutable.Map({\n          completed: true,\n          text: 'Return if depth exceeds max',\n        }),\n      ]),\n    };\n    const expected = [\n      'Object {',\n      '  \"filter\": \"all\",',\n      '  \"todos\": [Immutable.List],',\n      '}',\n    ].join('\\n');\n    expect(val).toPrettyPrintTo(expected, {maxDepth: 1});\n  });\n  test('Immutable.Map as child of Array', () => {\n    const val = [\n      // ++depth === 1\n      Immutable.Map({\n        completed: false,\n        text: 'Return if depth exceeds max',\n      }),\n    ];\n    const expected = ['Array [', '  [Immutable.Map],', ']'].join('\\n');\n    expect(val).toPrettyPrintTo(expected, {maxDepth: 1});\n  });\n\n  test('Immutable.Seq as child of Immutable.Map', () => {\n    const val = {\n      // ++depth === 1\n      filter: 'all',\n      todos: Immutable.Seq(\n        Immutable.List([\n          Immutable.Map({\n            completed: true,\n            text: 'Return if depth exceeds max',\n          }),\n        ]),\n      ),\n    };\n    const expected = [\n      'Object {',\n      '  \"filter\": \"all\",',\n      '  \"todos\": [Immutable.Seq],',\n      '}',\n    ].join('\\n');\n    expect(val).toPrettyPrintTo(expected, {maxDepth: 1});\n  });\n  test('Immutable.Map as descendants in immutable collection', () => {\n    const val = Immutable.Map({\n      // ++depth === 1\n      filter: 'uncompleted',\n      todos: Immutable.List([\n        // ++depth === 2\n        Immutable.Map({\n          // ++depth === 3\n          completed: true,\n          text: 'Replace print with serialize',\n        }),\n        Immutable.Map({\n          // ++depth === 3\n          completed: true,\n          text: 'Return if depth exceeds max',\n        }),\n      ]),\n    });\n    const expected = [\n      'Immutable.Map {',\n      '  \"filter\": \"uncompleted\",',\n      '  \"todos\": Immutable.List [',\n      '    [Immutable.Map],',\n      '    [Immutable.Map],',\n      '  ],',\n      '}',\n    ].join('\\n');\n    expect(val).toPrettyPrintTo(expected, {maxDepth: 2});\n  });\n});\n\ndescribe('Immutable.Seq', () => {\n  it('supports an empty sequence from array {min: true}', () => {\n    expect(Immutable.Seq([])).toPrettyPrintTo('Immutable.Seq []', {min: true});\n  });\n  it('supports an empty sequence from array {min: false}', () => {\n    expect(Immutable.Seq([])).toPrettyPrintTo('Immutable.Seq []', {min: false});\n  });\n  it('supports a non-empty sequence from array {min: true}', () => {\n    expect(Immutable.Seq([0, 1, 2])).toPrettyPrintTo(\n      'Immutable.Seq [0, 1, 2]',\n      {min: true},\n    );\n  });\n  it('supports a non-empty sequence from array {min: false}', () => {\n    expect(Immutable.Seq([0, 1, 2])).toPrettyPrintTo(\n      'Immutable.Seq [\\n  0,\\n  1,\\n  2,\\n]',\n      {min: false},\n    );\n  });\n\n  it('supports a non-empty sequence from arguments', () => {\n    function returnArguments(..._args: Array<any>) {\n      return arguments;\n    }\n    expect(Immutable.Seq(returnArguments(0, 1, 2))).toPrettyPrintTo(\n      'Immutable.Seq [\\n  0,\\n  1,\\n  2,\\n]',\n    );\n  });\n\n  it('supports an empty sequence from object {min: true}', () => {\n    expect(Immutable.Seq({})).toPrettyPrintTo('Immutable.Seq {}', {min: true});\n  });\n  it('supports an empty sequence from object {min: false}', () => {\n    expect(Immutable.Seq({})).toPrettyPrintTo('Immutable.Seq {}', {min: false});\n  });\n  it('supports a non-empty sequence from object {min: true}', () => {\n    expect(Immutable.Seq({key: 'value'})).toPrettyPrintTo(\n      'Immutable.Seq {\"key\": \"value\"}',\n      {\n        min: true,\n      },\n    );\n  });\n  it('supports a non-empty sequence from object {min: false}', () => {\n    expect(Immutable.Seq({key: 'value'})).toPrettyPrintTo(\n      'Immutable.Seq {\\n  \"key\": \"value\",\\n}',\n      {\n        min: false,\n      },\n    );\n  });\n\n  it('supports a sequence of entries from Immutable.Map', () => {\n    expect(Immutable.Seq(Immutable.Map({key: 'value'}))).toPrettyPrintTo(\n      'Immutable.Seq {\\n  \"key\": \"value\",\\n}',\n    );\n  });\n\n  it('supports a sequence of values from ECMAScript Set', () => {\n    expect(Immutable.Seq(new Set([0, 1, 2]))).toPrettyPrintTo(\n      'Immutable.Seq [\\n  0,\\n  1,\\n  2,\\n]',\n    );\n  });\n  it('supports a sequence of values from Immutable.List', () => {\n    expect(Immutable.Seq(Immutable.List([0, 1, 2]))).toPrettyPrintTo(\n      'Immutable.Seq [\\n  0,\\n  1,\\n  2,\\n]',\n    );\n  });\n  it('supports a sequence of values from Immutable.Set', () => {\n    expect(Immutable.Seq(Immutable.Set([0, 1, 2]))).toPrettyPrintTo(\n      'Immutable.Seq [\\n  0,\\n  1,\\n  2,\\n]',\n    );\n  });\n  it('supports a sequence of values from Immutable.Stack', () => {\n    expect(Immutable.Seq(Immutable.Stack([0, 1, 2]))).toPrettyPrintTo(\n      'Immutable.Seq [\\n  0,\\n  1,\\n  2,\\n]',\n    );\n  });\n});\n\ndescribe('Immutable.Seq lazy entries', () => {\n  const expected = 'Immutable.Seq {…}';\n  const object = {key0: '', key1: '1'};\n  const filterer = (value: string) => value.length > 0;\n\n  // undefined size confirms correct criteria for lazy Seq\n  test('from object properties', () => {\n    const val = Immutable.Seq(object).filter(filterer);\n    expect(val.size).toBeUndefined();\n    expect(val).toPrettyPrintTo(expected);\n  });\n  test('from Immutable.Map entries', () => {\n    const val = Immutable.Seq(Immutable.Map<string, string>(object)).filter(\n      filterer,\n    );\n    expect(val.size).toBeUndefined();\n    expect(val).toPrettyPrintTo(expected);\n  });\n});\n\ndescribe('Immutable.Seq lazy values', () => {\n  const expected = 'Immutable.Seq […]';\n  const array = ['', '1', '22'];\n  const filterer = (item: string) => item.length > 0;\n\n  test('from Immutable.Range', () => {\n    const val = Immutable.Range(1, Number.POSITIVE_INFINITY);\n    expect(val.size).toBe(Number.POSITIVE_INFINITY);\n    expect(val).toPrettyPrintTo(expected);\n  });\n\n  // undefined size confirms correct criteria for lazy Seq\n  test('from iterator', () => {\n    function returnIterator<T>(values: Array<T>): IterableIterator<T> {\n      let i = 0;\n      return {\n        next() {\n          return i < values.length\n            ? {done: false, value: values[i++]}\n            : {done: true, value: undefined};\n        },\n        [Symbol.iterator]() {\n          return this;\n        },\n      };\n    }\n    const val = Immutable.Seq(returnIterator(array)).filter(filterer);\n    expect(val.size).toBeUndefined();\n    expect(val).toPrettyPrintTo(expected);\n  });\n  test('from array items', () => {\n    const val = Immutable.Seq(array).filter(filterer);\n    expect(val.size).toBeUndefined();\n    expect(val).toPrettyPrintTo(expected);\n  });\n  test('from Immutable.List values', () => {\n    const val = Immutable.Seq(Immutable.List(array)).filter(filterer);\n    expect(val.size).toBeUndefined();\n    expect(val).toPrettyPrintTo(expected);\n  });\n  test('from ECMAScript Set values', () => {\n    const val = Immutable.Seq(new Set(array)).filter(filterer);\n    expect(val.size).toBeUndefined();\n    expect(val).toPrettyPrintTo(expected);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('imported globals', () => {\n  const result = runJest('imported-globals');\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"These will be hoisted above imports","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/* eslint-disable no-duplicate-imports, import/no-duplicates */\nimport {jest} from '@jest/globals';\nimport {jest as aliasedJest} from '@jest/globals';\nimport * as JestGlobals from '@jest/globals';\n/* eslint-enable no-duplicate-imports */\nimport a from '../__test_modules__/a';\nimport b from '../__test_modules__/b';\nimport c from '../__test_modules__/c';\nimport d from '../__test_modules__/d';\n\n// These will be hoisted above imports\n\njest.unmock('../__test_modules__/a');\naliasedJest.unmock('../__test_modules__/b');\nJestGlobals.jest.unmock('../__test_modules__/c');\n\n// These will not be hoisted above imports\n\n{\n  const jest = {unmock: () => {}};\n  jest.unmock('../__test_modules__/d');\n}\n\n// tests\n\ntest('named import', () => {\n  expect(a._isMockFunction).toBeUndefined();\n  expect(a()).toBe('unmocked');\n});\n\ntest('aliased named import', () => {\n  expect(b._isMockFunction).toBeUndefined();\n  expect(b()).toBe('unmocked');\n});\n\ntest('namespace import', () => {\n  expect(c._isMockFunction).toBeUndefined();\n  expect(c()).toBe('unmocked');\n});\n\ntest('fake jest, shadowed import', () => {\n  expect(d._isMockFunction).toBe(true);\n  expect(d()).toBeUndefined();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('something', done => {\n  setTimeout(() => {}, 10_000);\n  expect(true).toBe(true);\n  done();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nbeforeAll(done => {\n  setTimeout(() => {}, 10_000);\n  done();\n});\n\ntest('something', () => {\n  expect(true).toBe(true);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport HasteMap from '../index';\n\nconst rootDir = path.join(__dirname, './test_dotfiles_root');\n\nconst commonOptions = {\n  extensions: ['js'],\n  maxWorkers: 1,\n  platforms: [],\n  resetCache: true,\n  retainAllFiles: true,\n  rootDir,\n  roots: [rootDir],\n};\n\ntest('watchman crawler and node crawler both include dotfiles', async () => {\n  const hasteMapWithWatchman = await HasteMap.create({\n    ...commonOptions,\n    id: 'withWatchman',\n    useWatchman: true,\n  });\n\n  const hasteMapWithNode = await HasteMap.create({\n    ...commonOptions,\n    id: 'withNode',\n    useWatchman: false,\n  });\n\n  const [builtHasteMapWithWatchman, builtHasteMapWithNode] = await Promise.all([\n    hasteMapWithWatchman.build(),\n    hasteMapWithNode.build(),\n  ]);\n\n  expect(\n    builtHasteMapWithWatchman.hasteFS.matchFiles('.eslintrc.js'),\n  ).toHaveLength(1);\n\n  expect(builtHasteMapWithWatchman.hasteFS.getAllFiles().sort()).toEqual(\n    builtHasteMapWithNode.hasteFS.getAllFiles().sort(),\n  );\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports.outputString = 'This should happen';\nmodule.exports.parentFileName = module.parent.filename;"}
{"prompt":".prop[fc.arrayfc.char]should be reflexive, a => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {fc, it} from '@fast-check/jest';\nimport diff from '..';\n\nconst findCommonItems = (a: Array<string>, b: Array<string>): Array<string> => {\n  const array: Array<string> = [];\n  diff(\n    a.length,\n    b.length,\n    (aIndex: number, bIndex: number) => a[aIndex] === b[bIndex],\n    (nCommon: number, aCommon: number) => {\n      for (; nCommon !== 0; nCommon -= 1, aCommon += 1) {\n        array.push(a[aCommon]);\n      }\n    },\n  );\n  return array;\n};\n\nconst extractCount = (data: Array<string>): Map<string, number> => {\n  const countPerChar = new Map<string, number>();\n  for (const item of data) {\n    const currentCount = countPerChar.get(item) ?? 0;\n    countPerChar.set(item, currentCount + 1);\n  }\n  return countPerChar;\n};\n\nconst flatten = (data: Array<Array<string>>) => {\n  const array: Array<string> = [];\n  for (const items of data) {\n    array.push(...items);\n  }\n  return array;\n};\n\nconst isSubsequenceOf = (\n  subsequence: Array<string>,\n  sequence: Array<string>,\n): boolean => {\n  let iSub = 0;\n  for (let iSeq = 0; iSeq !== sequence.length; iSeq += 1) {\n    if (iSub !== subsequence.length && subsequence[iSub] === sequence[iSeq]) {\n      iSub += 1;\n    }\n  }\n\n  return iSub === subsequence.length;\n};\n\nit.prop([fc.array(fc.char())])('should be reflexive', a => {\n  expect(findCommonItems(a, a)).toEqual(a);\n});\n\nit.prop([fc.array(fc.char()), fc.array(fc.char())])(\n  'should find the same number of common items when switching the inputs',\n  // findCommonItems is not symmetric as:\n  // > findCommonItems([\"Z\",\" \"], [\" \",\"Z\"]) = [\" \"]\n  // > findCommonItems([\" \",\"Z\"], [\"Z\",\" \"]) = [\"Z\"]\n  (a, b) => {\n    const commonItems = findCommonItems(a, b);\n    const symmetricCommonItems = findCommonItems(b, a);\n    expect(symmetricCommonItems).toHaveLength(commonItems.length);\n  },\n);\n\nit.prop([fc.array(fc.char()), fc.array(fc.char())])(\n  'should have at most the length of its inputs',\n  (a, b) => {\n    const commonItems = findCommonItems(a, b);\n    expect(commonItems.length).toBeLessThanOrEqual(a.length);\n    expect(commonItems.length).toBeLessThanOrEqual(b.length);\n  },\n);\n\nit.prop([fc.array(fc.char()), fc.array(fc.char())])(\n  'should have at most the same number of each character as its inputs',\n  (a, b) => {\n    const commonItems = findCommonItems(a, b);\n    const commonCount = extractCount(commonItems);\n    const aCount = extractCount(a);\n    for (const [item, count] of commonCount) {\n      const countOfItemInA = aCount.get(item) ?? 0;\n      expect(countOfItemInA).toBeGreaterThanOrEqual(count);\n    }\n  },\n);\n\nit.prop([fc.array(fc.char()), fc.array(fc.char())])(\n  'should be a subsequence of its inputs',\n  (a, b) => {\n    const commonItems = findCommonItems(a, b);\n    expect(isSubsequenceOf(commonItems, a)).toBe(true);\n    expect(isSubsequenceOf(commonItems, b)).toBe(true);\n  },\n);\n\nit.prop([fc.array(fc.char()), fc.array(fc.char())])(\n  'should be no-op when passing common items',\n  (a, b) => {\n    const commonItems = findCommonItems(a, b);\n    expect(findCommonItems(a, commonItems)).toEqual(commonItems);\n    expect(findCommonItems(commonItems, a)).toEqual(commonItems);\n  },\n);\n\nit.prop([fc.array(fc.array(fc.char()))])(\n  'should find the exact common items when one array is subarray of the other',\n  data => {\n    const allData = flatten(data); // [...data[0], ...data[1], ...data[2], ...data[3], ...]\n    const partialData = flatten(data.filter((_, i) => i % 2 === 1)); // [...data[1], ...data[3], ...]\n    const commonItems = findCommonItems(allData, partialData);\n    // We have:\n    // 1. commonItems contains at least all the items of partialData as they are in allData too\n    // 2. commonItems cannot contain more items than its inputs (partialData for instance)\n    expect(commonItems.length).toBeGreaterThanOrEqual(partialData.length);\n  },\n);"}
{"prompt":"A file change can be triggered by wring into the","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as crypto from 'crypto';\nimport * as path from 'path';\n\nfunction mockHashContents(contents) {\n  return crypto.createHash('sha1').update(contents).digest('hex');\n}\n\nconst mockIsWatchmanInstalled = jest.fn().mockResolvedValue(true);\n\njest.mock('../lib/isWatchmanInstalled', () => ({\n  __esModule: true,\n  default: mockIsWatchmanInstalled,\n}));\n\njest.mock('jest-worker', () => ({\n  Worker: jest.fn(worker => {\n    mockWorker = jest.fn((...args) => require(worker).worker(...args));\n    mockEnd = jest.fn();\n\n    return {\n      end: mockEnd,\n      worker: mockWorker,\n    };\n  }),\n}));\n\njest.mock('../crawlers/node');\njest.mock('../crawlers/watchman', () => ({\n  watchmanCrawl: jest.fn(options => {\n    const path = require('path');\n\n    const {data, ignore, rootDir, roots, computeSha1} = options;\n    const list = mockChangedFiles || mockFs;\n    const removedFiles = new Map();\n\n    data.clocks = mockClocks;\n\n    for (const file in list) {\n      if (\n        new RegExp(roots.join('|').replaceAll('\\\\', '\\\\\\\\')).test(file) &&\n        !ignore(file)\n      ) {\n        const relativeFilePath = path.relative(rootDir, file);\n        if (list[file]) {\n          const hash = computeSha1 ? mockHashContents(list[file]) : null;\n\n          data.files.set(relativeFilePath, ['', 32, 42, 0, [], hash]);\n        } else {\n          const fileData = data.files.get(relativeFilePath);\n          if (fileData) {\n            removedFiles.set(relativeFilePath, fileData);\n            data.files.delete(relativeFilePath);\n          }\n        }\n      }\n    }\n\n    return Promise.resolve({\n      hasteMap: data,\n      removedFiles,\n    });\n  }),\n}));\n\nconst mockWatcherConstructor = jest.fn(root => {\n  const EventEmitter = require('events').EventEmitter;\n  mockEmitters[root] = new EventEmitter();\n  mockEmitters[root].close = jest.fn();\n  setTimeout(() => mockEmitters[root].emit('ready'), 0);\n  return mockEmitters[root];\n});\n\njest.mock('../watchers/NodeWatcher', () => mockWatcherConstructor);\njest.mock('../watchers/WatchmanWatcher', () => mockWatcherConstructor);\n\nlet mockChangedFiles;\nlet mockFs;\n\njest.mock('graceful-fs', () => ({\n  existsSync: jest.fn(path => {\n    // A file change can be triggered by writing into the\n    // mockChangedFiles object.\n    if (mockChangedFiles && path in mockChangedFiles) {\n      return true;\n    }\n\n    if (mockFs[path]) {\n      return true;\n    }\n\n    return false;\n  }),\n  readFileSync: jest.fn((path, options) => {\n    // A file change can be triggered by writing into the\n    // mockChangedFiles object.\n    if (mockChangedFiles && path in mockChangedFiles) {\n      return mockChangedFiles[path];\n    }\n\n    if (mockFs[path]) {\n      return mockFs[path];\n    }\n\n    const error = new Error(`Cannot read path '${path}'.`);\n    error.code = 'ENOENT';\n    throw error;\n  }),\n  writeFileSync: jest.fn((path, data, options) => {\n    expect(options).toBe(require('v8').serialize ? undefined : 'utf8');\n    mockFs[path] = data;\n  }),\n}));\n\nconst cacheFilePath = '/cache-file';\nconst object = data => Object.assign(Object.create(null), data);\nconst createMap = obj => new Map(Object.keys(obj).map(key => [key, obj[key]]));\n\n// Jest toEqual does not match Map instances from different contexts\n// This normalizes them for the uses cases in this test\nconst useBuitinsInContext = value => {\n  const stringTag = Object.prototype.toString.call(value);\n  switch (stringTag) {\n    case '[object Map]':\n      return new Map(\n        [...value].map(([k, v]) => [\n          useBuitinsInContext(k),\n          useBuitinsInContext(v),\n        ]),\n      );\n    case '[object Object]':\n      return Object.keys(value).reduce((obj, key) => {\n        obj[key] = useBuitinsInContext(value[key]);\n        return obj;\n      }, {});\n    default:\n      return value;\n  }\n};\n\nlet consoleWarn;\nlet consoleError;\nlet defaultConfig;\nlet fs;\nlet H;\nlet HasteMap;\nlet mockClocks;\nlet mockEmitters;\nlet mockEnd;\nlet mockWorker;\nlet getCacheFilePath;\n\ndescribe('HasteMap', () => {\n  beforeEach(() => {\n    jest.resetModules();\n\n    mockEmitters = Object.create(null);\n    mockFs = object({\n      [path.join('/', 'project', 'fruits', 'Banana.js')]: `\n        const Strawberry = require(\"Strawberry\");\n      `,\n      [path.join('/', 'project', 'fruits', 'Pear.js')]: `\n        const Banana = require(\"Banana\");\n        const Strawberry = require(\"Strawberry\");\n      `,\n      [path.join('/', 'project', 'fruits', 'Strawberry.js')]: `\n        // Strawberry!\n      `,\n      [path.join('/', 'project', 'fruits', '__mocks__', 'Pear.js')]: `\n        const Melon = require(\"Melon\");\n      `,\n      [path.join('/', 'project', 'vegetables', 'Melon.js')]: `\n        // Melon!\n      `,\n      [path.join('/', 'project', 'video', 'video.mp4')]: Buffer.from([\n        0xfa, 0xce, 0xb0, 0x0c,\n      ]).toString(),\n    });\n    mockClocks = createMap({\n      fruits: 'c:fake-clock:1',\n      vegetables: 'c:fake-clock:2',\n      video: 'c:fake-clock:3',\n    });\n\n    mockChangedFiles = null;\n\n    fs = require('graceful-fs');\n\n    consoleWarn = console.warn;\n    consoleError = console.error;\n\n    console.warn = jest.fn();\n    console.error = jest.fn();\n\n    HasteMap = require('../').default;\n    H = HasteMap.H;\n\n    getCacheFilePath = HasteMap.getCacheFilePath;\n    HasteMap.getCacheFilePath = jest.fn(() => cacheFilePath);\n\n    defaultConfig = {\n      extensions: ['js', 'json'],\n      hasteImplModulePath: require.resolve('./haste_impl.js'),\n      id: 'haste-map-test',\n      maxWorkers: 1,\n      platforms: ['ios', 'android'],\n      resetCache: false,\n      rootDir: path.join('/', 'project'),\n      roots: [\n        path.join('/', 'project', 'fruits'),\n        path.join('/', 'project', 'vegetables'),\n      ],\n      useWatchman: true,\n    };\n  });\n\n  afterEach(() => {\n    console.warn = consoleWarn;\n    console.error = consoleError;\n  });\n\n  it('exports constants', () => {\n    expect(HasteMap.H).toBe(require('../constants').default);\n  });\n\n  it('creates valid cache file paths', () => {\n    jest.resetModules();\n    HasteMap = require('../').default;\n\n    expect(\n      HasteMap.getCacheFilePath('/', '@scoped/package', 'random-value'),\n    ).toMatch(\n      process.platform === 'win32'\n        ? /^\\\\-scoped-package-(.*)$/\n        : /^\\/-scoped-package-(.*)$/,\n    );\n  });\n\n  it('creates different cache file paths for different roots', async () => {\n    jest.resetModules();\n    const HasteMap = require('../').default;\n    const hasteMap1 = await HasteMap.create({\n      ...defaultConfig,\n      rootDir: '/root1',\n    });\n    const hasteMap2 = await HasteMap.create({\n      ...defaultConfig,\n      rootDir: '/root2',\n    });\n    expect(hasteMap1.getCacheFilePath()).not.toBe(hasteMap2.getCacheFilePath());\n  });\n\n  it('creates different cache file paths for different dependency extractor cache keys', async () => {\n    jest.resetModules();\n    const HasteMap = require('../').default;\n    const dependencyExtractor = require('./dependencyExtractor');\n    const config = {\n      ...defaultConfig,\n      dependencyExtractor: require.resolve('./dependencyExtractor'),\n    };\n    dependencyExtractor.setCacheKey('foo');\n    const hasteMap1 = await HasteMap.create(config);\n    dependencyExtractor.setCacheKey('bar');\n    const hasteMap2 = await HasteMap.create(config);\n    expect(hasteMap1.getCacheFilePath()).not.toBe(hasteMap2.getCacheFilePath());\n  });\n\n  it('creates different cache file paths for different values of computeDependencies', async () => {\n    jest.resetModules();\n    const HasteMap = require('../').default;\n    const hasteMap1 = await HasteMap.create({\n      ...defaultConfig,\n      computeDependencies: true,\n    });\n    const hasteMap2 = await HasteMap.create({\n      ...defaultConfig,\n      computeDependencies: false,\n    });\n    expect(hasteMap1.getCacheFilePath()).not.toBe(hasteMap2.getCacheFilePath());\n  });\n\n  it('creates different cache file paths for different hasteImplModulePath cache keys', async () => {\n    jest.resetModules();\n    const HasteMap = require('../').default;\n    const hasteImpl = require('./haste_impl');\n    hasteImpl.setCacheKey('foo');\n    const hasteMap1 = await HasteMap.create(defaultConfig);\n    hasteImpl.setCacheKey('bar');\n    const hasteMap2 = await HasteMap.create(defaultConfig);\n    expect(hasteMap1.getCacheFilePath()).not.toBe(hasteMap2.getCacheFilePath());\n  });\n\n  it('creates different cache file paths for different projects', async () => {\n    jest.resetModules();\n    const HasteMap = require('../').default;\n    const hasteMap1 = await HasteMap.create({\n      ...defaultConfig,\n      id: '@scoped/package',\n    });\n    const hasteMap2 = await HasteMap.create({\n      ...defaultConfig,\n      id: '-scoped-package',\n    });\n    expect(hasteMap1.getCacheFilePath()).not.toBe(hasteMap2.getCacheFilePath());\n  });\n\n  it('matches files against a pattern', async () => {\n    const {hasteFS} = await (await HasteMap.create(defaultConfig)).build();\n    expect(\n      hasteFS.matchFiles(\n        process.platform === 'win32' ? /project\\\\fruits/ : /project\\/fruits/,\n      ),\n    ).toEqual([\n      path.join('/', 'project', 'fruits', 'Banana.js'),\n      path.join('/', 'project', 'fruits', 'Pear.js'),\n      path.join('/', 'project', 'fruits', 'Strawberry.js'),\n      path.join('/', 'project', 'fruits', '__mocks__', 'Pear.js'),\n    ]);\n\n    expect(hasteFS.matchFiles(/__mocks__/)).toEqual([\n      path.join('/', 'project', 'fruits', '__mocks__', 'Pear.js'),\n    ]);\n  });\n\n  it('ignores files given a pattern', async () => {\n    const config = {...defaultConfig, ignorePattern: /Kiwi/};\n    mockFs[path.join('/', 'project', 'fruits', 'Kiwi.js')] = `\n      // Kiwi!\n    `;\n    const {hasteFS} = await (await HasteMap.create(config)).build();\n    expect(hasteFS.matchFiles(/Kiwi/)).toEqual([]);\n  });\n\n  it('ignores vcs directories without ignore pattern', async () => {\n    mockFs[path.join('/', 'project', 'fruits', '.git', 'fruit-history.js')] = `\n      // test\n    `;\n    const {hasteFS} = await (await HasteMap.create(defaultConfig)).build();\n    expect(hasteFS.matchFiles('.git')).toEqual([]);\n  });\n\n  it('ignores sapling vcs directories without ignore pattern', async () => {\n    mockFs[path.join('/', 'project', 'fruits', '.sl', 'package.json')] = `\n      invalid}{\n    `;\n    const {hasteFS} = await (await HasteMap.create(defaultConfig)).build();\n    expect(hasteFS.matchFiles('.sl')).toEqual([]);\n  });\n\n  it('ignores vcs directories with ignore pattern regex', async () => {\n    const config = {...defaultConfig, ignorePattern: /Kiwi/};\n    mockFs[path.join('/', 'project', 'fruits', 'Kiwi.js')] = `\n      // Kiwi!\n    `;\n\n    mockFs[path.join('/', 'project', 'fruits', '.git', 'fruit-history.js')] = `\n      // test\n    `;\n    const {hasteFS} = await (await HasteMap.create(config)).build();\n    expect(hasteFS.matchFiles(/Kiwi/)).toEqual([]);\n    expect(hasteFS.matchFiles('.git')).toEqual([]);\n  });\n\n  it('warn on ignore pattern except for regex', async () => {\n    const config = {ignorePattern: 'Kiwi', ...defaultConfig};\n    mockFs['/project/fruits/Kiwi.js'] = `\n      // Kiwi!\n    `;\n\n    try {\n      await (await HasteMap.create(config)).build();\n    } catch (error) {\n      expect(error.message).toBe(\n        'jest-haste-map: the `ignorePattern` option must be a RegExp',\n      );\n    }\n  });\n\n  it('builds a haste map on a fresh cache', async () => {\n    // Include these files in the map\n    mockFs[\n      path.join('/', 'project', 'fruits', 'node_modules', 'react', 'React.js')\n    ] = `\n      const Component = require(\"Component\");\n    `;\n    mockFs[\n      path.join(\n        '/',\n        'project',\n        'fruits',\n        'node_modules',\n        'fbjs',\n        'lib',\n        'flatMap.js',\n      )\n    ] = `\n      // flatMap\n    `;\n\n    // Ignore these\n    mockFs[\n      path.join(\n        '/',\n        'project',\n        'fruits',\n        'node_modules',\n        'react',\n        'node_modules',\n        'fbjs',\n        'lib',\n        'mapObject.js',\n      )\n    ] = `\n      // mapObject\n    `;\n    mockFs[\n      path.join(\n        '/',\n        'project',\n        'fruits',\n        'node_modules',\n        'react',\n        'node_modules',\n        'dummy',\n        'merge.js',\n      )\n    ] = `\n      // merge\n    `;\n    mockFs[\n      path.join(\n        '/',\n        'project',\n        'fruits',\n        'node_modules',\n        'react',\n        'node_modules',\n        'merge',\n        'package.json',\n      )\n    ] = `\n      {\n        \"name\": \"merge\"\n      }\n    `;\n    mockFs[\n      path.join('/', 'project', 'fruits', 'node_modules', 'jest', 'Jest.js')\n    ] = `\n      const Test = require(\"Test\");\n    `;\n    mockFs[\n      path.join('/', 'project', 'fruits', 'node_modules', 'fbjs2', 'fbjs2.js')\n    ] = `\n      // fbjs2\n    `;\n\n    const hasteMap = await HasteMap.create({\n      ...defaultConfig,\n      mocksPattern: '__mocks__',\n    });\n\n    const {__hasteMapForTest: data} = await hasteMap.build();\n\n    expect(data.clocks).toEqual(mockClocks);\n\n    expect(data.files).toEqual(\n      createMap({\n        [path.join('fruits', 'Banana.js')]: [\n          'Banana',\n          32,\n          42,\n          1,\n          'Strawberry',\n          null,\n        ],\n        [path.join('fruits', 'Pear.js')]: [\n          'Pear',\n          32,\n          42,\n          1,\n          'Banana\\0Strawberry',\n          null,\n        ],\n        [path.join('fruits', 'Strawberry.js')]: [\n          'Strawberry',\n          32,\n          42,\n          1,\n          '',\n          null,\n        ],\n        [path.join('fruits', '__mocks__', 'Pear.js')]: [\n          '',\n          32,\n          42,\n          1,\n          'Melon',\n          null,\n        ],\n        [path.join('vegetables', 'Melon.js')]: ['Melon', 32, 42, 1, '', null],\n      }),\n    );\n\n    expect(data.map).toEqual(\n      createMap({\n        Banana: {\n          [H.GENERIC_PLATFORM]: [path.join('fruits', 'Banana.js'), H.MODULE],\n        },\n        Melon: {\n          [H.GENERIC_PLATFORM]: [path.join('vegetables', 'Melon.js'), H.MODULE],\n        },\n        Pear: {\n          [H.GENERIC_PLATFORM]: [path.join('fruits', 'Pear.js'), H.MODULE],\n        },\n        Strawberry: {\n          [H.GENERIC_PLATFORM]: [\n            path.join('fruits', 'Strawberry.js'),\n            H.MODULE,\n          ],\n        },\n      }),\n    );\n\n    expect(data.mocks).toEqual(\n      createMap({\n        Pear: path.join('fruits', '__mocks__', 'Pear.js'),\n      }),\n    );\n\n    // The cache file must exactly mirror the data structure returned from a\n    // build\n    expect(useBuitinsInContext(hasteMap.read())).toEqual(data);\n  });\n\n  it('throws if both symlinks and watchman is enabled', async () => {\n    await expect(\n      HasteMap.create({...defaultConfig, enableSymlinks: true}),\n    ).rejects.toThrow(\n      'Set either `enableSymlinks` to false or `useWatchman` to false.',\n    );\n    await expect(\n      HasteMap.create({\n        ...defaultConfig,\n        enableSymlinks: true,\n        useWatchman: true,\n      }),\n    ).rejects.toThrow(\n      'Set either `enableSymlinks` to false or `useWatchman` to false.',\n    );\n\n    await expect(\n      HasteMap.create({\n        ...defaultConfig,\n        enableSymlinks: false,\n        useWatchman: true,\n      }),\n    ).resolves.not.toThrow();\n\n    await expect(\n      HasteMap.create({\n        ...defaultConfig,\n        enableSymlinks: true,\n        useWatchman: false,\n      }),\n    ).resolves.not.toThrow();\n  });\n\n  describe('builds a haste map on a fresh cache with SHA-1s', () => {\n    it.each([false, true])('uses watchman: %s', async useWatchman => {\n      const node = require('../crawlers/node').nodeCrawl;\n\n      node.mockImplementation(options => {\n        const {data} = options;\n\n        // The node crawler returns \"null\" for the SHA-1.\n        data.files = createMap({\n          [path.join('fruits', 'Banana.js')]: [\n            'Banana',\n            32,\n            42,\n            0,\n            'Strawberry',\n            null,\n          ],\n          [path.join('fruits', 'Pear.js')]: [\n            'Pear',\n            32,\n            42,\n            0,\n            'Banana\\0Strawberry',\n            null,\n          ],\n          [path.join('fruits', 'Strawberry.js')]: [\n            'Strawberry',\n            32,\n            42,\n            0,\n            '',\n            null,\n          ],\n          [path.join('fruits', '__mocks__', 'Pear.js')]: [\n            '',\n            32,\n            42,\n            0,\n            'Melon',\n            null,\n          ],\n          [path.join('vegetables', 'Melon.js')]: ['Melon', 32, 42, 0, '', null],\n        });\n\n        return Promise.resolve({\n          hasteMap: data,\n          removedFiles: new Map(),\n        });\n      });\n\n      mockIsWatchmanInstalled.mockClear();\n\n      const hasteMap = await HasteMap.create({\n        ...defaultConfig,\n        computeSha1: true,\n        maxWorkers: 1,\n        useWatchman,\n      });\n\n      const data = (await hasteMap.build()).__hasteMapForTest;\n\n      expect(mockIsWatchmanInstalled).toHaveBeenCalledTimes(\n        useWatchman ? 1 : 0,\n      );\n\n      expect(data.files).toEqual(\n        createMap({\n          [path.join('fruits', 'Banana.js')]: [\n            'Banana',\n            32,\n            42,\n            1,\n            'Strawberry',\n            '7772b628e422e8cf59c526be4bb9f44c0898e3d1',\n          ],\n          [path.join('fruits', 'Pear.js')]: [\n            'Pear',\n            32,\n            42,\n            1,\n            'Banana\\0Strawberry',\n            '89d0c2cc11dcc5e1df50b8af04ab1b597acfba2f',\n          ],\n          [path.join('fruits', 'Strawberry.js')]: [\n            'Strawberry',\n            32,\n            42,\n            1,\n            '',\n            'e8aa38e232b3795f062f1d777731d9240c0f8c25',\n          ],\n          [path.join('fruits', '__mocks__', 'Pear.js')]: [\n            '',\n            32,\n            42,\n            1,\n            'Melon',\n            '8d40afbb6e2dc78e1ba383b6d02cafad35cceef2',\n          ],\n          [path.join('vegetables', 'Melon.js')]: [\n            'Melon',\n            32,\n            42,\n            1,\n            '',\n            'f16ccf6f2334ceff2ddb47628a2c5f2d748198ca',\n          ],\n        }),\n      );\n\n      expect(useBuitinsInContext(hasteMap.read())).toEqual(data);\n    });\n  });\n\n  it('does not crawl native files even if requested to do so', async () => {\n    mockFs[path.join('/', 'project', 'video', 'IRequireAVideo.js')] = `\n      module.exports = require(\"./video.mp4\");\n    `;\n\n    const hasteMap = await HasteMap.create({\n      ...defaultConfig,\n      extensions: [...defaultConfig.extensions],\n      roots: [...defaultConfig.roots, path.join('/', 'project', 'video')],\n    });\n\n    const {__hasteMapForTest: data} = await hasteMap.build();\n\n    expect(data.map.get('IRequireAVideo')).toBeDefined();\n    expect(data.files.get(path.join('video', 'video.mp4'))).toBeDefined();\n    expect(fs.readFileSync).not.toHaveBeenCalledWith(\n      path.join('video', 'video.mp4'),\n      'utf8',\n    );\n  });\n\n  it('retains all files if `retainAllFiles` is specified', async () => {\n    mockFs[\n      path.join('/', 'project', 'fruits', 'node_modules', 'fbjs', 'fbjs.js')\n    ] = `\n      // fbjs!\n    `;\n\n    const hasteMap = await HasteMap.create({\n      ...defaultConfig,\n      mocksPattern: '__mocks__',\n      retainAllFiles: true,\n    });\n\n    const {__hasteMapForTest: data} = await hasteMap.build();\n    // Expect the node module to be part of files but make sure it wasn't\n    // read.\n    expect(\n      data.files.get(path.join('fruits', 'node_modules', 'fbjs', 'fbjs.js')),\n    ).toEqual(['', 32, 42, 0, [], null]);\n\n    expect(data.map.get('fbjs')).toBeUndefined();\n\n    // cache file + 5 modules - the node_module\n    expect(fs.readFileSync).toHaveBeenCalledTimes(6);\n  });\n\n  it('warns on duplicate mock files', async () => {\n    expect.assertions(1);\n\n    // Duplicate mock files for blueberry\n    mockFs[\n      path.join(\n        '/',\n        'project',\n        'fruits1',\n        '__mocks__',\n        'subdir',\n        'Blueberry.js',\n      )\n    ] = `\n      // Blueberry\n    `;\n    mockFs[\n      path.join(\n        '/',\n        'project',\n        'fruits2',\n        '__mocks__',\n        'subdir',\n        'Blueberry.js',\n      )\n    ] = `\n      // Blueberry too!\n    `;\n\n    try {\n      await (\n        await HasteMap.create({\n          mocksPattern: '__mocks__',\n          throwOnModuleCollision: true,\n          ...defaultConfig,\n        })\n      ).build();\n    } catch {\n      expect(\n        console.error.mock.calls[0][0].replaceAll('\\\\', '/'),\n      ).toMatchSnapshot();\n    }\n  });\n\n  it('warns on duplicate module ids', async () => {\n    mockFs[path.join('/', 'project', 'fruits', 'other', 'Strawberry.js')] = `\n      const Banana = require(\"Banana\");\n    `;\n\n    const {__hasteMapForTest: data} = await (\n      await HasteMap.create(defaultConfig)\n    ).build();\n\n    // Duplicate modules are removed so that it doesn't cause\n    // non-determinism later on.\n    expect(data.map.get('Strawberry')[H.GENERIC_PLATFORM]).toBeUndefined();\n\n    expect(\n      console.warn.mock.calls[0][0].replaceAll('\\\\', '/'),\n    ).toMatchSnapshot();\n  });\n\n  it('warns on duplicate module ids only once', async () => {\n    mockFs[path.join('/', 'project', 'fruits', 'other', 'Strawberry.js')] = `\n      const Banana = require(\"Banana\");\n    `;\n\n    await (await HasteMap.create(defaultConfig)).build();\n    expect(console.warn).toHaveBeenCalledTimes(1);\n\n    await (await HasteMap.create(defaultConfig)).build();\n    expect(console.warn).toHaveBeenCalledTimes(1);\n  });\n\n  it('throws on duplicate module ids if \"throwOnModuleCollision\" is set to true', async () => {\n    expect.assertions(1);\n    // Raspberry thinks it is a Strawberry\n    mockFs[path.join('/', 'project', 'fruits', 'another', 'Strawberry.js')] = `\n      const Banana = require(\"Banana\");\n    `;\n\n    try {\n      await (\n        await HasteMap.create({\n          throwOnModuleCollision: true,\n          ...defaultConfig,\n        })\n      ).build();\n    } catch (error) {\n      expect(error.message).toBe(\n        'Duplicated files or mocks. Please check the console for more info',\n      );\n    }\n  });\n\n  it('splits up modules by platform', async () => {\n    mockFs = Object.create(null);\n    mockFs[path.join('/', 'project', 'fruits', 'Strawberry.js')] = `\n      const Banana = require(\"Banana\");\n    `;\n\n    mockFs[path.join('/', 'project', 'fruits', 'Strawberry.ios.js')] = `\n      const Raspberry = require(\"Raspberry\");\n    `;\n\n    mockFs[path.join('/', 'project', 'fruits', 'Strawberry.android.js')] = `\n      const Blackberry = require(\"Blackberry\");\n    `;\n\n    const {__hasteMapForTest: data} = await (\n      await HasteMap.create(defaultConfig)\n    ).build();\n\n    expect(data.files).toEqual(\n      createMap({\n        [path.join('fruits', 'Strawberry.android.js')]: [\n          'Strawberry',\n          32,\n          42,\n          1,\n          'Blackberry',\n          null,\n        ],\n        [path.join('fruits', 'Strawberry.ios.js')]: [\n          'Strawberry',\n          32,\n          42,\n          1,\n          'Raspberry',\n          null,\n        ],\n        [path.join('fruits', 'Strawberry.js')]: [\n          'Strawberry',\n          32,\n          42,\n          1,\n          'Banana',\n          null,\n        ],\n      }),\n    );\n\n    expect(data.map).toEqual(\n      createMap({\n        Strawberry: {\n          [H.GENERIC_PLATFORM]: [\n            path.join('fruits', 'Strawberry.js'),\n            H.MODULE,\n          ],\n          android: [path.join('fruits', 'Strawberry.android.js'), H.MODULE],\n          ios: [path.join('fruits', 'Strawberry.ios.js'), H.MODULE],\n        },\n      }),\n    );\n  });\n\n  it('does not access the file system on a warm cache with no changes', async () => {\n    const {__hasteMapForTest: initialData} = await (\n      await HasteMap.create(defaultConfig)\n    ).build();\n\n    // The first run should access the file system once for the (empty)\n    // cache file and five times for the files in the system.\n    expect(fs.readFileSync).toHaveBeenCalledTimes(6);\n\n    fs.readFileSync.mockClear();\n\n    // Explicitly mock that no files have changed.\n    mockChangedFiles = Object.create(null);\n\n    // Watchman would give us different clocks.\n    mockClocks = createMap({\n      fruits: 'c:fake-clock:3',\n      vegetables: 'c:fake-clock:4',\n    });\n\n    const {__hasteMapForTest: data} = await (\n      await HasteMap.create(defaultConfig)\n    ).build();\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    if (require('v8').deserialize) {\n      expect(fs.readFileSync).toHaveBeenCalledWith(cacheFilePath);\n    } else {\n      expect(fs.readFileSync).toHaveBeenCalledWith(cacheFilePath, 'utf8');\n    }\n    expect(useBuitinsInContext(data.clocks)).toEqual(mockClocks);\n    expect(useBuitinsInContext(data.files)).toEqual(initialData.files);\n    expect(useBuitinsInContext(data.map)).toEqual(initialData.map);\n  });\n\n  it('only does minimal file system access when files change', async () => {\n    const {__hasteMapForTest: initialData} = await (\n      await HasteMap.create(defaultConfig)\n    ).build();\n    fs.readFileSync.mockClear();\n\n    // Let's assume one JS file has changed.\n    mockChangedFiles = object({\n      [path.join('/', 'project', 'fruits', 'Banana.js')]: `\n            const Kiwi = require(\"Kiwi\");\n          `,\n    });\n\n    // Watchman would give us different clocks for `/project/fruits`.\n    mockClocks = createMap({\n      fruits: 'c:fake-clock:3',\n      vegetables: 'c:fake-clock:2',\n    });\n\n    const {__hasteMapForTest: data} = await (\n      await HasteMap.create(defaultConfig)\n    ).build();\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n\n    if (require('v8').serialize) {\n      expect(fs.readFileSync).toHaveBeenCalledWith(cacheFilePath);\n    } else {\n      expect(fs.readFileSync).toHaveBeenCalledWith(cacheFilePath, 'utf8');\n    }\n    expect(fs.readFileSync).toHaveBeenCalledWith(\n      path.join('/', 'project', 'fruits', 'Banana.js'),\n      'utf8',\n    );\n\n    expect(useBuitinsInContext(data.clocks)).toEqual(mockClocks);\n\n    const files = new Map(initialData.files);\n    files.set(path.join('fruits', 'Banana.js'), [\n      'Banana',\n      32,\n      42,\n      1,\n      'Kiwi',\n      null,\n    ]);\n\n    expect(useBuitinsInContext(data.files)).toEqual(files);\n\n    const map = new Map(initialData.map);\n    expect(useBuitinsInContext(data.map)).toEqual(map);\n  });\n\n  it('correctly handles file deletions', async () => {\n    const {__hasteMapForTest: initialData} = await (\n      await HasteMap.create(defaultConfig)\n    ).build();\n    fs.readFileSync.mockClear();\n\n    // Let's assume one JS file was removed.\n    delete mockFs[path.join('/', 'project', 'fruits', 'Banana.js')];\n    mockChangedFiles = object({\n      [path.join('/', 'project', 'fruits', 'Banana.js')]: null,\n    });\n\n    // Watchman would give us different clocks for `/project/fruits`.\n    mockClocks = createMap({\n      fruits: 'c:fake-clock:3',\n      vegetables: 'c:fake-clock:2',\n    });\n\n    const {__hasteMapForTest: data} = await (\n      await HasteMap.create(defaultConfig)\n    ).build();\n\n    const files = new Map(initialData.files);\n    files.delete(path.join('fruits', 'Banana.js'));\n    expect(useBuitinsInContext(data.files)).toEqual(files);\n\n    const map = new Map(initialData.map);\n    map.delete('Banana');\n    expect(useBuitinsInContext(data.map)).toEqual(map);\n  });\n\n  it('correctly handles platform-specific file additions', async () => {\n    mockFs = Object.create(null);\n    mockFs[path.join('/', 'project', 'fruits', 'Strawberry.js')] = `\n      const Banana = require(\"Banana\");\n    `;\n    let data;\n    ({__hasteMapForTest: data} = await (\n      await HasteMap.create(defaultConfig)\n    ).build());\n    expect(data.map.get('Strawberry')).toEqual({\n      g: [path.join('fruits', 'Strawberry.js'), 0],\n    });\n\n    delete mockFs[path.join('/', 'project', 'fruits', 'Strawberry.ios.js')];\n    mockChangedFiles = object({\n      [path.join('/', 'project', 'fruits', 'Strawberry.ios.js')]: `\n        const Raspberry = require(\"Raspberry\");\n      `,\n    });\n    mockClocks = createMap({fruits: 'c:fake-clock:3'});\n    ({__hasteMapForTest: data} = await (\n      await HasteMap.create(defaultConfig)\n    ).build());\n    expect(data.map.get('Strawberry')).toEqual({\n      g: [path.join('fruits', 'Strawberry.js'), 0],\n      ios: [path.join('fruits', 'Strawberry.ios.js'), 0],\n    });\n  });\n\n  it('correctly handles platform-specific file deletions', async () => {\n    mockFs = Object.create(null);\n    mockFs[path.join('/', 'project', 'fruits', 'Strawberry.js')] = `\n      const Banana = require(\"Banana\");\n    `;\n    mockFs[path.join('/', 'project', 'fruits', 'Strawberry.ios.js')] = `\n      const Raspberry = require(\"Raspberry\");\n    `;\n    let data;\n    ({__hasteMapForTest: data} = await (\n      await HasteMap.create(defaultConfig)\n    ).build());\n    expect(data.map.get('Strawberry')).toEqual({\n      g: [path.join('fruits', 'Strawberry.js'), 0],\n      ios: [path.join('fruits', 'Strawberry.ios.js'), 0],\n    });\n\n    delete mockFs[path.join('/', 'project', 'fruits', 'Strawberry.ios.js')];\n    mockChangedFiles = object({\n      [path.join('/', 'project', 'fruits', 'Strawberry.ios.js')]: null,\n    });\n    mockClocks = createMap({fruits: 'c:fake-clock:3'});\n    ({__hasteMapForTest: data} = await (\n      await HasteMap.create(defaultConfig)\n    ).build());\n    expect(data.map.get('Strawberry')).toEqual({\n      g: [path.join('fruits', 'Strawberry.js'), 0],\n    });\n  });\n\n  it('correctly handles platform-specific file renames', async () => {\n    mockFs = Object.create(null);\n    mockFs[path.join('/', 'project', 'fruits', 'Strawberry.ios.js')] = `\n      const Raspberry = require(\"Raspberry\");\n    `;\n    let data;\n    ({__hasteMapForTest: data} = await (\n      await HasteMap.create(defaultConfig)\n    ).build());\n    expect(data.map.get('Strawberry')).toEqual({\n      ios: [path.join('fruits', 'Strawberry.ios.js'), 0],\n    });\n\n    delete mockFs[path.join('/', 'project', 'fruits', 'Strawberry.ios.js')];\n    mockChangedFiles = object({\n      [path.join('/', 'project', 'fruits', 'Strawberry.ios.js')]: null,\n      [path.join('/', 'project', 'fruits', 'Strawberry.js')]: `\n        const Banana = require(\"Banana\");\n      `,\n    });\n    mockClocks = createMap({fruits: 'c:fake-clock:3'});\n    ({__hasteMapForTest: data} = await (\n      await HasteMap.create(defaultConfig)\n    ).build());\n    expect(data.map.get('Strawberry')).toEqual({\n      g: [path.join('fruits', 'Strawberry.js'), 0],\n    });\n  });\n\n  describe('duplicate modules', () => {\n    beforeEach(async () => {\n      mockFs[path.join('/', 'project', 'fruits', 'another', 'Strawberry.js')] =\n        `\n        const Blackberry = require(\"Blackberry\");\n      `;\n\n      const {__hasteMapForTest: data} = await (\n        await HasteMap.create(defaultConfig)\n      ).build();\n      expect(useBuitinsInContext(data.duplicates)).toEqual(\n        createMap({\n          Strawberry: createMap({\n            g: createMap({\n              [path.join('fruits', 'Strawberry.js')]: H.MODULE,\n              [path.join('fruits', 'another', 'Strawberry.js')]: H.MODULE,\n            }),\n          }),\n        }),\n      );\n      expect(data.map.get('Strawberry')).toEqual({});\n    });\n\n    it('recovers when a duplicate file is deleted', async () => {\n      delete mockFs[\n        path.join('/', 'project', 'fruits', 'another', 'Strawberry.js')\n      ];\n      mockChangedFiles = object({\n        [path.join('/', 'project', 'fruits', 'another', 'Strawberry.js')]: null,\n      });\n      mockClocks = createMap({\n        fruits: 'c:fake-clock:3',\n        vegetables: 'c:fake-clock:2',\n      });\n\n      const {__hasteMapForTest: data} = await (\n        await HasteMap.create(defaultConfig)\n      ).build();\n      expect(useBuitinsInContext(data.duplicates)).toEqual(new Map());\n      expect(data.map.get('Strawberry')).toEqual({\n        g: [path.join('fruits', 'Strawberry.js'), H.MODULE],\n      });\n      // Make sure the other files are not affected.\n      expect(data.map.get('Banana')).toEqual({\n        g: [path.join('fruits', 'Banana.js'), H.MODULE],\n      });\n    });\n\n    it('recovers with the correct type when a duplicate file is deleted', async () => {\n      mockFs[\n        path.join('/', 'project', 'fruits', 'strawberryPackage', 'package.json')\n      ] = `\n        {\"name\": \"Strawberry\"}\n      `;\n\n      const {__hasteMapForTest: data} = await (\n        await HasteMap.create(defaultConfig)\n      ).build();\n\n      expect(useBuitinsInContext(data.duplicates)).toEqual(\n        createMap({\n          Strawberry: createMap({\n            g: createMap({\n              [path.join('fruits', 'Strawberry.js')]: H.MODULE,\n              [path.join('fruits', 'another', 'Strawberry.js')]: H.MODULE,\n              [path.join('fruits', 'strawberryPackage', 'package.json')]:\n                H.PACKAGE,\n            }),\n          }),\n        }),\n      );\n\n      delete mockFs[\n        path.join('/', 'project', 'fruits', 'another', 'Strawberry.js')\n      ];\n      delete mockFs[\n        path.join('/', 'project', 'fruits', 'strawberryPackage', 'package.json')\n      ];\n\n      mockChangedFiles = object({\n        [path.join('/', 'project', 'fruits', 'another', 'Strawberry.js')]: null,\n        [path.join(\n          '/',\n          'project',\n          'fruits',\n          'strawberryPackage',\n          'package.json',\n        )]: null,\n      });\n      mockClocks = createMap({\n        fruits: 'c:fake-clock:4',\n      });\n\n      const {__hasteMapForTest: correctData} = await (\n        await HasteMap.create(defaultConfig)\n      ).build();\n\n      expect(useBuitinsInContext(correctData.duplicates)).toEqual(new Map());\n      expect(correctData.map.get('Strawberry')).toEqual({\n        g: [path.join('fruits', 'Strawberry.js'), H.MODULE],\n      });\n    });\n\n    it('recovers when a duplicate module is renamed', async () => {\n      mockChangedFiles = object({\n        [path.join('/', 'project', 'fruits', 'another', 'Pineapple.js')]: `\n          const Blackberry = require(\"Blackberry\");\n        `,\n        [path.join('/', 'project', 'fruits', 'another', 'Strawberry.js')]: null,\n      });\n      mockClocks = createMap({\n        fruits: 'c:fake-clock:3',\n        vegetables: 'c:fake-clock:2',\n      });\n\n      const {__hasteMapForTest: data} = await (\n        await HasteMap.create(defaultConfig)\n      ).build();\n      expect(useBuitinsInContext(data.duplicates)).toEqual(new Map());\n      expect(data.map.get('Strawberry')).toEqual({\n        g: [path.join('fruits', 'Strawberry.js'), H.MODULE],\n      });\n      expect(data.map.get('Pineapple')).toEqual({\n        g: [path.join('fruits', 'another', 'Pineapple.js'), H.MODULE],\n      });\n      // Make sure the other files are not affected.\n      expect(data.map.get('Banana')).toEqual({\n        g: [path.join('fruits', 'Banana.js'), H.MODULE],\n      });\n    });\n  });\n\n  it('discards the cache when configuration changes', async () => {\n    HasteMap.getCacheFilePath = getCacheFilePath;\n    await (await HasteMap.create(defaultConfig)).build();\n    fs.readFileSync.mockClear();\n\n    // Explicitly mock that no files have changed.\n    mockChangedFiles = Object.create(null);\n\n    // Watchman would give us different clocks.\n    mockClocks = createMap({\n      fruits: 'c:fake-clock:3',\n      vegetables: 'c:fake-clock:4',\n    });\n\n    const config = {...defaultConfig, ignorePattern: /Kiwi|Pear/};\n    const {moduleMap} = await (await HasteMap.create(config)).build();\n    expect(moduleMap.getModule('Pear')).toBeNull();\n  });\n\n  it('ignores files that do not exist', async () => {\n    const watchman = require('../crawlers/watchman').watchmanCrawl;\n    const mockImpl = watchman.getMockImplementation();\n    // Wrap the watchman mock and add an invalid file to the file list.\n    watchman.mockImplementation(options =>\n      mockImpl(options).then(() => {\n        const {data} = options;\n        data.files.set(path.join('fruits', 'invalid', 'file.js'), [\n          '',\n          34,\n          44,\n          0,\n          [],\n        ]);\n        return {hasteMap: data, removedFiles: new Map()};\n      }),\n    );\n\n    const {__hasteMapForTest: data} = await (\n      await HasteMap.create(defaultConfig)\n    ).build();\n    expect(data.files.size).toBe(5);\n\n    // Ensure this file is not part of the file list.\n    expect(\n      data.files.get(path.join('fruits', 'invalid', 'file.js')),\n    ).toBeUndefined();\n  });\n\n  it('distributes work across workers', async () => {\n    const jestWorker = require('jest-worker').Worker;\n    const path = require('path');\n    const dependencyExtractor = path.join(__dirname, 'dependencyExtractor.js');\n    const {__hasteMapForTest: data} = await (\n      await HasteMap.create({\n        ...defaultConfig,\n        dependencyExtractor,\n        hasteImplModulePath: undefined,\n        maxWorkers: 4,\n      })\n    ).build();\n\n    expect(jestWorker).toHaveBeenCalledTimes(1);\n\n    expect(mockWorker).toHaveBeenCalledTimes(5);\n\n    expect(mockWorker.mock.calls).toEqual([\n      [\n        {\n          computeDependencies: true,\n          computeSha1: false,\n          dependencyExtractor,\n          filePath: path.join('/', 'project', 'fruits', 'Banana.js'),\n          hasteImplModulePath: undefined,\n          rootDir: path.join('/', 'project'),\n        },\n      ],\n      [\n        {\n          computeDependencies: true,\n          computeSha1: false,\n          dependencyExtractor,\n          filePath: path.join('/', 'project', 'fruits', 'Pear.js'),\n          hasteImplModulePath: undefined,\n          rootDir: path.join('/', 'project'),\n        },\n      ],\n      [\n        {\n          computeDependencies: true,\n          computeSha1: false,\n          dependencyExtractor,\n          filePath: path.join('/', 'project', 'fruits', 'Strawberry.js'),\n          hasteImplModulePath: undefined,\n          rootDir: path.join('/', 'project'),\n        },\n      ],\n      [\n        {\n          computeDependencies: true,\n          computeSha1: false,\n          dependencyExtractor,\n          filePath: path.join('/', 'project', 'fruits', '__mocks__', 'Pear.js'),\n          hasteImplModulePath: undefined,\n          rootDir: path.join('/', 'project'),\n        },\n      ],\n      [\n        {\n          computeDependencies: true,\n          computeSha1: false,\n          dependencyExtractor,\n          filePath: path.join('/', 'project', 'vegetables', 'Melon.js'),\n          hasteImplModulePath: undefined,\n          rootDir: path.join('/', 'project'),\n        },\n      ],\n    ]);\n\n    expect(mockEnd).toHaveBeenCalled();\n  });\n\n  it('tries to crawl using node as a fallback', async () => {\n    const watchman = require('../crawlers/watchman').watchmanCrawl;\n    const node = require('../crawlers/node').nodeCrawl;\n\n    watchman.mockImplementation(() => {\n      throw new Error('watchman error');\n    });\n    node.mockImplementation(options => {\n      const {data} = options;\n      data.files = createMap({\n        [path.join('fruits', 'Banana.js')]: ['', 32, 42, 0, '', null],\n      });\n      return Promise.resolve({\n        hasteMap: data,\n        removedFiles: new Map(),\n      });\n    });\n\n    const {__hasteMapForTest: data} = await (\n      await HasteMap.create(defaultConfig)\n    ).build();\n    expect(watchman).toHaveBeenCalled();\n    expect(node).toHaveBeenCalled();\n\n    expect(data.files).toEqual(\n      createMap({\n        [path.join('fruits', 'Banana.js')]: [\n          'Banana',\n          32,\n          42,\n          1,\n          'Strawberry',\n          null,\n        ],\n      }),\n    );\n\n    expect(console.warn.mock.calls[0][0]).toMatchSnapshot();\n  });\n\n  it('tries to crawl using node as a fallback when promise fails once', async () => {\n    const watchman = require('../crawlers/watchman').watchmanCrawl;\n    const node = require('../crawlers/node').nodeCrawl;\n\n    watchman.mockImplementation(() =>\n      Promise.reject(new Error('watchman error')),\n    );\n    node.mockImplementation(options => {\n      const {data} = options;\n      data.files = createMap({\n        [path.join('fruits', 'Banana.js')]: ['', 32, 42, 0, '', null],\n      });\n      return Promise.resolve({\n        hasteMap: data,\n        removedFiles: new Map(),\n      });\n    });\n\n    const {__hasteMapForTest: data} = await (\n      await HasteMap.create(defaultConfig)\n    ).build();\n\n    expect(watchman).toHaveBeenCalled();\n    expect(node).toHaveBeenCalled();\n\n    expect(data.files).toEqual(\n      createMap({\n        [path.join('fruits', 'Banana.js')]: [\n          'Banana',\n          32,\n          42,\n          1,\n          'Strawberry',\n          null,\n        ],\n      }),\n    );\n  });\n\n  it('stops crawling when both crawlers fail', async () => {\n    expect.assertions(1);\n    const watchman = require('../crawlers/watchman').watchmanCrawl;\n    const node = require('../crawlers/node').nodeCrawl;\n\n    watchman.mockImplementation(() =>\n      Promise.reject(new Error('watchman error')),\n    );\n\n    node.mockImplementation((roots, extensions, ignore, data) =>\n      Promise.reject(new Error('node error')),\n    );\n\n    try {\n      await (await HasteMap.create(defaultConfig)).build();\n    } catch (error) {\n      expect(error.message).toEqual(\n        'Crawler retry failed:\\n' +\n          '  Original error: watchman error\\n' +\n          '  Retry error: node error\\n',\n      );\n    }\n  });\n\n  describe('file system changes processing', () => {\n    function waitForItToChange(hasteMap) {\n      return new Promise(resolve => {\n        hasteMap.once('change', resolve);\n      });\n    }\n\n    function mockDeleteFile(dirPath, filePath) {\n      const e = mockEmitters[dirPath];\n      e.emit('all', 'delete', filePath, dirPath, undefined);\n    }\n\n    function hm_it(title, fn, options) {\n      options = options || {};\n      (options.only ? it.only : it)(title, async () => {\n        if (options.mockFs) {\n          mockFs = options.mockFs;\n        }\n        const watchConfig = {...defaultConfig, watch: true};\n        const hm = await HasteMap.create(watchConfig);\n        await hm.build();\n        try {\n          await fn(hm);\n        } finally {\n          hm.end();\n        }\n      });\n    }\n\n    hm_it('provides a new set of hasteHS and moduleMap', async hm => {\n      const initialResult = await hm.build();\n      const filePath = path.join('/', 'project', 'fruits', 'Banana.js');\n      expect(initialResult.hasteFS.getModuleName(filePath)).toBeDefined();\n      expect(initialResult.moduleMap.getModule('Banana')).toBe(filePath);\n      mockDeleteFile(path.join('/', 'project', 'fruits'), 'Banana.js');\n      mockDeleteFile(path.join('/', 'project', 'fruits'), 'Banana.js');\n      const {eventsQueue, hasteFS, moduleMap} = await waitForItToChange(hm);\n      expect(eventsQueue).toHaveLength(1);\n      const deletedBanana = {filePath, stat: undefined, type: 'delete'};\n      expect(eventsQueue).toEqual([deletedBanana]);\n      // Verify we didn't change the original map.\n      expect(initialResult.hasteFS.getModuleName(filePath)).toBeDefined();\n      expect(initialResult.moduleMap.getModule('Banana')).toBe(filePath);\n      expect(hasteFS.getModuleName(filePath)).toBeNull();\n      expect(moduleMap.getModule('Banana')).toBeNull();\n    });\n\n    const MOCK_STAT_FILE = {\n      isDirectory: () => false,\n      mtime: {getTime: () => 45},\n      size: 55,\n    };\n\n    const MOCK_STAT_FOLDER = {\n      isDirectory: () => true,\n      mtime: {getTime: () => 45},\n      size: 55,\n    };\n\n    hm_it('handles several change events at once', async hm => {\n      mockFs[path.join('/', 'project', 'fruits', 'Tomato.js')] = `\n        // Tomato!\n      `;\n      mockFs[path.join('/', 'project', 'fruits', 'Pear.js')] = `\n        // Pear!\n      `;\n      const e = mockEmitters[path.join('/', 'project', 'fruits')];\n      e.emit(\n        'all',\n        'add',\n        'Tomato.js',\n        path.join('/', 'project', 'fruits'),\n        MOCK_STAT_FILE,\n      );\n      e.emit(\n        'all',\n        'change',\n        'Pear.js',\n        path.join('/', 'project', 'fruits'),\n        MOCK_STAT_FILE,\n      );\n      const {eventsQueue, hasteFS, moduleMap} = await waitForItToChange(hm);\n      expect(eventsQueue).toEqual([\n        {\n          filePath: path.join('/', 'project', 'fruits', 'Tomato.js'),\n          stat: MOCK_STAT_FILE,\n          type: 'add',\n        },\n        {\n          filePath: path.join('/', 'project', 'fruits', 'Pear.js'),\n          stat: MOCK_STAT_FILE,\n          type: 'change',\n        },\n      ]);\n      expect(\n        hasteFS.getModuleName(path.join('/', 'project', 'fruits', 'Tomato.js')),\n      ).not.toBeNull();\n      expect(moduleMap.getModule('Tomato')).toBeDefined();\n      expect(moduleMap.getModule('Pear')).toBe(\n        path.join('/', 'project', 'fruits', 'Pear.js'),\n      );\n    });\n\n    hm_it('does not emit duplicate change events', async hm => {\n      const e = mockEmitters[path.join('/', 'project', 'fruits')];\n      e.emit(\n        'all',\n        'change',\n        'tomato.js',\n        path.join('/', 'project', 'fruits'),\n        MOCK_STAT_FILE,\n      );\n      e.emit(\n        'all',\n        'change',\n        'tomato.js',\n        path.join('/', 'project', 'fruits'),\n        MOCK_STAT_FILE,\n      );\n      const {eventsQueue} = await waitForItToChange(hm);\n      expect(eventsQueue).toHaveLength(1);\n    });\n\n    hm_it(\n      'emits a change even if a file in node_modules has changed',\n      async hm => {\n        const e = mockEmitters[path.join('/', 'project', 'fruits')];\n        e.emit(\n          'all',\n          'add',\n          'apple.js',\n          path.join('/', 'project', 'fruits', 'node_modules', ''),\n          MOCK_STAT_FILE,\n        );\n        const {eventsQueue, hasteFS} = await waitForItToChange(hm);\n        const filePath = path.join(\n          '/',\n          'project',\n          'fruits',\n          'node_modules',\n          'apple.js',\n        );\n        expect(eventsQueue).toHaveLength(1);\n        expect(eventsQueue).toEqual([\n          {filePath, stat: MOCK_STAT_FILE, type: 'add'},\n        ]);\n        expect(hasteFS.getModuleName(filePath)).toBeDefined();\n      },\n    );\n\n    hm_it(\n      'correctly tracks changes to both platform-specific versions of a single module name',\n      async hm => {\n        const {moduleMap: initMM} = await hm.build();\n        expect(initMM.getModule('Orange', 'ios')).toBeTruthy();\n        expect(initMM.getModule('Orange', 'android')).toBeTruthy();\n        const e = mockEmitters[path.join('/', 'project', 'fruits')];\n        e.emit(\n          'all',\n          'change',\n          'Orange.ios.js',\n          path.join('/', 'project', 'fruits'),\n          MOCK_STAT_FILE,\n        );\n        e.emit(\n          'all',\n          'change',\n          'Orange.android.js',\n          path.join('/', 'project', 'fruits'),\n          MOCK_STAT_FILE,\n        );\n        const {eventsQueue, hasteFS, moduleMap} = await waitForItToChange(hm);\n        expect(eventsQueue).toHaveLength(2);\n        expect(eventsQueue).toEqual([\n          {\n            filePath: path.join('/', 'project', 'fruits', 'Orange.ios.js'),\n            stat: MOCK_STAT_FILE,\n            type: 'change',\n          },\n          {\n            filePath: path.join('/', 'project', 'fruits', 'Orange.android.js'),\n            stat: MOCK_STAT_FILE,\n            type: 'change',\n          },\n        ]);\n        expect(\n          hasteFS.getModuleName(\n            path.join('/', 'project', 'fruits', 'Orange.ios.js'),\n          ),\n        ).toBeTruthy();\n        expect(\n          hasteFS.getModuleName(\n            path.join('/', 'project', 'fruits', 'Orange.android.js'),\n          ),\n        ).toBeTruthy();\n        const iosVariant = moduleMap.getModule('Orange', 'ios');\n        expect(iosVariant).toBe(\n          path.join('/', 'project', 'fruits', 'Orange.ios.js'),\n        );\n        const androidVariant = moduleMap.getModule('Orange', 'android');\n        expect(androidVariant).toBe(\n          path.join('/', 'project', 'fruits', 'Orange.android.js'),\n        );\n      },\n      {\n        mockFs: {\n          [path.join('/', 'project', 'fruits', 'Orange.android.js')]: `\n            // Orange Android!\n          `,\n          [path.join('/', 'project', 'fruits', 'Orange.ios.js')]: `\n            // Orange iOS!\n          `,\n        },\n      },\n    );\n\n    describe('recovery from duplicate module IDs', () => {\n      async function setupDuplicates(hm) {\n        mockFs[path.join('/', 'project', 'fruits', 'Pear.js')] = `\n          // Pear!\n        `;\n        mockFs[path.join('/', 'project', 'fruits', 'another', 'Pear.js')] = `\n          // Pear too!\n        `;\n        const e = mockEmitters[path.join('/', 'project', 'fruits')];\n        e.emit(\n          'all',\n          'change',\n          'Pear.js',\n          path.join('/', 'project', 'fruits'),\n          MOCK_STAT_FILE,\n        );\n        e.emit(\n          'all',\n          'add',\n          'Pear.js',\n          path.join('/', 'project', 'fruits', 'another'),\n          MOCK_STAT_FILE,\n        );\n        const {hasteFS, moduleMap} = await waitForItToChange(hm);\n        expect(\n          hasteFS.exists(\n            path.join('/', 'project', 'fruits', 'another', 'Pear.js'),\n          ),\n        ).toBe(true);\n        try {\n          moduleMap.getModule('Pear');\n          throw new Error('should be unreachable');\n        } catch (error) {\n          const {DuplicateHasteCandidatesError} =\n            require('../ModuleMap').default;\n          expect(error).toBeInstanceOf(DuplicateHasteCandidatesError);\n          expect(error.hasteName).toBe('Pear');\n          expect(error.platform).toBe('g');\n          expect(error.supportsNativePlatform).toBe(false);\n          expect(error.duplicatesSet).toEqual(\n            createMap({\n              [path.join('/', 'project', 'fruits', 'Pear.js')]: H.MODULE,\n              [path.join('/', 'project', 'fruits', 'another', 'Pear.js')]:\n                H.MODULE,\n            }),\n          );\n          expect(error.message.replaceAll('\\\\', '/')).toMatchSnapshot();\n        }\n      }\n\n      hm_it(\n        'recovers when the oldest version of the duplicates is fixed',\n        async hm => {\n          await setupDuplicates(hm);\n          mockFs[path.join('/', 'project', 'fruits', 'Pear.js')] = null;\n          mockFs[path.join('/', 'project', 'fruits', 'Pear2.js')] = `\n            // Pear!\n          `;\n          const e = mockEmitters[path.join('/', 'project', 'fruits')];\n          e.emit(\n            'all',\n            'delete',\n            'Pear.js',\n            path.join('/', 'project', 'fruits'),\n            MOCK_STAT_FILE,\n          );\n          e.emit(\n            'all',\n            'add',\n            'Pear2.js',\n            path.join('/', 'project', 'fruits'),\n            MOCK_STAT_FILE,\n          );\n          const {moduleMap} = await waitForItToChange(hm);\n          expect(moduleMap.getModule('Pear')).toBe(\n            path.join('/', 'project', 'fruits', 'another', 'Pear.js'),\n          );\n          expect(moduleMap.getModule('Pear2')).toBe(\n            path.join('/', 'project', 'fruits', 'Pear2.js'),\n          );\n        },\n      );\n\n      hm_it('recovers when the most recent duplicate is fixed', async hm => {\n        await setupDuplicates(hm);\n        mockFs[path.join('/', 'project', 'fruits', 'another', 'Pear.js')] =\n          null;\n        mockFs[path.join('/', 'project', 'fruits', 'another', 'Pear2.js')] = `\n          // Pear too!\n        `;\n        const e = mockEmitters[path.join('/', 'project', 'fruits')];\n        e.emit(\n          'all',\n          'add',\n          'Pear2.js',\n          path.join('/', 'project', 'fruits', 'another'),\n          MOCK_STAT_FILE,\n        );\n        e.emit(\n          'all',\n          'delete',\n          'Pear.js',\n          path.join('/', 'project', 'fruits', 'another'),\n          MOCK_STAT_FILE,\n        );\n        const {moduleMap} = await waitForItToChange(hm);\n        expect(moduleMap.getModule('Pear')).toBe(\n          path.join('/', 'project', 'fruits', 'Pear.js'),\n        );\n        expect(moduleMap.getModule('Pear2')).toBe(\n          path.join('/', 'project', 'fruits', 'another', 'Pear2.js'),\n        );\n      });\n\n      hm_it('ignore directories', async hm => {\n        const e = mockEmitters[path.join('/', 'project', 'fruits')];\n        e.emit(\n          'all',\n          'change',\n          'tomato.js',\n          path.join('/', 'project', 'fruits'),\n          MOCK_STAT_FOLDER,\n        );\n        e.emit(\n          'all',\n          'change',\n          'tomato.js',\n          path.join('/', 'project', 'fruits', 'tomato.js', 'index.js'),\n          MOCK_STAT_FILE,\n        );\n        const {eventsQueue} = await waitForItToChange(hm);\n        expect(eventsQueue).toHaveLength(1);\n      });\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`HasteMap file system changes processing recovery from duplicate module IDs recovers when the most recent duplicate is fixed 1`] = `\n\"The name \\`Pear\\` was looked up in the Haste module map. It cannot be resolved, because there exists several different files, or packages, that provide a module for that particular name and platform. The platform is generic (no extension). You must delete or exclude files until there remains only one of these:\n\n  * \\`/project/fruits/Pear.js\\` (module)\n  * \\`/project/fruits/another/Pear.js\\` (module)\n\"\n`;\n\nexports[`HasteMap file system changes processing recovery from duplicate module IDs recovers when the oldest version of the duplicates is fixed 1`] = `\n\"The name \\`Pear\\` was looked up in the Haste module map. It cannot be resolved, because there exists several different files, or packages, that provide a module for that particular name and platform. The platform is generic (no extension). You must delete or exclude files until there remains only one of these:\n\n  * \\`/project/fruits/Pear.js\\` (module)\n  * \\`/project/fruits/another/Pear.js\\` (module)\n\"\n`;\n\nexports[`HasteMap tries to crawl using node as a fallback 1`] = `\n\"jest-haste-map: Watchman crawl failed. Retrying once with node crawler.\n  Usually this happens when watchman isn't running. Create an empty \\`.watchmanconfig\\` file in your project's root folder or initialize a git or hg repository in your project.\n  Error: watchman error\"\n`;\n\nexports[`HasteMap warns on duplicate mock files 1`] = `\n\"jest-haste-map: duplicate manual mock found: subdir/Blueberry\n  The following files share their name; please delete one of them:\n    * <rootDir>/fruits1/__mocks__/subdir/Blueberry.js\n    * <rootDir>/fruits2/__mocks__/subdir/Blueberry.js\n\"\n`;\n\nexports[`HasteMap warns on duplicate module ids 1`] = `\n\"jest-haste-map: Haste module naming collision: Strawberry\n  The following files share their name; please adjust your hasteImpl:\n    * <rootDir>/fruits/Strawberry.js\n    * <rootDir>/fruits/other/Strawberry.js\n\"\n`;"}
{"prompt":"makes a non-existing relative worker throw,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {pathToFileURL} from 'url';\nimport type {JestWorkerFarm, Worker, WorkerFarmOptions} from '..';\nimport type FarmClass from '../Farm';\nimport type WorkerPoolClass from '../WorkerPool';\n\nlet WorkerFarm: typeof Worker;\nlet WorkerPool: typeof WorkerPoolClass;\nlet Farm: typeof FarmClass;\n\nbeforeEach(() => {\n  jest.mock('../Farm', () => {\n    const fakeClass = jest.fn(() => ({\n      doWork: jest.fn(() => 42),\n    }));\n\n    return {\n      __esModule: true,\n      default: fakeClass,\n    };\n  });\n\n  jest.mock('../WorkerPool', () => {\n    const fakeWorker = jest.fn(() => ({\n      createWorker: jest.fn(),\n      end: jest.fn(),\n      getStderr: () => '<mocked stderr>',\n      getStdout: () => '<mocked stdout>',\n      send: jest.fn(),\n    }));\n\n    return {\n      __esModule: true,\n      default: fakeWorker,\n    };\n  });\n\n  jest.mock(\n    '/fake-worker.js',\n    () => ({\n      _shouldNotExist1() {},\n      methodA() {},\n      methodB() {},\n    }),\n    {virtual: true},\n  );\n\n  jest.mock('/fake-worker-with-default-method.js', () => () => {}, {\n    virtual: true,\n  });\n\n  WorkerFarm = (require('../') as typeof import('..')).Worker;\n  Farm = (require('../Farm') as typeof import('../Farm')).default;\n  WorkerPool = (require('../WorkerPool') as typeof import('../WorkerPool'))\n    .default;\n});\n\nafterEach(() => {\n  jest.resetModules();\n});\n\nit('makes a non-existing relative worker throw', () => {\n  expect(() => {\n    // eslint-disable-next-line no-new\n    new WorkerFarm('./relative/worker-module.js');\n  }).toThrow(\"'workerPath' must be absolute\");\n});\n\nit('supports URLs', () => {\n  const workerPathUrl = pathToFileURL(__filename);\n\n  // eslint-disable-next-line no-new\n  new WorkerFarm(workerPathUrl, {exposedMethods: ['foo', 'bar']});\n  // eslint-disable-next-line no-new\n  new WorkerFarm(workerPathUrl.href, {exposedMethods: ['foo', 'bar']});\n\n  expect(WorkerPool).toHaveBeenCalledTimes(2);\n  expect(WorkerPool).toHaveBeenNthCalledWith(1, __filename, expect.anything());\n  expect(WorkerPool).toHaveBeenNthCalledWith(2, __filename, expect.anything());\n});\n\nit('exposes the right API using default working', () => {\n  const farm = new WorkerFarm('/tmp/baz.js', {\n    exposedMethods: ['foo', 'bar'],\n    numWorkers: 4,\n  }) as JestWorkerFarm<{foo(): void; bar(): void}>;\n\n  expect(typeof farm.foo).toBe('function');\n  expect(typeof farm.bar).toBe('function');\n});\n\nit('exposes the right API using passed worker', () => {\n  const WorkerPool = jest.fn(() => ({\n    createWorker: jest.fn(),\n    end: jest.fn(),\n    getStderr: jest.fn(),\n    getStdout: jest.fn(),\n    getWorkers: jest.fn(),\n    send: jest.fn(),\n    start: jest.fn(),\n  }));\n\n  const farm = new WorkerFarm('/tmp/baz.js', {\n    WorkerPool,\n    exposedMethods: ['foo', 'bar'],\n    numWorkers: 4,\n  } as WorkerFarmOptions) as JestWorkerFarm<{foo(): void; bar(): void}>;\n\n  expect(typeof farm.foo).toBe('function');\n  expect(typeof farm.bar).toBe('function');\n});\n\nit('breaks if any of the forbidden methods is tried to be exposed', () => {\n  expect(\n    () => new WorkerFarm('/tmp/baz.js', {exposedMethods: ['getStdout']}),\n  ).toThrow('Cannot define a method called getStdout');\n\n  expect(\n    () => new WorkerFarm('/tmp/baz.js', {exposedMethods: ['getStderr']}),\n  ).toThrow('Cannot define a method called getStderr');\n\n  expect(\n    () => new WorkerFarm('/tmp/baz.js', {exposedMethods: ['end']}),\n  ).toThrow('Cannot define a method called end');\n});\n\nit('works with minimal options', () => {\n  const farm1 = new WorkerFarm('/fake-worker.js') as JestWorkerFarm<{\n    methodA(): void;\n    methodB(): void;\n  }>;\n\n  expect(Farm).toHaveBeenCalledTimes(1);\n  expect(WorkerPool).toHaveBeenCalledTimes(1);\n  expect(typeof farm1.methodA).toBe('function');\n  expect(typeof farm1.methodB).toBe('function');\n  expect(farm1).toEqual(\n    expect.not.objectContaining({\n      _shouldNotExist: expect.anything,\n    }),\n  );\n\n  const farm2 = new WorkerFarm(\n    '/fake-worker-with-default-method.js',\n  ) as JestWorkerFarm<{default(): void}>;\n\n  expect(typeof farm2.default).toBe('function');\n});\n\nit('does not let make calls after the farm is ended', () => {\n  const farm = new WorkerFarm('/tmp/baz.js', {\n    exposedMethods: ['foo', 'bar'],\n    numWorkers: 4,\n  }) as JestWorkerFarm<{foo(): void; bar(): void}>;\n\n  farm.end();\n\n  // @ts-expect-error: Testing internal method\n  expect(farm._workerPool.end).toHaveBeenCalledTimes(1);\n  expect(() => farm.foo()).toThrow(\n    'Farm is ended, no more calls can be done to it',\n  );\n  expect(() => farm.bar()).toThrow(\n    'Farm is ended, no more calls can be done to it',\n  );\n});\n\nit('does not let end the farm after it is ended', async () => {\n  const farm = new WorkerFarm('/tmp/baz.js', {\n    exposedMethods: ['foo', 'bar'],\n    numWorkers: 4,\n  });\n\n  farm.end();\n  // @ts-expect-error: Testing internal method\n  expect(farm._workerPool.end).toHaveBeenCalledTimes(1);\n  await expect(farm.end()).rejects.toThrow(\n    'Farm is ended, no more calls can be done to it',\n  );\n  await expect(farm.end()).rejects.toThrow(\n    'Farm is ended, no more calls can be done to it',\n  );\n  // @ts-expect-error: Testing internal method\n  expect(farm._workerPool.end).toHaveBeenCalledTimes(1);\n});\n\nit('calls doWork', async () => {\n  const farm = new WorkerFarm('/tmp/baz.js', {\n    exposedMethods: ['foo', 'bar'],\n    numWorkers: 1,\n  }) as JestWorkerFarm<{foo(a: string, b: string): number}>;\n\n  const promise = farm.foo('car', 'plane');\n\n  expect(await promise).toBe(42);\n});\n\nit('calls getStderr and getStdout from worker', async () => {\n  const farm = new WorkerFarm('/tmp/baz.js', {\n    exposedMethods: ['foo', 'bar'],\n    numWorkers: 1,\n  });\n\n  expect(farm.getStderr()).toBe('<mocked stderr>');\n  expect(farm.getStdout()).toBe('<mocked stdout>');\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`ensureNoExpected() throws error when expected is not undefined with matcherName 1`] = `\n<d>expect(</><r>received</><d>)[.not].toBeDefined()</>\n\n<b>Matcher error</>: this matcher must not have an expected argument\n\nExpected has type:  object\nExpected has value: <g>{\"a\": 1}</>\n`;\n\nexports[`ensureNoExpected() throws error when expected is not undefined with matcherName and options 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: this matcher must not have an expected argument\n\nExpected has type:  object\nExpected has value: <g>{\"a\": 1}</>\n`;\n\nexports[`ensureNumbers() throws error when expected is not a number (backward compatibility) 1`] = `\n<d>expect(</><r>received</><d>)[.not].toBeCloseTo(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a number or bigint\n\nExpected has type:  string\nExpected has value: <g>\"not_a_number\"</>\n`;\n\nexports[`ensureNumbers() throws error when received is not a number (backward compatibility) 1`] = `\n<d>expect(</><r>received</><d>)[.not].toBeCloseTo(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a number or bigint\n\nReceived has type:  string\nReceived has value: <r>\"not_a_number\"</>\n`;\n\nexports[`ensureNumbers() with options promise empty isNot false received 1`] = `\n<d>expect(</><r>received</><d>).</>toBeCloseTo<d>(</><g>expected</><d>, </><g>precision</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a number or bigint\n\nReceived has type:  string\nReceived has value: <r>\"\"</>\n`;\n\nexports[`ensureNumbers() with options promise empty isNot true expected 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a number or bigint\n\nExpected has value: <g>undefined</>\n`;\n\nexports[`ensureNumbers() with options promise rejects isNot false expected 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a number or bigint\n\nExpected has type:  string\nExpected has value: <g>\"0\"</>\n`;\n\nexports[`ensureNumbers() with options promise rejects isNot true received 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a number or bigint\n\nReceived has type:  symbol\nReceived has value: <r>Symbol(0.1)</>\n`;\n\nexports[`ensureNumbers() with options promise resolves isNot false received 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a number or bigint\n\nReceived has type:  boolean\nReceived has value: <r>false</>\n`;\n\nexports[`ensureNumbers() with options promise resolves isNot true expected 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a number or bigint\n\nExpected has value: <g>null</>\n`;\n\nexports[`printDiffOrStringify expected asymmetric matchers should be diffable 1`] = `\n<g>- Expected  - 2</>\n<r>+ Received  + 2</>\n\n<g>- ObjectContaining {</>\n<r>+ Object {</>\n<d>    \"array\": Array [</>\n<d>      Object {</>\n<d>        \"3\": \"three\",</>\n<d>        \"four\": \"4\",</>\n<d>        \"one\": 1,</>\n<g>-       \"two\": 2,</>\n<r>+       \"two\": 1,</>\n<d>      },</>\n<d>    ],</>\n<d>    \"foo\": \"bar\",</>\n<d>  }</>\n`;\n\nexports[`stringify() toJSON errors when comparing two objects 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"b\": 1,</>\n<r>+   \"a\": 1,</>\n<d>    \"toJSON\": [Function toJSON],</>\n<d>  }</>\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('throw when directly imported', () => {\n  expect(() => {\n    require('../');\n  }).toThrow(\n    'Do not import `@jest/globals` outside of the Jest test environment',\n  );\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\n'use strict';\n\njest.useFakeTimers();\n\nit('schedules a 10-second timer after 1 second', () => {\n  jest.spyOn(globalThis, 'setTimeout');\n  const infiniteTimerGame = require('../infiniteTimerGame');\n  const callback = jest.fn();\n\n  infiniteTimerGame(callback);\n\n  // At this point in time, there should have been a single call to\n  // setTimeout to schedule the end of the game in 1 second.\n  expect(setTimeout).toHaveBeenCalledTimes(1);\n  expect(setTimeout).toHaveBeenNthCalledWith(1, expect.any(Function), 1000);\n\n  // Fast forward and exhaust only currently pending timers\n  // (but not any new timers that get created during that process)\n  jest.runOnlyPendingTimers();\n\n  // At this point, our 1-second timer should have fired its callback\n  expect(callback).toHaveBeenCalled();\n\n  // And it should have created a new timer to start the game over in\n  // 10 seconds\n  expect(setTimeout).toHaveBeenCalledTimes(2);\n  expect(setTimeout).toHaveBeenNthCalledWith(2, expect.any(Function), 10_000);\n});"}
{"prompt":"init,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable no-eval */\nimport * as path from 'path';\nimport {writeFileSync} from 'graceful-fs';\nimport * as prompts from 'prompts';\nimport {constants} from 'jest-config';\nimport {runCreate} from '../runCreate';\n\nconst {JEST_CONFIG_EXT_ORDER} = constants;\n\njest.mock('prompts');\njest.mock('path', () => ({\n  ...jest.requireActual<typeof import('path')>('path'),\n  sep: '/',\n}));\njest.mock('graceful-fs', () => ({\n  ...jest.requireActual<typeof import('graceful-fs')>('graceful-fs'),\n  writeFileSync: jest.fn(),\n}));\n\nconst resolveFromFixture = (relativePath: string) =>\n  path.resolve(__dirname, '__fixtures__', relativePath);\n\nconst consoleLog = console.log;\n\ndescribe('init', () => {\n  beforeEach(() => {\n    console.log = jest.fn();\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n    console.log = consoleLog;\n  });\n\n  describe('project with package.json and no jest config', () => {\n    describe('all questions answered with answer: \"No\"', () => {\n      it('should return the default configuration (an empty config)', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenJestConfigFilename =\n          jest.mocked(writeFileSync).mock.calls[0][0];\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n\n        expect(path.basename(writtenJestConfigFilename as string)).toBe(\n          'jest.config.js',\n        );\n        expect(\n          (writtenJestConfig as string).replace(\n            /\\/\\/ cacheDirectory: .*,/,\n            '// cacheDirectory: \"/tmp/jest\",',\n          ),\n        ).toMatchSnapshot();\n\n        const evaluatedConfig = eval(writtenJestConfig as string) as Record<\n          string,\n          unknown\n        >;\n\n        expect(evaluatedConfig).toEqual({});\n      });\n\n      it('should generate empty config with mjs extension', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({});\n\n        await runCreate(resolveFromFixture('type-module'));\n\n        const writtenJestConfigFilename =\n          jest.mocked(writeFileSync).mock.calls[0][0];\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n\n        expect(path.basename(writtenJestConfigFilename as string)).toBe(\n          'jest.config.mjs',\n        );\n        expect(\n          (writtenJestConfig as string).replace(\n            /\\/\\/ cacheDirectory: .*,/,\n            '// cacheDirectory: \"/tmp/jest\",',\n          ),\n        ).toMatchSnapshot();\n      });\n    });\n\n    describe('some questions answered with answer: \"Yes\"', () => {\n      it('should create configuration for {clearMocks: true}', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({clearMocks: true});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n        const evaluatedConfig = eval(writtenJestConfig as string) as Record<\n          string,\n          unknown\n        >;\n\n        expect(evaluatedConfig).toEqual({clearMocks: true});\n      });\n\n      it('should create configuration for {coverage: true}', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({coverage: true});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n        const evaluatedConfig = eval(writtenJestConfig as string) as Record<\n          string,\n          unknown\n        >;\n\n        expect(evaluatedConfig).toEqual({\n          collectCoverage: true,\n          coverageDirectory: 'coverage',\n        });\n      });\n\n      it('should create configuration for {coverageProvider: \"babel\"}', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({coverageProvider: 'babel'});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n        const evaluatedConfig = eval(writtenJestConfig as string) as Record<\n          string,\n          unknown\n        >;\n        // should modify when the default coverageProvider will be changed to \"v8\"\n        expect(evaluatedConfig).toEqual({});\n      });\n\n      it('should create configuration for {coverageProvider: \"v8\"}', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({coverageProvider: 'v8'});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n        const evaluatedConfig = eval(writtenJestConfig as string) as Record<\n          string,\n          unknown\n        >;\n        // should modify when the default coverageProvider will be changed to \"v8\"\n        expect(evaluatedConfig).toEqual({coverageProvider: 'v8'});\n      });\n\n      it('should create configuration for {environment: \"jsdom\"}', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({environment: 'jsdom'});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n        const evaluatedConfig = eval(writtenJestConfig as string) as Record<\n          string,\n          unknown\n        >;\n        expect(evaluatedConfig).toEqual({testEnvironment: 'jsdom'});\n      });\n\n      it('should create configuration for {environment: \"node\"}', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({environment: 'node'});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n        const evaluatedConfig = eval(writtenJestConfig as string) as Record<\n          string,\n          unknown\n        >;\n        expect(evaluatedConfig).toEqual({});\n      });\n\n      it('should create package.json with configured test command when {scripts: true}', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({scripts: true});\n\n        await runCreate(resolveFromFixture('only-package-json'));\n\n        const writtenPackageJson = jest.mocked(writeFileSync).mock.calls[0][1];\n        const parsedPackageJson = JSON.parse(writtenPackageJson as string) as {\n          scripts: {test: string};\n        };\n\n        expect(writtenPackageJson).toMatchSnapshot();\n        expect(parsedPackageJson.scripts.test).toBe('jest');\n      });\n    });\n  });\n\n  describe('no package json', () => {\n    it('should throw an error if there is no package.json file', async () => {\n      expect.assertions(1);\n\n      try {\n        await runCreate(resolveFromFixture('no-package-json'));\n      } catch (error) {\n        expect((error as Error).message).toMatch(\n          'Could not find a \"package.json\" file in',\n        );\n      }\n    });\n  });\n\n  describe.each(JEST_CONFIG_EXT_ORDER.map(e => e.slice(1)))(\n    'has-jest-config-file-%s',\n    extension => {\n      describe('ask the user whether to override config or not', () => {\n        it('user answered with \"Yes\"', async () => {\n          jest\n            .mocked(prompts)\n            .mockResolvedValueOnce({continue: true})\n            .mockResolvedValueOnce({});\n\n          await runCreate(\n            resolveFromFixture(`has-jest-config-file-${extension}`),\n          );\n\n          expect(jest.mocked(prompts).mock.calls[0][0]).toMatchSnapshot();\n\n          const jestConfigFileName =\n            jest.mocked(writeFileSync).mock.calls[0][0];\n          const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n\n          expect(jestConfigFileName).toBe(`jest.config.${extension}`);\n          expect(writtenJestConfig).toBeDefined();\n        });\n\n        it('user answered with \"No\"', async () => {\n          jest.mocked(prompts).mockResolvedValueOnce({continue: false});\n\n          await runCreate(\n            resolveFromFixture(`has-jest-config-file-${extension}`),\n          );\n          // return after first prompt\n          expect(prompts).toHaveBeenCalledTimes(1);\n        });\n      });\n    },\n  );\n\n  describe('project using jest.config.ts', () => {\n    describe('ask the user whether he wants to use Typescript or not', () => {\n      it('user answered with \"Yes\"', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({useTypescript: true});\n\n        await runCreate(resolveFromFixture('test-generated-jest-config-ts'));\n\n        expect(jest.mocked(prompts).mock.calls[0][0]).toMatchSnapshot();\n\n        const jestConfigFileName = jest.mocked(writeFileSync).mock.calls[0][0];\n        const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n\n        expect(path.basename(jestConfigFileName as string)).toBe(\n          'jest.config.ts',\n        );\n        expect(\n          (writtenJestConfig as string).replace(\n            /\\/\\/ cacheDirectory: .*,/,\n            '// cacheDirectory: \"/tmp/jest\",',\n          ),\n        ).toMatchSnapshot();\n      });\n\n      it('user answered with \"No\"', async () => {\n        jest.mocked(prompts).mockResolvedValueOnce({useTypescript: false});\n\n        await runCreate(resolveFromFixture('test-generated-jest-config-ts'));\n\n        const jestConfigFileName = jest.mocked(writeFileSync).mock.calls[0][0];\n\n        expect(path.basename(jestConfigFileName as string)).not.toBe(\n          'jest.config.ts',\n        );\n      });\n    });\n  });\n\n  describe('has jest config in package.json', () => {\n    it('should ask the user whether to override config or not', async () => {\n      jest\n        .mocked(prompts)\n        .mockResolvedValueOnce({continue: true})\n        .mockResolvedValueOnce({});\n\n      await runCreate(resolveFromFixture('has-jest-config-in-package-json'));\n\n      expect(jest.mocked(prompts).mock.calls[0][0]).toMatchSnapshot();\n\n      const writtenJestConfig = jest.mocked(writeFileSync).mock.calls[0][1];\n\n      expect(writtenJestConfig).toBeDefined();\n    });\n  });\n\n  describe('already has \"jest\" in packageJson.scripts.test', () => {\n    it('should not ask \"test script question\"', async () => {\n      jest.mocked(prompts).mockResolvedValueOnce({});\n\n      await runCreate(resolveFromFixture('test-script-configured'));\n\n      const questions = jest.mocked(prompts).mock.calls[0][0] as Array<\n        prompts.PromptObject<string>\n      >;\n      const questionsNames = questions.map(question => question.name);\n\n      expect(questionsNames).not.toContain('scripts');\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`init has jest config in package.json should ask the user whether to override config or not 1`] = `\nObject {\n  \"initial\": true,\n  \"message\": \"It seems that you already have a jest configuration, do you want to override it?\",\n  \"name\": \"continue\",\n  \"type\": \"confirm\",\n}\n`;\n\nexports[`init has-jest-config-file-cjs ask the user whether to override config or not user answered with \"Yes\" 1`] = `\nObject {\n  \"initial\": true,\n  \"message\": \"It seems that you already have a jest configuration, do you want to override it?\",\n  \"name\": \"continue\",\n  \"type\": \"confirm\",\n}\n`;\n\nexports[`init has-jest-config-file-cts ask the user whether to override config or not user answered with \"Yes\" 1`] = `\nObject {\n  \"initial\": true,\n  \"message\": \"It seems that you already have a jest configuration, do you want to override it?\",\n  \"name\": \"continue\",\n  \"type\": \"confirm\",\n}\n`;\n\nexports[`init has-jest-config-file-js ask the user whether to override config or not user answered with \"Yes\" 1`] = `\nObject {\n  \"initial\": true,\n  \"message\": \"It seems that you already have a jest configuration, do you want to override it?\",\n  \"name\": \"continue\",\n  \"type\": \"confirm\",\n}\n`;\n\nexports[`init has-jest-config-file-json ask the user whether to override config or not user answered with \"Yes\" 1`] = `\nObject {\n  \"initial\": true,\n  \"message\": \"It seems that you already have a jest configuration, do you want to override it?\",\n  \"name\": \"continue\",\n  \"type\": \"confirm\",\n}\n`;\n\nexports[`init has-jest-config-file-mjs ask the user whether to override config or not user answered with \"Yes\" 1`] = `\nObject {\n  \"initial\": true,\n  \"message\": \"It seems that you already have a jest configuration, do you want to override it?\",\n  \"name\": \"continue\",\n  \"type\": \"confirm\",\n}\n`;\n\nexports[`init has-jest-config-file-ts ask the user whether to override config or not user answered with \"Yes\" 1`] = `\nObject {\n  \"initial\": true,\n  \"message\": \"It seems that you already have a jest configuration, do you want to override it?\",\n  \"name\": \"continue\",\n  \"type\": \"confirm\",\n}\n`;\n\nexports[`init project using jest.config.ts ask the user whether he wants to use Typescript or not user answered with \"Yes\" 1`] = `\nArray [\n  Object {\n    \"initial\": true,\n    \"message\": \"Would you like to use Jest when running \"test\" script in \"package.json\"?\",\n    \"name\": \"scripts\",\n    \"type\": \"confirm\",\n  },\n  Object {\n    \"initial\": false,\n    \"message\": \"Would you like to use Typescript for the configuration file?\",\n    \"name\": \"useTypescript\",\n    \"type\": \"confirm\",\n  },\n  Object {\n    \"choices\": Array [\n      Object {\n        \"title\": \"node\",\n        \"value\": \"node\",\n      },\n      Object {\n        \"title\": \"jsdom (browser-like)\",\n        \"value\": \"jsdom\",\n      },\n    ],\n    \"initial\": 0,\n    \"message\": \"Choose the test environment that will be used for testing\",\n    \"name\": \"environment\",\n    \"type\": \"select\",\n  },\n  Object {\n    \"initial\": false,\n    \"message\": \"Do you want Jest to add coverage reports?\",\n    \"name\": \"coverage\",\n    \"type\": \"confirm\",\n  },\n  Object {\n    \"choices\": Array [\n      Object {\n        \"title\": \"v8\",\n        \"value\": \"v8\",\n      },\n      Object {\n        \"title\": \"babel\",\n        \"value\": \"babel\",\n      },\n    ],\n    \"initial\": 0,\n    \"message\": \"Which provider should be used to instrument code for coverage?\",\n    \"name\": \"coverageProvider\",\n    \"type\": \"select\",\n  },\n  Object {\n    \"initial\": false,\n    \"message\": \"Automatically clear mock calls, instances, contexts and results before every test?\",\n    \"name\": \"clearMocks\",\n    \"type\": \"confirm\",\n  },\n]\n`;\n\nexports[`init project using jest.config.ts ask the user whether he wants to use Typescript or not user answered with \"Yes\" 2`] = `\n\"/**\n * For a detailed explanation regarding each configuration property, visit:\n * https://jestjs.io/docs/configuration\n */\n\nimport type {Config} from 'jest';\n\nconst config: Config = {\n  // All imported modules in your tests should be mocked automatically\n  // automock: false,\n\n  // Stop running tests after \\`n\\` failures\n  // bail: 0,\n\n  // The directory where Jest should store its cached dependency information\n  // cacheDirectory: \"/tmp/jest\",\n\n  // Automatically clear mock calls, instances, contexts and results before every test\n  // clearMocks: false,\n\n  // Indicates whether the coverage information should be collected while executing the test\n  // collectCoverage: false,\n\n  // An array of glob patterns indicating a set of files for which coverage information should be collected\n  // collectCoverageFrom: undefined,\n\n  // The directory where Jest should output its coverage files\n  // coverageDirectory: undefined,\n\n  // An array of regexp pattern strings used to skip coverage collection\n  // coveragePathIgnorePatterns: [\n  //   \"/node_modules/\"\n  // ],\n\n  // Indicates which provider should be used to instrument code for coverage\n  // coverageProvider: \"babel\",\n\n  // A list of reporter names that Jest uses when writing coverage reports\n  // coverageReporters: [\n  //   \"json\",\n  //   \"text\",\n  //   \"lcov\",\n  //   \"clover\"\n  // ],\n\n  // An object that configures minimum threshold enforcement for coverage results\n  // coverageThreshold: undefined,\n\n  // A path to a custom dependency extractor\n  // dependencyExtractor: undefined,\n\n  // Make calling deprecated APIs throw helpful error messages\n  // errorOnDeprecated: false,\n\n  // The default configuration for fake timers\n  // fakeTimers: {\n  //   \"enableGlobally\": false\n  // },\n\n  // Force coverage collection from ignored files using an array of glob patterns\n  // forceCoverageMatch: [],\n\n  // A path to a module which exports an async function that is triggered once before all test suites\n  // globalSetup: undefined,\n\n  // A path to a module which exports an async function that is triggered once after all test suites\n  // globalTeardown: undefined,\n\n  // A set of global variables that need to be available in all test environments\n  // globals: {},\n\n  // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.\n  // maxWorkers: \"50%\",\n\n  // An array of directory names to be searched recursively up from the requiring module's location\n  // moduleDirectories: [\n  //   \"node_modules\"\n  // ],\n\n  // An array of file extensions your modules use\n  // moduleFileExtensions: [\n  //   \"js\",\n  //   \"mjs\",\n  //   \"cjs\",\n  //   \"jsx\",\n  //   \"ts\",\n  //   \"mts\",\n  //   \"cts\",\n  //   \"tsx\",\n  //   \"json\",\n  //   \"node\"\n  // ],\n\n  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module\n  // moduleNameMapper: {},\n\n  // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader\n  // modulePathIgnorePatterns: [],\n\n  // Activates notifications for test results\n  // notify: false,\n\n  // An enum that specifies notification mode. Requires { notify: true }\n  // notifyMode: \"failure-change\",\n\n  // A preset that is used as a base for Jest's configuration\n  // preset: undefined,\n\n  // Run tests from one or more projects\n  // projects: undefined,\n\n  // Use this configuration option to add custom reporters to Jest\n  // reporters: undefined,\n\n  // Automatically reset mock state before every test\n  // resetMocks: false,\n\n  // Reset the module registry before running each individual test\n  // resetModules: false,\n\n  // A path to a custom resolver\n  // resolver: undefined,\n\n  // Automatically restore mock state and implementation before every test\n  // restoreMocks: false,\n\n  // The root directory that Jest should scan for tests and modules within\n  // rootDir: undefined,\n\n  // A list of paths to directories that Jest should use to search for files in\n  // roots: [\n  //   \"<rootDir>\"\n  // ],\n\n  // Allows you to use a custom runner instead of Jest's default test runner\n  // runner: \"jest-runner\",\n\n  // The paths to modules that run some code to configure or set up the testing environment before each test\n  // setupFiles: [],\n\n  // A list of paths to modules that run some code to configure or set up the testing framework before each test\n  // setupFilesAfterEnv: [],\n\n  // The number of seconds after which a test is considered as slow and reported as such in the results.\n  // slowTestThreshold: 5,\n\n  // A list of paths to snapshot serializer modules Jest should use for snapshot testing\n  // snapshotSerializers: [],\n\n  // The test environment that will be used for testing\n  // testEnvironment: \"jest-environment-node\",\n\n  // Options that will be passed to the testEnvironment\n  // testEnvironmentOptions: {},\n\n  // Adds a location field to test results\n  // testLocationInResults: false,\n\n  // The glob patterns Jest uses to detect test files\n  // testMatch: [\n  //   \"**/__tests__/**/*.?([mc])[jt]s?(x)\",\n  //   \"**/?(*.)+(spec|test).?([mc])[jt]s?(x)\"\n  // ],\n\n  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped\n  // testPathIgnorePatterns: [\n  //   \"/node_modules/\"\n  // ],\n\n  // The regexp pattern or array of patterns that Jest uses to detect test files\n  // testRegex: [],\n\n  // This option allows the use of a custom results processor\n  // testResultsProcessor: undefined,\n\n  // This option allows use of a custom test runner\n  // testRunner: \"jest-circus/runner\",\n\n  // A map from regular expressions to paths to transformers\n  // transform: undefined,\n\n  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation\n  // transformIgnorePatterns: [\n  //   \"/node_modules/\",\n  //   \"\\\\\\\\.pnp\\\\\\\\.[^\\\\\\\\/]+$\"\n  // ],\n\n  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them\n  // unmockedModulePathPatterns: undefined,\n\n  // Indicates whether each individual test should be reported during the run\n  // verbose: undefined,\n\n  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode\n  // watchPathIgnorePatterns: [],\n\n  // Whether to use watchman for file crawling\n  // watchman: true,\n};\n\nexport default config;\n\"\n`;\n\nexports[`init project with package.json and no jest config all questions answered with answer: \"No\" should generate empty config with mjs extension 1`] = `\n\"/**\n * For a detailed explanation regarding each configuration property, visit:\n * https://jestjs.io/docs/configuration\n */\n\n/** @type {import('jest').Config} */\nconst config = {\n  // All imported modules in your tests should be mocked automatically\n  // automock: false,\n\n  // Stop running tests after \\`n\\` failures\n  // bail: 0,\n\n  // The directory where Jest should store its cached dependency information\n  // cacheDirectory: \"/tmp/jest\",\n\n  // Automatically clear mock calls, instances, contexts and results before every test\n  // clearMocks: false,\n\n  // Indicates whether the coverage information should be collected while executing the test\n  // collectCoverage: false,\n\n  // An array of glob patterns indicating a set of files for which coverage information should be collected\n  // collectCoverageFrom: undefined,\n\n  // The directory where Jest should output its coverage files\n  // coverageDirectory: undefined,\n\n  // An array of regexp pattern strings used to skip coverage collection\n  // coveragePathIgnorePatterns: [\n  //   \"/node_modules/\"\n  // ],\n\n  // Indicates which provider should be used to instrument code for coverage\n  // coverageProvider: \"babel\",\n\n  // A list of reporter names that Jest uses when writing coverage reports\n  // coverageReporters: [\n  //   \"json\",\n  //   \"text\",\n  //   \"lcov\",\n  //   \"clover\"\n  // ],\n\n  // An object that configures minimum threshold enforcement for coverage results\n  // coverageThreshold: undefined,\n\n  // A path to a custom dependency extractor\n  // dependencyExtractor: undefined,\n\n  // Make calling deprecated APIs throw helpful error messages\n  // errorOnDeprecated: false,\n\n  // The default configuration for fake timers\n  // fakeTimers: {\n  //   \"enableGlobally\": false\n  // },\n\n  // Force coverage collection from ignored files using an array of glob patterns\n  // forceCoverageMatch: [],\n\n  // A path to a module which exports an async function that is triggered once before all test suites\n  // globalSetup: undefined,\n\n  // A path to a module which exports an async function that is triggered once after all test suites\n  // globalTeardown: undefined,\n\n  // A set of global variables that need to be available in all test environments\n  // globals: {},\n\n  // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.\n  // maxWorkers: \"50%\",\n\n  // An array of directory names to be searched recursively up from the requiring module's location\n  // moduleDirectories: [\n  //   \"node_modules\"\n  // ],\n\n  // An array of file extensions your modules use\n  // moduleFileExtensions: [\n  //   \"js\",\n  //   \"mjs\",\n  //   \"cjs\",\n  //   \"jsx\",\n  //   \"ts\",\n  //   \"mts\",\n  //   \"cts\",\n  //   \"tsx\",\n  //   \"json\",\n  //   \"node\"\n  // ],\n\n  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module\n  // moduleNameMapper: {},\n\n  // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader\n  // modulePathIgnorePatterns: [],\n\n  // Activates notifications for test results\n  // notify: false,\n\n  // An enum that specifies notification mode. Requires { notify: true }\n  // notifyMode: \"failure-change\",\n\n  // A preset that is used as a base for Jest's configuration\n  // preset: undefined,\n\n  // Run tests from one or more projects\n  // projects: undefined,\n\n  // Use this configuration option to add custom reporters to Jest\n  // reporters: undefined,\n\n  // Automatically reset mock state before every test\n  // resetMocks: false,\n\n  // Reset the module registry before running each individual test\n  // resetModules: false,\n\n  // A path to a custom resolver\n  // resolver: undefined,\n\n  // Automatically restore mock state and implementation before every test\n  // restoreMocks: false,\n\n  // The root directory that Jest should scan for tests and modules within\n  // rootDir: undefined,\n\n  // A list of paths to directories that Jest should use to search for files in\n  // roots: [\n  //   \"<rootDir>\"\n  // ],\n\n  // Allows you to use a custom runner instead of Jest's default test runner\n  // runner: \"jest-runner\",\n\n  // The paths to modules that run some code to configure or set up the testing environment before each test\n  // setupFiles: [],\n\n  // A list of paths to modules that run some code to configure or set up the testing framework before each test\n  // setupFilesAfterEnv: [],\n\n  // The number of seconds after which a test is considered as slow and reported as such in the results.\n  // slowTestThreshold: 5,\n\n  // A list of paths to snapshot serializer modules Jest should use for snapshot testing\n  // snapshotSerializers: [],\n\n  // The test environment that will be used for testing\n  // testEnvironment: \"jest-environment-node\",\n\n  // Options that will be passed to the testEnvironment\n  // testEnvironmentOptions: {},\n\n  // Adds a location field to test results\n  // testLocationInResults: false,\n\n  // The glob patterns Jest uses to detect test files\n  // testMatch: [\n  //   \"**/__tests__/**/*.?([mc])[jt]s?(x)\",\n  //   \"**/?(*.)+(spec|test).?([mc])[jt]s?(x)\"\n  // ],\n\n  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped\n  // testPathIgnorePatterns: [\n  //   \"/node_modules/\"\n  // ],\n\n  // The regexp pattern or array of patterns that Jest uses to detect test files\n  // testRegex: [],\n\n  // This option allows the use of a custom results processor\n  // testResultsProcessor: undefined,\n\n  // This option allows use of a custom test runner\n  // testRunner: \"jest-circus/runner\",\n\n  // A map from regular expressions to paths to transformers\n  // transform: undefined,\n\n  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation\n  // transformIgnorePatterns: [\n  //   \"/node_modules/\",\n  //   \"\\\\\\\\.pnp\\\\\\\\.[^\\\\\\\\/]+$\"\n  // ],\n\n  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them\n  // unmockedModulePathPatterns: undefined,\n\n  // Indicates whether each individual test should be reported during the run\n  // verbose: undefined,\n\n  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode\n  // watchPathIgnorePatterns: [],\n\n  // Whether to use watchman for file crawling\n  // watchman: true,\n};\n\nexport default config;\n\"\n`;\n\nexports[`init project with package.json and no jest config all questions answered with answer: \"No\" should return the default configuration (an empty config) 1`] = `\n\"/**\n * For a detailed explanation regarding each configuration property, visit:\n * https://jestjs.io/docs/configuration\n */\n\n/** @type {import('jest').Config} */\nconst config = {\n  // All imported modules in your tests should be mocked automatically\n  // automock: false,\n\n  // Stop running tests after \\`n\\` failures\n  // bail: 0,\n\n  // The directory where Jest should store its cached dependency information\n  // cacheDirectory: \"/tmp/jest\",\n\n  // Automatically clear mock calls, instances, contexts and results before every test\n  // clearMocks: false,\n\n  // Indicates whether the coverage information should be collected while executing the test\n  // collectCoverage: false,\n\n  // An array of glob patterns indicating a set of files for which coverage information should be collected\n  // collectCoverageFrom: undefined,\n\n  // The directory where Jest should output its coverage files\n  // coverageDirectory: undefined,\n\n  // An array of regexp pattern strings used to skip coverage collection\n  // coveragePathIgnorePatterns: [\n  //   \"/node_modules/\"\n  // ],\n\n  // Indicates which provider should be used to instrument code for coverage\n  // coverageProvider: \"babel\",\n\n  // A list of reporter names that Jest uses when writing coverage reports\n  // coverageReporters: [\n  //   \"json\",\n  //   \"text\",\n  //   \"lcov\",\n  //   \"clover\"\n  // ],\n\n  // An object that configures minimum threshold enforcement for coverage results\n  // coverageThreshold: undefined,\n\n  // A path to a custom dependency extractor\n  // dependencyExtractor: undefined,\n\n  // Make calling deprecated APIs throw helpful error messages\n  // errorOnDeprecated: false,\n\n  // The default configuration for fake timers\n  // fakeTimers: {\n  //   \"enableGlobally\": false\n  // },\n\n  // Force coverage collection from ignored files using an array of glob patterns\n  // forceCoverageMatch: [],\n\n  // A path to a module which exports an async function that is triggered once before all test suites\n  // globalSetup: undefined,\n\n  // A path to a module which exports an async function that is triggered once after all test suites\n  // globalTeardown: undefined,\n\n  // A set of global variables that need to be available in all test environments\n  // globals: {},\n\n  // The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.\n  // maxWorkers: \"50%\",\n\n  // An array of directory names to be searched recursively up from the requiring module's location\n  // moduleDirectories: [\n  //   \"node_modules\"\n  // ],\n\n  // An array of file extensions your modules use\n  // moduleFileExtensions: [\n  //   \"js\",\n  //   \"mjs\",\n  //   \"cjs\",\n  //   \"jsx\",\n  //   \"ts\",\n  //   \"mts\",\n  //   \"cts\",\n  //   \"tsx\",\n  //   \"json\",\n  //   \"node\"\n  // ],\n\n  // A map from regular expressions to module names or to arrays of module names that allow to stub out resources with a single module\n  // moduleNameMapper: {},\n\n  // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader\n  // modulePathIgnorePatterns: [],\n\n  // Activates notifications for test results\n  // notify: false,\n\n  // An enum that specifies notification mode. Requires { notify: true }\n  // notifyMode: \"failure-change\",\n\n  // A preset that is used as a base for Jest's configuration\n  // preset: undefined,\n\n  // Run tests from one or more projects\n  // projects: undefined,\n\n  // Use this configuration option to add custom reporters to Jest\n  // reporters: undefined,\n\n  // Automatically reset mock state before every test\n  // resetMocks: false,\n\n  // Reset the module registry before running each individual test\n  // resetModules: false,\n\n  // A path to a custom resolver\n  // resolver: undefined,\n\n  // Automatically restore mock state and implementation before every test\n  // restoreMocks: false,\n\n  // The root directory that Jest should scan for tests and modules within\n  // rootDir: undefined,\n\n  // A list of paths to directories that Jest should use to search for files in\n  // roots: [\n  //   \"<rootDir>\"\n  // ],\n\n  // Allows you to use a custom runner instead of Jest's default test runner\n  // runner: \"jest-runner\",\n\n  // The paths to modules that run some code to configure or set up the testing environment before each test\n  // setupFiles: [],\n\n  // A list of paths to modules that run some code to configure or set up the testing framework before each test\n  // setupFilesAfterEnv: [],\n\n  // The number of seconds after which a test is considered as slow and reported as such in the results.\n  // slowTestThreshold: 5,\n\n  // A list of paths to snapshot serializer modules Jest should use for snapshot testing\n  // snapshotSerializers: [],\n\n  // The test environment that will be used for testing\n  // testEnvironment: \"jest-environment-node\",\n\n  // Options that will be passed to the testEnvironment\n  // testEnvironmentOptions: {},\n\n  // Adds a location field to test results\n  // testLocationInResults: false,\n\n  // The glob patterns Jest uses to detect test files\n  // testMatch: [\n  //   \"**/__tests__/**/*.?([mc])[jt]s?(x)\",\n  //   \"**/?(*.)+(spec|test).?([mc])[jt]s?(x)\"\n  // ],\n\n  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped\n  // testPathIgnorePatterns: [\n  //   \"/node_modules/\"\n  // ],\n\n  // The regexp pattern or array of patterns that Jest uses to detect test files\n  // testRegex: [],\n\n  // This option allows the use of a custom results processor\n  // testResultsProcessor: undefined,\n\n  // This option allows use of a custom test runner\n  // testRunner: \"jest-circus/runner\",\n\n  // A map from regular expressions to paths to transformers\n  // transform: undefined,\n\n  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation\n  // transformIgnorePatterns: [\n  //   \"/node_modules/\",\n  //   \"\\\\\\\\.pnp\\\\\\\\.[^\\\\\\\\/]+$\"\n  // ],\n\n  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them\n  // unmockedModulePathPatterns: undefined,\n\n  // Indicates whether each individual test should be reported during the run\n  // verbose: undefined,\n\n  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode\n  // watchPathIgnorePatterns: [],\n\n  // Whether to use watchman for file crawling\n  // watchman: true,\n};\n\nmodule.exports = config;\n\"\n`;\n\nexports[`init project with package.json and no jest config some questions answered with answer: \"Yes\" should create package.json with configured test command when {scripts: true} 1`] = `\n\"{\n  \"name\": \"only_package_json\",\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport {\n  cleanup,\n  createEmptyPackage,\n  extractSummary,\n  writeFiles,\n} from '../Utils';\nimport {json as runJest} from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'injectGlobalVariables.test');\nconst TEST_DIR = path.resolve(DIR, '__tests__');\n\nskipSuiteOnJasmine();\n\nbeforeEach(() => {\n  cleanup(DIR);\n  createEmptyPackage(DIR);\n\n  const content = `\n    const {expect: importedExpect, test: importedTest} = require('@jest/globals');\n\n    importedTest('no globals injected', () =>{\n      importedExpect(typeof expect).toBe('undefined');\n      importedExpect(typeof test).toBe('undefined');\n      importedExpect(typeof jest).toBe('undefined');\n      importedExpect(typeof beforeEach).toBe('undefined');\n    });\n  `;\n\n  writeFiles(TEST_DIR, {'test.js': content});\n});\n\nafterAll(() => cleanup(DIR));\n\ntest.each`\n  configSource | args\n  ${'CLI'}     | ${['--inject-globals', 'false']}\n  ${'config'}  | ${['--config', JSON.stringify({injectGlobals: false})]}\n`('globals are undefined if passed `false` from $configSource', ({args}) => {\n  const {json, stderr, exitCode} = runJest(DIR, args);\n\n  const {summary, rest} = extractSummary(stderr);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n  expect(exitCode).toBe(0);\n  expect(json.numPassedTests).toBe(1);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`globals are undefined if passed \\`false\\` from CLI 1`] = `\n\"PASS __tests__/test.js\n  ✓ no globals injected\"\n`;\n\nexports[`globals are undefined if passed \\`false\\` from CLI 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`globals are undefined if passed \\`false\\` from config 1`] = `\n\"PASS __tests__/test.js\n  ✓ no globals injected\"\n`;\n\nexports[`globals are undefined if passed \\`false\\` from config 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"eslint-disable-next-line quotes","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest.failing('inline snapshot not updated', () => {\n  // eslint-disable-next-line quotes\n  expect('1').toMatchInlineSnapshot(`\"1\"`);\n});"}
{"prompt":"foos, async  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport type {Frame} from 'jest-message-util';\nimport {saveInlineSnapshots} from '../InlineSnapshots';\n\nconst prettier = require('prettier') as typeof import('prettier-v2');\n\njest.mock('prettier', () => {\n  const realPrettier =\n    jest.requireActual<typeof import('prettier-v2')>('prettier-v2');\n  const mockPrettier = {\n    format: realPrettier.format,\n    getFileInfo: {\n      sync: () => ({ignored: false, inferredParser: 'babel'}),\n    } as unknown as typeof prettier.getFileInfo,\n    resolveConfig: {\n      sync: jest.fn(),\n    } as unknown as typeof prettier.resolveConfig,\n    version: realPrettier.version,\n  } as typeof prettier;\n  return mockPrettier;\n});\n\nbeforeEach(() => {\n  jest.mocked(prettier.resolveConfig.sync).mockReset();\n});\n\nlet dir: string;\nbeforeEach(() => {\n  dir = path.join(tmpdir(), `jest-inline-snapshot-test-${Date.now()}`);\n  fs.mkdirSync(dir);\n});\n\nafterEach(() => {\n  fs.rmSync(dir, {recursive: true});\n});\n\ntest('saveInlineSnapshots() replaces empty function call with a template literal', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(filename, 'expect(1).toMatchInlineSnapshot();\\n');\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 11, file: filename, line: 1} as Frame,\n        snapshot: '1',\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    'expect(1).toMatchInlineSnapshot(`1`);\\n',\n  );\n});\n\ntest('saveInlineSnapshots() without prettier leaves formatting outside of snapshots alone', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    `${`\nconst a = [1,            2];\nexpect(a).toMatchInlineSnapshot(\\`an out-of-date and also multi-line\nsnapshot\\`);\nexpect(a).toMatchInlineSnapshot();\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\n`.trim()}\\n`,\n  );\n\n  saveInlineSnapshots(\n    [2, 4, 5].map(line => ({\n      frame: {column: 11, file: filename, line} as Frame,\n      snapshot: '[1, 2]',\n    })),\n    dir,\n    null,\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    `const a = [1,            2];\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\n`,\n  );\n});\n\ntest('saveInlineSnapshots() with bad prettier path leaves formatting outside of snapshots alone', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    `${`\nconst a = [1,            2];\nexpect(a).toMatchInlineSnapshot(\\`an out-of-date and also multi-line\nsnapshot\\`);\nexpect(a).toMatchInlineSnapshot();\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\n`.trim()}\\n`,\n  );\n\n  saveInlineSnapshots(\n    [2, 4, 5].map(line => ({\n      frame: {column: 11, file: filename, line} as Frame,\n      snapshot: '[1, 2]',\n    })),\n    dir,\n    'bad-prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    `const a = [1,            2];\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\n`,\n  );\n});\n\ntest.each([['ts'], ['cts'], ['mts']])(\n  'saveInlineSnapshots() can handle typescript without prettier - %s extension',\n  extension => {\n    const filename = path.join(dir, `my.test.${extension}`);\n    fs.writeFileSync(\n      filename,\n      `${`\ninterface Foo {\n  foo: string\n}\nconst a: [Foo, Foo] = [{ foo: 'one' },            { foo: 'two' }];\nexpect(a).toMatchInlineSnapshot();\n`.trim()}\\n`,\n    );\n\n    saveInlineSnapshots(\n      [\n        {\n          frame: {column: 11, file: filename, line: 5} as Frame,\n          snapshot: \"[{ foo: 'one' }, { foo: 'two' }]\",\n        },\n      ],\n      dir,\n      null,\n    );\n\n    expect(fs.readFileSync(filename, 'utf8')).toBe(\n      `${`\ninterface Foo {\n  foo: string\n}\nconst a: [Foo, Foo] = [{ foo: 'one' },            { foo: 'two' }];\nexpect(a).toMatchInlineSnapshot(\\`[{ foo: 'one' }, { foo: 'two' }]\\`);\n`.trim()}\\n`,\n    );\n  },\n);\n\ntest('saveInlineSnapshots() can handle tsx without prettier', () => {\n  const filename = path.join(dir, 'my.test.tsx');\n  fs.writeFileSync(\n    filename,\n    `${`\nit('foos', async () => {\n  const Foo = (props: { foo: string }) => <div>{props.foo}</div>;\n  const a = await Foo({ foo: \"hello\" });\n  expect(a).toMatchInlineSnapshot();\n})\n`.trim()}\\n`,\n  );\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 13, file: filename, line: 4} as Frame,\n        snapshot: '<div>hello</div>',\n      },\n    ],\n    dir,\n    null,\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    `${`\nit('foos', async () => {\n  const Foo = (props: { foo: string }) => <div>{props.foo}</div>;\n  const a = await Foo({ foo: \"hello\" });\n  expect(a).toMatchInlineSnapshot(\\`<div>hello</div>\\`);\n})\n`.trim()}\\n`,\n  );\n});\n\ntest('saveInlineSnapshots() can handle flow and jsx without prettier', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    `${`\nconst Foo = (props: { foo: string }) => <div>{props.foo}</div>;\nconst a = Foo({ foo: \"hello\" });\nexpect(a).toMatchInlineSnapshot();\n`.trim()}\\n`,\n  );\n  fs.writeFileSync(\n    path.join(dir, '.babelrc'),\n    JSON.stringify({\n      presets: [\n        require.resolve('@babel/preset-flow'),\n        require.resolve('@babel/preset-react'),\n      ],\n    }),\n  );\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 11, file: filename, line: 3} as Frame,\n        snapshot: '<div>hello</div>',\n      },\n    ],\n    dir,\n    null,\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    `${`\nconst Foo = (props: { foo: string }) => <div>{props.foo}</div>;\nconst a = Foo({ foo: \"hello\" });\nexpect(a).toMatchInlineSnapshot(\\`<div>hello</div>\\`);\n`.trim()}\\n`,\n  );\n});\n\ntest('saveInlineSnapshots() can use prettier to fix formatting for whole file', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    `${`\nconst a = [1,            2];\nexpect(a).toMatchInlineSnapshot(\\`an out-of-date and also multi-line\nsnapshot\\`);\nexpect(a).toMatchInlineSnapshot();\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\n`.trim()}\\n`,\n  );\n\n  saveInlineSnapshots(\n    [2, 4, 5].map(line => ({\n      frame: {column: 11, file: filename, line} as Frame,\n      snapshot: '[1, 2]',\n    })),\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    `const a = [1, 2];\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\nexpect(a).toMatchInlineSnapshot(\\`[1, 2]\\`);\n`,\n  );\n});\n\ntest.each([['babel'], ['flow'], ['typescript']])(\n  'saveInlineSnapshots() replaces existing template literal - %s parser',\n  parser => {\n    const filename = path.join(dir, 'my.test.js');\n    fs.writeFileSync(filename, 'expect(1).toMatchInlineSnapshot(`2`);\\n');\n\n    jest.mocked(prettier.resolveConfig.sync).mockReturnValue({parser});\n\n    saveInlineSnapshots(\n      [\n        {\n          frame: {column: 11, file: filename, line: 1} as Frame,\n          snapshot: '1',\n        },\n      ],\n      dir,\n      'prettier',\n    );\n\n    expect(\n      jest.mocked(prettier.resolveConfig.sync).mock.results[0].value,\n    ).toEqual({parser});\n\n    expect(fs.readFileSync(filename, 'utf8')).toBe(\n      'expect(1).toMatchInlineSnapshot(`1`);\\n',\n    );\n  },\n);\n\ntest('saveInlineSnapshots() replaces existing template literal with property matchers', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(filename, 'expect(1).toMatchInlineSnapshot({}, `2`);\\n');\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 11, file: filename, line: 1} as Frame,\n        snapshot: '1',\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    'expect(1).toMatchInlineSnapshot({}, `1`);\\n',\n  );\n});\n\ntest.each(['prettier', null])(\n  'saveInlineSnapshots() creates template literal with property matchers',\n  prettierModule => {\n    const filename = path.join(dir, 'my.test.js');\n    fs.writeFileSync(filename, 'expect(1).toMatchInlineSnapshot({});\\n');\n\n    saveInlineSnapshots(\n      [\n        {\n          frame: {column: 11, file: filename, line: 1} as Frame,\n          snapshot: '1',\n        },\n      ],\n      dir,\n      prettierModule,\n    );\n\n    expect(fs.readFileSync(filename, 'utf8')).toBe(\n      'expect(1).toMatchInlineSnapshot({}, `1`);\\n',\n    );\n  },\n);\n\ntest('saveInlineSnapshots() throws if frame does not match', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(filename, 'expect(1).toMatchInlineSnapshot();\\n');\n\n  const save = () =>\n    saveInlineSnapshots(\n      [\n        {\n          frame: {\n            column: 2 /* incorrect */,\n            file: filename,\n            line: 1,\n          } as Frame,\n          snapshot: '1',\n        },\n      ],\n      dir,\n      'prettier',\n    );\n\n  expect(save).toThrow(/Couldn't locate all inline snapshots./);\n});\n\ntest('saveInlineSnapshots() throws if multiple calls to to the same location', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(filename, 'expect(1).toMatchInlineSnapshot();\\n');\n\n  const frame = {column: 11, file: filename, line: 1} as Frame;\n  const save = () =>\n    saveInlineSnapshots(\n      [\n        {frame, snapshot: '1'},\n        {frame, snapshot: '2'},\n      ],\n      dir,\n      'prettier',\n    );\n\n  expect(save).toThrow(\n    /Multiple inline snapshots for the same call are not supported./,\n  );\n});\n\ntest('saveInlineSnapshots() uses escaped backticks', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(filename, 'expect(\"`\").toMatchInlineSnapshot();\\n');\n\n  const frame = {column: 13, file: filename, line: 1} as Frame;\n  saveInlineSnapshots([{frame, snapshot: '`'}], dir, 'prettier');\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    'expect(\"`\").toMatchInlineSnapshot(`\\\\``);\\n',\n  );\n});\n\ntest('saveInlineSnapshots() works with non-literals in expect call', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(filename, \"expect({a: 'a'}).toMatchInlineSnapshot();\\n\");\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 18, file: filename, line: 1} as Frame,\n        snapshot: \"{a: 'a'}\",\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"expect({a: 'a'}).toMatchInlineSnapshot(`{a: 'a'}`);\\n\",\n  );\n});\n\ntest('saveInlineSnapshots() indents multi-line snapshots with spaces', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    \"it('is a test', () => {\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot();\\n\" +\n      '});\\n',\n  );\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 20, file: filename, line: 2} as Frame,\n        snapshot: \"\\nObject {\\n  a: 'a'\\n}\\n\",\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"it('is a test', () => {\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot(`\\n\" +\n      '    Object {\\n' +\n      \"      a: 'a'\\n\" +\n      '    }\\n' +\n      '  `);\\n' +\n      '});\\n',\n  );\n});\n\ntest('saveInlineSnapshots() does not re-indent error snapshots', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    \"it('is an error test', () => {\\n\" +\n      '  expect(() => {\\n' +\n      \"    throw new Error(['a', 'b'].join('\\\\n'));\\n\" +\n      '  }).toThrowErrorMatchingInlineSnapshot(`\\n' +\n      '    \"a\\n' +\n      '    b\"\\n' +\n      '  `);\\n' +\n      '});\\n' +\n      \"it('is another test', () => {\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot();\\n\" +\n      '});\\n',\n  );\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 20, file: filename, line: 10} as Frame,\n        snapshot: \"\\nObject {\\n  a: 'a'\\n}\\n\",\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"it('is an error test', () => {\\n\" +\n      '  expect(() => {\\n' +\n      \"    throw new Error(['a', 'b'].join('\\\\n'));\\n\" +\n      '  }).toThrowErrorMatchingInlineSnapshot(`\\n' +\n      '    \"a\\n' +\n      '    b\"\\n' +\n      '  `);\\n' +\n      '});\\n' +\n      \"it('is another test', () => {\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot(`\\n\" +\n      '    Object {\\n' +\n      \"      a: 'a'\\n\" +\n      '    }\\n' +\n      '  `);\\n' +\n      '});\\n',\n  );\n});\n\ntest('saveInlineSnapshots() does not re-indent already indented snapshots', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    \"it('is a test', () => {\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot();\\n\" +\n      '});\\n' +\n      \"it('is a another test', () => {\\n\" +\n      \"  expect({b: 'b'}).toMatchInlineSnapshot(`\\n\" +\n      '    Object {\\n' +\n      \"      b: 'b'\\n\" +\n      '    }\\n' +\n      '  `);\\n' +\n      '});\\n',\n  );\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 20, file: filename, line: 2} as Frame,\n        snapshot: \"\\nObject {\\n  a: 'a'\\n}\\n\",\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"it('is a test', () => {\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot(`\\n\" +\n      '    Object {\\n' +\n      \"      a: 'a'\\n\" +\n      '    }\\n' +\n      '  `);\\n' +\n      '});\\n' +\n      \"it('is a another test', () => {\\n\" +\n      \"  expect({b: 'b'}).toMatchInlineSnapshot(`\\n\" +\n      '    Object {\\n' +\n      \"      b: 'b'\\n\" +\n      '    }\\n' +\n      '  `);\\n' +\n      '});\\n',\n  );\n});\n\ntest('saveInlineSnapshots() indents multi-line snapshots with tabs', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    \"it('is a test', () => {\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot();\\n\" +\n      '});\\n',\n  );\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n    useTabs: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 20, file: filename, line: 2} as Frame,\n        snapshot: \"\\nObject {\\n  a: 'a'\\n}\\n\",\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"it('is a test', () => {\\n\" +\n      \"\\texpect({a: 'a'}).toMatchInlineSnapshot(`\\n\" +\n      '\\t\\tObject {\\n' +\n      \"\\t\\t  a: 'a'\\n\" +\n      '\\t\\t}\\n' +\n      '\\t`);\\n' +\n      '});\\n',\n  );\n});\n\ntest('saveInlineSnapshots() indents snapshots after prettier reformats', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    \"it('is a test', () => expect({a: 'a'}).toMatchInlineSnapshot());\\n\",\n  );\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 40, file: filename, line: 1} as Frame,\n        snapshot: \"\\nObject {\\n  a: 'a'\\n}\\n\",\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"it('is a test', () =>\\n\" +\n      \"  expect({a: 'a'}).toMatchInlineSnapshot(`\\n\" +\n      '    Object {\\n' +\n      \"      a: 'a'\\n\" +\n      '    }\\n' +\n      '  `));\\n',\n  );\n});\n\ntest('saveInlineSnapshots() does not indent empty lines', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    \"it('is a test', () => expect(`hello\\n\\nworld`).toMatchInlineSnapshot());\\n\",\n  );\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 9, file: filename, line: 3} as Frame,\n        snapshot: '\\nhello\\n\\nworld\\n',\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"it('is a test', () =>\\n\" +\n      '  expect(`hello\\n\\nworld`).toMatchInlineSnapshot(`\\n' +\n      '    hello\\n' +\n      '\\n' +\n      '    world\\n' +\n      '  `));\\n',\n  );\n});\n\ntest('saveInlineSnapshots() indents awaited snapshots with spaces', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    \"it('is a test', async () => {\\n\" +\n      \"  const a = Promise.resolve({a: 'a'});\\n\" +\n      '  await expect(a).resolves.toMatchInlineSnapshot();\\n' +\n      '});\\n',\n  );\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    bracketSpacing: false,\n    singleQuote: true,\n  });\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 28, file: filename, line: 3} as Frame,\n        snapshot: \"\\nObject {\\n  a: 'a'\\n}\\n\",\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    \"it('is a test', async () => {\\n\" +\n      \"  const a = Promise.resolve({a: 'a'});\\n\" +\n      '  await expect(a).resolves.toMatchInlineSnapshot(`\\n' +\n      '    Object {\\n' +\n      \"      a: 'a'\\n\" +\n      '    }\\n' +\n      '  `);\\n' +\n      '});\\n',\n  );\n});\n\ntest('saveInlineSnapshots() prioritize parser from project/editor configuration', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(\n    filename,\n    'const foo = {\\n' +\n      '  \"1\": \"Some value\",\\n' +\n      '};\\n' +\n      'test(\"something\", () => {\\n' +\n      '  expect(\"a\").toMatchInlineSnapshot();\\n' +\n      '});\\n',\n  );\n\n  jest.mocked(prettier.resolveConfig.sync).mockReturnValue({\n    parser: 'flow',\n  });\n\n  const prettierSpy = jest.spyOn(prettier.getFileInfo, 'sync');\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 15, file: filename, line: 5} as Frame,\n        snapshot: 'a',\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(prettierSpy).not.toHaveBeenCalled();\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    'const foo = {\\n' +\n      '  \"1\": \"Some value\",\\n' +\n      '};\\n' +\n      'test(\"something\", () => {\\n' +\n      '  expect(\"a\").toMatchInlineSnapshot(`a`);\\n' +\n      '});\\n',\n  );\n});\n\ntest('saveInlineSnapshots() replaces string literal, not just template literal', () => {\n  const filename = path.join(dir, 'my.test.js');\n  fs.writeFileSync(filename, 'expect(\"a\").toMatchInlineSnapshot(\"b\");\\n');\n\n  saveInlineSnapshots(\n    [\n      {\n        frame: {column: 13, file: filename, line: 1} as Frame,\n        snapshot: 'a',\n      },\n    ],\n    dir,\n    'prettier',\n  );\n\n  expect(fs.readFileSync(filename, 'utf8')).toBe(\n    'expect(\"a\").toMatchInlineSnapshot(`a`);\\n',\n  );\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nconst impl = require('module-needing-parent');\n\nmodule.exports = impl;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('something', () => {\n  setTimeout(() => {}, 30_000);\n  expect(true).toBe(true);\n});"}
{"prompt":"returns the passed object,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {createContext, runInContext} from 'vm';\n\ndeclare global {\n  function DTRACE_NET_SERVER_CONNECTION(): unknown;\n}\n\nconst fake = jest.fn();\nglobalThis.DTRACE_NET_SERVER_CONNECTION = fake;\n\nlet installCommonGlobals: typeof import('../installCommonGlobals').default;\n\nfunction getGlobal(): typeof globalThis {\n  return runInContext('this', createContext()) as typeof globalThis;\n}\n\nbeforeEach(() => {\n  installCommonGlobals = (\n    require('../installCommonGlobals') as typeof import('../installCommonGlobals')\n  ).default;\n});\n\nafterEach(() => {\n  jest.clearAllMocks();\n  jest.resetModules();\n});\n\nit('returns the passed object', () => {\n  const myGlobal = getGlobal();\n\n  expect(installCommonGlobals(myGlobal, {})).toBe(myGlobal);\n});\n\nit('turns a V8 global object into a Node global object', () => {\n  const myGlobal = installCommonGlobals(getGlobal(), {});\n\n  expect(myGlobal.process).toBeDefined();\n  expect(myGlobal.DTRACE_NET_SERVER_CONNECTION).toBeDefined();\n  expect(myGlobal.DTRACE_NET_SERVER_CONNECTION).not.toBe(fake);\n\n  myGlobal.DTRACE_NET_SERVER_CONNECTION();\n\n  expect(fake).toHaveBeenCalledTimes(1);\n});"}
{"prompt":"instruments files, async  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as os from 'os';\nimport * as path from 'path';\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport {createScriptTransformer} from '@jest/transform';\n\njest.mock('vm');\n\nconst FILE_PATH_TO_INSTRUMENT = path.resolve(\n  __dirname,\n  './module_dir/to_be_instrumented.js',\n);\n\nit('instruments files', async () => {\n  const config = makeProjectConfig({\n    cache: false,\n    cacheDirectory: os.tmpdir(),\n    cwd: __dirname,\n    rootDir: __dirname,\n  });\n  const scriptTransformer = await createScriptTransformer(config);\n\n  const instrumented = scriptTransformer.transform(FILE_PATH_TO_INSTRUMENT, {\n    ...makeGlobalConfig({collectCoverage: true}),\n    changedFiles: undefined,\n  });\n  // We can't really snapshot the resulting coverage, because it depends on\n  // absolute path of the file, which will be different on different\n  // machines\n  expect(instrumented.code).toMatch('gcv = \"__coverage__\"');\n});"}
{"prompt":"The virtual mock call below will be hoisted above this require call.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nimport React from 'react';\nimport Mocked from '../__test_modules__/Mocked';\nimport Unmocked from '../__test_modules__/Unmocked';\nimport a from '../__test_modules__/a';\nimport b from '../__test_modules__/b';\nimport c from '../__test_modules__/c';\nimport d from '../__test_modules__/d';\nimport f from '../__test_modules__/f';\nimport jestBackticks from '../__test_modules__/jestBackticks';\n// The virtual mock call below will be hoisted above this `require` call.\nconst virtualModule = require('virtual-module');\n\n// These will all be hoisted above imports\njest.unmock('react');\njest.deepUnmock('../__test_modules__/Unmocked');\njest.unmock('../__test_modules__/c').unmock('../__test_modules__/d');\n\nlet e;\n(function () {\n  const _getJestObj = 42;\n  e = require('../__test_modules__/e').default;\n  // hoisted to the top of the function scope\n  jest.unmock('../__test_modules__/e');\n})();\n\njest.mock('../__test_modules__/f', () => {\n  if (!globalThis.CALLS) {\n    globalThis.CALLS = 0;\n  }\n  globalThis.CALLS++;\n\n  return {\n    _isMock: true,\n    fn: () => {\n      // The `jest.mock` transform will allow require, built-ins and globals.\n      const path = require('path');\n      const array = Array.from({length: 3});\n      array[0] = path.sep;\n      return jest.fn(() => array);\n    },\n  };\n});\n// uses backticks on purpose\n// eslint-disable-next-line quotes\njest.mock(`../__test_modules__/jestBackticks`);\njest.mock('virtual-module', () => 'kiwi', {virtual: true});\n// This has types that should be ignored by the out-of-scope variables check.\njest.mock('has-flow-types', () => (props: {children: unknown}) => 3, {\n  virtual: true,\n});\n\n// These will not be hoisted\njest.unmock('../__test_modules__/a').dontMock('../__test_modules__/b');\n// eslint-disable-next-line no-useless-concat\njest.unmock('../__test_modules__/' + 'a');\njest.dontMock('../__test_modules__/Mocked');\n{\n  const jest = {unmock: () => {}};\n  // Would error (used before initialization) if hoisted to the top of the scope\n  jest.unmock('../__test_modules__/a');\n}\n\n// This must not throw an error\nconst myObject = {mock: () => {}};\nmyObject.mock('apple', 27);\n\n// Variable names prefixed with `mock` (ignore case) should not throw as out-of-scope\nconst MockMethods = () => {};\njest.mock('../__test_modules__/g', () => MockMethods);\n\ndescribe('babel-plugin-jest-hoist', () => {\n  it('does not throw during transform', () => {\n    const object = {};\n    object.__defineGetter__('foo', () => 'bar');\n    expect(object.foo).toBe('bar');\n  });\n\n  it('hoists react unmock call before imports', () => {\n    expect(typeof React).toBe('object');\n    expect(React.isValidElement.mock).toBeUndefined();\n  });\n\n  it('hoists unmocked modules before imports', () => {\n    expect(Unmocked._isMockFunction).toBeUndefined();\n    expect(new Unmocked().isUnmocked).toBe(true);\n\n    expect(c._isMockFunction).toBeUndefined();\n    expect(c()).toBe('unmocked');\n\n    expect(d._isMockFunction).toBeUndefined();\n    expect(d()).toBe('unmocked');\n\n    expect(e._isMock).toBeUndefined();\n    expect(e()).toBe('unmocked');\n  });\n\n  it('hoists mock call with 2 arguments', () => {\n    const path = require('path');\n\n    expect(f._isMock).toBe(true);\n\n    const mockFn = f.fn();\n    expect(mockFn()).toEqual([path.sep, undefined, undefined]);\n  });\n\n  it('only executes the module factories once', () => {\n    jest.resetModules();\n\n    globalThis.CALLS = 0;\n\n    require('../__test_modules__/f');\n    expect(globalThis.CALLS).toBe(1);\n\n    require('../__test_modules__/f');\n    expect(globalThis.CALLS).toBe(1);\n\n    delete globalThis.CALLS;\n  });\n\n  it('does not hoist dontMock calls before imports', () => {\n    expect(Mocked._isMockFunction).toBe(true);\n    expect(new Mocked().isMocked).toBeUndefined();\n\n    expect(a._isMockFunction).toBe(true);\n    expect(a()).toBeUndefined();\n\n    expect(b._isMockFunction).toBe(true);\n    expect(b()).toBeUndefined();\n  });\n\n  it('requires modules that also call jest.mock', () => {\n    require('../mockFile');\n    const mock = require('../banana');\n    expect(mock).toBe('apple');\n  });\n\n  it('works with virtual modules', () => {\n    expect(virtualModule).toBe('kiwi');\n  });\n\n  it('works if the file name is mocked via backticks and defined in the \"__mocks__\" directory', () => {\n    expect(jestBackticks.name).toBe('backticks-with-jest');\n  });\n});"}
{"prompt":"These will all be hoisted above imports","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nimport a from '../__test_modules__/a';\nimport b from '../__test_modules__/b';\n\n// These will all be hoisted above imports\njest.disableAutomock();\njest.mock('../__test_modules__/b');\n\ndescribe('babel-plugin-jest-hoist', () => {\n  it('hoists disableAutomock call before imports', () => {\n    expect(a._isMockFunction).toBeUndefined();\n  });\n\n  it('hoists mock call before imports', () => {\n    expect(b._isMockFunction).toBe(true);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports = () => 'internal-module-code';"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports = () => 'internal-module-data';"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports = require('./internal-module');"}
{"prompt":"Test generated from existing file","test":"{\n  \"foo\": \"bar\"\n}"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.\n\n/**\n * Sample React Native Snapshot Test\n */\n\nimport React from 'react';\nimport {ActivityIndicator, FlatList, Text, TextInput} from 'react-native';\nimport renderer from 'react-test-renderer';\nimport Intro from '../Intro';\n\njest.setTimeout(15_000);\n\nit('renders correctly', () => {\n  const tree = renderer.create(<Intro />).toJSON();\n  expect(tree).toMatchSnapshot();\n});\n\n// These serve as integration tests for the jest-react-native preset.\nit('renders the ActivityIndicator component', () => {\n  const tree = renderer\n    .create(<ActivityIndicator animating={true} size=\"small\" />)\n    .toJSON();\n  expect(tree).toMatchSnapshot();\n});\n\nit('renders the TextInput component', () => {\n  const tree = renderer\n    .create(<TextInput autoCorrect={false} value=\"apple banana kiwi\" />)\n    .toJSON();\n  expect(tree).toMatchSnapshot();\n});\n\nit('renders the FlatList component', () => {\n  const tree = renderer\n    .create(\n      <FlatList\n        data={['apple', 'banana', 'kiwi']}\n        keyExtractor={item => item}\n        renderItem={({item}) => <Text>{item}</Text>}\n      />,\n    )\n    .toJSON();\n  expect(tree).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`renders correctly 1`] = `\n<View\n  style={\n    {\n      \"alignItems\": \"center\",\n      \"backgroundColor\": \"#F5FCFF\",\n      \"flex\": 1,\n      \"justifyContent\": \"center\",\n    }\n  }\n>\n  <Text\n    style={\n      {\n        \"fontSize\": 20,\n        \"margin\": 10,\n        \"textAlign\": \"center\",\n      }\n    }\n  >\n    Welcome to React Native!\n  </Text>\n  <Text\n    style={\n      {\n        \"color\": \"#333333\",\n        \"marginBottom\": 5,\n        \"textAlign\": \"center\",\n      }\n    }\n  >\n    This is a React Native snapshot test.\n  </Text>\n</View>\n`;\n\nexports[`renders the ActivityIndicator component 1`] = `\n<ActivityIndicator\n  animating={true}\n  size=\"small\"\n/>\n`;\n\nexports[`renders the FlatList component 1`] = `\n<RCTScrollView\n  data={\n    [\n      \"apple\",\n      \"banana\",\n      \"kiwi\",\n    ]\n  }\n  getItem={[Function]}\n  getItemCount={[Function]}\n  keyExtractor={[Function]}\n  onContentSizeChange={[Function]}\n  onLayout={[Function]}\n  onMomentumScrollBegin={[Function]}\n  onMomentumScrollEnd={[Function]}\n  onScroll={[Function]}\n  onScrollBeginDrag={[Function]}\n  onScrollEndDrag={[Function]}\n  removeClippedSubviews={false}\n  renderItem={[Function]}\n  scrollEventThrottle={0.0001}\n  stickyHeaderIndices={[]}\n  viewabilityConfigCallbackPairs={[]}\n>\n  <View>\n    <View\n      onFocusCapture={[Function]}\n      onLayout={[Function]}\n      style={null}\n    >\n      <Text>\n        apple\n      </Text>\n    </View>\n    <View\n      onFocusCapture={[Function]}\n      onLayout={[Function]}\n      style={null}\n    >\n      <Text>\n        banana\n      </Text>\n    </View>\n    <View\n      onFocusCapture={[Function]}\n      onLayout={[Function]}\n      style={null}\n    >\n      <Text>\n        kiwi\n      </Text>\n    </View>\n  </View>\n</RCTScrollView>\n`;\n\nexports[`renders the TextInput component 1`] = `\n<TextInput\n  autoCorrect={false}\n  value=\"apple banana kiwi\"\n/>\n`;"}
{"prompt":"isBuiltinModule,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport isBuiltinModule from '../isBuiltinModule';\n\ndescribe('isBuiltinModule', () => {\n  it('should return true for the `path` module', () => {\n    expect(isBuiltinModule('path')).toBe(true);\n  });\n\n  it('should return false for the `chalk` module', () => {\n    expect(isBuiltinModule('chalk')).toBe(false);\n  });\n\n  it('should return true for the `_http_common` module', () => {\n    expect(isBuiltinModule('_http_common')).toBe(true);\n  });\n\n  it('should return false for any internal node builtins', () => {\n    expect(isBuiltinModule('internal/http')).toBe(false);\n  });\n});"}
{"prompt":"/ <reference lib=dom />","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n/// <reference lib=\"dom\" />\n\nimport {isError} from '../utils';\n\n// Copied from https://github.com/graingert/angular.js/blob/a43574052e9775cbc1d7dd8a086752c979b0f020/test/AngularSpec.js#L1883\ndescribe('isError', () => {\n  function testErrorFromDifferentContext(\n    createError: (win: Window | typeof globalThis) => Error | null,\n  ) {\n    const iframe = document.createElement('iframe');\n    document.body.append(iframe);\n    try {\n      const contentWindow = iframe.contentWindow;\n\n      expect(contentWindow).toBeTruthy();\n\n      if (!contentWindow) {\n        throw new Error('Dead code');\n      }\n\n      const error = createError(contentWindow);\n      expect(isError(error)).toBe(true);\n    } finally {\n      iframe.remove();\n    }\n  }\n\n  it('should not assume objects are errors', () => {\n    const fakeError = {message: 'A fake error', stack: 'no stack here'};\n    expect(isError(fakeError)).toBe(false);\n  });\n\n  it('should detect simple error instances', () => {\n    expect(isError(new Error())).toBe(true);\n  });\n\n  it('should detect errors from another context', () => {\n    testErrorFromDifferentContext(\n      win => new (win as typeof globalThis).Error(),\n    );\n  });\n\n  it('should detect DOMException errors from another context', () => {\n    testErrorFromDifferentContext(win => {\n      try {\n        win.document.querySelectorAll('');\n      } catch (error) {\n        return error as Error;\n      }\n\n      return null;\n    });\n  });\n});"}
{"prompt":"Returns true when running in an interactive environment,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as process from 'process';\n\nconst oldIsTTY = process.stdout.isTTY;\nconst oldTERM = process.env.TERM;\n\nafterEach(() => {\n  process.stdout.isTTY = oldIsTTY;\n  process.env.TERM = oldTERM;\n  jest.resetModules();\n});\n\nit('Returns true when running in an interactive environment', () => {\n  jest.doMock('ci-info', () => ({isCI: false}));\n  process.stdout.isTTY = true;\n  process.env.TERM = 'xterm-256color';\n\n  const isInteractive = (\n    require('../isInteractive') as typeof import('../isInteractive')\n  ).default;\n\n  expect(isInteractive).toBe(true);\n});\n\nit.each([\n  {isCI: false, isTTY: false, term: 'xterm-256color'},\n  {isCI: false, isTTY: false, term: 'xterm-256color'},\n  {isCI: true, isTTY: true, term: 'xterm-256color'},\n  {isCI: false, isTTY: false, term: 'dumb'},\n])(\n  'Returns false when running in a non-interactive environment',\n  ({isCI, isTTY, term}) => {\n    jest.doMock('ci-info', () => ({isCI}));\n    process.stdout.isTTY = isTTY;\n    process.env.TERM = term;\n\n    const isInteractive = (\n      require('../isInteractive') as typeof import('../isInteractive')\n    ).default;\n\n    expect(isInteractive).toBe(false);\n  },\n);"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, createEmptyPackage, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'isolate-modules.test');\n\nbeforeEach(() => {\n  cleanup(DIR);\n  createEmptyPackage(DIR);\n});\n\nafterAll(() => cleanup(DIR));\n\ntest('works with mocks', () => {\n  writeFiles(DIR, {\n    'config.js': `\n      module.exports.getBoolean = function getBoolean(variableName) {\n        return false;\n      }\n    `,\n    'read.js': `\n      const {getBoolean} = require('./config');\n\n      const value = getBoolean('foo');\n      console.log(\"was \" + value);\n    `,\n    'test.js': `\n      jest.mock('./config');\n      const config = require('./config');\n\n      test('dummy test', () => {\n        const configGetMock = config.getBoolean.mockImplementation(() => {\n          return true;\n        });\n\n        jest.isolateModules(() => {\n          require(\"./read\");\n        });\n\n        expect(configGetMock).toHaveBeenCalledTimes(1);\n      })\n    `,\n  });\n  const {exitCode} = runJest(DIR);\n\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\ntest('runs test with isolate modules async import', () => {\n  const {exitCode, stderr} = runJest('isolate-modules-async', [], {\n    nodeOptions: '--experimental-vm-modules --no-warnings',\n  });\n\n  const {summary} = extractSummary(stderr);\n\n  expect(summary).toMatchSnapshot();\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`runs test with isolate modules async import 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":".isPrimitive,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {isPrimitive} from '..';\n\ndescribe('.isPrimitive()', () => {\n  test.each([\n    null,\n    undefined,\n    100,\n    'hello world',\n    true,\n    Symbol.for('a'),\n    0,\n    Number.NaN,\n    Number.POSITIVE_INFINITY,\n    BigInt(1),\n  ])('returns true when given primitive value of: %s', primitive => {\n    expect(isPrimitive(primitive)).toBe(true);\n  });\n\n  test.each([\n    {},\n    [],\n    () => {},\n    /abc/,\n    new Map(),\n    new Set(),\n    new Date(),\n    Object.create(null),\n  ])('returns false when given non primitive value of: %j', value => {\n    expect(isPrimitive(value)).toBe(false);\n  });\n});"}
{"prompt":"not a Promise: ,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport isPromise from '../isPromise';\n\ndescribe('not a Promise: ', () => {\n  test.each([undefined, null, true, 42, '1337', Symbol(), [], {}])(\n    '%p',\n    value => {\n      expect(isPromise(value)).toBe(false);\n    },\n  );\n});\n\ntest('a resolved Promise', () => {\n  expect(isPromise(Promise.resolve(42))).toBe(true);\n});\n\ntest('a rejected Promise', () => {\n  expect(isPromise(Promise.reject().catch(() => {}))).toBe(true);\n});\n\ntest('a thenable', () => {\n  // eslint-disable-next-line unicorn/no-thenable\n  expect(isPromise({then: () => 'hello'})).toBe(true);\n});\n\ntest('an async function', () => {\n  async function asyncFn() {}\n  expect(isPromise(asyncFn())).toBe(true);\n});"}
{"prompt":"is valid when it is a file inside roots,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {makeGlobalConfig} from '@jest/test-utils';\nimport isValidPath from '../isValidPath';\n\nconst rootDir = path.resolve(path.sep, 'root');\n\nit('is valid when it is a file inside roots', () => {\n  expect(\n    isValidPath(makeGlobalConfig(), path.resolve(rootDir, 'src', 'index.js')),\n  ).toBe(true);\n  expect(\n    isValidPath(\n      makeGlobalConfig(),\n      path.resolve(rootDir, 'src', 'components', 'Link.js'),\n    ),\n  ).toBe(true);\n  expect(\n    isValidPath(\n      makeGlobalConfig(),\n      path.resolve(rootDir, 'src', 'lib', 'something.js'),\n    ),\n  ).toBe(true);\n});\n\nit('is not valid when it is a snapshot file', () => {\n  expect(\n    isValidPath(\n      makeGlobalConfig(),\n      path.resolve(rootDir, 'src', 'index.js.snap'),\n    ),\n  ).toBe(false);\n  expect(\n    isValidPath(\n      makeGlobalConfig(),\n      path.resolve(rootDir, 'src', 'components', 'Link.js.snap'),\n    ),\n  ).toBe(false);\n  expect(\n    isValidPath(\n      makeGlobalConfig(),\n      path.resolve(rootDir, 'src', 'lib', 'something.js.snap'),\n    ),\n  ).toBe(false);\n});\n\nit('is not valid when it is a file in the coverage dir', () => {\n  expect(\n    isValidPath(\n      makeGlobalConfig({rootDir}),\n      path.resolve(rootDir, 'coverage', 'lib', 'index.js'),\n    ),\n  ).toBe(false);\n\n  expect(\n    isValidPath(\n      makeGlobalConfig({coverageDirectory: 'cov-dir'}),\n      path.resolve(rootDir, 'src', 'cov-dir', 'lib', 'index.js'),\n    ),\n  ).toBe(false);\n});"}
{"prompt":"isWatchmanInstalled,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {execFile} from 'child_process';\nimport isWatchmanInstalled from '../isWatchmanInstalled';\n\njest.mock('child_process');\n\ndescribe('isWatchmanInstalled', () => {\n  beforeEach(() => jest.clearAllMocks());\n\n  it('executes watchman --version and returns true on success', async () => {\n    execFile.mockImplementation((file, args, cb) => {\n      expect(file).toBe('watchman');\n      expect(args).toStrictEqual(['--version']);\n      cb(null, {stdout: 'v123'});\n    });\n    expect(await isWatchmanInstalled()).toBe(true);\n    expect(execFile).toHaveBeenCalledWith(\n      'watchman',\n      ['--version'],\n      expect.any(Function),\n    );\n  });\n\n  it('returns false when execFile fails', async () => {\n    execFile.mockImplementation((file, args, cb) => {\n      cb(new Error());\n    });\n    expect(await isWatchmanInstalled()).toBe(false);\n    expect(execFile).toHaveBeenCalled();\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/* eslint-disable no-extend-native */\nArray.prototype[Symbol.iterator] = null;\nString.prototype[Symbol.iterator] = null;\n/* eslint-enable */\n\ntest('modifying global object does not affect test runner', () => {});"}
{"prompt":"iterators,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\ndescribe('iterators', () => {\n  it('works for arrays', () => {\n    const mixedArray = [1, {}, []];\n\n    expect(mixedArray).toEqual(mixedArray);\n    expect([1, 2, 3]).toEqual([1, 2, 3]);\n    expect([1]).not.toEqual([2]);\n    expect([1, 2, 3]).not.toEqual([1, 2]);\n    expect([1, 2, 3]).not.toEqual([1, 2, 3, 4]);\n  });\n\n  it('works for custom iterables', () => {\n    const iterable = {\n      0: 'a',\n      1: 'b',\n      2: 'c',\n      length: 3,\n      [Symbol.iterator]: Array.prototype[Symbol.iterator],\n    };\n    const expectedIterable = {\n      0: 'a',\n      1: 'b',\n      2: 'c',\n      length: 3,\n      [Symbol.iterator]: Array.prototype[Symbol.iterator],\n    };\n    expect(iterable).toEqual(expectedIterable);\n    expect(iterable).not.toEqual(['a', 'b']);\n    expect(iterable).not.toEqual(['a', 'b', 'c']);\n    expect(iterable).not.toEqual(['a', 'b', 'c', 'd']);\n  });\n\n  it('works for Sets', () => {\n    const numbers = [1, 2, 3, 4];\n    const setOfNumbers = new Set(numbers);\n    expect(setOfNumbers).not.toEqual(new Set());\n    expect(setOfNumbers).not.toBe(numbers);\n    expect(setOfNumbers).not.toEqual([1, 2]);\n    expect(setOfNumbers).not.toEqual([1, 2, 3]);\n    expect(setOfNumbers).toEqual(new Set(numbers));\n\n    const nestedSets = new Set([new Set([1, 2])]);\n    expect(nestedSets).not.toEqual(new Set([new Set([1, 4])]));\n    expect(nestedSets).toEqual(new Set([new Set([1, 2])]));\n  });\n\n  it('works for Maps', () => {\n    const keyValuePairs: ReadonlyArray<[string, string]> = [\n      ['key1', 'value1'],\n      ['key2', 'value2'],\n    ];\n    const smallerKeyValuePairs: ReadonlyArray<[string, string]> = [\n      ['key1', 'value1'],\n    ];\n    const biggerKeyValuePairs: ReadonlyArray<[string, string]> = [\n      ['key1', 'value1'],\n      ['key2', 'value2'],\n      ['key3', 'value3'],\n    ];\n    const map = new Map(keyValuePairs);\n    expect(map).not.toEqual(smallerKeyValuePairs);\n    expect(map).not.toEqual(new Map(smallerKeyValuePairs));\n    expect(map).not.toEqual(biggerKeyValuePairs);\n    expect(map).not.toEqual(new Map(biggerKeyValuePairs));\n    expect(map).not.toEqual(keyValuePairs);\n    expect(map).not.toBe(keyValuePairs);\n    expect(map).toEqual(new Map(keyValuePairs));\n  });\n});"}
{"prompt":"test/it error throwing,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\ndescribe('test/it error throwing', () => {\n  it('it throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      it('test1');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });\n  it(\"it throws an error when first argument isn't valid\", () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      it(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });\n  it('it throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      it('test3', 'test3b');\n    }).toThrow(\n      'Invalid second argument, test3b. It must be a callback function.',\n    );\n  });\n  test('test throws error with missing callback function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      test('test4');\n    }).toThrow(\n      'Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.',\n    );\n  });\n  test(\"test throws an error when first argument isn't valid\", () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      test(() => {});\n    }).toThrow(\n      'Invalid first argument, () => {}. It must be a named class, named function, number, or string.',\n    );\n  });\n  test('test throws an error when callback function is not a function', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      test('test6', 'test6b');\n    }).toThrow(\n      'Invalid second argument, test6b. It must be a callback function.',\n    );\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\ntest('global.test', () => {});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\njasmine.addMatchers({\n  theSpanishInquisition: () => ({\n    compare: (actual, expected) => ({\n      message: 'Nobdy expects the Spanish Inquisition!',\n      pass: false,\n    }),\n  }),\n});\n\ntest('jasmine.addMatchers', () => {\n  expect('Anybody').not.theSpanishInquisition();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('jasmine.any', () => {\n  expect({name: 'Jessie'}).toEqual({name: jasmine.any(String)});\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('jasmine.anything', () => {\n  expect({input: ['some', 'stuff']}).toEqual({input: jasmine.anything()});\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('jasmine.arrayContaining', () => {\n  expect(['some', 'stuff']).toEqual(jasmine.arrayContaining(['stuff']));\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('jasmine.createSpy', () => {\n  const mySpy = jasmine.createSpy();\n  mySpy('hello?');\n  expect(mySpy).toHaveBeenCalledWith('hello?');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('jasmine.objectContaining', () => {\n  expect({input: 'trash', output: 'trash'}).toEqual(\n    jasmine.objectContaining({output: 'trash'}),\n  );\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('jasmine.stringMatching', () => {\n  expect('Greetings Earthling!').toEqual(jasmine.stringMatching(/^Greetings/));\n});"}
{"prompt":"async jasmine,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {isJestJasmineRun} from '@jest/test-utils';\nimport runJest, {json as runWithJson} from '../runJest';\n\ndescribe('async jasmine', () => {\n  it('works with beforeAll', () => {\n    const {json} = runWithJson('jasmine-async', ['promiseBeforeAll.test.js']);\n\n    expect(json.numTotalTests).toBe(4);\n    expect(json.numPassedTests).toBe(1);\n    expect(json.numFailedTests).toBe(3);\n    expect(json.numPendingTests).toBe(0);\n\n    const {message} = json.testResults[0];\n    expect(message).toMatch('with failing async');\n    expect(message).toMatch('timeout');\n    expect(message).toMatch('done - with error thrown');\n    expect(message).toMatch('done - with error called back');\n  });\n\n  it('works with beforeEach', () => {\n    const {json} = runWithJson('jasmine-async', ['promiseBeforeEach.test.js']);\n\n    expect(json.numTotalTests).toBe(3);\n    expect(json.numPassedTests).toBe(1);\n    expect(json.numFailedTests).toBe(2);\n    expect(json.numPendingTests).toBe(0);\n\n    const {message} = json.testResults[0];\n    expect(message).toMatch('done - with error thrown');\n    expect(message).toMatch('done - with error called back');\n  });\n\n  it('works with afterAll', () => {\n    const result = runWithJson('jasmine-async', ['promiseAfterAll.test.js']);\n    const {json} = result;\n\n    expect(json.numTotalTests).toBe(2);\n    expect(json.numPassedTests).toBe(2);\n    expect(json.numFailedTests).toBe(0);\n    expect(json.numPendingTests).toBe(0);\n    expect(json.testResults[0].message).toBe('');\n\n    expect(result.stderr.match(/unset flag/g) || []).toHaveLength(1);\n  });\n\n  it('works with afterEach', () => {\n    const {json} = runWithJson('jasmine-async', ['promiseAfterEach.test.js']);\n\n    expect(json.numTotalTests).toBe(2);\n    expect(json.numPassedTests).toBe(2);\n    expect(json.numFailedTests).toBe(0);\n    expect(json.numPendingTests).toBe(0);\n    expect(json.testResults[0].message).toBe('');\n  });\n\n  it('works with fit', () => {\n    const {json} = runWithJson('jasmine-async', ['promiseFit.test.js']);\n\n    expect(json.numTotalTests).toBe(3);\n    expect(json.numPassedTests).toBe(1);\n    expect(json.numFailedTests).toBe(1);\n    expect(json.numPendingTests).toBe(1);\n    expect(json.testResults[0].message).toMatch(/will run and fail/);\n  });\n\n  it('works with xit', () => {\n    const {json} = runWithJson('jasmine-async', ['promiseXit.test.js']);\n\n    expect(json.numTotalTests).toBe(2);\n    expect(json.numPassedTests).toBe(1);\n    expect(json.numFailedTests).toBe(0);\n    expect(json.numPendingTests).toBe(1);\n  });\n\n  it('throws when not a promise is returned', () => {\n    const {json} = runWithJson('jasmine-async', ['returningValues.test.js']);\n\n    expect(json.numTotalTests).toBe(11);\n    expect(json.numPassedTests).toBe(0);\n    expect(json.numFailedTests).toBe(11);\n    expect(json.numPendingTests).toBe(0);\n  });\n\n  it('tests async promise code', () => {\n    const {json} = runWithJson('jasmine-async', ['promiseIt.test.js']);\n    const message = json.testResults[0].message;\n\n    expect(json.numTotalTests).toBe(16);\n    expect(json.numPassedTests).toBe(6);\n    expect(json.numFailedTests).toBe(9);\n\n    expect(message).toMatch('fails if promise is rejected');\n    expect(message).toMatch('works with done.fail');\n    expect(message).toMatch('works with done(error)');\n    expect(message).toMatch('fails if failed expectation with done');\n    expect(message).toMatch('fails if failed expectation with done - async');\n    expect(message).toMatch('fails with thrown error with done - sync');\n    expect(message).toMatch('fails with thrown error with done - async');\n    expect(message).toMatch('fails a sync test');\n    expect(message).toMatch('fails if a custom timeout is exceeded');\n  });\n\n  it('works with concurrent', () => {\n    const {json, stderr} = runWithJson('jasmine-async', ['concurrent.test.js']);\n    expect(json.numTotalTests).toBe(4);\n    expect(json.numPassedTests).toBe(2);\n    expect(json.numFailedTests).toBe(1);\n    expect(json.numPendingTests).toBe(1);\n    expect(json.testResults[0].message).toMatch(/concurrent test fails/);\n    if (!isJestJasmineRun()) {\n      expect(stderr.match(/\\[\\[\\w+]]/g)).toEqual([\n        '[[beforeAll]]',\n        '[[test]]',\n        '[[test]]',\n        '[[test]]',\n        '[[afterAll]]',\n      ]);\n    }\n  });\n\n  it('works with concurrent within a describe block when invoked with testNamePattern', () => {\n    const {json, stderr} = runWithJson('jasmine-async', [\n      '--testNamePattern',\n      'one concurrent test fails',\n      'concurrentWithinDescribe.test.js',\n    ]);\n    expect(json.numTotalTests).toBe(2);\n    expect(json.numPassedTests).toBe(0);\n    expect(json.numFailedTests).toBe(1);\n    expect(json.numPendingTests).toBe(1);\n    expect(json.testResults[0].message).toMatch(/concurrent test fails/);\n    expect(stderr).toMatch(/this is logged \\d/);\n    expect(stderr).not.toMatch(/this is not logged \\d/);\n  });\n\n  it('works with concurrent.each', () => {\n    const {json} = runWithJson('jasmine-async', ['concurrent-each.test.js']);\n    expect(json.numTotalTests).toBe(4);\n    expect(json.numPassedTests).toBe(2);\n    expect(json.numFailedTests).toBe(0);\n    expect(json.numPendingTests).toBe(2);\n  });\n\n  it('works with concurrent.only.each', () => {\n    const {json} = runWithJson('jasmine-async', [\n      'concurrent-only-each.test.js',\n    ]);\n    expect(json.numTotalTests).toBe(4);\n    expect(json.numPassedTests).toBe(2);\n    expect(json.numFailedTests).toBe(0);\n    expect(json.numPendingTests).toBe(2);\n  });\n\n  it(\"doesn't execute more than 5 tests simultaneously\", () => {\n    const {json} = runWithJson('jasmine-async', ['concurrent-many.test.js']);\n    expect(json.numTotalTests).toBe(10);\n    expect(json.numPassedTests).toBe(10);\n    expect(json.numFailedTests).toBe(0);\n    expect(json.numPendingTests).toBe(0);\n  });\n\n  it('async test fails', () => {\n    const result = runWithJson('jasmine-async', ['asyncTestFails.test.js']);\n\n    expect(result.exitCode).toBe(1);\n    expect(result.json.testResults[0].message).toEqual(\n      expect.stringContaining('Received:'),\n    );\n  });\n\n  it('generator test', () => {\n    const result = runJest('jasmine-async', ['generator.test.js']);\n\n    expect(result.exitCode).toBe(0);\n  });\n\n  it('works when another test fails while one is running', () => {\n    const {json} = runWithJson('jasmine-async', [\n      'concurrent-parallel-failure.test.js',\n    ]);\n    expect(json.numTotalTests).toBe(2);\n    expect(json.numPassedTests).toBe(1);\n    expect(json.numFailedTests).toBe(1);\n  });\n});"}
{"prompt":"async jasmine with pending during test,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {skipSuiteOnJestCircus} from '@jest/test-utils';\nimport {json as runWithJson} from '../runJest';\n\ndescribe('async jasmine with pending during test', () => {\n  skipSuiteOnJestCircus();\n\n  it('should be reported as a pending test', () => {\n    const {json} = runWithJson('jasmine-async', ['pendingInPromise.test.js']);\n\n    expect(json.numTotalTests).toBe(1);\n    expect(json.numPassedTests).toBe(0);\n    expect(json.numFailedTests).toBe(0);\n    expect(json.numPendingTests).toBe(1);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"{\n  \"moduleNameMapper\": {\n    \"b\": \"b\"\n  },\n  \"modulePathIgnorePatterns\": [\"b\"],\n  \"setupFiles\": [\"b\"],\n}"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports = {};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport default {};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports = {};"}
{"prompt":"Snapshot the console.loged process.cwd and make sure  stays the same","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {cleanup, extractSummary, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../jest-config-js');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('works with jest.config.js', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': \"test('banana', () => expect(1).toBe(1));\",\n    'jest.config.js': \"module.exports = {testRegex: '.*-banana.js'};\",\n    'package.json': '{}',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false']);\n  const {rest, summary} = extractSummary(stderr);\n  expect(exitCode).toBe(0);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n});\n\ntest('traverses directory tree up until it finds jest.config', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': `\n    const slash = require('slash');\n    test('banana', () => expect(1).toBe(1));\n    test('abc', () => console.log(slash(process.cwd())));\n    `,\n    'jest.config.js': \"module.exports = {testRegex: '.*-banana.js'};\",\n    'package.json': '{}',\n    'some/nested/directory/file.js': '// nothing special',\n  });\n\n  const {stderr, exitCode, stdout} = runJest(\n    path.join(DIR, 'some', 'nested', 'directory'),\n    ['-w=1', '--ci=false'],\n    {skipPkgJsonCheck: true},\n  );\n\n  // Snapshot the console.loged `process.cwd()` and make sure it stays the same\n  expect(stdout.replaceAll(/^\\W+(.*)e2e/gm, '<<REPLACED>>')).toMatchSnapshot();\n\n  const {rest, summary} = extractSummary(stderr);\n  expect(exitCode).toBe(0);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n});\n\ntest('invalid JS in jest.config.js', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': \"test('banana', () => expect(1).toBe(1));\",\n    'jest.config.js': \"module.exports = i'll break this file yo\",\n    'package.json': '{}',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false']);\n  expect(stderr).toMatch('SyntaxError: ');\n  expect(exitCode).toBe(1);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`traverses directory tree up until it finds jest.config 1`] = `\n\"  console.log\n<<REPLACED>>/jest-config-js/some/nested/directory\n\n      at Object.log (__tests__/a-banana.js:3:27)\n\"\n`;\n\nexports[`traverses directory tree up until it finds jest.config 2`] = `\n\"PASS ../../../__tests__/a-banana.js\n  ✓ banana\n  ✓ abc\"\n`;\n\nexports[`traverses directory tree up until it finds jest.config 3`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`works with jest.config.js 1`] = `\n\"PASS __tests__/a-banana.js\n  ✓ banana\"\n`;\n\nexports[`works with jest.config.js 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"Test generated from existing file","test":"{}"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport default {};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport default {};"}
{"prompt":"Snapshot the console.logged process.cwd and make sure  stays the same","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {onNodeVersions} from '@jest/test-utils';\nimport {cleanup, extractSummary, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../jest-config-ts');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('works with jest.config.ts', () => {\n  writeFiles(DIR, {\n    '__tests__/a-giraffe.js': \"test('giraffe', () => expect(1).toBe(1));\",\n    'jest.config.ts':\n      \"export default {testEnvironment: 'jest-environment-node', testRegex: '.*-giraffe.js'};\",\n    'package.json': '{}',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false'], {\n    nodeOptions: '--no-warnings',\n  });\n  const {rest, summary} = extractSummary(stderr);\n  expect(exitCode).toBe(0);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n});\n\ntest('works with tsconfig.json', () => {\n  writeFiles(DIR, {\n    '__tests__/a-giraffe.js': \"test('giraffe', () => expect(1).toBe(1));\",\n    'jest.config.ts':\n      \"export default {testEnvironment: 'jest-environment-node', testRegex: '.*-giraffe.js'};\",\n    'package.json': '{}',\n    'tsconfig.json': '{ \"compilerOptions\": { \"module\": \"esnext\" } }',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false'], {\n    nodeOptions: '--no-warnings',\n  });\n  const {rest, summary} = extractSummary(stderr);\n  expect(exitCode).toBe(0);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n});\n\ntest('traverses directory tree up until it finds jest.config', () => {\n  writeFiles(DIR, {\n    '__tests__/a-giraffe.js': `\n    const slash = require('slash');\n    test('giraffe', () => expect(1).toBe(1));\n    test('abc', () => console.log(slash(process.cwd())));\n    `,\n    'jest.config.ts':\n      \"export default {testEnvironment: 'jest-environment-node', testRegex: '.*-giraffe.js'};\",\n    'package.json': '{}',\n    'some/nested/directory/file.js': '// nothing special',\n  });\n\n  const {stderr, exitCode, stdout} = runJest(\n    path.join(DIR, 'some', 'nested', 'directory'),\n    ['-w=1', '--ci=false'],\n    {nodeOptions: '--no-warnings', skipPkgJsonCheck: true},\n  );\n\n  // Snapshot the console.logged `process.cwd()` and make sure it stays the same\n  expect(\n    stdout\n      .replaceAll(/^\\W+(.*)e2e/gm, '<<REPLACED>>')\n      // slightly different log in node versions >= 23\n      .replace('at Object.log', 'at Object.<anonymous>'),\n  ).toMatchSnapshot();\n\n  const {rest, summary} = extractSummary(stderr);\n  expect(exitCode).toBe(0);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n});\n\nonNodeVersions('<23.6', () => {\n  const jestPath = require.resolve('jest');\n  const jestTypesPath = jestPath.replace(/\\.js$/, '.d.ts');\n  const jestTypesExists = fs.existsSync(jestTypesPath);\n\n  (jestTypesExists ? test : test.skip).each([true, false])(\n    'check the config disabled (skip type check: %p)',\n    skipTypeCheck => {\n      writeFiles(DIR, {\n        '__tests__/a-giraffe.js': \"test('giraffe', () => expect(1).toBe(1));\",\n        'jest.config.ts': `\n        /**@jest-config-loader-options {\"transpileOnly\":${!!skipTypeCheck}}*/\n        import {Config} from 'jest';\n        const config: Config = { testTimeout: \"10000\" };\n        export default config;\n      `,\n        'package.json': '{}',\n      });\n\n      const typeErrorString =\n        \"TS2322: Type 'string' is not assignable to type 'number'.\";\n      const runtimeErrorString = 'Option \"testTimeout\" must be of type:';\n\n      const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false']);\n\n      if (skipTypeCheck) {\n        expect(stderr).not.toMatch(typeErrorString);\n        expect(stderr).toMatch(runtimeErrorString);\n      } else {\n        expect(stderr).toMatch(typeErrorString);\n        expect(stderr).not.toMatch(runtimeErrorString);\n      }\n\n      expect(exitCode).toBe(1);\n    },\n  );\n\n  test('invalid JS in jest.config.ts', () => {\n    writeFiles(DIR, {\n      '__tests__/a-giraffe.js': \"test('giraffe', () => expect(1).toBe(1));\",\n      'jest.config.ts': \"export default i'll break this file yo\",\n      'package.json': '{}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false']);\n    expect(stderr).toMatch('TSError: ⨯ Unable to compile TypeScript:');\n    expect(exitCode).toBe(1);\n  });\n});\n\nonNodeVersions('>=23.6', () => {\n  test('invalid JS in jest.config.ts (node with native TS support)', () => {\n    writeFiles(DIR, {\n      '__tests__/a-giraffe.js': \"test('giraffe', () => expect(1).toBe(1));\",\n      'jest.config.ts': \"export default i'll break this file yo\",\n      'package.json': '{}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false'], {\n      nodeOptions: '--no-warnings',\n    });\n    expect(\n      stderr\n        // Remove the stack trace from the error message\n        .slice(0, Math.max(0, stderr.indexOf('at readConfigFileAndSetRootDir')))\n        .trim()\n        // Replace the path to the config file with a placeholder\n        .replace(\n          /(Error: Jest: Failed to parse the TypeScript config file).*$/m,\n          '$1 <<REPLACED>>',\n        ),\n    ).toMatchSnapshot();\n    expect(exitCode).toBe(1);\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`on node >=23.6 invalid JS in jest.config.ts (node with native TS support) 1`] = `\n\"Error: Jest: Failed to parse the TypeScript config file <<REPLACED>>\n  SyntaxError [ERR_INVALID_TYPESCRIPT_SYNTAX]:   x Expected ';', got 'string literal (ll break this file yo, 'll break this file yo)'\n   ,----\n 1 | export default i'll break this file yo\n   :                 ^^^^^^^^^^^^^^^^^^^^^^\n   \\`----\n  x Unterminated string constant\n   ,----\n 1 | export default i'll break this file yo\n   :                 ^^^^^^^^^^^^^^^^^^^^^^\n   \\`----\"\n`;\n\nexports[`traverses directory tree up until it finds jest.config 1`] = `\n\"  console.log\n<<REPLACED>>/jest-config-ts/some/nested/directory\n\n      at Object.<anonymous> (__tests__/a-giraffe.js:3:27)\n\"\n`;\n\nexports[`traverses directory tree up until it finds jest.config 2`] = `\n\"PASS ../../../__tests__/a-giraffe.js\n  ✓ giraffe\n  ✓ abc\"\n`;\n\nexports[`traverses directory tree up until it finds jest.config 3`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`works with jest.config.ts 1`] = `\n\"PASS __tests__/a-giraffe.js\n  ✓ giraffe\"\n`;\n\nexports[`works with jest.config.ts 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`works with tsconfig.json 1`] = `\n\"PASS __tests__/a-giraffe.js\n  ✓ giraffe\"\n`;\n\nexports[`works with tsconfig.json 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"pushes a hasAssertion error if theres no assertions/errors,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {beforeEach, it} from '@jest/globals';\nimport type {Circus} from '@jest/types';\nimport {eventHandler} from '../jestAdapterInit';\n\nbeforeEach(() => expect.hasAssertions());\n\nit(\"pushes a hasAssertion() error if there's no assertions/errors\", () => {\n  const event: Circus.Event = {\n    name: 'test_done',\n    test: {errors: []} as unknown as Circus.TestEntry,\n  };\n  const beforeLength = event.test.errors.length;\n\n  eventHandler(event);\n\n  expect(event.test.errors).toHaveLength(beforeLength + 1);\n  expect(event.test.errors).toEqual([\n    expect.getState().isExpectingAssertionsError,\n  ]);\n});\n\nit(\"omits hasAssertion() errors if there's already an error\", () => {\n  const errors = [new Error('ruh roh'), new Error('not good')];\n  const event: Circus.Event = {\n    name: 'test_done',\n    test: {errors} as unknown as Circus.TestEntry,\n  };\n  const beforeLength = event.test.errors.length;\n\n  eventHandler(event);\n\n  expect(event.test.errors).toHaveLength(beforeLength);\n  expect(event.test.errors).not.toContain(\n    expect.getState().isExpectingAssertionsError,\n  );\n\n  // Ensure test state is not accidentally leaked by e.g. not calling extractExpectedAssertionsErrors() at all.\n  expect(expect.getState().isExpectingAssertions).toBe(false);\n});"}
{"prompt":"s not possible to match the exact path because it will resolve","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport semver = require('semver');\nimport slash = require('slash');\nimport {findRepos, getChangedFilesForRoots} from 'jest-changed-files';\nimport {\n  cleanup,\n  run,\n  testIfHg,\n  testIfSl,\n  testIfSlAndHg,\n  writeFiles,\n} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'jest-changed-files-test-dir');\n\nconst GIT = 'git -c user.name=jest_test -c user.email=jest_test@test.com';\nconst HG = 'hg --config ui.username=jest_test';\nconst SL = 'sl --config ui.username=jest_test';\n\nconst gitVersionSupportsInitialBranch = (() => {\n  const {stdout} = run(`${GIT} --version`);\n  const gitVersion = stdout.trim();\n\n  const match = gitVersion.match(/^git version (?<version>\\d+\\.\\d+\\.\\d+)/);\n\n  if (match?.groups?.version == null) {\n    throw new Error(`Unable to parse git version from string \"${gitVersion}\"`);\n  }\n\n  const {version} = match.groups;\n\n  return semver.gte(version, '2.28.0');\n})();\n\nconst mainBranchName = gitVersionSupportsInitialBranch ? 'main' : 'master';\n\nfunction gitInit(dir: string) {\n  const initCommand = gitVersionSupportsInitialBranch\n    ? `${GIT} init --initial-branch=${mainBranchName}`\n    : `${GIT} init`;\n\n  run(initCommand, dir);\n}\n\nfunction gitCreateBranch(branchName: string, dir: string) {\n  run(`git branch ${branchName}`, dir);\n}\n\njest.retryTimes(3);\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ntestIfHg('gets hg SCM roots and dedupes them', async () => {\n  writeFiles(DIR, {\n    'first-repo/file1.txt': 'file1',\n    'first-repo/nested-dir/file2.txt': 'file2',\n    'first-repo/nested-dir/second-nested-dir/file3.txt': 'file3',\n    'second-repo/file1.txt': 'file1',\n    'second-repo/nested-dir/file2.txt': 'file2',\n    'second-repo/nested-dir/second-nested-dir/file3.txt': 'file3',\n  });\n\n  run(`${HG} init`, path.resolve(DIR, 'first-repo'));\n  run(`${HG} init`, path.resolve(DIR, 'second-repo'));\n\n  const roots = [\n    '',\n    'first-repo/nested-dir',\n    'first-repo/nested-dir/second-nested-dir',\n    'second-repo/nested-dir',\n    'second-repo/nested-dir/second-nested-dir',\n  ].map(filename => path.resolve(DIR, filename));\n\n  const repos = await findRepos(roots);\n  expect(repos.git.size).toBe(0);\n\n  const hgRepos = [...repos.hg];\n\n  // it's not possible to match the exact path because it will resolve\n  // differently on different platforms.\n  // NOTE: This test can break if you have a .hg repo initialized inside your\n  // os tmp directory.\n  expect(hgRepos).toHaveLength(2);\n  expect(slash(hgRepos[0])).toMatch(\n    /\\/jest-changed-files-test-dir\\/first-repo\\/?$/,\n  );\n  expect(slash(hgRepos[1])).toMatch(\n    /\\/jest-changed-files-test-dir\\/second-repo\\/?$/,\n  );\n});\n\ntest('gets git SCM roots and dedupes them', async () => {\n  writeFiles(DIR, {\n    'first-repo/file1.txt': 'file1',\n    'first-repo/nested-dir/file2.txt': 'file2',\n    'first-repo/nested-dir/second-nested-dir/file3.txt': 'file3',\n    'second-repo/file1.txt': 'file1',\n    'second-repo/nested-dir/file2.txt': 'file2',\n    'second-repo/nested-dir/second-nested-dir/file3.txt': 'file3',\n  });\n\n  gitInit(path.resolve(DIR, 'first-repo'));\n  gitInit(path.resolve(DIR, 'second-repo'));\n\n  const roots = [\n    '',\n    'first-repo/nested-dir',\n    'first-repo/nested-dir/second-nested-dir',\n    'second-repo/nested-dir',\n    'second-repo/nested-dir/second-nested-dir',\n  ].map(filename => path.resolve(DIR, filename));\n\n  const repos = await findRepos(roots);\n  expect(repos.hg.size).toBe(0);\n  const gitRepos = [...repos.git];\n\n  // it's not possible to match the exact path because it will resolve\n  // differently on different platforms.\n  // NOTE: This test can break if you have a .git repo initialized inside your\n  // os tmp directory.\n  expect(gitRepos).toHaveLength(2);\n  expect(slash(gitRepos[0])).toMatch(\n    /\\/jest-changed-files-test-dir\\/first-repo\\/?$/,\n  );\n  expect(slash(gitRepos[1])).toMatch(\n    /\\/jest-changed-files-test-dir\\/second-repo\\/?$/,\n  );\n});\n\ntestIfSlAndHg(\n  'gets mixed git, hg, and sl SCM roots and dedupes them',\n  async () => {\n    writeFiles(DIR, {\n      'first-repo/file1.txt': 'file1',\n      'first-repo/nested-dir/file2.txt': 'file2',\n      'first-repo/nested-dir/second-nested-dir/file3.txt': 'file3',\n      'second-repo/file1.txt': 'file1',\n      'second-repo/nested-dir/file2.txt': 'file2',\n      'second-repo/nested-dir/second-nested-dir/file3.txt': 'file3',\n      'third-repo/file1.txt': 'file1',\n      'third-repo/nested-dir/file2.txt': 'file2',\n      'third-repo/nested-dir/second-nested-dir/file3.txt': 'file3',\n    });\n\n    gitInit(path.resolve(DIR, 'first-repo'));\n    run(`${HG} init`, path.resolve(DIR, 'second-repo'));\n    run(`${SL} init --git`, path.resolve(DIR, 'third-repo'));\n\n    const roots = [\n      '',\n      'first-repo/nested-dir',\n      'first-repo/nested-dir/second-nested-dir',\n      'second-repo/nested-dir',\n      'second-repo/nested-dir/second-nested-dir',\n      'third-repo/nested-dir',\n      'third-repo/nested-dir/second-nested-dir',\n    ].map(filename => path.resolve(DIR, filename));\n\n    const repos = await findRepos(roots);\n    const hgRepos = [...repos.hg];\n    const gitRepos = [...repos.git];\n    const slRepos = [...repos.sl];\n\n    // NOTE: This test can break if you have a .git  or .hg repo initialized\n    // inside your os tmp directory.\n    expect(gitRepos).toHaveLength(1);\n    expect(hgRepos).toHaveLength(1);\n    expect(slRepos).toHaveLength(1);\n    expect(slash(gitRepos[0])).toMatch(\n      /\\/jest-changed-files-test-dir\\/first-repo\\/?$/,\n    );\n    expect(slash(hgRepos[0])).toMatch(\n      /\\/jest-changed-files-test-dir\\/second-repo\\/?$/,\n    );\n    expect(slash(slRepos[0])).toMatch(\n      /\\/jest-changed-files-test-dir\\/third-repo\\/?$/,\n    );\n  },\n);\n\ntest('gets changed files for git', async () => {\n  writeFiles(DIR, {\n    'file1.txt': 'file1',\n    'nested-dir/file2.txt': 'file2',\n    'nested-dir/second-nested-dir/file3.txt': 'file3',\n  });\n\n  gitInit(DIR);\n\n  const roots = [\n    // same first root name with existing branch name makes pitfall that\n    // causes \"ambiguous argument\" git error.\n    'nested-dir',\n    'nested-dir/second-nested-dir',\n    '',\n  ].map(filename => path.resolve(DIR, filename));\n\n  let {changedFiles: files} = await getChangedFilesForRoots(roots, {});\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n    'file2.txt',\n    'file3.txt',\n  ]);\n\n  run(`${GIT} add .`, DIR);\n\n  // Uses multiple `-m` to make the commit message have multiple\n  // paragraphs. This is done to ensure that `changedFiles` only\n  // returns files and not parts of commit messages.\n  run(`${GIT} commit --no-gpg-sign -m \"test\" -m \"extra-line\"`, DIR);\n\n  gitCreateBranch('nested-dir', DIR);\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {}));\n  expect([...files]).toEqual([]);\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {\n    lastCommit: true,\n  }));\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n    'file2.txt',\n    'file3.txt',\n  ]);\n\n  writeFiles(DIR, {\n    'file1.txt': 'modified file1',\n  });\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {}));\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n  ]);\n\n  run(`${GIT} add -A`, DIR);\n\n  // staged files should be included\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {}));\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n  ]);\n\n  run(`${GIT} commit --no-gpg-sign -am \"test2\"`, DIR);\n\n  writeFiles(DIR, {\n    'file4.txt': 'file4',\n  });\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {\n    withAncestor: true,\n  }));\n  // Returns files from current uncommitted state + the last commit\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n    'file4.txt',\n  ]);\n\n  run(`${GIT} add file4.txt`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"test3\"`, DIR);\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {\n    changedSince: 'HEAD^^',\n  }));\n  // Returns files from the last 2 commits\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n    'file4.txt',\n  ]);\n\n  run(`${GIT} checkout HEAD^^ -b feature-branch`, DIR);\n\n  writeFiles(DIR, {\n    'file5.txt': 'file5',\n  });\n  run(`${GIT} add file5.txt`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"test5\"`, DIR);\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {\n    changedSince: mainBranchName,\n  }));\n  // Returns files from this branch but not ones that only exist on mainBranchName\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file5.txt',\n  ]);\n});\n\ntest('monitors only root paths for git', async () => {\n  writeFiles(DIR, {\n    'file1.txt': 'file1',\n    'nested-dir/file2.txt': 'file2',\n    'nested-dir/second-nested-dir/file3.txt': 'file3',\n  });\n\n  gitInit(DIR);\n\n  const roots = [path.resolve(DIR, 'nested-dir')];\n\n  const {changedFiles: files} = await getChangedFilesForRoots(roots, {});\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file2.txt',\n    'file3.txt',\n  ]);\n});\n\nit('does not find changes in files with no diff, for git', async () => {\n  const roots = [path.resolve(DIR)];\n\n  // create an empty file, commit it to \"mainBranchName\"\n  writeFiles(DIR, {'file1.txt': ''});\n  gitInit(DIR);\n  run(`${GIT} add file1.txt`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"initial\"`, DIR);\n\n  // check out a new branch, jestChangedFilesSpecBase, to use later in diff\n  run(`${GIT} checkout -b jestChangedFilesSpecBase`, DIR);\n\n  // check out second branch, jestChangedFilesSpecMod, modify file & commit\n  run(`${GIT} checkout -b jestChangedFilesSpecMod`, DIR);\n  writeFiles(DIR, {\n    'file1.txt': 'modified file1',\n  });\n  run(`${GIT} add file1.txt`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"modified\"`, DIR);\n\n  // still on jestChangedFilesSpecMod branch, \"revert\" back to empty file and commit\n  writeFiles(DIR, {\n    'file1.txt': '',\n  });\n  run(`${GIT} add file1.txt`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"removemod\"`, DIR);\n\n  // check that passing in no changedSince arg doesn't return any unstaged / other changes\n  const {changedFiles: files} = await getChangedFilesForRoots(roots, {});\n  expect([...files]).toEqual([]);\n\n  // check that in diff from `jestChangedFilesSpecBase` branch, no changed files are reported\n  const {changedFiles: filesExplicitBaseBranch} = await getChangedFilesForRoots(\n    roots,\n    {\n      changedSince: 'jestChangedFilesSpecBase',\n    },\n  );\n  expect([...filesExplicitBaseBranch]).toEqual([]);\n});\n\ntest('handles a bad revision for \"changedSince\", for git', async () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    '__tests__/file1.test.js': \"require('../file1'); test('file1', () => {});\",\n    'file1.js': 'module.exports = {}',\n    'package.json': '{}',\n  });\n\n  gitInit(DIR);\n  run(`${GIT} add .`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"first\"`, DIR);\n\n  const {exitCode, stderr} = runJest(DIR, ['--changedSince=^blablabla']);\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toContain('Test suite failed to run');\n  expect(stderr).toContain(\"fatal: bad revision '^blablabla...HEAD'\");\n});\n\ntestIfHg('gets changed files for hg', async () => {\n  // file1.txt is used to make a multi-line commit message\n  // with `hg commit -l file1.txt`.\n  // This is done to ensure that `changedFiles` only returns files\n  // and not parts of commit messages.\n  writeFiles(DIR, {\n    'file1.txt': 'file1\\n\\nextra-line',\n    'nested-dir/file2.txt': 'file2',\n    'nested-dir/second-nested-dir/file3.txt': 'file3',\n  });\n\n  run(`${HG} init`, DIR);\n\n  const roots = ['', 'nested-dir', 'nested-dir/second-nested-dir'].map(\n    filename => path.resolve(DIR, filename),\n  );\n\n  let {changedFiles: files} = await getChangedFilesForRoots(roots, {});\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n    'file2.txt',\n    'file3.txt',\n  ]);\n\n  run(`${HG} add .`, DIR);\n  run(`${HG} commit -l file1.txt`, DIR);\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {}));\n  expect([...files]).toEqual([]);\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {\n    lastCommit: true,\n  }));\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n    'file2.txt',\n    'file3.txt',\n  ]);\n\n  writeFiles(DIR, {\n    'file1.txt': 'modified file1',\n  });\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {}));\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n  ]);\n\n  run(`${HG} commit -m \"test2\"`, DIR);\n\n  writeFiles(DIR, {\n    'file4.txt': 'file4',\n  });\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {\n    withAncestor: true,\n  }));\n  // Returns files from current uncommitted state + the last commit\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n    'file4.txt',\n  ]);\n\n  run(`${HG} add file4.txt`, DIR);\n  run(`${HG} commit -m \"test3\"`, DIR);\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {\n    changedSince: '-3',\n  }));\n  // Returns files from the last 2 commits\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n    'file4.txt',\n  ]);\n\n  run(`${HG} bookmark main`, DIR);\n  // Back up and develop on a different branch\n  run(`${HG} checkout --rev=-2`, DIR);\n\n  writeFiles(DIR, {\n    'file5.txt': 'file5',\n  });\n  run(`${HG} add file5.txt`, DIR);\n  run(`${HG} commit -m \"test4\"`, DIR);\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {\n    changedSince: 'main',\n  }));\n  // Returns files from this branch but not ones that only exist on main\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file5.txt',\n  ]);\n});\n\ntestIfHg('monitors only root paths for hg', async () => {\n  writeFiles(DIR, {\n    'file1.txt': 'file1',\n    'nested-dir/file2.txt': 'file2',\n    'nested-dir/second-nested-dir/file3.txt': 'file3',\n  });\n\n  run(`${HG} init`, DIR);\n\n  const roots = [path.resolve(DIR, 'nested-dir')];\n\n  const {changedFiles: files} = await getChangedFilesForRoots(roots, {});\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file2.txt',\n    'file3.txt',\n  ]);\n});\n\ntestIfHg('handles a bad revision for \"changedSince\", for hg', async () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    '__tests__/file1.test.js': \"require('../file1'); test('file1', () => {});\",\n    'file1.js': 'module.exports = {}',\n    'package.json': '{}',\n  });\n\n  run(`${HG} init`, DIR);\n  run(`${HG} add .`, DIR);\n  run(`${HG} commit -m \"first\"`, DIR);\n\n  const {exitCode, stderr} = runJest(DIR, ['--changedSince=blablabla']);\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toContain('Test suite failed to run');\n  expect(stderr).toContain(\"abort: unknown revision 'blablabla'\");\n});\n\ntestIfSl('gets sl SCM roots and dedupes them', async () => {\n  fs.mkdirSync(path.resolve(DIR, 'first-repo'), {recursive: true});\n  writeFiles(DIR, {\n    'first-repo/file1.txt': 'file1',\n    'first-repo/nested-dir/file2.txt': 'file2',\n    'first-repo/nested-dir/second-nested-dir/file3.txt': 'file3',\n    'second-repo/file1.txt': 'file1',\n    'second-repo/nested-dir/file2.txt': 'file2',\n    'second-repo/nested-dir/second-nested-dir/file3.txt': 'file3',\n  });\n\n  run(`${SL} init --git`, path.resolve(DIR, 'first-repo'));\n  run(`${SL} init --git`, path.resolve(DIR, 'second-repo'));\n\n  const roots = [\n    '',\n    'first-repo/nested-dir',\n    'first-repo/nested-dir/second-nested-dir',\n    'second-repo/nested-dir',\n    'second-repo/nested-dir/second-nested-dir',\n  ].map(filename => path.resolve(DIR, filename));\n\n  const repos = await findRepos(roots);\n  expect(repos.git.size).toBe(0);\n  expect(repos.hg.size).toBe(0);\n\n  const slRepos = [...repos.sl];\n\n  // it's not possible to match the exact path because it will resolve\n  // differently on different platforms.\n  // NOTE: This test can break if you have a .sl repo initialized inside your\n  // os tmp directory.\n  expect(slRepos).toHaveLength(2);\n  expect(slash(slRepos[0])).toMatch(\n    /\\/jest-changed-files-test-dir\\/first-repo\\/?$/,\n  );\n  expect(slash(slRepos[1])).toMatch(\n    /\\/jest-changed-files-test-dir\\/second-repo\\/?$/,\n  );\n});\n\ntestIfSl('gets changed files for sl', async () => {\n  // file1.txt is used to make a multi-line commit message\n  // with `sl commit -l file1.txt`.\n  // This is done to ensure that `changedFiles` only returns files\n  // and not parts of commit messages.\n  writeFiles(DIR, {\n    'file1.txt': 'file1\\n\\nextra-line',\n    'nested-dir/file2.txt': 'file2',\n    'nested-dir/second-nested-dir/file3.txt': 'file3',\n  });\n\n  run(`${SL} init --git`, DIR);\n\n  const roots = ['', 'nested-dir', 'nested-dir/second-nested-dir'].map(\n    filename => path.resolve(DIR, filename),\n  );\n\n  let {changedFiles: files} = await getChangedFilesForRoots(roots, {});\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n    'file2.txt',\n    'file3.txt',\n  ]);\n\n  run(`${SL} add .`, DIR);\n  run(`${SL} commit -l file1.txt`, DIR);\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {}));\n  expect([...files]).toEqual([]);\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {\n    lastCommit: true,\n  }));\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n    'file2.txt',\n    'file3.txt',\n  ]);\n\n  writeFiles(DIR, {\n    'file1.txt': 'modified file1',\n  });\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {}));\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n  ]);\n\n  run(`${SL} commit -m \"test2\"`, DIR);\n\n  writeFiles(DIR, {\n    'file4.txt': 'file4',\n  });\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {\n    withAncestor: true,\n  }));\n  // Returns files from current uncommitted state + the last commit\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n    'file4.txt',\n  ]);\n\n  run(`${SL} add file4.txt`, DIR);\n  run(`${SL} commit -m \"test3\"`, DIR);\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {\n    changedSince: '.~2',\n  }));\n  // Returns files from the last 2 commits\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file1.txt',\n    'file4.txt',\n  ]);\n\n  run(`${SL} bookmark main_branch`, DIR);\n  // Back up and develop on a different branch\n  run(`${SL}`, DIR);\n  run(`${SL} go prev(2)`, DIR);\n\n  writeFiles(DIR, {\n    'file5.txt': 'file5',\n  });\n  run(`${SL} add file5.txt`, DIR);\n  run(`${SL} commit -m \"test4\"`, DIR);\n\n  ({changedFiles: files} = await getChangedFilesForRoots(roots, {\n    changedSince: 'main_branch',\n  }));\n  // Returns files from this branch but not ones that only exist on main\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file5.txt',\n  ]);\n});\n\ntestIfSl('monitors only root paths for sl', async () => {\n  writeFiles(DIR, {\n    'file1.txt': 'file1',\n    'nested-dir/file2.txt': 'file2',\n    'nested-dir/second-nested-dir/file3.txt': 'file3',\n  });\n\n  run(`${SL} init --git`, DIR);\n\n  const roots = [path.resolve(DIR, 'nested-dir')];\n\n  const {changedFiles: files} = await getChangedFilesForRoots(roots, {});\n  expect([...files].map(filePath => path.basename(filePath)).sort()).toEqual([\n    'file2.txt',\n    'file3.txt',\n  ]);\n});\n\ntestIfSl('handles a bad revision for \"changedSince\", for sl', async () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    '__tests__/file1.test.js': \"require('../file1'); test('file1', () => {});\",\n    'file1.js': 'module.exports = {}',\n    'package.json': '{}',\n  });\n\n  run(`${SL} init --git`, DIR);\n  run(`${SL} add .`, DIR);\n  run(`${SL} commit -m \"first\"`, DIR);\n\n  const {exitCode, stderr} = runJest(DIR, ['--changedSince=blablabla']);\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toContain('Test suite failed to run');\n  expect(stderr).toContain(\"abort: unknown revision 'blablabla'\");\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport chalk = require('chalk');\n\nconst NODE_MODULES = `${path.sep}node_modules${path.sep}`;\nconst replacePathSepForRegex = (string: string) => {\n  if (path.sep === '\\\\') {\n    return string.replaceAll(/(\\/|\\\\(?!\\.))/g, '\\\\\\\\');\n  }\n  return string;\n};\n\nconst NODE_MODULES_REGEXP = replacePathSepForRegex(NODE_MODULES);\n\nexport const defaultConfig = {\n  automock: false,\n  bail: 0,\n  cacheDirectory: path.join(tmpdir(), 'jest'),\n  clearMocks: false,\n  coveragePathIgnorePatterns: [NODE_MODULES_REGEXP],\n  coverageReporters: ['json', 'text', 'lcov', 'clover'],\n  expand: false,\n  fakeTimers: {enableGlobally: false},\n  globals: {},\n  haste: {},\n  moduleDirectories: ['node_modules'],\n  moduleFileExtensions: ['js', 'json', 'jsx', 'node'],\n  moduleNameMapper: {},\n  modulePathIgnorePatterns: [],\n  noStackTrace: false,\n  notify: false,\n  notifyMode: 'failure-change',\n  preset: null,\n  prettierPath: 'prettier',\n  resetMocks: false,\n  resetModules: false,\n  restoreMocks: false,\n  roots: ['<rootDir>'],\n  snapshotSerializers: [],\n  testEnvironment: 'jest-environment-node',\n  testPathIgnorePatterns: [NODE_MODULES_REGEXP],\n  testRegex: '(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.[mc]?[jt]sx?$',\n  testResultsProcessor: null,\n  transformIgnorePatterns: [NODE_MODULES_REGEXP],\n  useStderr: false,\n  verbose: null,\n  watch: false,\n  watchPathIgnorePatterns: [],\n};\n\nexport const validConfig = {\n  automock: false,\n  bail: 0,\n  cache: true,\n  cacheDirectory: '/tmp/user/jest',\n  clearMocks: false,\n  collectCoverage: true,\n  collectCoverageFrom: ['src', '!public'],\n  coverageDirectory: 'coverage',\n  coveragePathIgnorePatterns: [NODE_MODULES_REGEXP],\n  coverageReporters: ['json', 'text', 'lcov', 'clover'],\n  coverageThreshold: {\n    global: {\n      branches: 50,\n    },\n  },\n  expand: false,\n  fakeTimers: {enableGlobally: false},\n  forceExit: false,\n  globals: {},\n  haste: {},\n  id: 'string',\n  logHeapUsage: true,\n  moduleDirectories: ['node_modules'],\n  moduleFileExtensions: ['js', 'json', 'jsx', 'node'],\n  moduleNameMapper: {\n    '^React$': '<rootDir>/node_modules/react',\n    '^Vue$': ['<rootDir>/node_modules/vue', '<rootDir>/node_modules/vue3'],\n  },\n  modulePathIgnorePatterns: ['<rootDir>/build/'],\n  modulePaths: ['/shared/vendor/modules'],\n  noStackTrace: false,\n  notify: false,\n  notifyMode: 'failure-change',\n  preset: 'react-native',\n  prettierPath: '<rootDir>/node_modules/prettier',\n  resetMocks: false,\n  resetModules: false,\n  restoreMocks: false,\n  rootDir: '/',\n  roots: ['<rootDir>'],\n  runtime: '<rootDir>',\n  setupFiles: ['<rootDir>/setup.js'],\n  setupFilesAfterEnv: ['<rootDir>/testSetupFile.js'],\n  silent: true,\n  snapshotSerializers: ['my-serializer-module'],\n  testEnvironment: 'jest-environment-node',\n  testNamePattern: 'test signature',\n  testPathIgnorePatterns: [NODE_MODULES_REGEXP],\n  testRegex: '(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.[mc]?[jt]sx?$',\n  testResultsProcessor: 'processor-node-module',\n  testRunner: 'circus',\n  transform: {\n    '\\\\.js$': '<rootDir>/preprocessor.js',\n  },\n  transformIgnorePatterns: [NODE_MODULES_REGEXP],\n  unmockedModulePathPatterns: ['mock'],\n  updateSnapshot: true,\n  useStderr: false,\n  verbose: false,\n  watch: false,\n  watchPathIgnorePatterns: [],\n  watchman: true,\n};\n\nconst format = (value: string) =>\n  (require('pretty-format') as typeof import('pretty-format')).format(value, {\n    min: true,\n  });\n\nexport const deprecatedConfig = {\n  preprocessorIgnorePatterns: (config: Record<string, unknown>) =>\n    `  Option ${chalk.bold(\n      'preprocessorIgnorePatterns',\n    )} was replaced by ${chalk.bold(\n      'transformIgnorePatterns',\n    )}, which support multiple preprocessors.\n\n  Jest now treats your current configuration as:\n  {\n    ${chalk.bold('\"transformIgnorePatterns\"')}: ${chalk.bold(\n      `${format(config.preprocessorIgnorePatterns as string)}`,\n    )}\n  }\n\n  Please update your configuration.`,\n\n  scriptPreprocessor: (config: Record<string, unknown>) =>\n    `  Option ${chalk.bold('scriptPreprocessor')} was replaced by ${chalk.bold(\n      'transform',\n    )}, which support multiple preprocessors.\n\n  Jest now treats your current configuration as:\n  {\n    ${chalk.bold('\"transform\"')}: ${chalk.bold(\n      `{\".*\": ${format(config.scriptPreprocessor as string)}}`,\n    )}\n  }\n\n  Please update your configuration.`,\n};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'jest_environment_jsdom_test');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('check is not leaking memory', () => {\n  writeFiles(DIR, {\n    '__tests__/a.test.js': \"test('a', () => console.log('a'));\",\n    '__tests__/b.test.js': \"test('b', () => console.log('b'));\",\n    'package.json': JSON.stringify({jest: {testEnvironment: 'jsdom'}}),\n  });\n\n  const {stderr} = runJest(DIR, ['--detect-leaks', '--runInBand']);\n  expect(stderr).toMatch(/PASS\\s__tests__\\/a.test.js/);\n  expect(stderr).toMatch(/PASS\\s__tests__\\/b.test.js/);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport runJest from '../runJest';\n\nconst dir = path.resolve(__dirname, '../jest-object');\n\ntest('passes with seed', () => {\n  const result = runJest(dir, ['get-seed.test.js', '--seed', '1234']);\n  expect(result.exitCode).toBe(0);\n});\n\ntest('fails with wrong seed', () => {\n  const result = runJest(dir, ['get-seed.test.js', '--seed', '1111']);\n  expect(result.exitCode).toBe(1);\n});\n\ntest('seed always exists', () => {\n  const result = runJest(dir, ['any-seed.test.js']);\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"change to jest.requireActual","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'jest-require-actual-test');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('understands dependencies using jest.requireActual', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    '__tests__/a.test.js': `\n      const a = jest.requireActual('../a');\n\n      test('a', () => {});\n    `,\n    '__tests__/b.test.js': \"test('b', () => {});\",\n    'a.js': 'module.exports = {}',\n    'package.json': JSON.stringify({jest: {}}),\n  });\n\n  let stdout;\n  let stderr;\n  ({stdout, stderr} = runJest(DIR, ['--findRelatedTests', 'a.js']));\n\n  expect(stdout).not.toMatch('No tests found');\n  expect(stderr).toMatch('PASS __tests__/a.test.js');\n  expect(stderr).not.toMatch('PASS __tests__/b.test.js');\n\n  // change to jest.requireActual\n  writeFiles(DIR, {\n    '__tests__/a.test.js': `\n      const a = jest.requireActual('../a');\n\n      test('a', () => {});\n    `,\n  });\n\n  ({stderr, stdout} = runJest(DIR, ['--findRelatedTests', 'a.js']));\n  expect(stdout).not.toMatch('No tests found');\n  expect(stderr).toMatch('PASS __tests__/a.test.js');\n  expect(stderr).not.toMatch('PASS __tests__/b.test.js');\n});"}
{"prompt":"change to jest.requireMock","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'jest-require-mock-test');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('understands dependencies using jest.requireMock', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    '__tests__/a.test.js': `\n      const a = jest.requireMock('../a');\n\n      test('a', () => {});\n    `,\n    '__tests__/b.test.js': \"test('b', () => {});\",\n    'a.js': 'module.exports = {}',\n    'package.json': JSON.stringify({jest: {}}),\n  });\n\n  let stdout;\n  let stderr;\n  ({stdout, stderr} = runJest(DIR, ['--findRelatedTests', 'a.js']));\n\n  expect(stdout).not.toMatch('No tests found');\n  expect(stderr).toMatch('PASS __tests__/a.test.js');\n  expect(stderr).not.toMatch('PASS __tests__/b.test.js');\n\n  // change to jest.requireMock\n  writeFiles(DIR, {\n    '__tests__/a.test.js': `\n      const a = jest.requireMock('../a');\n\n      test('a', () => {});\n    `,\n  });\n\n  ({stderr, stdout} = runJest(DIR, ['--findRelatedTests', 'a.js']));\n  expect(stdout).not.toMatch('No tests found');\n  expect(stderr).toMatch('PASS __tests__/a.test.js');\n  expect(stderr).not.toMatch('PASS __tests__/b.test.js');\n});"}
{"prompt":"Repl,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {spawnSync} from 'child_process';\nimport * as path from 'path';\n\nconst JEST_RUNTIME = require.resolve('../../bin/jest-repl.js');\n\ndescribe('Repl', () => {\n  describe('cli', () => {\n    it('runs without errors', () => {\n      let command = JEST_RUNTIME;\n      const args = [];\n\n      // Windows can't handle hashbangs, so is the best we can do\n      if (process.platform === 'win32') {\n        args.push(command);\n        command = 'node';\n      }\n\n      const output = spawnSync(command, args, {\n        cwd: process.cwd(),\n        encoding: 'utf8',\n        env: process.env,\n      });\n      expect(output.stderr.trim()).toBe('');\n      expect(output.stdout.trim()).toMatch(/›/u);\n    });\n  });\n});"}
{"prompt":"To align columns so people can review snapshots confidently:","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {DIFF_DELETE, DIFF_EQUAL, DIFF_INSERT, Diff} from '../cleanupSemantic';\nimport {\n  joinAlignedDiffsExpand,\n  joinAlignedDiffsNoExpand,\n} from '../joinAlignedDiffs';\nimport {noColor, normalizeDiffOptions} from '../normalizeDiffOptions';\n\n// To align columns so people can review snapshots confidently:\n\n// 1. Use options to omit line colors.\nconst changeColor = (string: string) => `<i>${string}</i>`;\nconst optionsNoColor = {\n  aColor: noColor,\n  bColor: noColor,\n  changeColor,\n  commonColor: noColor,\n  emptyFirstOrLastLinePlaceholder: '↵', // U+21B5\n  patchColor: noColor,\n};\n\n// 2. Add string serializer to omit double quote marks.\nexpect.addSnapshotSerializer({\n  serialize: (val: string) => val,\n  test: (val: unknown) => typeof val === 'string',\n});\n\nconst diffsCommonStartEnd = [\n  new Diff(DIFF_EQUAL, ''),\n  new Diff(DIFF_EQUAL, 'common 2 preceding A'),\n  new Diff(DIFF_EQUAL, 'common 1 preceding A'),\n  new Diff(DIFF_DELETE, 'delete line'),\n  new Diff(DIFF_DELETE, ['change ', changeColor('expect'), 'ed A'].join('')),\n  new Diff(DIFF_INSERT, ['change ', changeColor('receiv'), 'ed A'].join('')),\n  new Diff(DIFF_EQUAL, 'common 1 following A'),\n  new Diff(DIFF_EQUAL, 'common 2 following A'),\n  new Diff(DIFF_EQUAL, 'common 3 following A'),\n  new Diff(DIFF_EQUAL, 'common 4 following A'),\n  new Diff(DIFF_EQUAL, 'common 4 preceding B'),\n  new Diff(DIFF_EQUAL, 'common 3 preceding B'),\n  new Diff(DIFF_EQUAL, 'common 2 preceding B'),\n  new Diff(DIFF_EQUAL, 'common 1 preceding B'),\n  new Diff(DIFF_DELETE, ['change ', changeColor('expect'), 'ed B'].join('')),\n  new Diff(DIFF_INSERT, ['change ', changeColor('receiv'), 'ed B'].join('')),\n  new Diff(DIFF_INSERT, 'insert line'),\n  new Diff(DIFF_EQUAL, 'common 1 following B'),\n  new Diff(DIFF_EQUAL, 'common 2 following B'),\n  new Diff(DIFF_EQUAL, 'common 3 between B and C'),\n  new Diff(DIFF_EQUAL, 'common 2 preceding C'),\n  new Diff(DIFF_EQUAL, 'common 1 preceding C'),\n  new Diff(DIFF_DELETE, ['change ', changeColor('expect'), 'ed C'].join('')),\n  new Diff(DIFF_INSERT, ['change ', changeColor('receiv'), 'ed C'].join('')),\n  new Diff(DIFF_EQUAL, 'common 1 following C'),\n  new Diff(DIFF_EQUAL, 'common 2 following C'),\n  new Diff(DIFF_EQUAL, 'common 3 following C'),\n  new Diff(DIFF_EQUAL, ''),\n  new Diff(DIFF_EQUAL, 'common 5 following C'),\n];\n\nconst diffsChangeStartEnd = [\n  new Diff(DIFF_DELETE, 'delete'),\n  new Diff(DIFF_EQUAL, 'common following delete'),\n  new Diff(DIFF_EQUAL, 'common preceding insert'),\n  new Diff(DIFF_INSERT, 'insert'),\n];\n\ndescribe('joinAlignedDiffsExpand', () => {\n  test('first line is empty common', () => {\n    const options = normalizeDiffOptions(optionsNoColor);\n\n    expect(\n      joinAlignedDiffsExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });\n});\n\ndescribe('joinAlignedDiffsNoExpand', () => {\n  test('patch 0 with context 1 and change at start and end', () => {\n    const options = normalizeDiffOptions({\n      ...optionsNoColor,\n      contextLines: 1,\n      expand: false,\n    });\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsChangeStartEnd, options),\n    ).toMatchSnapshot();\n  });\n\n  test('patch 0 with context 5 and first line is empty common', () => {\n    const options = normalizeDiffOptions({...optionsNoColor, expand: false});\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });\n\n  test('patch 1 with context 4 and last line is empty common', () => {\n    const options = normalizeDiffOptions({\n      ...optionsNoColor,\n      contextLines: 4,\n      expand: false,\n    });\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });\n\n  test('patch 2 with context 3', () => {\n    const options = normalizeDiffOptions({\n      ...optionsNoColor,\n      contextLines: 3,\n      expand: false,\n    });\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });\n\n  test('patch 3 with context 2 and omit excess common at start', () => {\n    const options = normalizeDiffOptions({\n      ...optionsNoColor,\n      contextLines: 2,\n      expand: false,\n    });\n\n    expect(\n      joinAlignedDiffsNoExpand(diffsCommonStartEnd, options),\n    ).toMatchSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`joinAlignedDiffsExpand first line is empty common 1`] = `\n  ↵\n  common 2 preceding A\n  common 1 preceding A\n- delete line\n- change <i>expect</i>ed A\n+ change <i>receiv</i>ed A\n  common 1 following A\n  common 2 following A\n  common 3 following A\n  common 4 following A\n  common 4 preceding B\n  common 3 preceding B\n  common 2 preceding B\n  common 1 preceding B\n- change <i>expect</i>ed B\n+ change <i>receiv</i>ed B\n+ insert line\n  common 1 following B\n  common 2 following B\n  common 3 between B and C\n  common 2 preceding C\n  common 1 preceding C\n- change <i>expect</i>ed C\n+ change <i>receiv</i>ed C\n  common 1 following C\n  common 2 following C\n  common 3 following C\n\n  common 5 following C\n`;\n\nexports[`joinAlignedDiffsNoExpand patch 0 with context 1 and change at start and end 1`] = `\n- delete\n  common following delete\n  common preceding insert\n+ insert\n`;\n\nexports[`joinAlignedDiffsNoExpand patch 0 with context 5 and first line is empty common 1`] = `\n  ↵\n  common 2 preceding A\n  common 1 preceding A\n- delete line\n- change <i>expect</i>ed A\n+ change <i>receiv</i>ed A\n  common 1 following A\n  common 2 following A\n  common 3 following A\n  common 4 following A\n  common 4 preceding B\n  common 3 preceding B\n  common 2 preceding B\n  common 1 preceding B\n- change <i>expect</i>ed B\n+ change <i>receiv</i>ed B\n+ insert line\n  common 1 following B\n  common 2 following B\n  common 3 between B and C\n  common 2 preceding C\n  common 1 preceding C\n- change <i>expect</i>ed C\n+ change <i>receiv</i>ed C\n  common 1 following C\n  common 2 following C\n  common 3 following C\n\n  common 5 following C\n`;\n\nexports[`joinAlignedDiffsNoExpand patch 1 with context 4 and last line is empty common 1`] = `\n@@ -1,24 +1,24 @@\n\n  common 2 preceding A\n  common 1 preceding A\n- delete line\n- change <i>expect</i>ed A\n+ change <i>receiv</i>ed A\n  common 1 following A\n  common 2 following A\n  common 3 following A\n  common 4 following A\n  common 4 preceding B\n  common 3 preceding B\n  common 2 preceding B\n  common 1 preceding B\n- change <i>expect</i>ed B\n+ change <i>receiv</i>ed B\n+ insert line\n  common 1 following B\n  common 2 following B\n  common 3 between B and C\n  common 2 preceding C\n  common 1 preceding C\n- change <i>expect</i>ed C\n+ change <i>receiv</i>ed C\n  common 1 following C\n  common 2 following C\n  common 3 following C\n  ↵\n`;\n\nexports[`joinAlignedDiffsNoExpand patch 2 with context 3 1`] = `\n@@ -1,8 +1,7 @@\n\n  common 2 preceding A\n  common 1 preceding A\n- delete line\n- change <i>expect</i>ed A\n+ change <i>receiv</i>ed A\n  common 1 following A\n  common 2 following A\n  common 3 following A\n@@ -11,13 +10,14 @@\n  common 3 preceding B\n  common 2 preceding B\n  common 1 preceding B\n- change <i>expect</i>ed B\n+ change <i>receiv</i>ed B\n+ insert line\n  common 1 following B\n  common 2 following B\n  common 3 between B and C\n  common 2 preceding C\n  common 1 preceding C\n- change <i>expect</i>ed C\n+ change <i>receiv</i>ed C\n  common 1 following C\n  common 2 following C\n  common 3 following C\n`;\n\nexports[`joinAlignedDiffsNoExpand patch 3 with context 2 and omit excess common at start 1`] = `\n@@ -2,6 +2,5 @@\n  common 2 preceding A\n  common 1 preceding A\n- delete line\n- change <i>expect</i>ed A\n+ change <i>receiv</i>ed A\n  common 1 following A\n  common 2 following A\n@@ -12,5 +11,6 @@\n  common 2 preceding B\n  common 1 preceding B\n- change <i>expect</i>ed B\n+ change <i>receiv</i>ed B\n+ insert line\n  common 1 following B\n  common 2 following B\n@@ -18,5 +18,5 @@\n  common 2 preceding C\n  common 1 preceding C\n- change <i>expect</i>ed C\n+ change <i>receiv</i>ed C\n  common 1 following C\n  common 2 following C\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jest-environment-jsdom\n * @jest-environment-options {\"customExportConditions\": [\"special\"]}\n */\n\nimport {fn} from 'fake-dual-dep';\n\ntest('returns correct message', () => {\n  expect(fn()).toBe('hello from special');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n'use strict';\n\ntest('use unref', () => {\n  setTimeout(() => {}, 0).unref();\n\n  expect(1).toBe(1);\n});"}
{"prompt":"JSDomEnvironment,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport JSDomEnvironment from '..';\n\ndescribe('JSDomEnvironment', () => {\n  it('should configure setTimeout/setInterval to use the browser api', () => {\n    const env = new JSDomEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      {console, docblockPragmas: {}, testPath: __filename},\n    );\n\n    env.fakeTimers!.useFakeTimers();\n\n    const timer1 = env.global.setTimeout(() => {}, 0);\n    const timer2 = env.global.setInterval(() => {}, 0);\n\n    for (const timer of [timer1, timer2]) {\n      expect(typeof timer).toBe('number');\n    }\n  });\n\n  it('has modern fake timers implementation', () => {\n    const env = new JSDomEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      {console, docblockPragmas: {}, testPath: __filename},\n    );\n\n    expect(env.fakeTimersModern).toBeDefined();\n  });\n\n  it('should respect userAgent option', () => {\n    const env = new JSDomEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig({\n          testEnvironmentOptions: {\n            userAgent: 'foo',\n          },\n        }),\n      },\n      {console, docblockPragmas: {}, testPath: __filename},\n    );\n\n    expect(env.dom.window.navigator.userAgent).toBe('foo');\n  });\n\n  it('should respect url option', () => {\n    const env = new JSDomEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      {console, docblockPragmas: {}, testPath: __filename},\n    );\n\n    expect(env.dom.window.location.href).toBe('http://localhost/');\n\n    const envWithUrl = new JSDomEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig({\n          testEnvironmentOptions: {\n            url: 'https://jestjs.io',\n          },\n        }),\n      },\n      {console, docblockPragmas: {}, testPath: __filename},\n    );\n\n    expect(envWithUrl.dom.window.location.href).toBe('https://jestjs.io/');\n  });\n\n  /**\n   * When used in conjunction with Custom Elements (part of the WebComponents standard)\n   * setting the `global` and `global.document` to null too early is problematic because:\n   *\n   * CustomElement's disconnectedCallback method is called when a custom element\n   * is removed from the DOM. The disconnectedCallback could need the document\n   * in order to remove some listener for example.\n   *\n   * global.close calls jsdom's Window.js.close which does this._document.body.innerHTML = \"\".\n   * The custom element will be removed from the DOM at this point, therefore disconnectedCallback\n   * will be called, so please make sure the global.document is still available at this point.\n   */\n  it('should call CE disconnectedCallback with valid globals on teardown', () => {\n    const env = new JSDomEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      {console, docblockPragmas: {}, testPath: __filename},\n    );\n\n    let hasDisconnected = false;\n    let documentWhenDisconnected = null;\n\n    // define a custom element\n    const {HTMLElement} = env.global;\n    class MyCustomElement extends HTMLElement {\n      disconnectedCallback() {\n        hasDisconnected = true;\n        documentWhenDisconnected = env.global.document;\n      }\n    }\n\n    // append an instance of the custom element\n    env.global.customElements.define('my-custom-element', MyCustomElement);\n    const instance = env.global.document.createElement('my-custom-element');\n    env.global.document.body.append(instance);\n\n    // teardown will disconnect the custom elements\n    env.teardown();\n\n    expect(hasDisconnected).toBe(true);\n    expect(documentWhenDisconnected).not.toBeNull();\n  });\n\n  it('should not fire load event after the environment was teared down', async () => {\n    const env = new JSDomEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      {console, docblockPragmas: {}, testPath: __filename},\n    );\n\n    const loadHandler = jest.fn();\n    env.global.document.addEventListener('load', loadHandler);\n    env.teardown();\n\n    // The `load` event is fired in microtasks, wait until the microtask queue is reliably flushed\n    await new Promise(resolve => setTimeout(resolve, 0));\n\n    expect(loadHandler).not.toHaveBeenCalled();\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('JSON is available in the global scope', () => {\n  expect(JSON).toBe(globalThis.JSON);\n});\n\ntest('JSON.parse creates objects from within this context', () => {\n  expect(JSON.parse('{}').constructor).toBe(Object);\n});"}
{"prompt":"Test generated from existing file","test":"{\"isJSONModule\": true}"}
{"prompt":"JSON Reporter,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport type {FormattedTestResults} from '@jest/test-result';\nimport runJest from '../runJest';\n\ndescribe('JSON Reporter', () => {\n  const outputFileName = 'sum.result.json';\n  const outputFilePath = path.join(\n    process.cwd(),\n    'e2e/json-reporter/',\n    outputFileName,\n  );\n\n  afterAll(() => {\n    fs.unlinkSync(outputFilePath);\n  });\n\n  it('writes test result to sum.result.json', () => {\n    let jsonResult: FormattedTestResults;\n\n    runJest('json-reporter', ['--json', `--outputFile=${outputFileName}`]);\n    const testOutput = fs.readFileSync(outputFilePath, 'utf8');\n\n    expect(testOutput.endsWith('\\n')).toBe(true);\n\n    try {\n      jsonResult = JSON.parse(testOutput);\n    } catch (error: any) {\n      throw new Error(\n        `Can't parse the JSON result from ${outputFileName}, ${error.toString()}`,\n      );\n    }\n\n    expect(jsonResult.numTotalTests).toBe(4);\n    expect(jsonResult.numTotalTestSuites).toBe(1);\n    expect(jsonResult.numRuntimeErrorTestSuites).toBe(0);\n    expect(jsonResult.numPassedTests).toBe(2);\n    expect(jsonResult.numFailedTests).toBe(1);\n    expect(jsonResult.numPendingTests).toBe(1);\n\n    const noAncestors = jsonResult.testResults[0].assertionResults.find(\n      item => item.title === 'no ancestors',\n    );\n    let expected = {ancestorTitles: [] as Array<string>};\n    expect(noAncestors).toEqual(expect.objectContaining(expected));\n    expect(noAncestors).toHaveProperty('duration', expect.any(Number));\n\n    const addsNumbers = jsonResult.testResults[0].assertionResults.find(\n      item => item.title === 'adds numbers',\n    );\n    expected = {ancestorTitles: ['sum']};\n    expect(addsNumbers).toEqual(expect.objectContaining(expected));\n    expect(addsNumbers).toHaveProperty('duration', expect.any(Number));\n\n    const failsTheTest = jsonResult.testResults[0].assertionResults.find(\n      item => item.title === 'fails the test',\n    );\n    expected = {ancestorTitles: ['sum', 'failing tests']};\n    expect(failsTheTest).toEqual(expect.objectContaining(expected));\n    expect(failsTheTest).toHaveProperty('duration', expect.any(Number));\n\n    const skipedTest = jsonResult.testResults[0].assertionResults.find(\n      item => item.title === 'skipped test',\n    );\n    expect(skipedTest).toHaveProperty('duration', null);\n  });\n\n  it('outputs coverage report', () => {\n    const result = runJest('json-reporter', ['--json'], {\n      keepTrailingNewline: true,\n    });\n    let jsonResult: FormattedTestResults;\n\n    expect(result.stderr).toMatch(/1 failed, 1 skipped, 2 passed/);\n    expect(result.exitCode).toBe(1);\n\n    expect(result.stdout.endsWith('\\n')).toBe(true);\n\n    try {\n      jsonResult = JSON.parse(result.stdout);\n    } catch (error: any) {\n      throw new Error(\n        `Can't parse the JSON result from stdout${error.toString()}`,\n      );\n    }\n\n    expect(jsonResult.numTotalTests).toBe(4);\n    expect(jsonResult.numTotalTestSuites).toBe(1);\n    expect(jsonResult.numRuntimeErrorTestSuites).toBe(0);\n    expect(jsonResult.numPassedTests).toBe(2);\n    expect(jsonResult.numFailedTests).toBe(1);\n    expect(jsonResult.numPendingTests).toBe(1);\n\n    const noAncestors = jsonResult.testResults[0].assertionResults.find(\n      item => item.title === 'no ancestors',\n    );\n    let expected = {ancestorTitles: [] as Array<string>};\n    expect(noAncestors).toEqual(expect.objectContaining(expected));\n\n    const addsNumbers = jsonResult.testResults[0].assertionResults.find(\n      item => item.title === 'adds numbers',\n    );\n    expected = {ancestorTitles: ['sum']};\n    expect(addsNumbers).toEqual(expect.objectContaining(expected));\n\n    const failsTheTest = jsonResult.testResults[0].assertionResults.find(\n      item => item.title === 'fails the test',\n    );\n    expected = {ancestorTitles: ['sum', 'failing tests']};\n    expect(failsTheTest).toEqual(expect.objectContaining(expected));\n  });\n});"}
{"prompt":"Custom Reporters,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\ndescribe('Custom Reporters', () => {\n  it('test 1', () => {\n    expect(true).toBeTruthy();\n  });\n\n  it('test 2', () => {\n    expect(true).toBeTruthy();\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('require after done', () => {\n  setTimeout(() => {\n    const double = require('../');\n\n    expect(double(5)).toBe(10);\n  }, 0);\n});"}
{"prompt":"WorkerThreads leaks,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport {join} from 'path';\nimport {writeFileSync} from 'graceful-fs';\nimport LeakDetector from 'jest-leak-detector';\nimport {type JestWorkerFarm, Worker} from '../../build';\n\ndescribe('WorkerThreads leaks', () => {\n  let workerFile: string;\n  beforeAll(() => {\n    workerFile = join(tmpdir(), 'baz.js');\n    writeFileSync(workerFile, 'module.exports.fn = () => {};');\n  });\n\n  let worker: JestWorkerFarm<{fn(a: unknown): void}>;\n  beforeEach(() => {\n    worker = new Worker(workerFile, {\n      enableWorkerThreads: true,\n      exposedMethods: ['fn'],\n    }) as JestWorkerFarm<{fn(a: unknown): void}>;\n  });\n  afterEach(async () => {\n    await worker.end();\n  });\n\n  it('does not retain arguments after a task finished', async () => {\n    let leakDetector: LeakDetector;\n    await new Promise((resolve, reject) => {\n      const obj = {};\n      leakDetector = new LeakDetector(obj);\n      worker.fn(obj).then(resolve, reject);\n    });\n\n    expect(await leakDetector!.isLeaking()).toBe(false);\n  });\n});\n\ndescribe('Worker leaks', () => {\n  let workerFile!: string;\n  beforeAll(() => {\n    workerFile = join(tmpdir(), 'baz.js');\n    writeFileSync(workerFile, 'module.exports.fn = (obj) => [obj];');\n  });\n\n  let worker: JestWorkerFarm<{fn(a: unknown): void}>;\n  beforeEach(() => {\n    worker = new Worker(workerFile, {\n      enableWorkerThreads: false,\n      exposedMethods: ['fn'],\n      forkOptions: {serialization: 'json'},\n    }) as JestWorkerFarm<{fn(a: unknown): void}>;\n  });\n  afterEach(async () => {\n    await worker.end();\n  });\n\n  it('does not retain result after next task call', async () => {\n    let leakDetector: LeakDetector;\n    await new Promise((resolve, reject) => {\n      const obj = {};\n      worker\n        .fn(obj)\n        .then((result: unknown) => {\n          leakDetector = new LeakDetector(result);\n          return result;\n        })\n        .then(resolve, reject);\n    });\n    await new Promise((resolve, reject) => {\n      const obj = {};\n      worker.fn(obj).then(resolve, reject);\n    });\n\n    expect(await leakDetector!.isLeaking()).toBe(false);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ntest('fake timers', () => {\n  jest.useFakeTimers();\n  const f = jest.fn();\n  setTimeout(f, 0);\n  jest.runAllTimers();\n  expect(f).toHaveBeenCalledTimes(1);\n});\n\ntest('getRealSystemTime', () => {\n  expect(() => jest.getRealSystemTime()).toThrow(\n    '`jest.getRealSystemTime()` is not available when using legacy fake timers.',\n  );\n});\n\ntest('setSystemTime', () => {\n  expect(() => jest.setSystemTime(0)).toThrow(\n    '`jest.setSystemTime()` is not available when using legacy fake timers.',\n  );\n});"}
{"prompt":"/ <reference lib=dom />","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/// <reference lib=\"dom\" />\n\nimport * as util from 'util';\nimport {runInNewContext} from 'vm';\nimport {ModuleMocker} from 'jest-mock';\nimport FakeTimers from '../legacyFakeTimers';\n\nconst timerConfig = {\n  idToRef: (id: number) => id,\n  refToId: (ref: number) => ref,\n};\n\nconst config = {\n  rootDir: '/',\n  testMatch: [],\n};\n\ndescribe('FakeTimers', () => {\n  let moduleMocker: ModuleMocker;\n\n  beforeEach(() => {\n    const global = runInNewContext('this');\n    moduleMocker = new ModuleMocker(global);\n  });\n\n  describe('construction', () => {\n    it('installs setTimeout mock', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.setTimeout).toBeDefined();\n    });\n\n    it('accepts to promisify setTimeout mock', async () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      const timeoutPromise = util.promisify(global.setTimeout)(0, 'resolved');\n      timers.runAllTimers();\n      await expect(timeoutPromise).resolves.toBe('resolved');\n    });\n\n    it('installs clearTimeout mock', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.clearTimeout).toBeDefined();\n    });\n\n    it('installs setInterval mock', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.setInterval).toBeDefined();\n    });\n\n    it('installs clearInterval mock', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.clearInterval).toBeDefined();\n    });\n\n    it('mocks process.nextTick if it exists on global', () => {\n      const origNextTick = () => {};\n      const global = {\n        process: {\n          nextTick: origNextTick,\n        },\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.process.nextTick).not.toBe(origNextTick);\n    });\n\n    it('mocks setImmediate if it exists on global', () => {\n      const origSetImmediate = () => {};\n      const global = {\n        process,\n        setImmediate: origSetImmediate,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.setImmediate).not.toBe(origSetImmediate);\n    });\n\n    it('mocks clearImmediate if setImmediate is on global', () => {\n      const origSetImmediate = () => {};\n      const origClearImmediate = () => {};\n      const global = {\n        clearImmediate: origClearImmediate,\n        process,\n        setImmediate: origSetImmediate,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.clearImmediate).not.toBe(origClearImmediate);\n    });\n\n    it('does not mock requestAnimationFrame if not available', () => {\n      const global = {\n        process,\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.requestAnimationFrame).toBeUndefined();\n    });\n\n    it('mocks requestAnimationFrame if available on global', () => {\n      const origRequestAnimationFrame = () => {};\n      const global = {\n        process,\n        requestAnimationFrame: origRequestAnimationFrame,\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.requestAnimationFrame).toBeDefined();\n      expect(global.requestAnimationFrame).not.toBe(origRequestAnimationFrame);\n    });\n\n    it('does not mock cancelAnimationFrame if not available on global', () => {\n      const global = {\n        process,\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.cancelAnimationFrame).toBeUndefined();\n    });\n\n    it('mocks cancelAnimationFrame if available on global', () => {\n      const origCancelAnimationFrame = () => {};\n      const global = {\n        cancelAnimationFrame: origCancelAnimationFrame,\n        process,\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      expect(global.cancelAnimationFrame).toBeDefined();\n      expect(global.cancelAnimationFrame).not.toBe(origCancelAnimationFrame);\n    });\n  });\n\n  describe('runAllTicks', () => {\n    it('runs all ticks, in order', () => {\n      const global = {\n        process: {\n          nextTick: () => {},\n        },\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n\n      global.process.nextTick(mock1);\n      global.process.nextTick(mock2);\n\n      expect(mock1).toHaveBeenCalledTimes(0);\n      expect(mock2).toHaveBeenCalledTimes(0);\n\n      timers.runAllTicks();\n\n      expect(mock1).toHaveBeenCalledTimes(1);\n      expect(mock2).toHaveBeenCalledTimes(1);\n      expect(runOrder).toEqual(['mock1', 'mock2']);\n    });\n\n    it('does nothing when no ticks have been scheduled', () => {\n      const nextTick = jest.fn();\n      const global = {\n        process: {\n          nextTick,\n        },\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      timers.runAllTicks();\n\n      expect(nextTick).toHaveBeenCalledTimes(0);\n    });\n\n    it('only runs a scheduled callback once', () => {\n      const global = {\n        process: {\n          nextTick: () => {},\n        },\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.process.nextTick(mock1);\n      expect(mock1).toHaveBeenCalledTimes(0);\n\n      timers.runAllTicks();\n      expect(mock1).toHaveBeenCalledTimes(1);\n\n      timers.runAllTicks();\n      expect(mock1).toHaveBeenCalledTimes(1);\n    });\n\n    it('cancels a callback even from native nextTick', () => {\n      const nativeNextTick = jest.fn<typeof process.nextTick>();\n\n      const global = {\n        process: {\n          nextTick: nativeNextTick,\n        },\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.process.nextTick(mock1);\n      timers.runAllTicks();\n      expect(mock1).toHaveBeenCalledTimes(1);\n      expect(nativeNextTick).toHaveBeenCalledTimes(1);\n\n      // Now imagine we fast forward to the next real tick. We need to be sure\n      // that native nextTick doesn't try to run the callback again\n      nativeNextTick.mock.calls[0][0]();\n      expect(mock1).toHaveBeenCalledTimes(1);\n    });\n\n    it('cancels a callback even from native setImmediate', () => {\n      const nativeSetImmediate = jest.fn<typeof setImmediate>();\n\n      const global = {\n        process,\n        setImmediate: nativeSetImmediate,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setImmediate(mock1);\n      timers.runAllImmediates();\n      expect(mock1).toHaveBeenCalledTimes(1);\n      expect(nativeSetImmediate).toHaveBeenCalledTimes(1);\n\n      // ensure that native setImmediate doesn't try to run the callback again\n      nativeSetImmediate.mock.calls[0][0]();\n      expect(mock1).toHaveBeenCalledTimes(1);\n    });\n\n    it('doesnt run a tick callback if native nextTick already did', () => {\n      const nativeNextTick = jest.fn<typeof process.nextTick>();\n\n      const global = {\n        process: {\n          nextTick: nativeNextTick,\n        },\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.process.nextTick(mock1);\n\n      // Emulate native nextTick running...\n      nativeNextTick.mock.calls[0][0]();\n      expect(mock1).toHaveBeenCalledTimes(1);\n\n      // Ensure runAllTicks() doesn't run the callback again\n      timers.runAllTicks();\n      expect(mock1).toHaveBeenCalledTimes(1);\n    });\n\n    it('doesnt run immediate if native setImmediate already did', () => {\n      const nativeSetImmediate = jest.fn<typeof setImmediate>();\n\n      const global = {\n        process,\n        setImmediate: nativeSetImmediate,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setImmediate(mock1);\n\n      // Emulate native setImmediate running...\n      nativeSetImmediate.mock.calls[0][0]();\n      expect(mock1).toHaveBeenCalledTimes(1);\n\n      // Ensure runAllTicks() doesn't run the callback again\n      timers.runAllImmediates();\n      expect(mock1).toHaveBeenCalledTimes(1);\n    });\n\n    it('native doesnt run immediate if fake already did', () => {\n      const nativeSetImmediate = jest.fn<typeof setImmediate>();\n\n      const global = {\n        process,\n        setImmediate: nativeSetImmediate,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setImmediate(mock1);\n\n      //run all immediates now\n      timers.runAllImmediates();\n      expect(mock1).toHaveBeenCalledTimes(1);\n\n      // Emulate native setImmediate running ensuring it doesn't re-run\n      nativeSetImmediate.mock.calls[0][0]();\n\n      expect(mock1).toHaveBeenCalledTimes(1);\n    });\n\n    it('throws before allowing infinite recursion', () => {\n      const global = {\n        process: {\n          nextTick: () => {},\n        },\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        maxLoops: 100,\n        moduleMocker,\n        timerConfig,\n      });\n\n      timers.useFakeTimers();\n\n      global.process.nextTick(function infinitelyRecursingCallback() {\n        global.process.nextTick(infinitelyRecursingCallback);\n      });\n\n      expect(() => {\n        timers.runAllTicks();\n      }).toThrow(\n        new Error(\n          \"Ran 100 ticks, and there are still more! Assuming we've hit an \" +\n            'infinite recursion and bailing out...',\n        ),\n      );\n    });\n  });\n\n  describe('runAllTimers', () => {\n    it('runs all timers in order', () => {\n      const global = {\n        cancelAnimationFrame: () => {},\n        process,\n        requestAnimationFrame: () => {},\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n      const mock5 = jest.fn(() => runOrder.push('mock5'));\n      const mock6 = jest.fn(() => runOrder.push('mock6'));\n      const mockAnimationFrame = jest.fn(() => runOrder.push('animationFrame'));\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, Number.NaN);\n      global.setTimeout(mock3, 0);\n      const intervalHandler = global.setInterval(() => {\n        mock4();\n        global.clearInterval(intervalHandler);\n      }, 200);\n      global.setTimeout(mock5, Number.POSITIVE_INFINITY);\n      global.setTimeout(mock6, Number.NEGATIVE_INFINITY);\n      global.requestAnimationFrame(mockAnimationFrame);\n\n      timers.runAllTimers();\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        'mock5',\n        'mock6',\n        'animationFrame',\n        'mock1',\n        'mock4',\n      ]);\n    });\n\n    it('warns when trying to advance timers while real timers are used', () => {\n      const mockConsole = {warn: jest.fn<typeof console.warn>()};\n      const timers = new FakeTimers({\n        config: {\n          rootDir: __dirname,\n          testMatch: [],\n        },\n        global: {console: mockConsole} as unknown as typeof globalThis,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.runAllTimers();\n      expect(\n        mockConsole.warn.mock.calls[0][0].split('\\nStack Trace')[0],\n      ).toMatchSnapshot();\n    });\n\n    it('does nothing when no timers have been scheduled', () => {\n      const nativeSetTimeout = jest.fn();\n      const global = {\n        process,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n      timers.runAllTimers();\n    });\n\n    it('only runs a setTimeout callback once (ever)', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      global.setTimeout(fn, 0);\n      expect(fn).toHaveBeenCalledTimes(0);\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n    });\n\n    it('runs callbacks with arguments after the interval', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      global.setTimeout(fn, 0, 'mockArg1', 'mockArg2');\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n      expect(fn).toHaveBeenCalledWith('mockArg1', 'mockArg2');\n    });\n\n    it('doesnt pass the callback to native setTimeout', () => {\n      const nativeSetTimeout = jest.fn();\n\n      const global = {\n        process,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setTimeout(mock1, 0);\n\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(1);\n      expect(nativeSetTimeout).toHaveBeenCalledTimes(0);\n    });\n\n    it('throws before allowing infinite recursion', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        maxLoops: 100,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      global.setTimeout(function infinitelyRecursingCallback() {\n        global.setTimeout(infinitelyRecursingCallback, 0);\n      }, 0);\n\n      expect(() => {\n        timers.runAllTimers();\n      }).toThrow(\n        new Error(\n          \"Ran 100 timers, and there are still more! Assuming we've hit an \" +\n            'infinite recursion and bailing out...',\n        ),\n      );\n    });\n\n    it('also clears ticks', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      global.setTimeout(() => {\n        process.nextTick(fn);\n      }, 0);\n      expect(fn).toHaveBeenCalledTimes(0);\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('advanceTimersByTime', () => {\n    it('runs timers in order', () => {\n      const global = {\n        cancelAnimationFrame: () => {},\n        process,\n        requestAnimationFrame: () => {},\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const runOrder: Array<string | ['animationFrame', number]> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n      const mockAnimationFrame = jest.fn(timestamp =>\n        runOrder.push(['animationFrame', timestamp]),\n      );\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      global.setInterval(() => {\n        mock4();\n      }, 200);\n      global.requestAnimationFrame(mockAnimationFrame);\n\n      // Move forward to t=15\n      timers.advanceTimersByTime(15);\n      expect(runOrder).toEqual(['mock2', 'mock3']);\n\n      // Move forward to t=16\n      timers.advanceTimersByTime(1);\n      expect(runOrder).toEqual(['mock2', 'mock3', ['animationFrame', 16]]);\n\n      // Move forward to t=60\n      timers.advanceTimersByTime(44);\n      expect(runOrder).toEqual(['mock2', 'mock3', ['animationFrame', 16]]);\n\n      // Move forward to t=100\n      timers.advanceTimersByTime(40);\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        ['animationFrame', 16],\n        'mock1',\n      ]);\n\n      // Move forward to t=200\n      timers.advanceTimersByTime(100);\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        ['animationFrame', 16],\n        'mock1',\n        'mock4',\n      ]);\n\n      // Move forward to t=400\n      timers.advanceTimersByTime(200);\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        ['animationFrame', 16],\n        'mock1',\n        'mock4',\n        'mock4',\n      ]);\n    });\n\n    it('does nothing when no timers have been scheduled', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      timers.advanceTimersByTime(100);\n    });\n    it('throws before allowing infinite recursion', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        maxLoops: 100,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      global.setTimeout(function infinitelyRecursingCallback() {\n        global.setTimeout(infinitelyRecursingCallback, 0);\n      }, 0);\n\n      expect(() => {\n        timers.advanceTimersByTime(50);\n      }).toThrow(\n        new Error(\n          \"Ran 100 timers, and there are still more! Assuming we've hit an \" +\n            'infinite recursion and bailing out...',\n        ),\n      );\n    });\n  });\n\n  describe('advanceTimersToNextTimer', () => {\n    it('runs timers in order', () => {\n      const global = {\n        cancelAnimationFrame: () => {},\n        process,\n        requestAnimationFrame: () => {},\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n      const mockAnimationFrame = jest.fn(() => runOrder.push('animationFrame'));\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      global.setInterval(() => {\n        mock4();\n      }, 200);\n      global.requestAnimationFrame(mockAnimationFrame);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=0\n      expect(runOrder).toEqual(['mock2', 'mock3']);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=17\n      expect(runOrder).toEqual(['mock2', 'mock3', 'animationFrame']);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=100\n      expect(runOrder).toEqual(['mock2', 'mock3', 'animationFrame', 'mock1']);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=200\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        'animationFrame',\n        'mock1',\n        'mock4',\n      ]);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=400\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        'animationFrame',\n        'mock1',\n        'mock4',\n        'mock4',\n      ]);\n    });\n\n    it('run correct amount of steps', () => {\n      const global = {\n        cancelAnimationFrame: () => {},\n        process,\n        requestAnimationFrame: () => {},\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n      const mockAnimationFrame = jest.fn(() => runOrder.push('animationFrame'));\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      global.setInterval(() => {\n        mock4();\n      }, 200);\n      global.requestAnimationFrame(mockAnimationFrame);\n\n      // Move forward to t=17\n      timers.advanceTimersToNextTimer(2);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'animationFrame']);\n\n      // Move forward to t=100\n      timers.advanceTimersToNextTimer(1);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'animationFrame', 'mock1']);\n\n      // Move forward to t=600\n      timers.advanceTimersToNextTimer(3);\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        'animationFrame',\n        'mock1',\n        'mock4',\n        'mock4',\n        'mock4',\n      ]);\n    });\n\n    it('setTimeout inside setTimeout', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n\n      global.setTimeout(mock1, 0);\n      global.setTimeout(() => {\n        mock2();\n        global.setTimeout(mock3, 50);\n      }, 25);\n      global.setTimeout(mock4, 100);\n\n      // Move forward to t=75\n      timers.advanceTimersToNextTimer(3);\n      expect(runOrder).toEqual(['mock1', 'mock2', 'mock3']);\n    });\n\n    it('does nothing when no timers have been scheduled', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      timers.advanceTimersToNextTimer();\n    });\n  });\n\n  describe('reset', () => {\n    it('resets all pending setTimeouts', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setTimeout(mock1, 100);\n\n      timers.reset();\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets all pending setIntervals', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setInterval(mock1, 200);\n\n      timers.reset();\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets all pending animation frames', () => {\n      const global = {\n        cancelAnimationFrame: () => {},\n        process,\n        requestAnimationFrame: () => {},\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.requestAnimationFrame(mock1);\n\n      timers.reset();\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets all pending ticks callbacks & immediates', () => {\n      const global = {\n        process: {\n          nextTick: () => {},\n        },\n        setImmediate: () => {},\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.process.nextTick(mock1);\n      global.setImmediate(mock1);\n\n      timers.reset();\n      timers.runAllTicks();\n      timers.runAllImmediates();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets current advanceTimersByTime time cursor', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setTimeout(mock1, 100);\n      timers.advanceTimersByTime(50);\n\n      timers.reset();\n      global.setTimeout(mock1, 100);\n\n      timers.advanceTimersByTime(50);\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n  });\n\n  describe('runOnlyPendingTimers', () => {\n    it('runs all timers in order', () => {\n      const nativeSetImmediate = jest.fn<typeof setImmediate>();\n\n      const global = {\n        cancelAnimationFrame: () => {},\n        process,\n        requestAnimationFrame: () => {},\n        setImmediate: nativeSetImmediate,\n      } as unknown as typeof globalThis & Window;\n\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n\n      global.setTimeout(function cb() {\n        runOrder.push('mock1');\n        global.setTimeout(cb, 100);\n      }, 100);\n\n      global.setTimeout(function cb() {\n        runOrder.push('mock2');\n        global.setTimeout(cb, 0);\n      }, 0);\n\n      global.setInterval(() => {\n        runOrder.push('mock3');\n      }, 200);\n\n      global.setImmediate(() => {\n        runOrder.push('mock4');\n      });\n\n      global.setImmediate(function cb() {\n        runOrder.push('mock5');\n        global.setTimeout(cb, 400);\n      });\n\n      global.requestAnimationFrame(function cb() {\n        runOrder.push('animationFrame');\n        global.requestAnimationFrame(cb);\n      });\n\n      timers.runOnlyPendingTimers();\n      expect(runOrder).toEqual([\n        'mock4',\n        'mock5',\n        'mock2',\n        'animationFrame',\n        'mock1',\n        'mock3',\n      ]);\n\n      timers.runOnlyPendingTimers();\n      expect(runOrder).toEqual([\n        'mock4',\n        'mock5',\n        'mock2',\n        'animationFrame',\n        'mock1',\n        'mock3',\n\n        'mock2',\n        'animationFrame',\n        'mock1',\n        'mock3',\n        'mock5',\n      ]);\n    });\n\n    it('does not run timers that were cleared in another timer', () => {\n      const global = {process} as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      const timer = global.setTimeout(fn, 10);\n      global.setTimeout(() => {\n        global.clearTimeout(timer);\n      }, 0);\n\n      timers.runOnlyPendingTimers();\n      expect(fn).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('runWithRealTimers', () => {\n    it('executes callback with native timers', () => {\n      const nativeClearInterval = jest.fn();\n      const nativeClearTimeout = jest.fn();\n      const nativeSetInterval = jest.fn();\n      const nativeSetTimeout = jest.fn();\n\n      const global = {\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        process,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      // clearInterval()\n      timers.runWithRealTimers(() => {\n        (global as any).clearInterval();\n      });\n      expect(nativeClearInterval).toHaveBeenCalledTimes(1);\n      expect(global.clearInterval).toHaveBeenCalledTimes(0);\n\n      // clearTimeout()\n      timers.runWithRealTimers(() => {\n        (global as any).clearTimeout();\n      });\n      expect(nativeClearTimeout).toHaveBeenCalledTimes(1);\n      expect(global.clearTimeout).toHaveBeenCalledTimes(0);\n\n      // setInterval()\n      timers.runWithRealTimers(() => {\n        (global as any).setInterval();\n      });\n      expect(nativeSetInterval).toHaveBeenCalledTimes(1);\n      expect(global.setInterval).toHaveBeenCalledTimes(0);\n\n      // setTimeout()\n      timers.runWithRealTimers(() => {\n        (global as any).setTimeout();\n      });\n      expect(nativeSetTimeout).toHaveBeenCalledTimes(1);\n      expect(global.setTimeout).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets mock timers after executing callback', () => {\n      const nativeClearInterval = jest.fn();\n      const nativeClearTimeout = jest.fn();\n      const nativeSetInterval = jest.fn();\n      const nativeSetTimeout = jest.fn();\n\n      const global = {\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        process,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      // clearInterval()\n      timers.runWithRealTimers(() => {\n        (global as any).clearInterval();\n      });\n      expect(nativeClearInterval).toHaveBeenCalledTimes(1);\n      expect(global.clearInterval).toHaveBeenCalledTimes(0);\n\n      (global as any).clearInterval();\n      expect(nativeClearInterval).toHaveBeenCalledTimes(1);\n      expect(global.clearInterval).toHaveBeenCalledTimes(1);\n\n      // clearTimeout()\n      timers.runWithRealTimers(() => {\n        (global as any).clearTimeout();\n      });\n      expect(nativeClearTimeout).toHaveBeenCalledTimes(1);\n      expect(global.clearTimeout).toHaveBeenCalledTimes(0);\n\n      (global as any).clearTimeout();\n      expect(nativeClearTimeout).toHaveBeenCalledTimes(1);\n      expect(global.clearTimeout).toHaveBeenCalledTimes(1);\n\n      // setInterval()\n      timers.runWithRealTimers(() => {\n        (global as any).setInterval();\n      });\n      expect(nativeSetInterval).toHaveBeenCalledTimes(1);\n      expect(global.setInterval).toHaveBeenCalledTimes(0);\n\n      (global as any).setInterval();\n      expect(nativeSetInterval).toHaveBeenCalledTimes(1);\n      expect(global.setInterval).toHaveBeenCalledTimes(1);\n\n      // setTimeout()\n      timers.runWithRealTimers(() => {\n        (global as any).setTimeout();\n      });\n      expect(nativeSetTimeout).toHaveBeenCalledTimes(1);\n      expect(global.setTimeout).toHaveBeenCalledTimes(0);\n\n      (global as any).setTimeout();\n      expect(nativeSetTimeout).toHaveBeenCalledTimes(1);\n      expect(global.setTimeout).toHaveBeenCalledTimes(1);\n    });\n\n    it('resets mock timer functions even if callback throws', () => {\n      const nativeSetTimeout = jest.fn();\n      const global = {\n        process,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      expect(() => {\n        timers.runWithRealTimers(() => {\n          (global as any).setTimeout();\n          throw new Error('test');\n        });\n      }).toThrow(new Error('test'));\n      expect(nativeSetTimeout).toHaveBeenCalledTimes(1);\n      expect(global.setTimeout).toHaveBeenCalledTimes(0);\n\n      (global as any).setTimeout();\n      expect(nativeSetTimeout).toHaveBeenCalledTimes(1);\n      expect(global.setTimeout).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('useRealTimers', () => {\n    it('resets native timer APIs', () => {\n      const nativeSetTimeout = jest.fn();\n      const nativeSetInterval = jest.fn();\n      const nativeClearTimeout = jest.fn();\n      const nativeClearInterval = jest.fn();\n\n      const global = {\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        process,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      // Ensure that timers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.setTimeout).not.toBe(nativeSetTimeout);\n      expect(global.setInterval).not.toBe(nativeSetInterval);\n      expect(global.clearTimeout).not.toBe(nativeClearTimeout);\n      expect(global.clearInterval).not.toBe(nativeClearInterval);\n\n      timers.useRealTimers();\n\n      expect(global.setTimeout).toBe(nativeSetTimeout);\n      expect(global.setInterval).toBe(nativeSetInterval);\n      expect(global.clearTimeout).toBe(nativeClearTimeout);\n      expect(global.clearInterval).toBe(nativeClearInterval);\n    });\n\n    it('resets native process.nextTick when present', () => {\n      const nativeProcessNextTick = jest.fn();\n\n      const global = {\n        process: {nextTick: nativeProcessNextTick},\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      // Ensure that timers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.process.nextTick).not.toBe(nativeProcessNextTick);\n\n      timers.useRealTimers();\n\n      expect(global.process.nextTick).toBe(nativeProcessNextTick);\n    });\n\n    it('resets native setImmediate when present', () => {\n      const nativeSetImmediate = jest.fn<typeof setImmediate>();\n      const nativeClearImmediate = jest.fn<typeof clearImmediate>();\n\n      const global = {\n        clearImmediate: nativeClearImmediate,\n        process,\n        setImmediate: nativeSetImmediate,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      // Ensure that timers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.setImmediate).not.toBe(nativeSetImmediate);\n      expect(global.clearImmediate).not.toBe(nativeClearImmediate);\n\n      timers.useRealTimers();\n\n      expect(global.setImmediate).toBe(nativeSetImmediate);\n      expect(global.clearImmediate).toBe(nativeClearImmediate);\n    });\n\n    it('resets native requestAnimationFrame when present', () => {\n      const nativeCancelAnimationFrame = jest.fn();\n      const nativeRequestAnimationFrame = jest.fn();\n\n      const global = {\n        cancelAnimationFrame: nativeCancelAnimationFrame,\n        process,\n        requestAnimationFrame: nativeRequestAnimationFrame,\n      } as unknown as typeof globalThis & Window;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useFakeTimers();\n\n      // Ensure that timers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.cancelAnimationFrame).not.toBe(nativeCancelAnimationFrame);\n      expect(global.requestAnimationFrame).not.toBe(\n        nativeRequestAnimationFrame,\n      );\n\n      timers.useRealTimers();\n\n      expect(global.cancelAnimationFrame).toBe(nativeCancelAnimationFrame);\n      expect(global.requestAnimationFrame).toBe(nativeRequestAnimationFrame);\n    });\n  });\n\n  describe('useFakeTimers', () => {\n    it('resets mock timer APIs', () => {\n      const nativeSetTimeout = jest.fn();\n      const nativeSetInterval = jest.fn();\n      const nativeClearTimeout = jest.fn();\n      const nativeClearInterval = jest.fn();\n\n      const global = {\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        process,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.setTimeout).toBe(nativeSetTimeout);\n      expect(global.setInterval).toBe(nativeSetInterval);\n      expect(global.clearTimeout).toBe(nativeClearTimeout);\n      expect(global.clearInterval).toBe(nativeClearInterval);\n\n      timers.useFakeTimers();\n\n      expect(global.setTimeout).not.toBe(nativeSetTimeout);\n      expect(global.setInterval).not.toBe(nativeSetInterval);\n      expect(global.clearTimeout).not.toBe(nativeClearTimeout);\n      expect(global.clearInterval).not.toBe(nativeClearInterval);\n    });\n\n    it('resets mock process.nextTick when present', () => {\n      const nativeProcessNextTick = jest.fn();\n\n      const global = {\n        process: {nextTick: nativeProcessNextTick},\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      timers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.process.nextTick).toBe(nativeProcessNextTick);\n\n      timers.useFakeTimers();\n\n      expect(global.process.nextTick).not.toBe(nativeProcessNextTick);\n    });\n\n    it('resets mock setImmediate when present', () => {\n      const nativeSetImmediate = jest.fn<typeof setImmediate>();\n      const nativeClearImmediate = jest.fn<typeof clearImmediate>();\n\n      const global = {\n        clearImmediate: nativeClearImmediate,\n        process,\n        setImmediate: nativeSetImmediate,\n      } as unknown as typeof globalThis;\n      const fakeTimers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      fakeTimers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.setImmediate).toBe(nativeSetImmediate);\n      expect(global.clearImmediate).toBe(nativeClearImmediate);\n\n      fakeTimers.useFakeTimers();\n\n      expect(global.setImmediate).not.toBe(nativeSetImmediate);\n      expect(global.clearImmediate).not.toBe(nativeClearImmediate);\n    });\n\n    it('resets mock requestAnimationFrame when present', () => {\n      const nativeCancelAnimationFrame = jest.fn();\n      const nativeRequestAnimationFrame = jest.fn();\n\n      const global = {\n        cancelAnimationFrame: nativeCancelAnimationFrame,\n        process,\n        requestAnimationFrame: nativeRequestAnimationFrame,\n      } as unknown as typeof globalThis & Window;\n      const fakeTimers = new FakeTimers({\n        config,\n        global,\n        moduleMocker,\n        timerConfig,\n      });\n      fakeTimers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.cancelAnimationFrame).toBe(nativeCancelAnimationFrame);\n      expect(global.requestAnimationFrame).toBe(nativeRequestAnimationFrame);\n\n      fakeTimers.useFakeTimers();\n\n      expect(global.cancelAnimationFrame).not.toBe(nativeCancelAnimationFrame);\n      expect(global.requestAnimationFrame).not.toBe(\n        nativeRequestAnimationFrame,\n      );\n    });\n  });\n\n  describe('getTimerCount', () => {\n    let timers: FakeTimers<number>;\n    let fakedGlobal: typeof globalThis;\n\n    beforeEach(() => {\n      fakedGlobal = {\n        Date,\n        cancelAnimationFrame: () => {},\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => {},\n        setImmediate,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      timers = new FakeTimers({\n        config,\n        global: fakedGlobal,\n        moduleMocker,\n        timerConfig,\n      });\n    });\n\n    it('returns the correct count', () => {\n      timers.useFakeTimers();\n\n      fakedGlobal.setTimeout(() => {}, 0);\n      fakedGlobal.setTimeout(() => {}, 0);\n      fakedGlobal.setTimeout(() => {}, 10);\n\n      expect(timers.getTimerCount()).toBe(3);\n\n      timers.advanceTimersByTime(5);\n\n      expect(timers.getTimerCount()).toBe(1);\n\n      timers.advanceTimersByTime(5);\n\n      expect(timers.getTimerCount()).toBe(0);\n    });\n\n    it('includes immediates and ticks', () => {\n      timers.useFakeTimers();\n\n      fakedGlobal.setTimeout(() => {}, 0);\n      fakedGlobal.setImmediate(() => {});\n      process.nextTick(() => {});\n\n      expect(timers.getTimerCount()).toBe(3);\n    });\n\n    it('not includes cancelled immediates', () => {\n      timers.useFakeTimers();\n\n      fakedGlobal.setImmediate(() => {});\n      expect(timers.getTimerCount()).toBe(1);\n      timers.clearAllTimers();\n\n      expect(timers.getTimerCount()).toBe(0);\n    });\n\n    it('includes animation frames', () => {\n      timers.useFakeTimers();\n\n      fakedGlobal.requestAnimationFrame(() => {});\n      expect(timers.getTimerCount()).toBe(1);\n      timers.clearAllTimers();\n\n      expect(timers.getTimerCount()).toBe(0);\n    });\n  });\n\n  describe('now', () => {\n    let timers: FakeTimers<number>;\n    let fakedGlobal: typeof globalThis;\n\n    beforeEach(() => {\n      fakedGlobal = {\n        Date,\n        clearTimeout,\n        process,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      timers = new FakeTimers({\n        config,\n        global: fakedGlobal,\n        moduleMocker,\n        timerConfig,\n      });\n    });\n\n    it('returns the current clock', () => {\n      timers.useFakeTimers();\n      fakedGlobal.setTimeout(() => {}, 2);\n      fakedGlobal.setTimeout(() => {}, 100);\n\n      expect(timers.now()).toBe(0);\n\n      // This should run the 2ms timer, and then advance _now by 3ms\n      timers.advanceTimersByTime(5);\n      expect(timers.now()).toBe(5);\n\n      // Advance _now even though there are no timers to run\n      timers.advanceTimersByTime(5);\n      expect(timers.now()).toBe(10);\n\n      // Run up to the 100ms timer\n      timers.runAllTimers();\n      expect(timers.now()).toBe(100);\n\n      // Verify that runOnlyPendingTimers advances now only up to the first\n      // recursive timer\n      fakedGlobal.setTimeout(function infinitelyRecursingCallback() {\n        fakedGlobal.setTimeout(infinitelyRecursingCallback, 20);\n      }, 10);\n      timers.runOnlyPendingTimers();\n      expect(timers.now()).toBe(110);\n\n      // For legacy timers, reset() sets the clock to 0\n      timers.reset();\n      expect(timers.now()).toBe(0);\n    });\n\n    it('returns the real time if useFakeTimers is not called', () => {\n      const before = Date.now();\n      const now = timers.now();\n      const after = Date.now();\n      expect(now).toBeGreaterThanOrEqual(before);\n      expect(now).toBeLessThanOrEqual(after);\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`FakeTimers runAllTimers warns when trying to advance timers while real timers are used 1`] = `\"A function to advance timers was called but the timers APIs are not mocked with fake timers. Call \\`jest.useFakeTimers({legacyFakeTimers: true})\\` in this test file or enable fake timers for all tests by setting {'enableGlobally': true, 'legacyFakeTimers': true} in Jest configuration file.\"`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('suite with invalid assertions in afterAll', () => {\n  const {stderr, exitCode} = runJest('lifecycles');\n  expect(stderr).toMatch(/afterAll just failed!/);\n  expect(exitCode).toBe(1);\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\n'use strict';\n\nimport renderer from 'react-test-renderer';\nimport Link from '../Link';\n\nit('renders correctly', () => {\n  const tree = renderer\n    .create(<Link page=\"http://www.facebook.com\">Facebook</Link>)\n    .toJSON();\n  expect(tree).toMatchSnapshot();\n});\n\nit('renders as an anchor when no page is set', () => {\n  const tree = renderer.create(<Link>Facebook</Link>).toJSON();\n  expect(tree).toMatchSnapshot();\n});\n\nit('properly escapes quotes', () => {\n  const tree = renderer\n    .create(<Link>{\"\\\"Facebook\\\" \\\\'is \\\\ 'awesome'\"}</Link>)\n    .toJSON();\n  expect(tree).toMatchSnapshot();\n});\n\nit('changes the class when hovered', () => {\n  const component = renderer.create(\n    <Link page=\"http://www.facebook.com\">Facebook</Link>,\n  );\n  let tree = component.toJSON();\n  expect(tree).toMatchSnapshot();\n\n  // manually trigger the callback\n  renderer.act(() => {\n    tree.props.onMouseEnter();\n  });\n  // re-rendering\n  tree = component.toJSON();\n  expect(tree).toMatchSnapshot();\n\n  // manually trigger the callback\n  renderer.act(() => {\n    tree.props.onMouseLeave();\n  });\n  // re-rendering\n  tree = component.toJSON();\n  expect(tree).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`changes the class when hovered 1`] = `\n<a\n  className=\"normal\"\n  href=\"http://www.facebook.com\"\n  onMouseEnter={[Function]}\n  onMouseLeave={[Function]}\n>\n  Facebook\n</a>\n`;\n\nexports[`changes the class when hovered 2`] = `\n<a\n  className=\"hovered\"\n  href=\"http://www.facebook.com\"\n  onMouseEnter={[Function]}\n  onMouseLeave={[Function]}\n>\n  Facebook\n</a>\n`;\n\nexports[`changes the class when hovered 3`] = `\n<a\n  className=\"normal\"\n  href=\"http://www.facebook.com\"\n  onMouseEnter={[Function]}\n  onMouseLeave={[Function]}\n>\n  Facebook\n</a>\n`;\n\nexports[`properly escapes quotes 1`] = `\n<a\n  className=\"normal\"\n  href=\"#\"\n  onMouseEnter={[Function]}\n  onMouseLeave={[Function]}\n>\n  \"Facebook\" \\\\'is \\\\ 'awesome'\n</a>\n`;\n\nexports[`renders as an anchor when no page is set 1`] = `\n<a\n  className=\"normal\"\n  href=\"#\"\n  onMouseEnter={[Function]}\n  onMouseLeave={[Function]}\n>\n  Facebook\n</a>\n`;\n\nexports[`renders correctly 1`] = `\n<a\n  className=\"normal\"\n  href=\"http://www.facebook.com\"\n  onMouseEnter={[Function]}\n  onMouseLeave={[Function]}\n>\n  Facebook\n</a>\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('normal file', () => {\n  const normal = require('../ignored/normal');\n  expect(normal).toBe('ignored/normal');\n});\n\ntest('symlink', () => {\n  const symlink = require('../ignored/symlink');\n  expect(symlink).toBe('transformed');\n});"}
{"prompt":"--listTests flag,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport runJest from '../runJest';\n\nconst testRootDir = path.resolve(__dirname, '..', '..');\n\nconst normalizePaths = (rawPaths: string) =>\n  rawPaths\n    .split(testRootDir)\n    .join(`${path.sep}MOCK_ABSOLUTE_PATH`)\n    .split('\\\\')\n    .join('/');\n\ndescribe('--listTests flag', () => {\n  it('causes tests to be printed in different lines', () => {\n    const {exitCode, stdout} = runJest('list-tests', ['--listTests']);\n\n    expect(exitCode).toBe(0);\n    expect(\n      normalizePaths(stdout).split('\\n').sort().join('\\n'),\n    ).toMatchSnapshot();\n  });\n\n  it('causes tests to be printed out as JSON when using the --json flag', () => {\n    const {exitCode, stdout} = runJest('list-tests', ['--listTests', '--json']);\n\n    expect(exitCode).toBe(0);\n    expect(() => JSON.parse(stdout)).not.toThrow();\n    expect(\n      JSON.stringify(JSON.parse(stdout).map(normalizePaths).sort()),\n    ).toMatchSnapshot();\n  });\n\n  describe('--outputFile flag', () => {\n    const outputFilePath = path.resolve('.', 'test-lists.json');\n    afterAll(() => {\n      fs.unlinkSync(outputFilePath);\n    });\n    it('causes tests to be saved in the file as JSON', () => {\n      const {exitCode, stdout} = runJest('list-tests', [\n        '--listTests',\n        '--json',\n        '--outputFile',\n        outputFilePath,\n      ]);\n\n      expect(exitCode).toBe(0);\n      expect(stdout).toBe('');\n\n      const outputFileExists = fs.existsSync(outputFilePath);\n      expect(outputFileExists).toBe(true);\n\n      const outputFileContent = fs.readFileSync(outputFilePath, 'utf8');\n      expect(() => JSON.parse(outputFileContent)).not.toThrow();\n      expect(\n        JSON.stringify(\n          JSON.parse(outputFileContent).map(normalizePaths).sort(),\n        ),\n      ).toMatchSnapshot();\n    });\n\n    it('causes tests to be saved in the file in different lines', () => {\n      const {exitCode, stdout} = runJest('list-tests', [\n        '--listTests',\n        '--outputFile',\n        outputFilePath,\n      ]);\n\n      expect(exitCode).toBe(0);\n      expect(stdout).toBe('');\n\n      const outputFileExists = fs.existsSync(outputFilePath);\n      expect(outputFileExists).toBe(true);\n\n      const outputFileContent = fs.readFileSync(outputFilePath, 'utf8');\n      expect(\n        normalizePaths(outputFileContent).split('\\n').sort().join('\\n'),\n      ).toMatchSnapshot();\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`--listTests flag --outputFile flag causes tests to be saved in the file as JSON 1`] = `\"[\"/MOCK_ABSOLUTE_PATH/e2e/list-tests/__tests__/dummy.test.js\",\"/MOCK_ABSOLUTE_PATH/e2e/list-tests/__tests__/other.test.js\"]\"`;\n\nexports[`--listTests flag --outputFile flag causes tests to be saved in the file in different lines 1`] = `\n\"/MOCK_ABSOLUTE_PATH/e2e/list-tests/__tests__/dummy.test.js\n/MOCK_ABSOLUTE_PATH/e2e/list-tests/__tests__/other.test.js\"\n`;\n\nexports[`--listTests flag causes tests to be printed in different lines 1`] = `\n\"/MOCK_ABSOLUTE_PATH/e2e/list-tests/__tests__/dummy.test.js\n/MOCK_ABSOLUTE_PATH/e2e/list-tests/__tests__/other.test.js\"\n`;\n\nexports[`--listTests flag causes tests to be printed out as JSON when using the --json flag 1`] = `\"[\"/MOCK_ABSOLUTE_PATH/e2e/list-tests/__tests__/dummy.test.js\",\"/MOCK_ABSOLUTE_PATH/e2e/list-tests/__tests__/other.test.js\"]\"`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst loader = require('../loader');\n\ntest('loader should load a module', () => {\n  expect(loader('../example.js')).toBeTruthy();\n});"}
{"prompt":"defaults to null for location,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {isJestJasmineRun} from '@jest/test-utils';\nimport {json as runWithJson} from '../runJest';\n\nit('defaults to null for location', () => {\n  const {json: result} = runWithJson('location-in-results');\n\n  const assertions = result.testResults[0].assertionResults;\n  expect(result.success).toBe(true);\n  expect(result.numTotalTests).toBe(10);\n  expect(assertions).toHaveLength(10);\n  for (const assertion of assertions) {\n    expect(assertion.location).toBeNull();\n  }\n});\n\nit('adds correct location info when provided with flag', () => {\n  const {json: result} = runWithJson('location-in-results', [\n    '--testLocationInResults',\n  ]);\n\n  const assertions = result.testResults[0].assertionResults;\n  expect(result.success).toBe(true);\n  expect(result.numTotalTests).toBe(10);\n\n  expect(assertions[0].location).toEqual({\n    column: 1,\n    line: 10,\n  });\n\n  expect(assertions[1].location).toEqual({\n    column: 1,\n    line: 14,\n  });\n\n  expect(assertions[2].location).toEqual({\n    column: 1,\n    line: 19,\n  });\n\n  expect(assertions[3].location).toEqual({\n    column: 22,\n    line: 23,\n  });\n\n  expect(assertions[4].location).toEqual({\n    column: 22,\n    line: 23,\n  });\n\n  // Technically the column should be 3, but callsites is not correct.\n  // jest-circus uses stack-utils + asyncErrors which resolves this.\n  expect(assertions[5].location).toEqual({\n    column: isJestJasmineRun() ? 2 : 3,\n    line: 28,\n  });\n\n  expect(assertions[6].location).toEqual({\n    column: isJestJasmineRun() ? 2 : 3,\n    line: 32,\n  });\n\n  expect(assertions[7].location).toEqual({\n    column: isJestJasmineRun() ? 2 : 3,\n    line: 37,\n  });\n\n  expect(assertions[8].location).toEqual({\n    column: 24,\n    line: 41,\n  });\n\n  expect(assertions[9].location).toEqual({\n    column: 24,\n    line: 41,\n  });\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\nimport lodash from 'lodash';\n\ntest('if lodash head is mocked', () => {\n  expect(lodash.head([2, 3])).toBe(5);\n});"}
{"prompt":"prints the jest version, async  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {WriteStream} from 'tty';\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport logDebugMessages from '../logDebugMessages';\n\njest.mock('../../../package.json', () => ({version: 123}));\n\njest.mock('myRunner', () => ({name: 'My Runner'}), {virtual: true});\n\nconst getOutputStream = (resolve: (message: string) => void) =>\n  ({\n    write(message: string) {\n      resolve(message);\n    },\n  }) as WriteStream;\n\nit('prints the jest version', async () => {\n  expect.assertions(1);\n  const message = await new Promise<string>(resolve => {\n    logDebugMessages(\n      makeGlobalConfig({watch: true}),\n      makeProjectConfig({testRunner: 'myRunner'}),\n      getOutputStream(resolve),\n    );\n  });\n\n  expect(JSON.parse(message).version).toBe(123);\n});\n\nit('prints the test framework name', async () => {\n  expect.assertions(1);\n  const message = await new Promise<string>(resolve => {\n    logDebugMessages(\n      makeGlobalConfig({watch: true}),\n      makeProjectConfig({testRunner: 'myRunner'}),\n      getOutputStream(resolve),\n    );\n  });\n\n  expect(JSON.parse(message).configs.testRunner).toBe('myRunner');\n});\n\nit('prints the config object', async () => {\n  expect.assertions(1);\n  const globalConfig = makeGlobalConfig({\n    watch: true,\n  });\n  const config = makeProjectConfig({\n    automock: false,\n    rootDir: '/path/to/dir',\n    roots: ['path/to/dir/test'],\n    testRunner: 'myRunner',\n  });\n  const message = await new Promise<string>(resolve => {\n    logDebugMessages(globalConfig, config, getOutputStream(resolve));\n  });\n  expect(message).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`prints the config object 1`] = `\n\"{\n  \"configs\": {\n    \"automock\": false,\n    \"cache\": false,\n    \"cacheDirectory\": \"/test_cache_dir/\",\n    \"clearMocks\": false,\n    \"collectCoverageFrom\": [\n      \"src\",\n      \"!public\"\n    ],\n    \"coverageDirectory\": \"coverage\",\n    \"coveragePathIgnorePatterns\": [],\n    \"coverageReporters\": [],\n    \"cwd\": \"/test_root_dir/\",\n    \"detectLeaks\": false,\n    \"detectOpenHandles\": false,\n    \"errorOnDeprecated\": false,\n    \"extensionsToTreatAsEsm\": [],\n    \"fakeTimers\": {\n      \"enableGlobally\": false\n    },\n    \"forceCoverageMatch\": [],\n    \"globals\": {},\n    \"haste\": {},\n    \"id\": \"test_name\",\n    \"injectGlobals\": true,\n    \"moduleDirectories\": [],\n    \"moduleFileExtensions\": [\n      \"js\"\n    ],\n    \"moduleNameMapper\": [],\n    \"modulePathIgnorePatterns\": [],\n    \"modulePaths\": [],\n    \"openHandlesTimeout\": 1000,\n    \"prettierPath\": \"prettier\",\n    \"reporters\": [\n      \"default\",\n      \"custom-reporter-1\",\n      [\n        \"custom-reporter-2\",\n        {\n          \"configValue\": true\n        }\n      ]\n    ],\n    \"resetMocks\": false,\n    \"resetModules\": false,\n    \"restoreMocks\": false,\n    \"rootDir\": \"/path/to/dir\",\n    \"roots\": [\n      \"path/to/dir/test\"\n    ],\n    \"runner\": \"jest-runner\",\n    \"runtime\": \"/test_module_loader_path\",\n    \"sandboxInjectedGlobals\": [],\n    \"setupFiles\": [],\n    \"setupFilesAfterEnv\": [],\n    \"skipFilter\": false,\n    \"skipNodeResolution\": false,\n    \"slowTestThreshold\": 5,\n    \"snapshotFormat\": {},\n    \"snapshotSerializers\": [],\n    \"testEnvironment\": \"node\",\n    \"testEnvironmentOptions\": {},\n    \"testLocationInResults\": false,\n    \"testMatch\": [],\n    \"testPathIgnorePatterns\": [],\n    \"testRegex\": [\n      \"\\\\\\\\.test\\\\\\\\.js$\"\n    ],\n    \"testRunner\": \"myRunner\",\n    \"testTimeout\": 5000,\n    \"transform\": [],\n    \"transformIgnorePatterns\": [],\n    \"waitNextEventLoopTurnForUnhandledRejectionEvents\": false,\n    \"watchPathIgnorePatterns\": []\n  },\n  \"globalConfig\": {\n    \"bail\": 0,\n    \"changedFilesWithAncestor\": false,\n    \"changedSince\": \"\",\n    \"ci\": false,\n    \"collectCoverage\": false,\n    \"collectCoverageFrom\": [],\n    \"coverageDirectory\": \"coverage\",\n    \"coverageProvider\": \"babel\",\n    \"coverageReporters\": [],\n    \"coverageThreshold\": {\n      \"global\": {}\n    },\n    \"detectLeaks\": false,\n    \"detectOpenHandles\": false,\n    \"errorOnDeprecated\": false,\n    \"expand\": false,\n    \"findRelatedTests\": false,\n    \"forceExit\": false,\n    \"json\": false,\n    \"lastCommit\": false,\n    \"listTests\": false,\n    \"logHeapUsage\": false,\n    \"maxConcurrency\": 5,\n    \"maxWorkers\": 2,\n    \"noStackTrace\": false,\n    \"nonFlagArgs\": [],\n    \"notify\": false,\n    \"notifyMode\": \"failure-change\",\n    \"onlyChanged\": false,\n    \"onlyFailures\": false,\n    \"openHandlesTimeout\": 1000,\n    \"passWithNoTests\": false,\n    \"projects\": [],\n    \"reporters\": [],\n    \"rootDir\": \"/test_root_dir/\",\n    \"runInBand\": false,\n    \"runTestsByPath\": false,\n    \"seed\": 1234,\n    \"silent\": false,\n    \"skipFilter\": false,\n    \"snapshotFormat\": {},\n    \"testFailureExitCode\": 1,\n    \"testNamePattern\": \"\",\n    \"testPathPatterns\": [],\n    \"testSequencer\": \"@jest/test-sequencer\",\n    \"testTimeout\": 5000,\n    \"updateSnapshot\": \"none\",\n    \"useStderr\": false,\n    \"verbose\": false,\n    \"waitNextEventLoopTurnForUnhandledRejectionEvents\": false,\n    \"watch\": true,\n    \"watchAll\": false,\n    \"watchPlugins\": [],\n    \"watchman\": false\n  },\n  \"version\": 123\n}\n\"\n`;"}
{"prompt":"retryTimes set,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nlet i = 0;\njest.retryTimes(3, {logErrorsBeforeRetry: true});\nit('retryTimes set', () => {\n  i++;\n  if (i === 3) {\n    expect(true).toBeTruthy();\n  } else {\n    expect(true).toBeFalsy();\n  }\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (\n  require('jest-runtime/src/__tests__/test_root/RegularModule').getModuleStateValue()\n) {\n  console.log('Hello, world!');\n} else {\n  console.log('Automocking is not properly disabled in jest-runtime.');\n}"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'log_heap_usage_test');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('logs memory usage', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': \"test('banana', () => expect(1).toBe(1));\",\n    'package.json': JSON.stringify({jest: {testEnvironment: 'node'}}),\n  });\n\n  const {stderr} = runJest(DIR, ['--logHeapUsage']);\n  expect(stderr).toMatch(/PASS\\s__tests__\\/a-banana.js.*\\d+ MB heap size/);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {jest} from '@jest/globals';\n\ntest('should have a fresh module state in each isolateModulesAsync context', async () => {\n  await jest.isolateModulesAsync(async () => {\n    const {getState, incState} = await import('../main.js');\n    expect(getState()).toBe(0);\n    incState();\n    expect(getState()).toBe(1);\n  });\n  await jest.isolateModulesAsync(async () => {\n    const {getState, incState} = await import('../main.js');\n    expect(getState()).toBe(0);\n    incState();\n    expect(getState()).toBe(1);\n  });\n});"}
{"prompt":"If the module cannot be loaded, use a dummy value. There is one test","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nlet OnlyRequiredFromMock;\nlet moduleStateValue = 'default';\n\ntry {\n  OnlyRequiredFromMock = jest.requireActual('OnlyRequiredFromMock');\n} catch {\n  // If the module cannot be loaded, use a dummy value. There is one test\n  // that specifically tests for the correct value which ensures this feature\n  // works. If the feature is broken, it doesn't cause additional log-spew in\n  // surrounding tests.\n  OnlyRequiredFromMock = {value: 'module OnlyRequiredFromMock not found'};\n}\n\nfunction setModuleStateValue(value) {\n  moduleStateValue = value;\n}\n\nfunction getModuleStateValue() {\n  return moduleStateValue;\n}\n\nexports.onlyRequiredFromMockModuleValue = OnlyRequiredFromMock.value;\nexports.getModuleStateValue = getModuleStateValue;\nexports.isManualMockModule = true;\nexports.setModuleStateValue = setModuleStateValue;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports = {\n  test: () => '42',\n};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports = 'mapped_module';"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {type Context, toMatchSnapshot} from '..';\n\ntest('returns matcher name, expected and actual values', () => {\n  const mockedContext = {\n    snapshotState: {\n      match: () => ({actual: 'a', expected: 'b'}),\n    },\n  } as unknown as Context;\n\n  const matcherResult = toMatchSnapshot.call(mockedContext, {\n    a: 1,\n  });\n\n  expect(matcherResult).toEqual(\n    expect.objectContaining({\n      actual: 'a',\n      expected: 'b',\n      name: 'toMatchSnapshot',\n    }),\n  );\n});"}
{"prompt":"toContain,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {fc, it} from '@fast-check/jest';\nimport expect from '..';\nimport {\n  anythingSettings,\n  assertSettings,\n} from './__arbitraries__/sharedSettings';\n\ndescribe('toContain', () => {\n  it.prop(\n    [\n      fc.array(fc.anything(anythingSettings)),\n      fc.array(fc.anything(anythingSettings)),\n      fc.anything(anythingSettings).filter(v => !Number.isNaN(v)),\n    ],\n    assertSettings,\n  )(\n    'should always find the value when inside the array',\n    (startValues, endValues, v) => {\n      // Given: startValues, endValues arrays and v value (not NaN)\n      expect([...startValues, v, ...endValues]).toContain(v);\n    },\n  );\n\n  it.prop(\n    [\n      fc.array(fc.anything(anythingSettings)),\n      fc.array(fc.anything(anythingSettings)),\n      fc.clone(fc.anything(anythingSettings), 2),\n    ],\n    assertSettings,\n  )(\n    'should not find the value if it has been cloned into the array',\n    (startValues, endValues, [a, b]) => {\n      // Given: startValues, endValues arrays\n      //        and [a, b] equal, but not the same values\n      //        with `typeof a === 'object && a !== null`\n      fc.pre(typeof a === 'object' && a !== null);\n      expect([...startValues, a, ...endValues]).not.toContain(b);\n    },\n  );\n});"}
{"prompt":"toContainEqual,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {fc, it} from '@fast-check/jest';\nimport expect from '..';\nimport {\n  anythingSettings,\n  assertSettings,\n} from './__arbitraries__/sharedSettings';\n\ndescribe('toContainEqual', () => {\n  it.prop(\n    [\n      fc.array(fc.anything(anythingSettings)),\n      fc.array(fc.anything(anythingSettings)),\n      fc.anything(anythingSettings),\n    ],\n    assertSettings,\n  )(\n    'should always find the value when inside the array',\n    (startValues, endValues, v) => {\n      // Given: startValues, endValues arrays and v any value\n      expect([...startValues, v, ...endValues]).toContainEqual(v);\n    },\n  );\n\n  it.prop(\n    [\n      fc.array(fc.anything(anythingSettings)),\n      fc.array(fc.anything(anythingSettings)),\n      fc.clone(fc.anything(anythingSettings), 2),\n    ],\n    assertSettings,\n  )(\n    'should always find the value when cloned inside the array',\n    (startValues, endValues, [a, b]) => {\n      // Given: startValues, endValues arrays\n      //        and [a, b] identical values\n      expect([...startValues, a, ...endValues]).toContainEqual(b);\n    },\n  );\n});"}
{"prompt":"toEqual,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {fc, it} from '@fast-check/jest';\nimport expect from '..';\nimport {\n  anythingSettings,\n  assertSettings,\n} from './__arbitraries__/sharedSettings';\n\ndescribe('toEqual', () => {\n  it.prop([fc.clone(fc.anything(anythingSettings), 2)], assertSettings)(\n    'should be reflexive',\n    ([a, b]) => {\n      // Given: a and b identical values\n      expect(a).toEqual(b);\n    },\n  );\n\n  const safeExpectEqual = (a: unknown, b: unknown) => {\n    try {\n      expect(a).toEqual(b);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n\n  it.prop([fc.anything(anythingSettings), fc.anything(anythingSettings)], {\n    ...assertSettings,\n    examples: [\n      [0, 5e-324], // Issue #7941\n      // [\n      //   new Set([false, true]),\n      //   new Set([new Boolean(true), new Boolean(true)]),\n      // ], // Issue #7975\n    ],\n  })('should be symmetric', (a, b) => {\n    // Given:  a and b values\n    // Assert: We expect `expect(a).toEqual(b)`\n    //         to be equivalent to `expect(b).toEqual(a)`\n    expect(safeExpectEqual(a, b)).toBe(safeExpectEqual(b, a));\n  });\n});"}
{"prompt":"toStrictEqual,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {strict as assert} from 'assert';\nimport {fc, it} from '@fast-check/jest';\nimport expect from '..';\nimport {\n  anythingSettings,\n  assertSettings,\n} from './__arbitraries__/sharedSettings';\n\ndescribe('toStrictEqual', () => {\n  const safeExpectStrictEqual = (a: unknown, b: unknown) => {\n    try {\n      expect(a).toStrictEqual(b);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n  const safeAssertDeepStrictEqual = (a: unknown, b: unknown) => {\n    try {\n      assert.deepStrictEqual(a, b);\n      return true;\n    } catch {\n      return false;\n    }\n  };\n\n  it.prop([fc.clone(fc.anything(anythingSettings), 2)], assertSettings)(\n    'should be reflexive',\n    ([a, b]) => {\n      // Given: a and b identical values\n      expect(a).toStrictEqual(b);\n    },\n  );\n\n  it.prop(\n    [fc.anything(anythingSettings), fc.anything(anythingSettings)],\n    assertSettings,\n  )('should be symmetric', (a, b) => {\n    // Given:  a and b values\n    // Assert: We expect `expect(a).toStrictEqual(b)`\n    //         to be equivalent to `expect(b).toStrictEqual(a)`\n    expect(safeExpectStrictEqual(a, b)).toBe(safeExpectStrictEqual(b, a));\n  });\n\n  it.prop(\n    [fc.anything(anythingSettings), fc.anything(anythingSettings)],\n    assertSettings,\n  )('should be equivalent to Node deepStrictEqual', (a, b) => {\n    expect(safeExpectStrictEqual(a, b)).toBe(safeAssertDeepStrictEqual(a, b));\n  });\n});"}
{"prompt":"should throw if passed two arguments,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst chalk = require('chalk');\nconst Immutable = require('immutable');\nconst {alignedAnsiStyleSerializer} = require('@jest/test-utils');\nconst {stringify} = require('jest-matcher-utils');\nconst {expect: jestExpect} = require('../');\nconst chalkEnabled = chalk.enabled;\n\nexpect.addSnapshotSerializer(alignedAnsiStyleSerializer);\n\njestExpect.extend({\n  optionalFn(fn) {\n    const pass = fn === undefined || typeof fn === 'function';\n    return {message: () => 'expect either a function or undefined', pass};\n  },\n});\n\nbeforeAll(() => {\n  chalk.enabled = true;\n});\n\nafterAll(() => {\n  chalk.enabled = chalkEnabled;\n});\n\nit('should throw if passed two arguments', () => {\n  expect(() => jestExpect('foo', 'bar')).toThrow(\n    new Error('Expect takes at most one argument.'),\n  );\n});\n\ndescribe('.rejects', () => {\n  it('should reject', async () => {\n    await jestExpect(Promise.reject(4)).rejects.toBe(4);\n    await jestExpect(Promise.reject(4)).rejects.not.toBe(5);\n    await jestExpect(Promise.reject(4.2)).rejects.toBeCloseTo(4.2, 5);\n    await jestExpect(Promise.reject(3)).rejects.not.toBeCloseTo(4.2, 5);\n    await jestExpect(Promise.reject({a: 1, b: 2})).rejects.toMatchObject({\n      a: 1,\n    });\n    await jestExpect(Promise.reject({a: 1, b: 2})).rejects.not.toMatchObject({\n      c: 1,\n    });\n    await jestExpect(\n      Promise.reject(new Error('rejectMessage')),\n    ).rejects.toMatchObject({message: 'rejectMessage'});\n    await jestExpect(Promise.reject(new Error())).rejects.toThrow();\n  });\n\n  it('should reject with toThrow', async () => {\n    async function fn() {\n      throw new Error('some error');\n    }\n    await jestExpect(fn()).rejects.toThrow('some error');\n  });\n\n  it('should reject async function to toThrow', async () => {\n    await jestExpect(async () => {\n      throw new Error('Test');\n    }).rejects.toThrow('Test');\n  });\n\n  for (const value of ['a', [1], () => {}, {a: 1}]) {\n    it(`fails non-promise value ${stringify(value)} synchronously`, () => {\n      let error;\n      try {\n        jestExpect(value).rejects.toBe(111);\n      } catch (rejectedError) {\n        error = rejectedError;\n      }\n      expect(error).toBeDefined();\n    });\n\n    it(`fails non-promise value ${stringify(value)}`, async () => {\n      let error;\n      try {\n        await jestExpect(value).rejects.toBeDefined();\n      } catch (rejectedError) {\n        error = rejectedError;\n      }\n      expect(error).toBeDefined();\n      expect(error.message).toMatchSnapshot();\n    });\n  }\n\n  for (const value of [4, null, true, undefined]) {\n    it(`fails non-promise value ${stringify(value)} synchronously`, () => {\n      let error;\n      try {\n        jestExpect(value).rejects.not.toBe(111);\n      } catch (rejectedError) {\n        error = rejectedError;\n      }\n      expect(error).toBeDefined();\n    });\n\n    it(`fails non-promise value ${stringify(value)}`, async () => {\n      let error;\n      try {\n        await jestExpect(value).rejects.not.toBeDefined();\n      } catch (rejectedError) {\n        error = rejectedError;\n      }\n      expect(error).toBeDefined();\n      expect(error.message).toMatchSnapshot();\n    });\n  }\n\n  it('fails for promise that resolves', async () => {\n    let error;\n    try {\n      await jestExpect(Promise.resolve(4)).rejects.toBe(4);\n    } catch (error_) {\n      error = error_;\n    }\n    expect(error).toBeDefined();\n    expect(error.message).toMatchSnapshot();\n  });\n});\n\ndescribe('.resolves', () => {\n  it('should resolve', async () => {\n    await jestExpect(Promise.resolve(4)).resolves.toBe(4);\n    await jestExpect(Promise.resolve(4)).resolves.not.toBe(5);\n    await jestExpect(Promise.resolve(4.2)).resolves.toBeCloseTo(4.2, 5);\n    await jestExpect(Promise.resolve(3)).resolves.not.toBeCloseTo(4.2, 5);\n    await jestExpect(Promise.resolve({a: 1, b: 2})).resolves.toMatchObject({\n      a: 1,\n    });\n    await jestExpect(Promise.resolve({a: 1, b: 2})).resolves.not.toMatchObject({\n      c: 1,\n    });\n    await jestExpect(\n      Promise.resolve(() => {\n        throw new Error();\n      }),\n    ).resolves.toThrow();\n  });\n\n  for (const value of ['a', [1], () => {}, {a: 1}]) {\n    it(`fails non-promise value ${stringify(value)} synchronously`, () => {\n      let error;\n      try {\n        jestExpect(value).resolves.toBeDefined();\n      } catch (rejectedError) {\n        error = rejectedError;\n      }\n      expect(error).toBeDefined();\n      expect(error.message).toMatchSnapshot();\n    });\n\n    it(`fails non-promise value ${stringify(value)}`, async () => {\n      let error;\n      try {\n        await jestExpect(value).resolves.toBeDefined();\n      } catch (rejectedError) {\n        error = rejectedError;\n      }\n      expect(error).toBeDefined();\n      expect(error.message).toMatchSnapshot();\n    });\n  }\n\n  for (const value of [4, null, true, undefined]) {\n    it(`fails non-promise value ${stringify(value)} synchronously`, () => {\n      let error;\n      try {\n        jestExpect(value).resolves.not.toBeDefined();\n      } catch (rejectedError) {\n        error = rejectedError;\n      }\n      expect(error).toBeDefined();\n      expect(error.message).toMatchSnapshot();\n    });\n\n    it(`fails non-promise value ${stringify(value)}`, async () => {\n      let error;\n      try {\n        await jestExpect(value).resolves.not.toBeDefined();\n      } catch (rejectedError) {\n        error = rejectedError;\n      }\n      expect(error).toBeDefined();\n      expect(error.message).toMatchSnapshot();\n    });\n  }\n\n  it('fails for promise that rejects', async () => {\n    let error;\n    try {\n      await jestExpect(Promise.reject(4)).resolves.toBe(4);\n    } catch (error_) {\n      error = error_;\n    }\n    expect(error).toBeDefined();\n    expect(error.message).toMatchSnapshot();\n  });\n});\n\ndescribe('.toBe()', () => {\n  it('does not throw', () => {\n    jestExpect('a').not.toBe('b');\n    jestExpect('a').toBe('a');\n    jestExpect(1).not.toBe(2);\n    jestExpect(1).toBe(1);\n    jestExpect(null).not.toBe(undefined);\n    jestExpect(null).toBe(null);\n    jestExpect(undefined).toBe(undefined);\n    jestExpect(NaN).toBe(NaN);\n    jestExpect(BigInt(1)).not.toBe(BigInt(2));\n    jestExpect(BigInt(1)).not.toBe(1);\n    jestExpect(BigInt(1)).toBe(BigInt(1));\n  });\n\n  for (const [a, b] of [\n    [1, 2],\n    [true, false],\n    [() => {}, () => {}],\n    [{}, {}],\n    [{a: 1}, {a: 1}],\n    [{a: 1}, {a: 5}],\n    [\n      {a: () => {}, b: 2},\n      {a: expect.any(Function), b: 2},\n    ],\n    [{a: undefined, b: 2}, {b: 2}],\n    [new Date('2020-02-20'), new Date('2020-02-20')],\n    [new Date('2020-02-21'), new Date('2020-02-20')],\n    [/received/, /expected/],\n    [Symbol('received'), Symbol('expected')],\n    [new Error('received'), new Error('expected')],\n    ['abc', 'cde'],\n    ['painless JavaScript testing', 'delightful JavaScript testing'],\n    ['', 'compare one-line string to empty string'],\n    ['with \\ntrailing space', 'without trailing space'],\n    ['four\\n4\\nline\\nstring', '3\\nline\\nstring'],\n    [[], []],\n    [null, undefined],\n    [-0, +0],\n  ]) {\n    it(`fails for: ${stringify(a)} and ${stringify(b)}`, () => {\n      expect(() => jestExpect(a).toBe(b)).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const [a, b] of [\n    [BigInt(1), BigInt(2)],\n    [{a: BigInt(1)}, {a: BigInt(1)}],\n  ]) {\n    it(`fails for: ${stringify(a)} and ${stringify(b)}`, () => {\n      expect(() => jestExpect(a).toBe(b)).toThrow('toBe');\n    });\n  }\n\n  for (const v of [false, 1, 'a', undefined, null, {}, []]) {\n    it(`fails for '${stringify(v)}' with '.not'`, () => {\n      expect(() => jestExpect(v).not.toBe(v)).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const v of [BigInt(1), BigInt('1')]) {\n    it(`fails for '${stringify(v)}' with '.not'`, () => {\n      expect(() => jestExpect(v).not.toBe(v)).toThrow('toBe');\n    });\n  }\n\n  it('does not crash on circular references', () => {\n    const obj = {};\n    obj.circular = obj;\n\n    expect(() => jestExpect(obj).toBe({})).toThrowErrorMatchingSnapshot();\n  });\n\n  test('assertion error matcherResult property contains matcher name, expected and actual values', () => {\n    const actual = {a: 1};\n    const expected = {a: 2};\n    try {\n      jestExpect(actual).toBe(expected);\n    } catch (error) {\n      expect(error.matcherResult).toEqual(\n        expect.objectContaining({\n          actual,\n          expected,\n          name: 'toBe',\n        }),\n      );\n    }\n  });\n});\n\ndescribe('.toStrictEqual()', () => {\n  class TestClassA {\n    constructor(a, b) {\n      this.a = a;\n      this.b = b;\n    }\n  }\n\n  class TestClassB {\n    constructor(a, b) {\n      this.a = a;\n      this.b = b;\n    }\n  }\n\n  const TestClassC = class Child extends TestClassA {\n    constructor(a, b) {\n      super(a, b);\n    }\n  };\n\n  const TestClassD = class Child extends TestClassB {\n    constructor(a, b) {\n      super(a, b);\n    }\n  };\n\n  it('does not ignore keys with undefined values', () => {\n    expect({\n      a: undefined,\n      b: 2,\n    }).not.toStrictEqual({b: 2});\n  });\n\n  it('does not ignore keys with undefined values inside an array', () => {\n    expect([{a: undefined}]).not.toStrictEqual([{}]);\n  });\n\n  it('does not ignore keys with undefined values deep inside an object', () => {\n    expect([{a: [{a: undefined}]}]).not.toStrictEqual([{a: [{}]}]);\n  });\n\n  it('does not consider holes as undefined in sparse arrays', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    expect([, , , 1, , ,]).not.toStrictEqual([, , , 1, undefined, ,]);\n  });\n\n  it('passes when comparing same type', () => {\n    expect({\n      test: new TestClassA(1, 2),\n    }).toStrictEqual({test: new TestClassA(1, 2)});\n  });\n\n  it('matches the expected snapshot when it fails', () => {\n    expect(() =>\n      jestExpect({\n        test: 2,\n      }).toStrictEqual({test: new TestClassA(1, 2)}),\n    ).toThrowErrorMatchingSnapshot();\n\n    expect(() =>\n      jestExpect({\n        test: new TestClassA(1, 2),\n      }).not.toStrictEqual({test: new TestClassA(1, 2)}),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  it('displays substring diff', () => {\n    const expected =\n      'Another caveat is that Jest will not typecheck your tests.';\n    const received =\n      'Because TypeScript support in Babel is just transpilation, Jest will not type-check your tests as they run.';\n    expect(() =>\n      jestExpect(received).toStrictEqual(expected),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  it('displays substring diff for multiple lines', () => {\n    const expected = [\n      '    69 | ',\n      \"    70 | test('assert.doesNotThrow', () => {\",\n      '  > 71 |   assert.doesNotThrow(() => {',\n      '       |          ^',\n      \"    72 |     throw Error('err!');\",\n      '    73 |   });',\n      '    74 | });',\n      '    at Object.doesNotThrow (__tests__/assertionError.test.js:71:10)',\n    ].join('\\n');\n    const received = [\n      '    68 | ',\n      \"    69 | test('assert.doesNotThrow', () => {\",\n      '  > 70 |   assert.doesNotThrow(() => {',\n      '       |          ^',\n      \"    71 |     throw Error('err!');\",\n      '    72 |   });',\n      '    73 | });',\n      '    at Object.doesNotThrow (__tests__/assertionError.test.js:70:10)',\n    ].join('\\n');\n    expect(() =>\n      jestExpect(received).toStrictEqual(expected),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  it('does not pass for different types', () => {\n    expect({\n      test: new TestClassA(1, 2),\n    }).not.toStrictEqual({test: new TestClassB(1, 2)});\n  });\n\n  it('does not simply compare constructor names', () => {\n    const c = new TestClassC(1, 2);\n    const d = new TestClassD(1, 2);\n    expect(c.constructor.name).toEqual(d.constructor.name);\n    expect({test: c}).not.toStrictEqual({test: d});\n  });\n\n  /* eslint-disable no-sparse-arrays */\n  it('passes for matching sparse arrays', () => {\n    expect([, 1]).toStrictEqual([, 1]);\n  });\n\n  it('does not pass when sparseness of arrays do not match', () => {\n    expect([, 1]).not.toStrictEqual([undefined, 1]);\n    expect([undefined, 1]).not.toStrictEqual([, 1]);\n    expect([, , , 1]).not.toStrictEqual([, 1]);\n  });\n\n  it('does not pass when equally sparse arrays have different values', () => {\n    expect([, 1]).not.toStrictEqual([, 2]);\n  });\n\n  it('does not pass when ArrayBuffers are not equal', () => {\n    expect(Uint8Array.from([1, 2]).buffer).not.toStrictEqual(\n      Uint8Array.from([0, 0]).buffer,\n    );\n    expect(Uint8Array.from([2, 1]).buffer).not.toStrictEqual(\n      Uint8Array.from([2, 2]).buffer,\n    );\n    expect(Uint8Array.from([]).buffer).not.toStrictEqual(\n      Uint8Array.from([1]).buffer,\n    );\n  });\n\n  it('passes for matching buffers', () => {\n    expect(Uint8Array.from([1]).buffer).toStrictEqual(\n      Uint8Array.from([1]).buffer,\n    );\n    expect(Uint8Array.from([]).buffer).toStrictEqual(\n      Uint8Array.from([]).buffer,\n    );\n    expect(Uint8Array.from([9, 3]).buffer).toStrictEqual(\n      Uint8Array.from([9, 3]).buffer,\n    );\n  });\n\n  it('fails for missing keys even if backed by an asymmetric matcher accepting them', () => {\n    // issue 12463\n    expect({a: 1}).not.toStrictEqual({a: 1, b: jestExpect.optionalFn()});\n    expect({a: 1, b: jestExpect.optionalFn()}).not.toStrictEqual({a: 1});\n    expect([1]).not.toStrictEqual([1, jestExpect.optionalFn()]);\n    expect([1, jestExpect.optionalFn()]).not.toStrictEqual([1]);\n  });\n\n  it('passes if keys are present and asymmetric matcher accept them', () => {\n    // issue 12463\n    // with a proper function\n    expect({a: 1, b: () => {}}).toStrictEqual({\n      a: 1,\n      b: jestExpect.optionalFn(),\n    });\n    expect({a: 1, b: jestExpect.optionalFn()}).toStrictEqual({\n      a: 1,\n      b: () => {},\n    });\n    expect([1, () => {}]).toStrictEqual([1, jestExpect.optionalFn()]);\n    expect([1, jestExpect.optionalFn()]).toStrictEqual([1, () => {}]);\n    // with undefined\n    expect({a: 1, b: undefined}).toStrictEqual({\n      a: 1,\n      b: jestExpect.optionalFn(),\n    });\n    expect({a: 1, b: jestExpect.optionalFn()}).toStrictEqual({\n      a: 1,\n      b: undefined,\n    });\n    expect([1, undefined]).toStrictEqual([1, jestExpect.optionalFn()]);\n    expect([1, jestExpect.optionalFn()]).toStrictEqual([1, undefined]);\n  });\n  /* eslint-enable */\n});\n\ndescribe('.toEqual()', () => {\n  /* eslint-disable no-new-wrappers, unicorn/new-for-builtins */\n  for (const [a, b] of [\n    [true, false],\n    [1, 2],\n    [0, -0],\n    [0, Number.MIN_VALUE], // issues/7941\n    [Number.MIN_VALUE, 0],\n    [0, new Number(0)],\n    [new Number(0), 0],\n    [new Number(0), new Number(1)],\n    ['abc', new String('abc')],\n    [new String('abc'), 'abc'],\n    [/abc/gsy, /abc/g],\n    [{a: 1}, {a: 2}],\n    [{a: 5}, {b: 6}],\n    [Object.freeze({foo: {bar: 1}}), {foo: {}}],\n    [\n      {\n        get getterAndSetter() {\n          return {};\n        },\n        set getterAndSetter(value) {\n          throw new Error('noo');\n        },\n      },\n      {getterAndSetter: {foo: 'bar'}},\n    ],\n    [\n      Object.freeze({\n        get frozenGetterAndSetter() {\n          return {};\n        },\n        set frozenGetterAndSetter(value) {\n          throw new Error('noo');\n        },\n      }),\n      {frozenGetterAndSetter: {foo: 'bar'}},\n    ],\n    [\n      {\n        get getter() {\n          return {};\n        },\n      },\n      {getter: {foo: 'bar'}},\n    ],\n    [\n      Object.freeze({\n        get frozenGetter() {\n          return {};\n        },\n      }),\n      {frozenGetter: {foo: 'bar'}},\n    ],\n    [\n      {\n        // eslint-disable-next-line accessor-pairs\n        set setter(value) {\n          throw new Error('noo');\n        },\n      },\n      {setter: {foo: 'bar'}},\n    ],\n    [\n      Object.freeze({\n        // eslint-disable-next-line accessor-pairs\n        set frozenSetter(value) {\n          throw new Error('noo');\n        },\n      }),\n      {frozenSetter: {foo: 'bar'}},\n    ],\n    ['banana', 'apple'],\n    ['1\\u{00A0}234,57\\u{00A0}$', '1 234,57 $'], // issues/6881\n    [\n      'type TypeName<T> = T extends Function ? \"function\" : \"object\";',\n      'type TypeName<T> = T extends Function\\n? \"function\"\\n: \"object\";',\n    ],\n    [null, undefined],\n    [[1], [2]],\n    [\n      [1, 2],\n      [2, 1],\n    ],\n    [Immutable.List([1]), Immutable.List([2])],\n    [Immutable.List([1, 2]), Immutable.List([2, 1])],\n    [new Map(), new Set()],\n    [new Set([1, 2]), new Set()],\n    [new Set([1, 2]), new Set([1, 2, 3])],\n    [new Set([[1], [2]]), new Set([[1], [2], [3]])],\n    [new Set([[1], [2]]), new Set([[1], [2], [2]])],\n    [\n      new Set([new Set([1]), new Set([2])]),\n      new Set([new Set([1]), new Set([3])]),\n    ],\n    [Immutable.Set([1, 2]), Immutable.Set()],\n    [Immutable.Set([1, 2]), Immutable.Set([1, 2, 3])],\n    [Immutable.OrderedSet([1, 2]), Immutable.OrderedSet([2, 1])],\n    [\n      new Map([\n        [1, 'one'],\n        [2, 'two'],\n      ]),\n      new Map([[1, 'one']]),\n    ],\n    [new Map([['a', 0]]), new Map([['b', 0]])],\n    [new Map([['v', 1]]), new Map([['v', 2]])],\n    [new Map([[['v'], 1]]), new Map([[['v'], 2]])],\n    [\n      new Map([[[1], new Map([[[1], 'one']])]]),\n      new Map([[[1], new Map([[[1], 'two']])]]),\n    ],\n    [Immutable.Map({a: 0}), Immutable.Map({b: 0})],\n    [Immutable.Map({v: 1}), Immutable.Map({v: 2})],\n    [\n      Immutable.OrderedMap().set(1, 'one').set(2, 'two'),\n      Immutable.OrderedMap().set(2, 'two').set(1, 'one'),\n    ],\n    [\n      Immutable.Map({1: Immutable.Map({2: {a: 99}})}),\n      Immutable.Map({1: Immutable.Map({2: {a: 11}})}),\n    ],\n    [new Uint8Array([97, 98, 99]), new Uint8Array([97, 98, 100])],\n    [{a: 1, b: 2}, jestExpect.objectContaining({a: 2})],\n    [false, jestExpect.objectContaining({a: 2})],\n    [[1, 3], jestExpect.arrayContaining([1, 2])],\n    [1, jestExpect.arrayContaining([1, 2])],\n    ['abd', jestExpect.stringContaining('bc')],\n    ['abd', jestExpect.stringMatching(/bc/i)],\n    [undefined, jestExpect.anything()],\n    [undefined, jestExpect.any(Function)],\n    [\n      'Eve',\n      {\n        asymmetricMatch: function asymmetricMatch(who) {\n          return who === 'Alice' || who === 'Bob';\n        },\n      },\n    ],\n    [\n      {\n        target: {\n          nodeType: 1,\n          value: 'a',\n        },\n      },\n      {\n        target: {\n          nodeType: 1,\n          value: 'b',\n        },\n      },\n    ],\n    [\n      {\n        nodeName: 'div',\n        nodeType: 1,\n      },\n      {\n        nodeName: 'p',\n        nodeType: 1,\n      },\n    ],\n    [\n      {\n        [Symbol.for('foo')]: 1,\n        [Symbol.for('bar')]: 2,\n      },\n      {\n        [Symbol.for('foo')]: jestExpect.any(Number),\n        [Symbol.for('bar')]: 1,\n      },\n    ],\n    [\n      // eslint-disable-next-line no-sparse-arrays\n      [, , 1, ,],\n      // eslint-disable-next-line no-sparse-arrays\n      [, , 2, ,],\n    ],\n    [\n      Object.assign([], {4_294_967_295: 1}),\n      Object.assign([], {4_294_967_295: 2}), // issue 11056\n    ],\n    [\n      // eslint-disable-next-line no-useless-computed-key\n      Object.assign([], {['-0']: 1}),\n      // eslint-disable-next-line no-useless-computed-key\n      Object.assign([], {['0']: 1}), // issue 11056: also check (-0, 0)\n    ],\n    [\n      Object.assign([], {a: 1}),\n      Object.assign([], {b: 1}), // issue 11056: also check strings\n    ],\n    [\n      Object.assign([], {[Symbol()]: 1}),\n      Object.assign([], {[Symbol()]: 1}), // issue 11056: also check symbols\n    ],\n  ]) {\n    test(`{pass: false} expect(${stringify(a)}).toEqual(${stringify(\n      b,\n    )})`, () => {\n      expect(() => jestExpect(a).toEqual(b)).toThrowErrorMatchingSnapshot();\n      jestExpect(a).not.toEqual(b);\n    });\n  }\n\n  for (const [a, b] of [\n    [BigInt(1), BigInt(2)],\n    [BigInt(1), 1],\n  ]) {\n    test(`{pass: false} expect(${stringify(a)}).toEqual(${stringify(\n      b,\n    )})`, () => {\n      expect(() => jestExpect(a).toEqual(b)).toThrow('toEqual');\n      jestExpect(a).not.toEqual(b);\n    });\n  }\n\n  for (const [a, b] of [\n    [true, true],\n    [1, 1],\n    [NaN, NaN],\n    [0, Number(0)],\n    [Number(0), 0],\n    [new Number(0), new Number(0)],\n    ['abc', 'abc'],\n    [String('abc'), 'abc'],\n    ['abc', String('abc')],\n    [[1], [1]],\n    [\n      [1, 2],\n      [1, 2],\n    ],\n    [Immutable.List([1]), Immutable.List([1])],\n    [Immutable.List([1, 2]), Immutable.List([1, 2])],\n    [{}, {}],\n    [{a: 99}, {a: 99}],\n    [new Set(), new Set()],\n    [new Set([1, 2]), new Set([1, 2])],\n    [new Set([1, 2]), new Set([2, 1])],\n    [new Set([[1], [2]]), new Set([[2], [1]])],\n    [\n      new Set([new Set([[1]]), new Set([[2]])]),\n      new Set([new Set([[2]]), new Set([[1]])]),\n    ],\n    [new Set([[1], [2], [3], [3]]), new Set([[3], [3], [2], [1]])],\n    [new Set([{a: 1}, {b: 2}]), new Set([{b: 2}, {a: 1}])],\n    [Immutable.Set(), Immutable.Set()],\n    [Immutable.Set([1, 2]), Immutable.Set([1, 2])],\n    [Immutable.Set([1, 2]), Immutable.Set([2, 1])],\n    [Immutable.OrderedSet(), Immutable.OrderedSet()],\n    [Immutable.OrderedSet([1, 2]), Immutable.OrderedSet([1, 2])],\n    [new Map(), new Map()],\n    [\n      new Map([\n        [1, 'one'],\n        [2, 'two'],\n      ]),\n      new Map([\n        [1, 'one'],\n        [2, 'two'],\n      ]),\n    ],\n    [\n      new Map([\n        [1, 'one'],\n        [2, 'two'],\n      ]),\n      new Map([\n        [2, 'two'],\n        [1, 'one'],\n      ]),\n    ],\n    [\n      new Map([\n        [[1], 'one'],\n        [[2], 'two'],\n        [[3], 'three'],\n        [[3], 'four'],\n      ]),\n      new Map([\n        [[3], 'three'],\n        [[3], 'four'],\n        [[2], 'two'],\n        [[1], 'one'],\n      ]),\n    ],\n    [\n      new Map([\n        [[1], new Map([[[1], 'one']])],\n        [[2], new Map([[[2], 'two']])],\n      ]),\n      new Map([\n        [[2], new Map([[[2], 'two']])],\n        [[1], new Map([[[1], 'one']])],\n      ]),\n    ],\n    [\n      new Map([\n        [[1], 'one'],\n        [[2], 'two'],\n      ]),\n      new Map([\n        [[2], 'two'],\n        [[1], 'one'],\n      ]),\n    ],\n    [\n      new Map([\n        [{a: 1}, 'one'],\n        [{b: 2}, 'two'],\n      ]),\n      new Map([\n        [{b: 2}, 'two'],\n        [{a: 1}, 'one'],\n      ]),\n    ],\n    [\n      new Map([\n        [1, ['one']],\n        [2, ['two']],\n      ]),\n      new Map([\n        [2, ['two']],\n        [1, ['one']],\n      ]),\n    ],\n    [Immutable.Map(), Immutable.Map()],\n    [\n      Immutable.Map().set(1, 'one').set(2, 'two'),\n      Immutable.Map().set(1, 'one').set(2, 'two'),\n    ],\n    [\n      Immutable.Map().set(1, 'one').set(2, 'two'),\n      Immutable.Map().set(2, 'two').set(1, 'one'),\n    ],\n    [\n      Immutable.OrderedMap().set(1, 'one').set(2, 'two'),\n      Immutable.OrderedMap().set(1, 'one').set(2, 'two'),\n    ],\n    [\n      Immutable.Map({1: Immutable.Map({2: {a: 99}})}),\n      Immutable.Map({1: Immutable.Map({2: {a: 99}})}),\n    ],\n    [new Uint8Array([97, 98, 99]), new Uint8Array([97, 98, 99])],\n    [{a: 1, b: 2}, jestExpect.objectContaining({a: 1})],\n    [[1, 2, 3], jestExpect.arrayContaining([2, 3])],\n    ['abcd', jestExpect.stringContaining('bc')],\n    ['abcd', jestExpect.stringMatching('bc')],\n    [true, jestExpect.anything()],\n    [() => {}, jestExpect.any(Function)],\n    [\n      {\n        a: 1,\n        b: function b() {},\n        c: true,\n      },\n      {\n        a: 1,\n        b: jestExpect.any(Function),\n        c: jestExpect.anything(),\n      },\n    ],\n    [\n      'Alice',\n      {\n        asymmetricMatch: function asymmetricMatch(who) {\n          return who === 'Alice' || who === 'Bob';\n        },\n      },\n    ],\n    [\n      {\n        nodeName: 'div',\n        nodeType: 1,\n      },\n      {\n        nodeName: 'div',\n        nodeType: 1,\n      },\n    ],\n    [\n      {\n        [Symbol.for('foo')]: 1,\n        [Symbol.for('bar')]: 2,\n      },\n      {\n        [Symbol.for('foo')]: jestExpect.any(Number),\n        [Symbol.for('bar')]: 2,\n      },\n    ],\n    [\n      // eslint-disable-next-line no-sparse-arrays\n      [, , 1, ,],\n      // eslint-disable-next-line no-sparse-arrays\n      [, , 1, ,],\n    ],\n    [\n      // eslint-disable-next-line no-sparse-arrays\n      [, , 1, , ,],\n      // eslint-disable-next-line no-sparse-arrays\n      [, , 1, undefined, ,], // same length but hole replaced by undefined\n    ],\n    // issue 12463 - \"matcher\" vs \"proper function\"\n    [\n      {a: 1, b: () => {}},\n      {a: 1, b: jestExpect.optionalFn()},\n    ],\n    [\n      {a: 1, b: jestExpect.optionalFn()},\n      {a: 1, b: () => {}},\n    ],\n    [\n      [1, () => {}],\n      [1, jestExpect.optionalFn()],\n    ],\n    [\n      [1, jestExpect.optionalFn()],\n      [1, () => {}],\n    ],\n    // issue 12463 - \"matcher\" vs \"undefined\"\n    [\n      {a: 1, b: undefined},\n      {a: 1, b: jestExpect.optionalFn()},\n    ],\n    [\n      {a: 1, b: jestExpect.optionalFn()},\n      {a: 1, b: undefined},\n    ],\n    [\n      [1, undefined],\n      [1, jestExpect.optionalFn()],\n    ],\n    [\n      [1, jestExpect.optionalFn()],\n      [1, undefined],\n    ],\n    // issue 12463 - \"matcher\" vs \"missing\"\n    [{a: 1}, {a: 1, b: jestExpect.optionalFn()}],\n    [{a: 1, b: jestExpect.optionalFn()}, {a: 1}],\n    [[1], [1, jestExpect.optionalFn()]],\n    [[1, jestExpect.optionalFn()], [1]],\n  ]) {\n    test(`{pass: true} expect(${stringify(a)}).not.toEqual(${stringify(\n      b,\n    )})`, () => {\n      jestExpect(a).toEqual(b);\n      expect(() => jestExpect(a).not.toEqual(b)).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const [a, b] of [\n    [BigInt(1), BigInt(1)],\n    [BigInt(0), BigInt('0')],\n    [[BigInt(1)], [BigInt(1)]],\n    [\n      [BigInt(1), 2],\n      [BigInt(1), 2],\n    ],\n    [Immutable.List([BigInt(1)]), Immutable.List([BigInt(1)])],\n    [{a: BigInt(99)}, {a: BigInt(99)}],\n    [new Set([BigInt(1), BigInt(2)]), new Set([BigInt(1), BigInt(2)])],\n  ]) {\n    test(`{pass: true} expect(${stringify(a)}).not.toEqual(${stringify(\n      b,\n    )})`, () => {\n      jestExpect(a).toEqual(b);\n      expect(() => jestExpect(a).not.toEqual(b)).toThrow('toEqual');\n    });\n  }\n\n  test('assertion error matcherResult property contains matcher name, expected and actual values', () => {\n    const actual = {a: 1};\n    const expected = {a: 2};\n    try {\n      jestExpect(actual).toEqual(expected);\n    } catch (error) {\n      expect(error.matcherResult).toEqual(\n        expect.objectContaining({\n          actual,\n          expected,\n          name: 'toEqual',\n        }),\n      );\n    }\n  });\n\n  test('symbol based keys in arrays are processed correctly', () => {\n    const mySymbol = Symbol('test');\n    const actual1 = [];\n    actual1[mySymbol] = 3;\n    const actual2 = [];\n    actual2[mySymbol] = 4;\n    const expected = [];\n    expected[mySymbol] = 3;\n\n    expect(actual1).toEqual(expected);\n    expect(actual2).not.toEqual(expected);\n  });\n\n  test('non-enumerable members should be skipped during equal', () => {\n    const actual = {\n      x: 3,\n    };\n    Object.defineProperty(actual, 'test', {\n      enumerable: false,\n      value: 5,\n    });\n    expect(actual).toEqual({x: 3});\n  });\n\n  test('non-enumerable symbolic members should be skipped during equal', () => {\n    const actual = {\n      x: 3,\n    };\n    const mySymbol = Symbol('test');\n    Object.defineProperty(actual, mySymbol, {\n      enumerable: false,\n      value: 5,\n    });\n    expect(actual).toEqual({x: 3});\n  });\n\n  describe('cyclic object equality', () => {\n    test('properties with the same circularity are equal', () => {\n      const a = {};\n      a.x = a;\n      const b = {};\n      b.x = b;\n      expect(a).toEqual(b);\n      expect(b).toEqual(a);\n\n      const c = {};\n      c.x = a;\n      const d = {};\n      d.x = b;\n      expect(c).toEqual(d);\n      expect(d).toEqual(c);\n    });\n\n    test('properties with different circularity are not equal', () => {\n      const a = {};\n      a.x = {y: a};\n      const b = {};\n      const bx = {};\n      b.x = bx;\n      bx.y = bx;\n      expect(a).not.toEqual(b);\n      expect(b).not.toEqual(a);\n\n      const c = {};\n      c.x = a;\n      const d = {};\n      d.x = b;\n      expect(c).not.toEqual(d);\n      expect(d).not.toEqual(c);\n    });\n\n    test('are not equal if circularity is not on the same property', () => {\n      const a = {};\n      const b = {};\n      a.a = a;\n      b.a = {};\n      b.a.a = a;\n      expect(a).not.toEqual(b);\n      expect(b).not.toEqual(a);\n\n      const c = {};\n      c.x = {x: c};\n      const d = {};\n      d.x = d;\n      expect(c).not.toEqual(d);\n      expect(d).not.toEqual(c);\n    });\n  });\n  /* eslint-enable */\n});\n\ndescribe('.toBeInstanceOf()', () => {\n  class A {}\n  class B {}\n  class C extends B {}\n  class D extends C {}\n  class E extends D {}\n\n  class SubHasStaticNameMethod extends B {\n    constructor() {\n      super();\n    }\n    static name() {}\n  }\n\n  class HasStaticNameMethod {\n    constructor() {}\n    static name() {}\n  }\n\n  function DefinesNameProp() {}\n  Object.defineProperty(DefinesNameProp, 'name', {\n    configurable: true,\n    enumerable: false,\n    value: '',\n    writable: true,\n  });\n  class SubHasNameProp extends DefinesNameProp {}\n\n  for (const [a, b] of [\n    [new Map(), Map],\n    [[], Array],\n    [new A(), A],\n    [new C(), B], // C extends B\n    [new E(), B], // E extends … extends B\n    [new SubHasNameProp(), DefinesNameProp], // omit extends\n    [new SubHasStaticNameMethod(), B], // Received\n    [new HasStaticNameMethod(), HasStaticNameMethod], // Expected\n  ]) {\n    test(`passing ${stringify(a)} and ${stringify(b)}`, () => {\n      expect(() =>\n        jestExpect(a).not.toBeInstanceOf(b),\n      ).toThrowErrorMatchingSnapshot();\n\n      jestExpect(a).toBeInstanceOf(b);\n    });\n  }\n\n  for (const [a, b] of [\n    ['a', String],\n    [1, Number],\n    [true, Boolean],\n    [new A(), B],\n    [Object.create(null), A],\n    [undefined, String],\n    [null, String],\n    [/\\w+/, function () {}],\n    [new DefinesNameProp(), RegExp],\n  ]) {\n    test(`failing ${stringify(a)} and ${stringify(b)}`, () => {\n      expect(() =>\n        jestExpect(a).toBeInstanceOf(b),\n      ).toThrowErrorMatchingSnapshot();\n\n      jestExpect(a).not.toBeInstanceOf(b);\n    });\n  }\n\n  it('throws if constructor is not a function', () => {\n    expect(() =>\n      jestExpect({}).toBeInstanceOf(4),\n    ).toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe('.toBeTruthy(), .toBeFalsy()', () => {\n  it('does not accept arguments', () => {\n    expect(() => jestExpect(0).toBeTruthy(null)).toThrowErrorMatchingSnapshot();\n\n    expect(() =>\n      jestExpect(0).not.toBeFalsy(null),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  for (const v of [{}, [], true, 1, 'a', 0.5, new Map(), () => {}, Infinity]) {\n    test(`'${stringify(v)}' is truthy`, () => {\n      jestExpect(v).toBeTruthy();\n      jestExpect(v).not.toBeFalsy();\n\n      expect(() =>\n        jestExpect(v).not.toBeTruthy(),\n      ).toThrowErrorMatchingSnapshot();\n\n      expect(() => jestExpect(v).toBeFalsy()).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const v of [BigInt(1)]) {\n    test(`'${stringify(v)}' is truthy`, () => {\n      jestExpect(v).toBeTruthy();\n      jestExpect(v).not.toBeFalsy();\n\n      expect(() => jestExpect(v).not.toBeTruthy()).toThrow('toBeTruthy');\n\n      expect(() => jestExpect(v).toBeFalsy()).toThrow('toBeFalsy');\n    });\n  }\n\n  for (const v of [false, null, NaN, 0, '', undefined]) {\n    test(`'${stringify(v)}' is falsy`, () => {\n      jestExpect(v).toBeFalsy();\n      jestExpect(v).not.toBeTruthy();\n\n      expect(() => jestExpect(v).toBeTruthy()).toThrowErrorMatchingSnapshot();\n\n      expect(() =>\n        jestExpect(v).not.toBeFalsy(),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const v of [BigInt(0)]) {\n    test(`'${stringify(v)}' is falsy`, () => {\n      jestExpect(v).toBeFalsy();\n      jestExpect(v).not.toBeTruthy();\n\n      expect(() => jestExpect(v).toBeTruthy()).toThrow('toBeTruthy');\n\n      expect(() => jestExpect(v).not.toBeFalsy()).toThrow('toBeFalsy');\n    });\n  }\n});\n\ndescribe('.toBeNaN()', () => {\n  it('{pass: true} expect(NaN).toBeNaN()', () => {\n    for (const v of [NaN, Math.sqrt(-1), Infinity - Infinity, 0 / 0]) {\n      jestExpect(v).toBeNaN();\n\n      expect(() => jestExpect(v).not.toBeNaN()).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  it('throws', () => {\n    for (const v of [\n      1,\n      '',\n      null,\n      undefined,\n      {},\n      [],\n      0.2,\n      0,\n      Infinity,\n      -Infinity,\n    ]) {\n      expect(() => jestExpect(v).toBeNaN()).toThrowErrorMatchingSnapshot();\n\n      jestExpect(v).not.toBeNaN();\n    }\n  });\n});\n\ndescribe('.toBeNull()', () => {\n  for (const v of [{}, [], true, 1, 'a', 0.5, new Map(), () => {}, Infinity]) {\n    test(`fails for '${stringify(v)}'`, () => {\n      jestExpect(v).not.toBeNull();\n\n      expect(() => jestExpect(v).toBeNull()).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  it('fails for null with .not', () => {\n    expect(() =>\n      jestExpect(null).not.toBeNull(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  it('pass for null', () => {\n    jestExpect(null).toBeNull();\n  });\n});\n\ndescribe('.toBeDefined(), .toBeUndefined()', () => {\n  for (const v of [{}, [], true, 1, 'a', 0.5, new Map(), () => {}, Infinity]) {\n    test(`'${stringify(v)}' is defined`, () => {\n      jestExpect(v).toBeDefined();\n      jestExpect(v).not.toBeUndefined();\n\n      expect(() =>\n        jestExpect(v).not.toBeDefined(),\n      ).toThrowErrorMatchingSnapshot();\n\n      expect(() =>\n        jestExpect(v).toBeUndefined(),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const v of [BigInt(1)]) {\n    test(`'${stringify(v)}' is defined`, () => {\n      jestExpect(v).toBeDefined();\n      jestExpect(v).not.toBeUndefined();\n\n      expect(() => jestExpect(v).not.toBeDefined()).toThrow('toBeDefined');\n\n      expect(() => jestExpect(v).toBeUndefined()).toThrow('toBeUndefined');\n    });\n  }\n\n  test('undefined is undefined', () => {\n    jestExpect(undefined).toBeUndefined();\n    jestExpect(undefined).not.toBeDefined();\n\n    expect(() =>\n      jestExpect(undefined).toBeDefined(),\n    ).toThrowErrorMatchingSnapshot();\n\n    expect(() =>\n      jestExpect(undefined).not.toBeUndefined(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe(\n  '.toBeGreaterThan(), .toBeLessThan(), ' +\n    '.toBeGreaterThanOrEqual(), .toBeLessThanOrEqual()',\n  () => {\n    for (const [small, big] of [\n      [1, 2],\n      [-Infinity, Infinity],\n      [Number.MIN_VALUE, Number.MAX_VALUE],\n      [0x11, 0x22],\n      [0b11, 0b111],\n      [0o11, 0o22],\n      [0.1, 0.2],\n    ]) {\n      it(`{pass: true} expect(${small}).toBeLessThan(${big})`, () => {\n        jestExpect(small).toBeLessThan(big);\n      });\n\n      it(`{pass: false} expect(${big}).toBeLessThan(${small})`, () => {\n        jestExpect(big).not.toBeLessThan(small);\n      });\n\n      it(`{pass: true} expect(${big}).toBeGreaterThan(${small})`, () => {\n        jestExpect(big).toBeGreaterThan(small);\n      });\n\n      it(`{pass: false} expect(${small}).toBeGreaterThan(${big})`, () => {\n        jestExpect(small).not.toBeGreaterThan(big);\n      });\n\n      it(`{pass: true} expect(${small}).toBeLessThanOrEqual(${big})`, () => {\n        jestExpect(small).toBeLessThanOrEqual(big);\n      });\n\n      it(`{pass: false} expect(${big}).toBeLessThanOrEqual(${small})`, () => {\n        jestExpect(big).not.toBeLessThanOrEqual(small);\n      });\n\n      it(`{pass: true} expect(${big}).toBeGreaterThanOrEqual(${small})`, () => {\n        jestExpect(big).toBeGreaterThanOrEqual(small);\n      });\n\n      it(`{pass: false} expect(${small}).toBeGreaterThanOrEqual(${big})`, () => {\n        jestExpect(small).not.toBeGreaterThanOrEqual(big);\n      });\n\n      it(`throws: [${small}, ${big}]`, () => {\n        expect(() =>\n          jestExpect(small).toBeGreaterThan(big),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(small).not.toBeLessThan(big),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(big).not.toBeGreaterThan(small),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(big).toBeLessThan(small),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(small).toBeGreaterThanOrEqual(big),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(small).not.toBeLessThanOrEqual(big),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(big).not.toBeGreaterThanOrEqual(small),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(big).toBeLessThanOrEqual(small),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    }\n\n    test('can compare BigInt to Numbers', () => {\n      const a = BigInt(2);\n      jestExpect(a).toBeGreaterThan(1);\n      jestExpect(a).toBeGreaterThanOrEqual(2);\n      jestExpect(2).toBeLessThanOrEqual(a);\n      jestExpect(a).toBeLessThan(3);\n      jestExpect(a).toBeLessThanOrEqual(2);\n    });\n    for (const [small, big] of [\n      [BigInt(1), BigInt(2)],\n      [BigInt(0x11), BigInt(0x22)],\n      [-1, BigInt(2)],\n    ]) {\n      it(`{pass: true} expect(${stringify(small)}).toBeLessThan(${stringify(\n        big,\n      )})`, () => {\n        jestExpect(small).toBeLessThan(big);\n      });\n\n      it(`{pass: false} expect(${stringify(big)}).toBeLessThan(${stringify(\n        small,\n      )})`, () => {\n        jestExpect(big).not.toBeLessThan(small);\n      });\n\n      it(`{pass: true} expect(${stringify(big)}).toBeGreaterThan(${stringify(\n        small,\n      )})`, () => {\n        jestExpect(big).toBeGreaterThan(small);\n      });\n\n      it(`{pass: false} expect(${stringify(small)}).toBeGreaterThan(${stringify(\n        big,\n      )})`, () => {\n        jestExpect(small).not.toBeGreaterThan(big);\n      });\n\n      it(`{pass: true} expect(${stringify(\n        small,\n      )}).toBeLessThanOrEqual(${stringify(big)})`, () => {\n        jestExpect(small).toBeLessThanOrEqual(big);\n      });\n\n      it(`{pass: false} expect(${stringify(\n        big,\n      )}).toBeLessThanOrEqual(${stringify(small)})`, () => {\n        jestExpect(big).not.toBeLessThanOrEqual(small);\n      });\n\n      it(`{pass: true} expect(${stringify(\n        big,\n      )}).toBeGreaterThanOrEqual(${stringify(small)})`, () => {\n        jestExpect(big).toBeGreaterThanOrEqual(small);\n      });\n\n      it(`{pass: false} expect(${stringify(\n        small,\n      )}).toBeGreaterThanOrEqual(${stringify(big)})`, () => {\n        jestExpect(small).not.toBeGreaterThanOrEqual(big);\n      });\n\n      it(`throws: [${stringify(small)}, ${stringify(big)}]`, () => {\n        expect(() => jestExpect(small).toBeGreaterThan(big)).toThrow(\n          'toBeGreaterThan',\n        );\n\n        expect(() => jestExpect(small).not.toBeLessThan(big)).toThrow(\n          'toBeLessThan',\n        );\n\n        expect(() => jestExpect(big).not.toBeGreaterThan(small)).toThrow(\n          'toBeGreaterThan',\n        );\n\n        expect(() => jestExpect(big).toBeLessThan(small)).toThrow(\n          'toBeLessThan',\n        );\n\n        expect(() => jestExpect(small).toBeGreaterThanOrEqual(big)).toThrow(\n          'toBeGreaterThanOrEqual',\n        );\n\n        expect(() => jestExpect(small).not.toBeLessThanOrEqual(big)).toThrow(\n          'toBeLessThanOrEqual',\n        );\n\n        expect(() => jestExpect(big).not.toBeGreaterThanOrEqual(small)).toThrow(\n          'toBeGreaterThanOrEqual',\n        );\n\n        expect(() => jestExpect(big).toBeLessThanOrEqual(small)).toThrow(\n          'toBeLessThanOrEqual',\n        );\n      });\n    }\n\n    for (const [n1, n2] of [\n      [1, 1],\n      [Number.MIN_VALUE, Number.MIN_VALUE],\n      [Number.MAX_VALUE, Number.MAX_VALUE],\n      [Infinity, Infinity],\n      [-Infinity, -Infinity],\n    ]) {\n      test(`equal numbers: [${n1}, ${n2}]`, () => {\n        jestExpect(n1).toBeGreaterThanOrEqual(n2);\n        jestExpect(n1).toBeLessThanOrEqual(n2);\n\n        expect(() =>\n          jestExpect(n1).not.toBeGreaterThanOrEqual(n2),\n        ).toThrowErrorMatchingSnapshot();\n\n        expect(() =>\n          jestExpect(n1).not.toBeLessThanOrEqual(n2),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    }\n\n    for (const [n1, n2] of [\n      [BigInt(1), BigInt(1)],\n      [BigInt(Number.MAX_SAFE_INTEGER), BigInt(Number.MAX_SAFE_INTEGER)],\n    ]) {\n      test(`equal numbers: [${n1}, ${n2}]`, () => {\n        jestExpect(n1).toBeGreaterThanOrEqual(n2);\n        jestExpect(n1).toBeLessThanOrEqual(n2);\n\n        expect(() => jestExpect(n1).not.toBeGreaterThanOrEqual(n2)).toThrow(\n          'toBeGreaterThanOrEqual',\n        );\n\n        expect(() => jestExpect(n1).not.toBeLessThanOrEqual(n2)).toThrow(\n          'toBeLessThanOrEqual',\n        );\n      });\n    }\n  },\n);\n\ndescribe('.toContain(), .toContainEqual()', () => {\n  const typedArray = new Int8Array(2);\n  typedArray[0] = 0;\n  typedArray[1] = 1;\n\n  test('iterable', () => {\n    // different node versions print iterable differently, so we can't\n    // use snapshots here.\n    const iterable = {\n      *[Symbol.iterator]() {\n        yield 1;\n        yield 2;\n        yield 3;\n      },\n    };\n\n    jestExpect(iterable).toContain(2);\n    jestExpect(iterable).toContainEqual(2);\n    expect(() => jestExpect(iterable).not.toContain(1)).toThrow('toContain');\n    expect(() => jestExpect(iterable).not.toContainEqual(1)).toThrow(\n      'toContainEqual',\n    );\n  });\n\n  for (const [list, v] of [\n    [[1, 2, 3, 4], 1],\n    [['a', 'b', 'c', 'd'], 'a'],\n    [[undefined, null], null],\n    [[undefined, null], undefined],\n    [[Symbol.for('a')], Symbol.for('a')],\n    ['abcdef', 'abc'],\n    ['11112111', '2'],\n    [new Set(['abc', 'def']), 'abc'],\n    [typedArray, 1],\n  ]) {\n    it(`'${stringify(list)}' contains '${stringify(v)}'`, () => {\n      jestExpect(list).toContain(v);\n\n      expect(() =>\n        jestExpect(list).not.toContain(v),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const [list, v] of [\n    [[BigInt(1), BigInt(2), BigInt(3), BigInt(4)], BigInt(1)],\n    [[1, 2, 3, BigInt(3), 4], BigInt(3)],\n  ]) {\n    it(`'${stringify(list)}' contains '${stringify(v)}'`, () => {\n      jestExpect(list).toContain(v);\n\n      expect(() => jestExpect(list).not.toContain(v)).toThrow('toContain');\n    });\n  }\n\n  for (const [list, v] of [\n    [[1, 2, 3], 4],\n    [[null, undefined], 1],\n    [[{}, []], []],\n    [[{}, []], {}],\n  ]) {\n    it(`'${stringify(list)}' does not contain '${stringify(v)}'`, () => {\n      jestExpect(list).not.toContain(v);\n\n      expect(() =>\n        jestExpect(list).toContain(v),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const [list, v] of [[[BigInt(1), BigInt(2), BigInt(3)], 3]]) {\n    it(`'${stringify(list)}' does not contain '${stringify(v)}'`, () => {\n      jestExpect(list).not.toContain(v);\n\n      expect(() => jestExpect(list).toContain(v)).toThrow('toContain');\n    });\n  }\n\n  test('error cases', () => {\n    expect(() => jestExpect(null).toContain(1)).toThrowErrorMatchingSnapshot();\n    expect(() => jestExpect('-0').toContain(-0)).toThrowErrorMatchingSnapshot();\n    expect(() =>\n      jestExpect('null').toContain(null),\n    ).toThrowErrorMatchingSnapshot();\n    expect(() =>\n      jestExpect('undefined').toContain(undefined),\n    ).toThrowErrorMatchingSnapshot();\n    expect(() =>\n      jestExpect('false').toContain(false),\n    ).toThrowErrorMatchingSnapshot();\n    expect(() => jestExpect('1').toContain(BigInt(1))).toThrow('toContain');\n  });\n\n  for (const [list, v] of [\n    [[1, 2, 3, 4], 1],\n    [['a', 'b', 'c', 'd'], 'a'],\n    [[undefined, null], null],\n    [[undefined, null], undefined],\n    [[Symbol.for('a')], Symbol.for('a')],\n    [[{a: 'b'}, {a: 'c'}], {a: 'b'}],\n    [new Set([1, 2, 3, 4]), 1],\n    [typedArray, 1],\n  ]) {\n    it(`'${stringify(list)}' contains a value equal to '${stringify(\n      v,\n    )}'`, () => {\n      jestExpect(list).toContainEqual(v);\n      expect(() =>\n        jestExpect(list).not.toContainEqual(v),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const [list, v] of [[[{a: 'b'}, {a: 'c'}], {a: 'd'}]]) {\n    it(`'${stringify(list)}' does not contain a value equal to'${stringify(\n      v,\n    )}'`, () => {\n      jestExpect(list).not.toContainEqual(v);\n\n      expect(() =>\n        jestExpect(list).toContainEqual(v),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  test('error cases for toContainEqual', () => {\n    expect(() =>\n      jestExpect(null).toContainEqual(1),\n    ).toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe('.toBeCloseTo', () => {\n  for (const [n1, n2] of [\n    [0, 0],\n    [0, 0.001],\n    [1.23, 1.229],\n    [1.23, 1.226],\n    [1.23, 1.225],\n    [1.23, 1.234],\n    [Infinity, Infinity],\n    [-Infinity, -Infinity],\n  ]) {\n    it(`{pass: true} expect(${n1}).toBeCloseTo(${n2})`, () => {\n      jestExpect(n1).toBeCloseTo(n2);\n\n      expect(() =>\n        jestExpect(n1).not.toBeCloseTo(n2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const [n1, n2] of [\n    [0, 0.01],\n    [1, 1.23],\n    [1.23, 1.224_999_9],\n    [Infinity, -Infinity],\n    [Infinity, 1.23],\n    [-Infinity, -1.23],\n  ]) {\n    it(`{pass: false} expect(${n1}).toBeCloseTo(${n2})`, () => {\n      jestExpect(n1).not.toBeCloseTo(n2);\n\n      expect(() =>\n        jestExpect(n1).toBeCloseTo(n2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const [n1, n2, p] of [\n    [3.141_592e-7, 3e-7, 8],\n    [56_789, 51_234, -4],\n  ]) {\n    it(`{pass: false} expect(${n1}).toBeCloseTo(${n2}, ${p})`, () => {\n      jestExpect(n1).not.toBeCloseTo(n2, p);\n\n      expect(() =>\n        jestExpect(n1).toBeCloseTo(n2, p),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const [n1, n2, p] of [\n    [0, 0.1, 0],\n    [0, 0.0001, 3],\n    [0, 0.000_004, 5],\n    [2.000_000_2, 2, 5],\n  ]) {\n    it(`{pass: true} expect(${n1}).toBeCloseTo(${n2}, ${p})`, () => {\n      jestExpect(n1).toBeCloseTo(n2, p);\n\n      expect(() =>\n        jestExpect(n1).not.toBeCloseTo(n2, p),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  describe('throws: Matcher error', () => {\n    test('promise empty isNot false received', () => {\n      const precision = 3;\n      const expected = 0;\n      const received = '';\n      expect(() => {\n        jestExpect(received).toBeCloseTo(expected, precision);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('promise empty isNot true expected', () => {\n      const received = 0.1;\n      // expected is undefined\n      expect(() => {\n        jestExpect(received).not.toBeCloseTo();\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('promise rejects isNot false expected', () => {\n      const expected = '0';\n      const received = Promise.reject(0.01);\n      return expect(\n        jestExpect(received).rejects.toBeCloseTo(expected),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n\n    test('promise rejects isNot true received', () => {\n      const expected = 0;\n      const received = Promise.reject(Symbol('0.1'));\n      return expect(\n        jestExpect(received).rejects.not.toBeCloseTo(expected),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n\n    test('promise resolves isNot false received', () => {\n      const precision = 3;\n      const expected = 0;\n      const received = Promise.resolve(false);\n      return expect(\n        jestExpect(received).resolves.toBeCloseTo(expected, precision),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n\n    test('promise resolves isNot true expected', () => {\n      const precision = 3;\n      const expected = null;\n      const received = Promise.resolve(0.1);\n      return expect(\n        jestExpect(received).resolves.not.toBeCloseTo(expected, precision),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n  });\n});\n\ndescribe('.toMatch()', () => {\n  for (const [n1, n2] of [\n    ['foo', 'foo'],\n    ['Foo bar', /^foo/i],\n  ]) {\n    it(`{pass: true} expect(${n1}).toMatch(${n2})`, () => {\n      jestExpect(n1).toMatch(n2);\n\n      expect(() =>\n        jestExpect(n1).not.toMatch(n2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const [n1, n2] of [\n    ['bar', 'foo'],\n    ['bar', /foo/],\n  ]) {\n    it(`throws: [${n1}, ${n2}]`, () => {\n      expect(() => jestExpect(n1).toMatch(n2)).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const [n1, n2] of [\n    [1, 'foo'],\n    [{}, 'foo'],\n    [[], 'foo'],\n    [true, 'foo'],\n    [/foo/i, 'foo'],\n    [() => {}, 'foo'],\n    [undefined, 'foo'],\n  ]) {\n    it(\n      'throws if non String actual value passed:' +\n        ` [${stringify(n1)}, ${stringify(n2)}]`,\n      () => {\n        expect(() => jestExpect(n1).toMatch(n2)).toThrowErrorMatchingSnapshot();\n      },\n    );\n  }\n\n  for (const [n1, n2] of [\n    ['foo', 1],\n    ['foo', {}],\n    ['foo', []],\n    ['foo', true],\n    ['foo', () => {}],\n    ['foo', undefined],\n  ]) {\n    it(\n      'throws if non String/RegExp expected value passed:' +\n        ` [${stringify(n1)}, ${stringify(n2)}]`,\n      () => {\n        expect(() => jestExpect(n1).toMatch(n2)).toThrowErrorMatchingSnapshot();\n      },\n    );\n  }\n\n  it('escapes strings properly', () => {\n    jestExpect('this?: throws').toMatch('this?: throws');\n  });\n\n  it('does not maintain RegExp state between calls', () => {\n    const regex = /f\\d+/gi;\n    jestExpect('f123').toMatch(regex);\n    jestExpect('F456').toMatch(regex);\n    jestExpect(regex.lastIndex).toBe(0);\n  });\n});\n\ndescribe('.toHaveLength', () => {\n  for (const [received, length] of [\n    [[1, 2], 2],\n    [[], 0],\n    [['a', 'b'], 2],\n    ['abc', 3],\n    ['', 0],\n    [() => {}, 0],\n  ]) {\n    test(`{pass: true} expect(${stringify(\n      received,\n    )}).toHaveLength(${length})`, () => {\n      jestExpect(received).toHaveLength(length);\n      expect(() =>\n        jestExpect(received).not.toHaveLength(length),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const [received, length] of [\n    [[1, 2], 3],\n    [[], 1],\n    [['a', 'b'], 99],\n    ['abc', 66],\n    ['', 1],\n  ]) {\n    test(`{pass: false} expect(${stringify(\n      received,\n    )}).toHaveLength(${length})`, () => {\n      jestExpect(received).not.toHaveLength(length);\n      expect(() =>\n        jestExpect(received).toHaveLength(length),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  test('error cases', () => {\n    expect(() =>\n      jestExpect({a: 9}).toHaveLength(1),\n    ).toThrowErrorMatchingSnapshot();\n    expect(() => jestExpect(0).toHaveLength(1)).toThrowErrorMatchingSnapshot();\n    expect(() =>\n      jestExpect(undefined).not.toHaveLength(1),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  describe('matcher error expected length', () => {\n    test('not number', () => {\n      const expected = '3';\n      const received = 'abc';\n      expect(() => {\n        jestExpect(received).not.toHaveLength(expected);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('number Infinity', () => {\n      const expected = Infinity;\n      const received = Promise.reject('abc');\n      return expect(\n        jestExpect(received).rejects.toHaveLength(expected),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n\n    test('number NaN', () => {\n      const expected = NaN;\n      const received = Promise.reject('abc');\n      return expect(\n        jestExpect(received).rejects.not.toHaveLength(expected),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n\n    test('number float', () => {\n      const expected = 0.5;\n      const received = Promise.resolve('abc');\n      return expect(\n        jestExpect(received).resolves.toHaveLength(expected),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n\n    test('number negative integer', () => {\n      const expected = -3;\n      const received = Promise.resolve('abc');\n      return expect(\n        jestExpect(received).resolves.not.toHaveLength(expected),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n  });\n});\n\ndescribe('.toHaveProperty()', () => {\n  class Foo {\n    get a() {\n      return undefined;\n    }\n    get b() {\n      return 'b';\n    }\n    // eslint-disable-next-line accessor-pairs\n    set setter(val) {\n      this.val = val;\n    }\n  }\n\n  class Foo2 extends Foo {\n    get c() {\n      return 'c';\n    }\n  }\n  const foo2 = new Foo2();\n  foo2.setter = true;\n\n  function E(nodeName) {\n    this.nodeName = nodeName.toUpperCase();\n  }\n  E.prototype.nodeType = 1;\n\n  const memoized = function () {};\n  memoized.memo = [];\n\n  const pathDiff = ['children', 0];\n\n  const receivedDiffSingle = {\n    children: ['\"That cartoon\"'],\n    props: null,\n    type: 'p',\n  };\n  const valueDiffSingle = '\"That cat cartoon\"';\n\n  const receivedDiffMultiple = {\n    children: [\n      'Roses are red.\\nViolets are blue.\\nTesting with Jest is good for you.',\n    ],\n    props: null,\n    type: 'pre',\n  };\n  const valueDiffMultiple =\n    'Roses are red, violets are blue.\\nTesting with Jest\\nIs good for you.';\n\n  for (const [obj, keyPath, value] of [\n    [{a: {b: {c: {d: 1}}}}, 'a.b.c.d', 1],\n    [{a: {b: {c: {d: 1}}}}, ['a', 'b', 'c', 'd'], 1],\n    [{'a.b.c.d': 1}, ['a.b.c.d'], 1],\n    [{a: {b: [1, 2, 3]}}, ['a', 'b', 1], 2],\n    [{a: {b: [1, 2, 3]}}, ['a', 'b', 1], expect.any(Number)],\n    [{a: 0}, 'a', 0],\n    [{a: {b: undefined}}, 'a.b', undefined],\n    [{a: {b: {c: 5}}}, 'a.b', {c: 5}],\n    [{a: {b: [{c: [{d: 1}]}]}}, 'a.b[0].c[0].d', 1],\n    [{a: {b: [{c: {d: [{e: 1}, {f: 2}]}}]}}, 'a.b[0].c.d[1].f', 2],\n    [{a: {b: [[{c: [{d: 1}]}]]}}, 'a.b[0][0].c[0].d', 1],\n    [Object.assign(Object.create(null), {property: 1}), 'property', 1],\n    [new Foo(), 'a', undefined],\n    [new Foo(), 'b', 'b'],\n    [new Foo(), 'setter', undefined],\n    [foo2, 'a', undefined],\n    [foo2, 'c', 'c'],\n    [foo2, 'val', true],\n    [new E('div'), 'nodeType', 1],\n    ['', 'length', 0],\n    [memoized, 'memo', []],\n    [{'': 1}, '', 1],\n  ]) {\n    test(`{pass: true} expect(${stringify(\n      obj,\n    )}).toHaveProperty('${keyPath}', ${stringify(value)})`, () => {\n      jestExpect(obj).toHaveProperty(keyPath, value);\n      expect(() =>\n        jestExpect(obj).not.toHaveProperty(keyPath, value),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const [obj, keyPath, value] of [\n    [{a: {b: {c: {d: 1}}}}, 'a.b.ttt.d', 1],\n    [{a: {b: {c: {d: 1}}}}, 'a.b.c.d', 2],\n    [{'a.b.c.d': 1}, 'a.b.c.d', 2],\n    [{'a.b.c.d': 1}, ['a.b.c.d'], 2],\n    [receivedDiffSingle, pathDiff, valueDiffSingle],\n    [receivedDiffMultiple, pathDiff, valueDiffMultiple],\n    [{a: {b: {c: {d: 1}}}}, ['a', 'b', 'c', 'd'], 2],\n    [{a: {b: {c: {}}}}, 'a.b.c.d', 1],\n    [{a: 1}, 'a.b.c.d', 5],\n    [{}, 'a', 'test'],\n    [{a: {b: 3}}, 'a.b', undefined],\n    [1, 'a.b.c', 'test'],\n    ['abc', 'a.b.c', {a: 5}],\n    [{a: {b: {c: 5}}}, 'a.b', {c: 4}],\n    [new Foo(), 'a', 'a'],\n    [new Foo(), 'b', undefined],\n    [{a: {}}, 'a.b', undefined],\n  ]) {\n    test(`{pass: false} expect(${stringify(\n      obj,\n    )}).toHaveProperty('${keyPath}', ${stringify(value)})`, () => {\n      expect(() =>\n        jestExpect(obj).toHaveProperty(keyPath, value),\n      ).toThrowErrorMatchingSnapshot();\n      jestExpect(obj).not.toHaveProperty(keyPath, value);\n    });\n  }\n\n  for (const [obj, keyPath] of [\n    [{a: {b: {c: {d: 1}}}}, 'a.b.c.d'],\n    [{a: {b: {c: {d: 1}}}}, ['a', 'b', 'c', 'd']],\n    [{'a.b.c.d': 1}, ['a.b.c.d']],\n    [{a: {b: [1, 2, 3]}}, ['a', 'b', 1]],\n    [{a: 0}, 'a'],\n    [{a: {b: undefined}}, 'a.b'],\n  ]) {\n    test(`{pass: true} expect(${stringify(\n      obj,\n    )}).toHaveProperty('${keyPath}')`, () => {\n      jestExpect(obj).toHaveProperty(keyPath);\n      expect(() =>\n        jestExpect(obj).not.toHaveProperty(keyPath),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  for (const [obj, keyPath] of [\n    [{a: {b: {c: {}}}}, 'a.b.c.d'],\n    [{a: {b: {c: {}}}}, '.a.b.c'],\n    [{a: 1}, 'a.b.c.d'],\n    [{}, 'a'],\n    [1, 'a.b.c'],\n    ['abc', 'a.b.c'],\n    [false, 'key'],\n    [0, 'key'],\n    ['', 'key'],\n    [Symbol(), 'key'],\n    [Object.assign(Object.create(null), {key: 1}), 'not'],\n  ]) {\n    test(`{pass: false} expect(${stringify(\n      obj,\n    )}).toHaveProperty('${keyPath}')`, () => {\n      expect(() =>\n        jestExpect(obj).toHaveProperty(keyPath),\n      ).toThrowErrorMatchingSnapshot();\n      jestExpect(obj).not.toHaveProperty(keyPath);\n    });\n  }\n\n  for (const [obj, keyPath] of [\n    [null, 'a.b'],\n    [undefined, 'a'],\n    [{a: {b: {}}}, undefined],\n    [{a: {b: {}}}, null],\n    [{a: {b: {}}}, 1],\n    [{}, []], // Residue: pass must be initialized\n  ]) {\n    test(`{error} expect(${stringify(\n      obj,\n    )}).toHaveProperty('${keyPath}')`, () => {\n      expect(() =>\n        jestExpect(obj).toHaveProperty(keyPath),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n});\n\ndescribe('toMatchObject()', () => {\n  class Foo {\n    get a() {\n      return undefined;\n    }\n    get b() {\n      return 'b';\n    }\n  }\n\n  class Sub extends Foo {\n    get c() {\n      return 'c';\n    }\n  }\n\n  const withDefineProperty = (obj, key, val) => {\n    Object.defineProperty(obj, key, {\n      get() {\n        return val;\n      },\n    });\n\n    return obj;\n  };\n\n  const testNotToMatchSnapshots = tuples => {\n    for (const [n1, n2] of tuples) {\n      it(`{pass: true} expect(${stringify(n1)}).toMatchObject(${stringify(\n        n2,\n      )})`, () => {\n        jestExpect(n1).toMatchObject(n2);\n        expect(() =>\n          jestExpect(n1).not.toMatchObject(n2),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    }\n  };\n\n  const testToMatchSnapshots = tuples => {\n    for (const [n1, n2] of tuples) {\n      it(`{pass: false} expect(${stringify(n1)}).toMatchObject(${stringify(\n        n2,\n      )})`, () => {\n        jestExpect(n1).not.toMatchObject(n2);\n        expect(() =>\n          jestExpect(n1).toMatchObject(n2),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    }\n  };\n\n  describe('circular references', () => {\n    describe('simple circular references', () => {\n      const circularObjA1 = {a: 'hello'};\n      circularObjA1.ref = circularObjA1;\n\n      const circularObjB = {a: 'world'};\n      circularObjB.ref = circularObjB;\n\n      const circularObjA2 = {a: 'hello'};\n      circularObjA2.ref = circularObjA2;\n\n      const primitiveInsteadOfRef = {};\n      primitiveInsteadOfRef.ref = 'not a ref';\n\n      testNotToMatchSnapshots([\n        [circularObjA1, {}],\n        [circularObjA2, circularObjA1],\n      ]);\n\n      testToMatchSnapshots([\n        [{}, circularObjA1],\n        [circularObjA1, circularObjB],\n        [primitiveInsteadOfRef, circularObjA1],\n      ]);\n    });\n\n    describe('transitive circular references', () => {\n      const transitiveCircularObjA1 = {a: 'hello'};\n      transitiveCircularObjA1.nestedObj = {parentObj: transitiveCircularObjA1};\n\n      const transitiveCircularObjA2 = {a: 'hello'};\n      transitiveCircularObjA2.nestedObj = {\n        parentObj: transitiveCircularObjA2,\n      };\n\n      const transitiveCircularObjB = {a: 'world'};\n      transitiveCircularObjB.nestedObj = {\n        parentObj: transitiveCircularObjB,\n      };\n\n      const primitiveInsteadOfRef = {};\n      primitiveInsteadOfRef.nestedObj = {\n        parentObj: 'not the parent ref',\n      };\n\n      testNotToMatchSnapshots([\n        [transitiveCircularObjA1, {}],\n        [transitiveCircularObjA2, transitiveCircularObjA1],\n      ]);\n\n      testToMatchSnapshots([\n        [{}, transitiveCircularObjA1],\n        [transitiveCircularObjB, transitiveCircularObjA1],\n        [primitiveInsteadOfRef, transitiveCircularObjA1],\n      ]);\n    });\n  });\n\n  testNotToMatchSnapshots([\n    [{a: 'b', c: 'd'}, {a: 'b'}],\n    [\n      {a: 'b', c: 'd'},\n      {a: 'b', c: 'd'},\n    ],\n    [\n      {a: 'b', t: {x: {r: 'r'}, z: 'z'}},\n      {a: 'b', t: {z: 'z'}},\n    ],\n    [{a: 'b', t: {x: {r: 'r'}, z: 'z'}}, {t: {x: {r: 'r'}}}],\n    [{a: [3, 4, 5], b: 'b'}, {a: [3, 4, 5]}],\n    [{a: [3, 4, 5, 'v'], b: 'b'}, {a: [3, 4, 5, 'v']}],\n    [{a: 1, c: 2}, {a: jestExpect.any(Number)}],\n    [{a: {x: 'x', y: 'y'}}, {a: {x: jestExpect.any(String)}}],\n    [new Set([1, 2]), new Set([1, 2])],\n    [new Set([1, 2]), new Set([2, 1])],\n    [new Date('2015-11-30'), new Date('2015-11-30')],\n    [{a: new Date('2015-11-30'), b: 'b'}, {a: new Date('2015-11-30')}],\n    [{a: null, b: 'b'}, {a: null}],\n    [{a: undefined, b: 'b'}, {a: undefined}],\n    [{a: [{a: 'a', b: 'b'}]}, {a: [{a: 'a'}]}],\n    [\n      [1, 2],\n      [1, 2],\n    ],\n    [{a: undefined}, {a: undefined}],\n    [[], []],\n    [new Error('foo'), new Error('foo')],\n    [new Error('bar'), {message: 'bar'}],\n    [new Foo(), {a: undefined, b: 'b'}],\n    [Object.assign(Object.create(null), {a: 'b'}), {a: 'b'}],\n    [\n      {a: 'b', c: 'd', [Symbol.for('jest')]: 'jest'},\n      {a: 'b', [Symbol.for('jest')]: 'jest'},\n    ],\n    [\n      {a: 'b', c: 'd', [Symbol.for('jest')]: 'jest'},\n      {a: 'b', c: 'd', [Symbol.for('jest')]: 'jest'},\n    ],\n    // These snapshots will show {} as the object because the properties\n    // are not enumerable. We will need to somehow make the serialization of\n    // these keys a little smarter before reporting accurately.\n    [new Sub(), {a: undefined, b: 'b', c: 'c'}],\n    [withDefineProperty(new Sub(), 'd', 4), {d: 4}],\n    [{a: 'b', toString() {}}, {toString: jestExpect.any(Function)}],\n  ]);\n\n  testToMatchSnapshots([\n    [{a: 'b', c: 'd'}, {e: 'b'}],\n    [\n      {a: 'b', c: 'd'},\n      {a: 'b!', c: 'd'},\n    ],\n    [{a: 'a', c: 'd'}, {a: jestExpect.any(Number)}],\n    [\n      {a: 'b', t: {x: {r: 'r'}, z: 'z'}},\n      {a: 'b', t: {z: [3]}},\n    ],\n    [{a: 'b', t: {x: {r: 'r'}, z: 'z'}}, {t: {l: {r: 'r'}}}],\n    [{a: [3, 4, 5], b: 'b'}, {a: [3, 4, 5, 6]}],\n    [{a: [3, 4, 5], b: 'b'}, {a: [3, 4]}],\n    [{a: [3, 4, 'v'], b: 'b'}, {a: ['v']}],\n    [{a: [3, 4, 5], b: 'b'}, {a: {b: 4}}],\n    [{a: [3, 4, 5], b: 'b'}, {a: {b: jestExpect.any(String)}}],\n    [\n      [1, 2],\n      [1, 3],\n    ],\n    [[0], [-0]],\n    [new Set([1, 2]), new Set([2])],\n    [new Date('2015-11-30'), new Date('2015-10-10')],\n    [{a: new Date('2015-11-30'), b: 'b'}, {a: new Date('2015-10-10')}],\n    [{a: null, b: 'b'}, {a: '4'}],\n    [{a: null, b: 'b'}, {a: undefined}],\n    [{a: undefined}, {a: null}],\n    [{a: [{a: 'a', b: 'b'}]}, {a: [{a: 'c'}]}],\n    [{a: 1, b: 1, c: 1, d: {e: {f: 555}}}, {d: {e: {f: 222}}}],\n    [{}, {a: undefined}],\n    [\n      [1, 2, 3],\n      [2, 3, 1],\n    ],\n    [\n      [1, 2, 3],\n      [1, 2, 2],\n    ],\n    [new Error('foo'), new Error('bar')],\n    [Object.assign(Object.create(null), {a: 'b'}), {c: 'd'}],\n    [\n      {a: 'b', c: 'd', [Symbol.for('jest')]: 'jest'},\n      {a: 'c', [Symbol.for('jest')]: expect.any(String)},\n    ],\n    [{a: 'b'}, {toString: jestExpect.any(Function)}],\n  ]);\n\n  for (const [n1, n2] of [\n    [null, {}],\n    [4, {}],\n    ['44', {}],\n    [true, {}],\n    [undefined, {}],\n    [{}, null],\n    [{}, 4],\n    [{}, 'some string'],\n    [{}, true],\n    [{}, undefined],\n  ]) {\n    it(`throws expect(${stringify(n1)}).toMatchObject(${stringify(\n      n2,\n    )})`, () => {\n      expect(() =>\n        jestExpect(n1).toMatchObject(n2),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  it('does not match properties up in the prototype chain', () => {\n    const a = {};\n    a.ref = a;\n\n    const b = Object.create(a);\n    b.other = 'child';\n\n    const matcher = {other: 'child'};\n    matcher.ref = matcher;\n\n    jestExpect(b).not.toMatchObject(matcher);\n    expect(() =>\n      jestExpect(b).toMatchObject(matcher),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  it('toMatchObject ignores symbol key properties', () => {\n    // issue 13638\n    const sym = Symbol('foo');\n    const sym2 = Symbol('foo2');\n    jestExpect({}).not.toMatchObject({[sym]: true});\n    jestExpect({[sym]: true}).not.toMatchObject({[sym2]: true});\n    jestExpect({[sym]: true}).not.toMatchObject({[sym]: false});\n    jestExpect({example: 10, [sym]: true}).not.toMatchObject({\n      example: 12,\n      [sym]: true,\n    });\n    jestExpect({[sym]: true}).toMatchObject({[sym]: true});\n    jestExpect({example: 10, [sym]: true}).toMatchObject({\n      example: 10,\n      [sym]: true,\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`.rejects fails for promise that resolves 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>toBe<d>()</>\n\nReceived promise resolved instead of rejected\nResolved to value: <r>4</>\n`;\n\nexports[`.rejects fails non-promise value \"a\" 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise or a function returning a promise\n\nReceived has type:  string\nReceived has value: <r>\"a\"</>\n`;\n\nexports[`.rejects fails non-promise value [1] 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise or a function returning a promise\n\nReceived has type:  array\nReceived has value: <r>[1]</>\n`;\n\nexports[`.rejects fails non-promise value [Function anonymous] 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise or a function returning a promise\n\nReceived has type:  function\nReceived has value: <r>[Function anonymous]</>\n`;\n\nexports[`.rejects fails non-promise value {\"a\": 1} 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise or a function returning a promise\n\nReceived has type:  object\nReceived has value: <r>{\"a\": 1}</>\n`;\n\nexports[`.rejects fails non-promise value 4 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>not<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise or a function returning a promise\n\nReceived has type:  number\nReceived has value: <r>4</>\n`;\n\nexports[`.rejects fails non-promise value null 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>not<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise or a function returning a promise\n\nReceived has value: <r>null</>\n`;\n\nexports[`.rejects fails non-promise value true 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>not<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise or a function returning a promise\n\nReceived has type:  boolean\nReceived has value: <r>true</>\n`;\n\nexports[`.rejects fails non-promise value undefined 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>not<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise or a function returning a promise\n\nReceived has value: <r>undefined</>\n`;\n\nexports[`.resolves fails for promise that rejects 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>toBe<d>()</>\n\nReceived promise rejected instead of resolved\nRejected to value: <r>4</>\n`;\n\nexports[`.resolves fails non-promise value \"a\" 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has type:  string\nReceived has value: <r>\"a\"</>\n`;\n\nexports[`.resolves fails non-promise value \"a\" synchronously 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has type:  string\nReceived has value: <r>\"a\"</>\n`;\n\nexports[`.resolves fails non-promise value [1] 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has type:  array\nReceived has value: <r>[1]</>\n`;\n\nexports[`.resolves fails non-promise value [1] synchronously 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has type:  array\nReceived has value: <r>[1]</>\n`;\n\nexports[`.resolves fails non-promise value [Function anonymous] 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has type:  function\nReceived has value: <r>[Function anonymous]</>\n`;\n\nexports[`.resolves fails non-promise value [Function anonymous] synchronously 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has type:  function\nReceived has value: <r>[Function anonymous]</>\n`;\n\nexports[`.resolves fails non-promise value {\"a\": 1} 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has type:  object\nReceived has value: <r>{\"a\": 1}</>\n`;\n\nexports[`.resolves fails non-promise value {\"a\": 1} synchronously 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has type:  object\nReceived has value: <r>{\"a\": 1}</>\n`;\n\nexports[`.resolves fails non-promise value 4 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>not<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has type:  number\nReceived has value: <r>4</>\n`;\n\nexports[`.resolves fails non-promise value 4 synchronously 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>not<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has type:  number\nReceived has value: <r>4</>\n`;\n\nexports[`.resolves fails non-promise value null 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>not<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has value: <r>null</>\n`;\n\nexports[`.resolves fails non-promise value null synchronously 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>not<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has value: <r>null</>\n`;\n\nexports[`.resolves fails non-promise value true 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>not<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has type:  boolean\nReceived has value: <r>true</>\n`;\n\nexports[`.resolves fails non-promise value true synchronously 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>not<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has type:  boolean\nReceived has value: <r>true</>\n`;\n\nexports[`.resolves fails non-promise value undefined 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>not<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has value: <r>undefined</>\n`;\n\nexports[`.resolves fails non-promise value undefined synchronously 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>not<d>.</>toBeDefined<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a promise\n\nReceived has value: <r>undefined</>\n`;\n\nexports[`.toBe() does not crash on circular references 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 3</>\n\n<g>- Object {}</>\n<r>+ Object {</>\n<r>+   \"circular\": [Circular],</>\n<r>+ }</>\n`;\n\nexports[`.toBe() fails for '\"a\"' with '.not' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: not <g>\"a\"</>\n`;\n\nexports[`.toBe() fails for '[]' with '.not' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: not <g>[]</>\n`;\n\nexports[`.toBe() fails for '{}' with '.not' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: not <g>{}</>\n`;\n\nexports[`.toBe() fails for '1' with '.not' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: not <g>1</>\n`;\n\nexports[`.toBe() fails for 'false' with '.not' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: not <g>false</>\n`;\n\nexports[`.toBe() fails for 'null' with '.not' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: not <g>null</>\n`;\n\nexports[`.toBe() fails for 'undefined' with '.not' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: not <g>undefined</>\n`;\n\nexports[`.toBe() fails for: \"\" and \"compare one-line string to empty string\" 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: <g>\"compare one-line string to empty string\"</>\nReceived: <r>\"\"</>\n`;\n\nexports[`.toBe() fails for: \"abc\" and \"cde\" 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: <g>\"cde\"</>\nReceived: <r>\"abc\"</>\n`;\n\nexports[`.toBe() fails for: \"four\n4\nline\nstring\" and \"3\nline\nstring\" 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 2</>\n\n<g>- 3</>\n<r>+ four</>\n<r>+ 4</>\n<d>  line</>\n<d>  string</>\n`;\n\nexports[`.toBe() fails for: \"painless JavaScript testing\" and \"delightful JavaScript testing\" 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: <g>\"<i>delightful</i> JavaScript testing\"</>\nReceived: <r>\"<i>painless</i> JavaScript testing\"</>\n`;\n\nexports[`.toBe() fails for: \"with \ntrailing space\" and \"without trailing space\" 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 2</>\n\n<g>- with<i>out</i> trailing space</>\n<r>+ with<Y> </></>\n<r>+ trailing space</>\n`;\n\nexports[`.toBe() fails for: /received/ and /expected/ 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: <g>/expected/</>\nReceived: <r>/received/</>\n`;\n\nexports[`.toBe() fails for: [] and [] 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\n<d>If it should pass with deep equality, replace \"toBe\" with \"toStrictEqual\"</>\n\nExpected: <g>[]</>\nReceived: serializes to the same string\n`;\n\nexports[`.toBe() fails for: [Error: received] and [Error: expected] 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: <g>[Error: expected]</>\nReceived: <r>[Error: received]</>\n`;\n\nexports[`.toBe() fails for: [Function anonymous] and [Function anonymous] 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: <g>[Function anonymous]</>\nReceived: serializes to the same string\n`;\n\nexports[`.toBe() fails for: {\"a\": [Function a], \"b\": 2} and {\"a\": Any<Function>, \"b\": 2} 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\n<d>If it should pass with deep equality, replace \"toBe\" with \"toStrictEqual\"</>\n\nExpected: <g>{\"a\": Any<Function>, \"b\": 2}</>\nReceived: <r>{\"a\": [Function a], \"b\": 2}</>\n`;\n\nexports[`.toBe() fails for: {\"a\": 1} and {\"a\": 1} 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\n<d>If it should pass with deep equality, replace \"toBe\" with \"toStrictEqual\"</>\n\nExpected: <g>{\"a\": 1}</>\nReceived: serializes to the same string\n`;\n\nexports[`.toBe() fails for: {\"a\": 1} and {\"a\": 5} 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": 5,</>\n<r>+   \"a\": 1,</>\n<d>  }</>\n`;\n\nexports[`.toBe() fails for: {\"a\": undefined, \"b\": 2} and {\"b\": 2} 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\n<d>If it should pass with deep equality, replace \"toBe\" with \"toEqual\"</>\n\n<g>- Expected  - 0</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<r>+   \"a\": undefined,</>\n<d>    \"b\": 2,</>\n<d>  }</>\n`;\n\nexports[`.toBe() fails for: {} and {} 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\n<d>If it should pass with deep equality, replace \"toBe\" with \"toStrictEqual\"</>\n\nExpected: <g>{}</>\nReceived: serializes to the same string\n`;\n\nexports[`.toBe() fails for: -0 and 0 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: <g>0</>\nReceived: <r>-0</>\n`;\n\nexports[`.toBe() fails for: 1 and 2 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: <g>2</>\nReceived: <r>1</>\n`;\n\nexports[`.toBe() fails for: 2020-02-20T00:00:00.000Z and 2020-02-20T00:00:00.000Z 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\n<d>If it should pass with deep equality, replace \"toBe\" with \"toStrictEqual\"</>\n\nExpected: <g>2020-02-20T00:00:00.000Z</>\nReceived: serializes to the same string\n`;\n\nexports[`.toBe() fails for: 2020-02-21T00:00:00.000Z and 2020-02-20T00:00:00.000Z 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: <g>2020-02-20T00:00:00.000Z</>\nReceived: <r>2020-02-21T00:00:00.000Z</>\n`;\n\nexports[`.toBe() fails for: Symbol(received) and Symbol(expected) 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: <g>Symbol(expected)</>\nReceived: <r>Symbol(received)</>\n`;\n\nexports[`.toBe() fails for: null and undefined 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: <g>undefined</>\nReceived: <r>null</>\n`;\n\nexports[`.toBe() fails for: true and false 1`] = `\n<d>expect(</><r>received</><d>).</>toBe<d>(</><g>expected</><d>) // Object.is equality</>\n\nExpected: <g>false</>\nReceived: <r>true</>\n`;\n\nexports[`.toBeCloseTo {pass: false} expect(-Infinity).toBeCloseTo(-1.23) 1`] = `\n<d>expect(</><r>received</><d>).</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\nExpected: <g>-1.23</>\nReceived: <r>-Infinity</>\n\nExpected precision:    2\nExpected difference: < <g>0.005</>\nReceived difference:   <r>Infinity</>\n`;\n\nexports[`.toBeCloseTo {pass: false} expect(0).toBeCloseTo(0.01) 1`] = `\n<d>expect(</><r>received</><d>).</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\nExpected: <g>0.01</>\nReceived: <r>0</>\n\nExpected precision:    2\nExpected difference: < <g>0.005</>\nReceived difference:   <r>0.01</>\n`;\n\nexports[`.toBeCloseTo {pass: false} expect(1).toBeCloseTo(1.23) 1`] = `\n<d>expect(</><r>received</><d>).</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\nExpected: <g>1.23</>\nReceived: <r>1</>\n\nExpected precision:    2\nExpected difference: < <g>0.005</>\nReceived difference:   <r>0.22999999999999998</>\n`;\n\nexports[`.toBeCloseTo {pass: false} expect(1.23).toBeCloseTo(1.2249999) 1`] = `\n<d>expect(</><r>received</><d>).</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\nExpected: <g>1.2249999</>\nReceived: <r>1.23</>\n\nExpected precision:    2\nExpected difference: < <g>0.005</>\nReceived difference:   <r>0.005000099999999952</>\n`;\n\nexports[`.toBeCloseTo {pass: false} expect(3.141592e-7).toBeCloseTo(3e-7, 8) 1`] = `\n<d>expect(</><r>received</><d>).</>toBeCloseTo<d>(</><g>expected</><d>, </>precision<d>)</>\n\nExpected: <g>3e-7</>\nReceived: <r>3.141592e-7</>\n\nExpected precision:    8\nExpected difference: < <g>5e-9</>\nReceived difference:   <r>1.4159200000000025e-8</>\n`;\n\nexports[`.toBeCloseTo {pass: false} expect(56789).toBeCloseTo(51234, -4) 1`] = `\n<d>expect(</><r>received</><d>).</>toBeCloseTo<d>(</><g>expected</><d>, </>precision<d>)</>\n\nExpected: <g>51234</>\nReceived: <r>56789</>\n\nExpected precision:    -4\nExpected difference: < <g>5000</>\nReceived difference:   <r>5555</>\n`;\n\nexports[`.toBeCloseTo {pass: false} expect(Infinity).toBeCloseTo(-Infinity) 1`] = `\n<d>expect(</><r>received</><d>).</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\nExpected: <g>-Infinity</>\nReceived: <r>Infinity</>\n\nExpected precision:    2\nExpected difference: < <g>0.005</>\nReceived difference:   <r>Infinity</>\n`;\n\nexports[`.toBeCloseTo {pass: false} expect(Infinity).toBeCloseTo(1.23) 1`] = `\n<d>expect(</><r>received</><d>).</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\nExpected: <g>1.23</>\nReceived: <r>Infinity</>\n\nExpected precision:    2\nExpected difference: < <g>0.005</>\nReceived difference:   <r>Infinity</>\n`;\n\nexports[`.toBeCloseTo {pass: true} expect(-Infinity).toBeCloseTo(-Infinity) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\nExpected: not <g>-Infinity</>\n\n`;\n\nexports[`.toBeCloseTo {pass: true} expect(0).toBeCloseTo(0) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\nExpected: not <g>0</>\n\n`;\n\nexports[`.toBeCloseTo {pass: true} expect(0).toBeCloseTo(0.000004, 5) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>, </>precision<d>)</>\n\nExpected: not <g>0.000004</>\nReceived:     <r>0</>\n\nExpected precision:        5\nExpected difference: not < <g>0.000005</>\nReceived difference:       <r>0.000004</>\n`;\n\nexports[`.toBeCloseTo {pass: true} expect(0).toBeCloseTo(0.0001, 3) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>, </>precision<d>)</>\n\nExpected: not <g>0.0001</>\nReceived:     <r>0</>\n\nExpected precision:        3\nExpected difference: not < <g>0.0005</>\nReceived difference:       <r>0.0001</>\n`;\n\nexports[`.toBeCloseTo {pass: true} expect(0).toBeCloseTo(0.001) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\nExpected: not <g>0.001</>\nReceived:     <r>0</>\n\nExpected precision:        2\nExpected difference: not < <g>0.005</>\nReceived difference:       <r>0.001</>\n`;\n\nexports[`.toBeCloseTo {pass: true} expect(0).toBeCloseTo(0.1, 0) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>, </>precision<d>)</>\n\nExpected: not <g>0.1</>\nReceived:     <r>0</>\n\nExpected precision:        0\nExpected difference: not < <g>0.5</>\nReceived difference:       <r>0.1</>\n`;\n\nexports[`.toBeCloseTo {pass: true} expect(1.23).toBeCloseTo(1.225) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\nExpected: not <g>1.225</>\nReceived:     <r>1.23</>\n\nExpected precision:        2\nExpected difference: not < <g>0.005</>\nReceived difference:       <r>0.004999999999999893</>\n`;\n\nexports[`.toBeCloseTo {pass: true} expect(1.23).toBeCloseTo(1.226) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\nExpected: not <g>1.226</>\nReceived:     <r>1.23</>\n\nExpected precision:        2\nExpected difference: not < <g>0.005</>\nReceived difference:       <r>0.0040000000000000036</>\n`;\n\nexports[`.toBeCloseTo {pass: true} expect(1.23).toBeCloseTo(1.229) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\nExpected: not <g>1.229</>\nReceived:     <r>1.23</>\n\nExpected precision:        2\nExpected difference: not < <g>0.005</>\nReceived difference:       <r>0.0009999999999998899</>\n`;\n\nexports[`.toBeCloseTo {pass: true} expect(1.23).toBeCloseTo(1.234) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\nExpected: not <g>1.234</>\nReceived:     <r>1.23</>\n\nExpected precision:        2\nExpected difference: not < <g>0.005</>\nReceived difference:       <r>0.0040000000000000036</>\n`;\n\nexports[`.toBeCloseTo {pass: true} expect(2.0000002).toBeCloseTo(2, 5) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>, </>precision<d>)</>\n\nExpected: not <g>2</>\nReceived:     <r>2.0000002</>\n\nExpected precision:        5\nExpected difference: not < <g>5e-6</>\nReceived difference:       <r>2.0000000011677344e-7</>\n`;\n\nexports[`.toBeCloseTo {pass: true} expect(Infinity).toBeCloseTo(Infinity) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\nExpected: not <g>Infinity</>\n\n`;\n\nexports[`.toBeCloseTo throws: Matcher error promise empty isNot false received 1`] = `\n<d>expect(</><r>received</><d>).</>toBeCloseTo<d>(</><g>expected</><d>, </>precision<d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a number\n\nReceived has type:  string\nReceived has value: <r>\"\"</>\n`;\n\nexports[`.toBeCloseTo throws: Matcher error promise empty isNot true expected 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a number\n\nExpected has value: <g>undefined</>\n`;\n\nexports[`.toBeCloseTo throws: Matcher error promise rejects isNot false expected 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a number\n\nExpected has type:  string\nExpected has value: <g>\"0\"</>\n`;\n\nexports[`.toBeCloseTo throws: Matcher error promise rejects isNot true received 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a number\n\nReceived has type:  symbol\nReceived has value: <r>Symbol(0.1)</>\n`;\n\nexports[`.toBeCloseTo throws: Matcher error promise resolves isNot false received 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>toBeCloseTo<d>(</><g>expected</><d>, </>precision<d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a number\n\nReceived has type:  boolean\nReceived has value: <r>false</>\n`;\n\nexports[`.toBeCloseTo throws: Matcher error promise resolves isNot true expected 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>not<d>.</>toBeCloseTo<d>(</><g>expected</><d>, </>precision<d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a number\n\nExpected has value: <g>null</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() '\"a\"' is defined 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeDefined<d>()</>\n\nReceived: <r>\"a\"</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() '\"a\"' is defined 2`] = `\n<d>expect(</><r>received</><d>).</>toBeUndefined<d>()</>\n\nReceived: <r>\"a\"</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() '[]' is defined 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeDefined<d>()</>\n\nReceived: <r>[]</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() '[]' is defined 2`] = `\n<d>expect(</><r>received</><d>).</>toBeUndefined<d>()</>\n\nReceived: <r>[]</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() '[Function anonymous]' is defined 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeDefined<d>()</>\n\nReceived: <r>[Function anonymous]</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() '[Function anonymous]' is defined 2`] = `\n<d>expect(</><r>received</><d>).</>toBeUndefined<d>()</>\n\nReceived: <r>[Function anonymous]</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() '{}' is defined 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeDefined<d>()</>\n\nReceived: <r>{}</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() '{}' is defined 2`] = `\n<d>expect(</><r>received</><d>).</>toBeUndefined<d>()</>\n\nReceived: <r>{}</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() '0.5' is defined 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeDefined<d>()</>\n\nReceived: <r>0.5</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() '0.5' is defined 2`] = `\n<d>expect(</><r>received</><d>).</>toBeUndefined<d>()</>\n\nReceived: <r>0.5</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() '1' is defined 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeDefined<d>()</>\n\nReceived: <r>1</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() '1' is defined 2`] = `\n<d>expect(</><r>received</><d>).</>toBeUndefined<d>()</>\n\nReceived: <r>1</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() 'Infinity' is defined 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeDefined<d>()</>\n\nReceived: <r>Infinity</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() 'Infinity' is defined 2`] = `\n<d>expect(</><r>received</><d>).</>toBeUndefined<d>()</>\n\nReceived: <r>Infinity</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() 'Map {}' is defined 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeDefined<d>()</>\n\nReceived: <r>Map {}</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() 'Map {}' is defined 2`] = `\n<d>expect(</><r>received</><d>).</>toBeUndefined<d>()</>\n\nReceived: <r>Map {}</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() 'true' is defined 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeDefined<d>()</>\n\nReceived: <r>true</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() 'true' is defined 2`] = `\n<d>expect(</><r>received</><d>).</>toBeUndefined<d>()</>\n\nReceived: <r>true</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() undefined is undefined 1`] = `\n<d>expect(</><r>received</><d>).</>toBeDefined<d>()</>\n\nReceived: <r>undefined</>\n`;\n\nexports[`.toBeDefined(), .toBeUndefined() undefined is undefined 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeUndefined<d>()</>\n\nReceived: <r>undefined</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [-Infinity, -Infinity] 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not >= <g>-Infinity</>\nReceived:        <r>-Infinity</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [-Infinity, -Infinity] 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not <= <g>-Infinity</>\nReceived:        <r>-Infinity</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [1, 1] 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not >= <g>1</>\nReceived:        <r>1</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [1, 1] 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not <= <g>1</>\nReceived:        <r>1</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [1.7976931348623157e+308, 1.7976931348623157e+308] 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not >= <g>1.7976931348623157e+308</>\nReceived:        <r>1.7976931348623157e+308</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [1.7976931348623157e+308, 1.7976931348623157e+308] 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not <= <g>1.7976931348623157e+308</>\nReceived:        <r>1.7976931348623157e+308</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [5e-324, 5e-324] 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not >= <g>5e-324</>\nReceived:        <r>5e-324</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [5e-324, 5e-324] 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not <= <g>5e-324</>\nReceived:        <r>5e-324</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [Infinity, Infinity] 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not >= <g>Infinity</>\nReceived:        <r>Infinity</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() equal numbers: [Infinity, Infinity] 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not <= <g>Infinity</>\nReceived:        <r>Infinity</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [-Infinity, Infinity] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeGreaterThan<d>(</><g>expected</><d>)</>\n\nExpected: > <g>Infinity</>\nReceived:   <r>-Infinity</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [-Infinity, Infinity] 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThan<d>(</><g>expected</><d>)</>\n\nExpected: not < <g>Infinity</>\nReceived:       <r>-Infinity</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [-Infinity, Infinity] 3`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThan<d>(</><g>expected</><d>)</>\n\nExpected: not > <g>-Infinity</>\nReceived:       <r>Infinity</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [-Infinity, Infinity] 4`] = `\n<d>expect(</><r>received</><d>).</>toBeLessThan<d>(</><g>expected</><d>)</>\n\nExpected: < <g>-Infinity</>\nReceived:   <r>Infinity</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [-Infinity, Infinity] 5`] = `\n<d>expect(</><r>received</><d>).</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: >= <g>Infinity</>\nReceived:    <r>-Infinity</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [-Infinity, Infinity] 6`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not <= <g>Infinity</>\nReceived:        <r>-Infinity</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [-Infinity, Infinity] 7`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not >= <g>-Infinity</>\nReceived:        <r>Infinity</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [-Infinity, Infinity] 8`] = `\n<d>expect(</><r>received</><d>).</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: <= <g>-Infinity</>\nReceived:    <r>Infinity</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [0.1, 0.2] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeGreaterThan<d>(</><g>expected</><d>)</>\n\nExpected: > <g>0.2</>\nReceived:   <r>0.1</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [0.1, 0.2] 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThan<d>(</><g>expected</><d>)</>\n\nExpected: not < <g>0.2</>\nReceived:       <r>0.1</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [0.1, 0.2] 3`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThan<d>(</><g>expected</><d>)</>\n\nExpected: not > <g>0.1</>\nReceived:       <r>0.2</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [0.1, 0.2] 4`] = `\n<d>expect(</><r>received</><d>).</>toBeLessThan<d>(</><g>expected</><d>)</>\n\nExpected: < <g>0.1</>\nReceived:   <r>0.2</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [0.1, 0.2] 5`] = `\n<d>expect(</><r>received</><d>).</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: >= <g>0.2</>\nReceived:    <r>0.1</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [0.1, 0.2] 6`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not <= <g>0.2</>\nReceived:        <r>0.1</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [0.1, 0.2] 7`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not >= <g>0.1</>\nReceived:        <r>0.2</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [0.1, 0.2] 8`] = `\n<d>expect(</><r>received</><d>).</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: <= <g>0.1</>\nReceived:    <r>0.2</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [1, 2] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeGreaterThan<d>(</><g>expected</><d>)</>\n\nExpected: > <g>2</>\nReceived:   <r>1</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [1, 2] 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThan<d>(</><g>expected</><d>)</>\n\nExpected: not < <g>2</>\nReceived:       <r>1</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [1, 2] 3`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThan<d>(</><g>expected</><d>)</>\n\nExpected: not > <g>1</>\nReceived:       <r>2</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [1, 2] 4`] = `\n<d>expect(</><r>received</><d>).</>toBeLessThan<d>(</><g>expected</><d>)</>\n\nExpected: < <g>1</>\nReceived:   <r>2</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [1, 2] 5`] = `\n<d>expect(</><r>received</><d>).</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: >= <g>2</>\nReceived:    <r>1</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [1, 2] 6`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not <= <g>2</>\nReceived:        <r>1</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [1, 2] 7`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not >= <g>1</>\nReceived:        <r>2</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [1, 2] 8`] = `\n<d>expect(</><r>received</><d>).</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: <= <g>1</>\nReceived:    <r>2</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [3, 7] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeGreaterThan<d>(</><g>expected</><d>)</>\n\nExpected: > <g>7</>\nReceived:   <r>3</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [3, 7] 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThan<d>(</><g>expected</><d>)</>\n\nExpected: not < <g>7</>\nReceived:       <r>3</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [3, 7] 3`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThan<d>(</><g>expected</><d>)</>\n\nExpected: not > <g>3</>\nReceived:       <r>7</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [3, 7] 4`] = `\n<d>expect(</><r>received</><d>).</>toBeLessThan<d>(</><g>expected</><d>)</>\n\nExpected: < <g>3</>\nReceived:   <r>7</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [3, 7] 5`] = `\n<d>expect(</><r>received</><d>).</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: >= <g>7</>\nReceived:    <r>3</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [3, 7] 6`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not <= <g>7</>\nReceived:        <r>3</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [3, 7] 7`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not >= <g>3</>\nReceived:        <r>7</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [3, 7] 8`] = `\n<d>expect(</><r>received</><d>).</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: <= <g>3</>\nReceived:    <r>7</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [5e-324, 1.7976931348623157e+308] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeGreaterThan<d>(</><g>expected</><d>)</>\n\nExpected: > <g>1.7976931348623157e+308</>\nReceived:   <r>5e-324</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [5e-324, 1.7976931348623157e+308] 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThan<d>(</><g>expected</><d>)</>\n\nExpected: not < <g>1.7976931348623157e+308</>\nReceived:       <r>5e-324</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [5e-324, 1.7976931348623157e+308] 3`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThan<d>(</><g>expected</><d>)</>\n\nExpected: not > <g>5e-324</>\nReceived:       <r>1.7976931348623157e+308</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [5e-324, 1.7976931348623157e+308] 4`] = `\n<d>expect(</><r>received</><d>).</>toBeLessThan<d>(</><g>expected</><d>)</>\n\nExpected: < <g>5e-324</>\nReceived:   <r>1.7976931348623157e+308</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [5e-324, 1.7976931348623157e+308] 5`] = `\n<d>expect(</><r>received</><d>).</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: >= <g>1.7976931348623157e+308</>\nReceived:    <r>5e-324</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [5e-324, 1.7976931348623157e+308] 6`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not <= <g>1.7976931348623157e+308</>\nReceived:        <r>5e-324</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [5e-324, 1.7976931348623157e+308] 7`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not >= <g>5e-324</>\nReceived:        <r>1.7976931348623157e+308</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [5e-324, 1.7976931348623157e+308] 8`] = `\n<d>expect(</><r>received</><d>).</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: <= <g>5e-324</>\nReceived:    <r>1.7976931348623157e+308</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [9, 18] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeGreaterThan<d>(</><g>expected</><d>)</>\n\nExpected: > <g>18</>\nReceived:   <r>9</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [9, 18] 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThan<d>(</><g>expected</><d>)</>\n\nExpected: not < <g>18</>\nReceived:       <r>9</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [9, 18] 3`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThan<d>(</><g>expected</><d>)</>\n\nExpected: not > <g>9</>\nReceived:       <r>18</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [9, 18] 4`] = `\n<d>expect(</><r>received</><d>).</>toBeLessThan<d>(</><g>expected</><d>)</>\n\nExpected: < <g>9</>\nReceived:   <r>18</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [9, 18] 5`] = `\n<d>expect(</><r>received</><d>).</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: >= <g>18</>\nReceived:    <r>9</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [9, 18] 6`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not <= <g>18</>\nReceived:        <r>9</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [9, 18] 7`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not >= <g>9</>\nReceived:        <r>18</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [9, 18] 8`] = `\n<d>expect(</><r>received</><d>).</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: <= <g>9</>\nReceived:    <r>18</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [17, 34] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeGreaterThan<d>(</><g>expected</><d>)</>\n\nExpected: > <g>34</>\nReceived:   <r>17</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [17, 34] 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThan<d>(</><g>expected</><d>)</>\n\nExpected: not < <g>34</>\nReceived:       <r>17</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [17, 34] 3`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThan<d>(</><g>expected</><d>)</>\n\nExpected: not > <g>17</>\nReceived:       <r>34</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [17, 34] 4`] = `\n<d>expect(</><r>received</><d>).</>toBeLessThan<d>(</><g>expected</><d>)</>\n\nExpected: < <g>17</>\nReceived:   <r>34</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [17, 34] 5`] = `\n<d>expect(</><r>received</><d>).</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: >= <g>34</>\nReceived:    <r>17</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [17, 34] 6`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not <= <g>34</>\nReceived:        <r>17</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [17, 34] 7`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeGreaterThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: not >= <g>17</>\nReceived:        <r>34</>\n`;\n\nexports[`.toBeGreaterThan(), .toBeLessThan(), .toBeGreaterThanOrEqual(), .toBeLessThanOrEqual() throws: [17, 34] 8`] = `\n<d>expect(</><r>received</><d>).</>toBeLessThanOrEqual<d>(</><g>expected</><d>)</>\n\nExpected: <= <g>17</>\nReceived:    <r>34</>\n`;\n\nexports[`.toBeInstanceOf() failing \"a\" and [Function String] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor: <g>String</>\n\nReceived value has no prototype\nReceived value: <r>\"a\"</>\n`;\n\nexports[`.toBeInstanceOf() failing /\\\\w+/ and [Function anonymous] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor name is an empty string\nReceived constructor: <r>RegExp</>\n\n`;\n\nexports[`.toBeInstanceOf() failing {} and [Function A] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor: <g>A</>\n\nReceived value has no prototype\nReceived value: <r>{}</>\n`;\n\nexports[`.toBeInstanceOf() failing {} and [Function B] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor: <g>B</>\nReceived constructor: <r>A</>\n\n`;\n\nexports[`.toBeInstanceOf() failing {} and [Function RegExp] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor: <g>RegExp</>\nReceived constructor name is an empty string\n\n`;\n\nexports[`.toBeInstanceOf() failing 1 and [Function Number] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor: <g>Number</>\n\nReceived value has no prototype\nReceived value: <r>1</>\n`;\n\nexports[`.toBeInstanceOf() failing null and [Function String] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor: <g>String</>\n\nReceived value has no prototype\nReceived value: <r>null</>\n`;\n\nexports[`.toBeInstanceOf() failing true and [Function Boolean] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor: <g>Boolean</>\n\nReceived value has no prototype\nReceived value: <r>true</>\n`;\n\nexports[`.toBeInstanceOf() failing undefined and [Function String] 1`] = `\n<d>expect(</><r>received</><d>).</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor: <g>String</>\n\nReceived value has no prototype\nReceived value: <r>undefined</>\n`;\n\nexports[`.toBeInstanceOf() passing [] and [Function Array] 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor: not <g>Array</>\n\n`;\n\nexports[`.toBeInstanceOf() passing {} and [Function A] 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor: not <g>A</>\n\n`;\n\nexports[`.toBeInstanceOf() passing {} and [Function B] 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor: not <g>B</>\nReceived constructor:     <r>C</> extends <g>B</>\n\n`;\n\nexports[`.toBeInstanceOf() passing {} and [Function B] 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor: not <g>B</>\nReceived constructor:     <r>E</> extends … extends <g>B</>\n\n`;\n\nexports[`.toBeInstanceOf() passing {} and [Function B] 3`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor: not <g>B</>\nReceived constructor name is not a string\n\n`;\n\nexports[`.toBeInstanceOf() passing {} and [Function anonymous] 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor name is an empty string\nReceived constructor: <r>SubHasNameProp</>\n\n`;\n\nexports[`.toBeInstanceOf() passing {} and [Function name() {}] 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor name is not a string\n\n`;\n\nexports[`.toBeInstanceOf() passing Map {} and [Function Map] 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\nExpected constructor: not <g>Map</>\n\n`;\n\nexports[`.toBeInstanceOf() throws if constructor is not a function 1`] = `\n<d>expect(</><r>received</><d>).</>toBeInstanceOf<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a function\n\nExpected has type:  number\nExpected has value: <g>4</>\n`;\n\nexports[`.toBeNaN() {pass: true} expect(NaN).toBeNaN() 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeNaN<d>()</>\n\nReceived: <r>NaN</>\n`;\n\nexports[`.toBeNaN() {pass: true} expect(NaN).toBeNaN() 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeNaN<d>()</>\n\nReceived: <r>NaN</>\n`;\n\nexports[`.toBeNaN() {pass: true} expect(NaN).toBeNaN() 3`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeNaN<d>()</>\n\nReceived: <r>NaN</>\n`;\n\nexports[`.toBeNaN() {pass: true} expect(NaN).toBeNaN() 4`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeNaN<d>()</>\n\nReceived: <r>NaN</>\n`;\n\nexports[`.toBeNaN() throws 1`] = `\n<d>expect(</><r>received</><d>).</>toBeNaN<d>()</>\n\nReceived: <r>1</>\n`;\n\nexports[`.toBeNaN() throws 2`] = `\n<d>expect(</><r>received</><d>).</>toBeNaN<d>()</>\n\nReceived: <r>\"\"</>\n`;\n\nexports[`.toBeNaN() throws 3`] = `\n<d>expect(</><r>received</><d>).</>toBeNaN<d>()</>\n\nReceived: <r>null</>\n`;\n\nexports[`.toBeNaN() throws 4`] = `\n<d>expect(</><r>received</><d>).</>toBeNaN<d>()</>\n\nReceived: <r>undefined</>\n`;\n\nexports[`.toBeNaN() throws 5`] = `\n<d>expect(</><r>received</><d>).</>toBeNaN<d>()</>\n\nReceived: <r>{}</>\n`;\n\nexports[`.toBeNaN() throws 6`] = `\n<d>expect(</><r>received</><d>).</>toBeNaN<d>()</>\n\nReceived: <r>[]</>\n`;\n\nexports[`.toBeNaN() throws 7`] = `\n<d>expect(</><r>received</><d>).</>toBeNaN<d>()</>\n\nReceived: <r>0.2</>\n`;\n\nexports[`.toBeNaN() throws 8`] = `\n<d>expect(</><r>received</><d>).</>toBeNaN<d>()</>\n\nReceived: <r>0</>\n`;\n\nexports[`.toBeNaN() throws 9`] = `\n<d>expect(</><r>received</><d>).</>toBeNaN<d>()</>\n\nReceived: <r>Infinity</>\n`;\n\nexports[`.toBeNaN() throws 10`] = `\n<d>expect(</><r>received</><d>).</>toBeNaN<d>()</>\n\nReceived: <r>-Infinity</>\n`;\n\nexports[`.toBeNull() fails for '\"a\"' 1`] = `\n<d>expect(</><r>received</><d>).</>toBeNull<d>()</>\n\nReceived: <r>\"a\"</>\n`;\n\nexports[`.toBeNull() fails for '[]' 1`] = `\n<d>expect(</><r>received</><d>).</>toBeNull<d>()</>\n\nReceived: <r>[]</>\n`;\n\nexports[`.toBeNull() fails for '[Function anonymous]' 1`] = `\n<d>expect(</><r>received</><d>).</>toBeNull<d>()</>\n\nReceived: <r>[Function anonymous]</>\n`;\n\nexports[`.toBeNull() fails for '{}' 1`] = `\n<d>expect(</><r>received</><d>).</>toBeNull<d>()</>\n\nReceived: <r>{}</>\n`;\n\nexports[`.toBeNull() fails for '0.5' 1`] = `\n<d>expect(</><r>received</><d>).</>toBeNull<d>()</>\n\nReceived: <r>0.5</>\n`;\n\nexports[`.toBeNull() fails for '1' 1`] = `\n<d>expect(</><r>received</><d>).</>toBeNull<d>()</>\n\nReceived: <r>1</>\n`;\n\nexports[`.toBeNull() fails for 'Infinity' 1`] = `\n<d>expect(</><r>received</><d>).</>toBeNull<d>()</>\n\nReceived: <r>Infinity</>\n`;\n\nexports[`.toBeNull() fails for 'Map {}' 1`] = `\n<d>expect(</><r>received</><d>).</>toBeNull<d>()</>\n\nReceived: <r>Map {}</>\n`;\n\nexports[`.toBeNull() fails for 'true' 1`] = `\n<d>expect(</><r>received</><d>).</>toBeNull<d>()</>\n\nReceived: <r>true</>\n`;\n\nexports[`.toBeNull() fails for null with .not 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeNull<d>()</>\n\nReceived: <r>null</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '\"\"' is falsy 1`] = `\n<d>expect(</><r>received</><d>).</>toBeTruthy<d>()</>\n\nReceived: <r>\"\"</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '\"\"' is falsy 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeFalsy<d>()</>\n\nReceived: <r>\"\"</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '\"a\"' is truthy 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeTruthy<d>()</>\n\nReceived: <r>\"a\"</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '\"a\"' is truthy 2`] = `\n<d>expect(</><r>received</><d>).</>toBeFalsy<d>()</>\n\nReceived: <r>\"a\"</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '[]' is truthy 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeTruthy<d>()</>\n\nReceived: <r>[]</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '[]' is truthy 2`] = `\n<d>expect(</><r>received</><d>).</>toBeFalsy<d>()</>\n\nReceived: <r>[]</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '[Function anonymous]' is truthy 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeTruthy<d>()</>\n\nReceived: <r>[Function anonymous]</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '[Function anonymous]' is truthy 2`] = `\n<d>expect(</><r>received</><d>).</>toBeFalsy<d>()</>\n\nReceived: <r>[Function anonymous]</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '{}' is truthy 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeTruthy<d>()</>\n\nReceived: <r>{}</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '{}' is truthy 2`] = `\n<d>expect(</><r>received</><d>).</>toBeFalsy<d>()</>\n\nReceived: <r>{}</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '0' is falsy 1`] = `\n<d>expect(</><r>received</><d>).</>toBeTruthy<d>()</>\n\nReceived: <r>0</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '0' is falsy 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeFalsy<d>()</>\n\nReceived: <r>0</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '0.5' is truthy 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeTruthy<d>()</>\n\nReceived: <r>0.5</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '0.5' is truthy 2`] = `\n<d>expect(</><r>received</><d>).</>toBeFalsy<d>()</>\n\nReceived: <r>0.5</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '1' is truthy 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeTruthy<d>()</>\n\nReceived: <r>1</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() '1' is truthy 2`] = `\n<d>expect(</><r>received</><d>).</>toBeFalsy<d>()</>\n\nReceived: <r>1</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() 'Infinity' is truthy 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeTruthy<d>()</>\n\nReceived: <r>Infinity</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() 'Infinity' is truthy 2`] = `\n<d>expect(</><r>received</><d>).</>toBeFalsy<d>()</>\n\nReceived: <r>Infinity</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() 'Map {}' is truthy 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeTruthy<d>()</>\n\nReceived: <r>Map {}</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() 'Map {}' is truthy 2`] = `\n<d>expect(</><r>received</><d>).</>toBeFalsy<d>()</>\n\nReceived: <r>Map {}</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() 'NaN' is falsy 1`] = `\n<d>expect(</><r>received</><d>).</>toBeTruthy<d>()</>\n\nReceived: <r>NaN</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() 'NaN' is falsy 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeFalsy<d>()</>\n\nReceived: <r>NaN</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() 'false' is falsy 1`] = `\n<d>expect(</><r>received</><d>).</>toBeTruthy<d>()</>\n\nReceived: <r>false</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() 'false' is falsy 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeFalsy<d>()</>\n\nReceived: <r>false</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() 'null' is falsy 1`] = `\n<d>expect(</><r>received</><d>).</>toBeTruthy<d>()</>\n\nReceived: <r>null</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() 'null' is falsy 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeFalsy<d>()</>\n\nReceived: <r>null</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() 'true' is truthy 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeTruthy<d>()</>\n\nReceived: <r>true</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() 'true' is truthy 2`] = `\n<d>expect(</><r>received</><d>).</>toBeFalsy<d>()</>\n\nReceived: <r>true</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() 'undefined' is falsy 1`] = `\n<d>expect(</><r>received</><d>).</>toBeTruthy<d>()</>\n\nReceived: <r>undefined</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() 'undefined' is falsy 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeFalsy<d>()</>\n\nReceived: <r>undefined</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() does not accept arguments 1`] = `\n<d>expect(</><r>received</><d>).</>toBeTruthy<d>()</>\n\n<b>Matcher error</>: this matcher must not have an expected argument\n\nExpected has value: <g>null</>\n`;\n\nexports[`.toBeTruthy(), .toBeFalsy() does not accept arguments 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toBeFalsy<d>()</>\n\n<b>Matcher error</>: this matcher must not have an expected argument\n\nExpected has value: <g>null</>\n`;\n\nexports[`.toContain(), .toContainEqual() '\"11112111\"' contains '\"2\"' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContain<d>(</><g>expected</><d>) // indexOf</>\n\nExpected substring: not <g>\"2\"</>\nReceived string:        <r>\"1111<i>2</i>111\"</>\n`;\n\nexports[`.toContain(), .toContainEqual() '\"abcdef\"' contains '\"abc\"' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContain<d>(</><g>expected</><d>) // indexOf</>\n\nExpected substring: not <g>\"abc\"</>\nReceived string:        <r>\"<i>abc</i>def\"</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[\"a\", \"b\", \"c\", \"d\"]' contains '\"a\"' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContain<d>(</><g>expected</><d>) // indexOf</>\n\nExpected value: not <g>\"a\"</>\nReceived array:     <r>[<i>\"a\"</i>, \"b\", \"c\", \"d\"]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[\"a\", \"b\", \"c\", \"d\"]' contains a value equal to '\"a\"' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContainEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected value: not <g>\"a\"</>\nReceived array:     <r>[<i>\"a\"</i>, \"b\", \"c\", \"d\"]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[{\"a\": \"b\"}, {\"a\": \"c\"}]' contains a value equal to '{\"a\": \"b\"}' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContainEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected value: not <g>{\"a\": \"b\"}</>\nReceived array:     <r>[<i>{\"a\": \"b\"}</i>, {\"a\": \"c\"}]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[{\"a\": \"b\"}, {\"a\": \"c\"}]' does not contain a value equal to'{\"a\": \"d\"}' 1`] = `\n<d>expect(</><r>received</><d>).</>toContainEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected value: <g>{\"a\": \"d\"}</>\nReceived array: <r>[{\"a\": \"b\"}, {\"a\": \"c\"}]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[{}, []]' does not contain '[]' 1`] = `\n<d>expect(</><r>received</><d>).</>toContain<d>(</><g>expected</><d>) // indexOf</>\n\nExpected value: <g>[]</>\nReceived array: <r>[{}, []]</>\n\n<d>Looks like you wanted to test for object/array equality with the stricter \\`toContain\\` matcher. You probably need to use \\`toContainEqual\\` instead.</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[{}, []]' does not contain '{}' 1`] = `\n<d>expect(</><r>received</><d>).</>toContain<d>(</><g>expected</><d>) // indexOf</>\n\nExpected value: <g>{}</>\nReceived array: <r>[{}, []]</>\n\n<d>Looks like you wanted to test for object/array equality with the stricter \\`toContain\\` matcher. You probably need to use \\`toContainEqual\\` instead.</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[0, 1]' contains '1' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContain<d>(</><g>expected</><d>) // indexOf</>\n\nExpected value:  not <g>1</>\nReceived object:     <r>[0, 1]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[0, 1]' contains a value equal to '1' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContainEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected value:  not <g>1</>\nReceived object:     <r>[0, 1]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[1, 2, 3, 4]' contains '1' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContain<d>(</><g>expected</><d>) // indexOf</>\n\nExpected value: not <g>1</>\nReceived array:     <r>[<i>1</i>, 2, 3, 4]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[1, 2, 3, 4]' contains a value equal to '1' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContainEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected value: not <g>1</>\nReceived array:     <r>[<i>1</i>, 2, 3, 4]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[1, 2, 3]' does not contain '4' 1`] = `\n<d>expect(</><r>received</><d>).</>toContain<d>(</><g>expected</><d>) // indexOf</>\n\nExpected value: <g>4</>\nReceived array: <r>[1, 2, 3]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[Symbol(a)]' contains 'Symbol(a)' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContain<d>(</><g>expected</><d>) // indexOf</>\n\nExpected value: not <g>Symbol(a)</>\nReceived array:     <r>[<i>Symbol(a)</i>]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[Symbol(a)]' contains a value equal to 'Symbol(a)' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContainEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected value: not <g>Symbol(a)</>\nReceived array:     <r>[<i>Symbol(a)</i>]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[null, undefined]' does not contain '1' 1`] = `\n<d>expect(</><r>received</><d>).</>toContain<d>(</><g>expected</><d>) // indexOf</>\n\nExpected value: <g>1</>\nReceived array: <r>[null, undefined]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[undefined, null]' contains 'null' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContain<d>(</><g>expected</><d>) // indexOf</>\n\nExpected value: not <g>null</>\nReceived array:     <r>[undefined, <i>null</i>]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[undefined, null]' contains 'undefined' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContain<d>(</><g>expected</><d>) // indexOf</>\n\nExpected value: not <g>undefined</>\nReceived array:     <r>[<i>undefined</i>, null]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[undefined, null]' contains a value equal to 'null' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContainEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected value: not <g>null</>\nReceived array:     <r>[undefined, <i>null</i>]</>\n`;\n\nexports[`.toContain(), .toContainEqual() '[undefined, null]' contains a value equal to 'undefined' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContainEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected value: not <g>undefined</>\nReceived array:     <r>[<i>undefined</i>, null]</>\n`;\n\nexports[`.toContain(), .toContainEqual() 'Set {\"abc\", \"def\"}' contains '\"abc\"' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContain<d>(</><g>expected</><d>) // indexOf</>\n\nExpected value: not <g>\"abc\"</>\nReceived set:       <r>Set {\"abc\", \"def\"}</>\n`;\n\nexports[`.toContain(), .toContainEqual() 'Set {1, 2, 3, 4}' contains a value equal to '1' 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toContainEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected value: not <g>1</>\nReceived set:       <r>Set {1, 2, 3, 4}</>\n`;\n\nexports[`.toContain(), .toContainEqual() error cases 1`] = `\n<d>expect(</><r>received</><d>).</>toContain<d>(</><g>expected</><d>) // indexOf</>\n\n<b>Matcher error</>: <r>received</> value must not be null nor undefined\n\nReceived has value: <r>null</>\n`;\n\nexports[`.toContain(), .toContainEqual() error cases 2`] = `\n<d>expect(</><r>-0</><d>).</>toContain<d>(</><g>0</><d>) // indexOf</>\n\n<b>Matcher error</>: <g>expected</> value must be a string if <r>received</> value is a string\n\nExpected has type:  number\nExpected has value: <g>-0</>\nReceived has type:  string\nReceived has value: <r>\"-0\"</>\n`;\n\nexports[`.toContain(), .toContainEqual() error cases 3`] = `\n<d>expect(</><r>null</><d>).</>toContain<d>(</><g>null</><d>) // indexOf</>\n\n<b>Matcher error</>: <g>expected</> value must be a string if <r>received</> value is a string\n\nExpected has value: <g>null</>\nReceived has type:  string\nReceived has value: <r>\"null\"</>\n`;\n\nexports[`.toContain(), .toContainEqual() error cases 4`] = `\n<d>expect(</><r>undefined</><d>).</>toContain<d>(</><g>undefined</><d>) // indexOf</>\n\n<b>Matcher error</>: <g>expected</> value must be a string if <r>received</> value is a string\n\nExpected has value: <g>undefined</>\nReceived has type:  string\nReceived has value: <r>\"undefined\"</>\n`;\n\nexports[`.toContain(), .toContainEqual() error cases 5`] = `\n<d>expect(</><r>false</><d>).</>toContain<d>(</><g>false</><d>) // indexOf</>\n\n<b>Matcher error</>: <g>expected</> value must be a string if <r>received</> value is a string\n\nExpected has type:  boolean\nExpected has value: <g>false</>\nReceived has type:  string\nReceived has value: <r>\"false\"</>\n`;\n\nexports[`.toContain(), .toContainEqual() error cases for toContainEqual 1`] = `\n<d>expect(</><r>received</><d>).</>toContainEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<b>Matcher error</>: <r>received</> value must not be null nor undefined\n\nReceived has value: <r>null</>\n`;\n\nexports[`.toEqual() {pass: false} expect(\"1 234,57 $\").toEqual(\"1 234,57 $\") 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>\"1<i> </i>234,57<i> </i>$\"</>\nReceived: <r>\"1<i> </i>234,57<i> </i>$\"</>\n`;\n\nexports[`.toEqual() {pass: false} expect(\"Eve\").toEqual({\"asymmetricMatch\": [Function asymmetricMatch]}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>{\"asymmetricMatch\": [Function asymmetricMatch]}</>\nReceived: <r>\"Eve\"</>\n`;\n\nexports[`.toEqual() {pass: false} expect(\"abc\").toEqual({\"0\": \"a\", \"1\": \"b\", \"2\": \"c\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>{\"0\": \"a\", \"1\": \"b\", \"2\": \"c\"}</>\nReceived: <r>\"abc\"</>\n`;\n\nexports[`.toEqual() {pass: false} expect(\"abd\").toEqual(StringContaining \"bc\") 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>StringContaining \"bc\"</>\nReceived: <r>\"abd\"</>\n`;\n\nexports[`.toEqual() {pass: false} expect(\"abd\").toEqual(StringMatching /bc/i) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>StringMatching /bc/i</>\nReceived: <r>\"abd\"</>\n`;\n\nexports[`.toEqual() {pass: false} expect(\"banana\").toEqual(\"apple\") 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>\"apple\"</>\nReceived: <r>\"banana\"</>\n`;\n\nexports[`.toEqual() {pass: false} expect(\"type TypeName<T> = T extends Function ? \\\\\"function\\\\\" : \\\\\"object\\\\\";\").toEqual(\"type TypeName<T> = T extends Function\n? \\\\\"function\\\\\"\n: \\\\\"object\\\\\";\") 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 3</>\n<r>+ Received  + 1</>\n\n<g>- type TypeName<T> = T extends Function</>\n<g>- ? \"function\"</>\n<g>- : \"object\";</>\n<r>+ type TypeName<T> = T extends Function<i> </i>? \"function\"<i> </i>: \"object\";</>\n`;\n\nexports[`.toEqual() {pass: false} expect(/abc/gsy).toEqual(/abc/g) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>/abc/g</>\nReceived: <r>/abc/gsy</>\n`;\n\nexports[`.toEqual() {pass: false} expect([, , 1, ]).toEqual([, , 2, ]) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Array [</>\n<d>    undefined,</>\n<d>    undefined,</>\n<g>-   2,</>\n<r>+   1,</>\n<d>    undefined,</>\n<d>  ]</>\n`;\n\nexports[`.toEqual() {pass: false} expect([]).toEqual([]) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>[]</>\nReceived: serializes to the same string\n`;\n\nexports[`.toEqual() {pass: false} expect([]).toEqual([]) 2`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>[]</>\nReceived: serializes to the same string\n`;\n\nexports[`.toEqual() {pass: false} expect([]).toEqual([]) 3`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>[]</>\nReceived: serializes to the same string\n`;\n\nexports[`.toEqual() {pass: false} expect([]).toEqual([1]) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 3</>\n<r>+ Received  + 1</>\n\n<g>- Array [</>\n<g>-   1,</>\n<g>- ]</>\n<r>+ Array []</>\n`;\n\nexports[`.toEqual() {pass: false} expect([1, 2]).toEqual([2, 1]) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Array [</>\n<g>-   2,</>\n<d>    1,</>\n<r>+   2,</>\n<d>  ]</>\n`;\n\nexports[`.toEqual() {pass: false} expect([1, 3]).toEqual(ArrayContaining [1, 2]) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>ArrayContaining [1, 2]</>\nReceived: <r>[1, 3]</>\n`;\n\nexports[`.toEqual() {pass: false} expect([1]).toEqual([2]) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Array [</>\n<g>-   2,</>\n<r>+   1,</>\n<d>  ]</>\n`;\n\nexports[`.toEqual() {pass: false} expect([97, 98, 99]).toEqual([97, 98, 100]) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Uint8Array [</>\n<d>    97,</>\n<d>    98,</>\n<g>-   100,</>\n<r>+   99,</>\n<d>  ]</>\n`;\n\nexports[`.toEqual() {pass: false} expect({\"0\": \"a\", \"1\": \"b\", \"2\": \"c\"}).toEqual(\"abc\") 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>\"abc\"</>\nReceived: <r>{\"0\": \"a\", \"1\": \"b\", \"2\": \"c\"}</>\n`;\n\nexports[`.toEqual() {pass: false} expect({\"a\": 1, \"b\": 2}).toEqual(ObjectContaining {\"a\": 2}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 2</>\n<r>+ Received  + 2</>\n\n<g>- ObjectContaining {</>\n<g>-   \"a\": 2,</>\n<r>+ Object {</>\n<r>+   \"a\": 1,</>\n<d>    \"b\": 2,</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect({\"a\": 1}).toEqual({\"a\": 2}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": 2,</>\n<r>+   \"a\": 1,</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect({\"a\": 5}).toEqual({\"b\": 6}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"b\": 6,</>\n<r>+   \"a\": 5,</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect({\"foo\": {\"bar\": 1}}).toEqual({\"foo\": {}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 3</>\n\n<d>  Object {</>\n<g>-   \"foo\": Object {},</>\n<r>+   \"foo\": Object {</>\n<r>+     \"bar\": 1,</>\n<r>+   },</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect({\"frozenGetter\": {}}).toEqual({\"frozenGetter\": {\"foo\": \"bar\"}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 3</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"frozenGetter\": Object {</>\n<g>-     \"foo\": \"bar\",</>\n<g>-   },</>\n<r>+   \"frozenGetter\": Object {},</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect({\"frozenGetterAndSetter\": {}}).toEqual({\"frozenGetterAndSetter\": {\"foo\": \"bar\"}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 3</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"frozenGetterAndSetter\": Object {</>\n<g>-     \"foo\": \"bar\",</>\n<g>-   },</>\n<r>+   \"frozenGetterAndSetter\": Object {},</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect({\"frozenSetter\": undefined}).toEqual({\"frozenSetter\": {\"foo\": \"bar\"}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 3</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"frozenSetter\": Object {</>\n<g>-     \"foo\": \"bar\",</>\n<g>-   },</>\n<r>+   \"frozenSetter\": undefined,</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect({\"getter\": {}}).toEqual({\"getter\": {\"foo\": \"bar\"}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 3</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"getter\": Object {</>\n<g>-     \"foo\": \"bar\",</>\n<g>-   },</>\n<r>+   \"getter\": Object {},</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect({\"getterAndSetter\": {}}).toEqual({\"getterAndSetter\": {\"foo\": \"bar\"}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 3</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"getterAndSetter\": Object {</>\n<g>-     \"foo\": \"bar\",</>\n<g>-   },</>\n<r>+   \"getterAndSetter\": Object {},</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect({\"nodeName\": \"div\", \"nodeType\": 1}).toEqual({\"nodeName\": \"p\", \"nodeType\": 1}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"nodeName\": \"p\",</>\n<r>+   \"nodeName\": \"div\",</>\n<d>    \"nodeType\": 1,</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect({\"setter\": undefined}).toEqual({\"setter\": {\"foo\": \"bar\"}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 3</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"setter\": Object {</>\n<g>-     \"foo\": \"bar\",</>\n<g>-   },</>\n<r>+   \"setter\": undefined,</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect({\"target\": {\"nodeType\": 1, \"value\": \"a\"}}).toEqual({\"target\": {\"nodeType\": 1, \"value\": \"b\"}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<d>    \"target\": Object {</>\n<d>      \"nodeType\": 1,</>\n<g>-     \"value\": \"b\",</>\n<r>+     \"value\": \"a\",</>\n<d>    },</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect({}).toEqual({}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>{}</>\nReceived: serializes to the same string\n`;\n\nexports[`.toEqual() {pass: false} expect({}).toEqual(0) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>0</>\nReceived: <r>{}</>\n`;\n\nexports[`.toEqual() {pass: false} expect({Symbol(foo): 1, Symbol(bar): 2}).toEqual({Symbol(foo): Any<Number>, Symbol(bar): 1}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<d>    Symbol(foo): Any<Number>,</>\n<g>-   Symbol(bar): 1,</>\n<r>+   Symbol(bar): 2,</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(0).toEqual({}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>{}</>\nReceived: <r>0</>\n`;\n\nexports[`.toEqual() {pass: false} expect(0).toEqual(-0) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>-0</>\nReceived: <r>0</>\n`;\n\nexports[`.toEqual() {pass: false} expect(0).toEqual(5e-324) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>5e-324</>\nReceived: <r>0</>\n`;\n\nexports[`.toEqual() {pass: false} expect(1).toEqual(2) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>2</>\nReceived: <r>1</>\n`;\n\nexports[`.toEqual() {pass: false} expect(1).toEqual(ArrayContaining [1, 2]) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>ArrayContaining [1, 2]</>\nReceived: <r>1</>\n`;\n\nexports[`.toEqual() {pass: false} expect(5e-324).toEqual(0) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>0</>\nReceived: <r>5e-324</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Immutable.List [1, 2]).toEqual(Immutable.List [2, 1]) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Immutable.List [</>\n<g>-   2,</>\n<d>    1,</>\n<r>+   2,</>\n<d>  ]</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Immutable.List [1]).toEqual(Immutable.List [2]) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Immutable.List [</>\n<g>-   2,</>\n<r>+   1,</>\n<d>  ]</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Immutable.Map {\"1\": Immutable.Map {\"2\": {\"a\": 99}}}).toEqual(Immutable.Map {\"1\": Immutable.Map {\"2\": {\"a\": 11}}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Immutable.Map {</>\n<d>    \"1\": Immutable.Map {</>\n<d>      \"2\": Object {</>\n<g>-       \"a\": 11,</>\n<r>+       \"a\": 99,</>\n<d>      },</>\n<d>    },</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Immutable.Map {\"a\": 0}).toEqual(Immutable.Map {\"b\": 0}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Immutable.Map {</>\n<g>-   \"b\": 0,</>\n<r>+   \"a\": 0,</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Immutable.Map {\"v\": 1}).toEqual(Immutable.Map {\"v\": 2}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Immutable.Map {</>\n<g>-   \"v\": 2,</>\n<r>+   \"v\": 1,</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Immutable.OrderedMap {1: \"one\", 2: \"two\"}).toEqual(Immutable.OrderedMap {2: \"two\", 1: \"one\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Immutable.OrderedMap {</>\n<g>-   2: \"two\",</>\n<d>    1: \"one\",</>\n<r>+   2: \"two\",</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Immutable.OrderedSet [1, 2]).toEqual(Immutable.OrderedSet [2, 1]) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Immutable.OrderedSet [</>\n<g>-   2,</>\n<d>    1,</>\n<r>+   2,</>\n<d>  ]</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Immutable.Set [1, 2]).toEqual(Immutable.Set []) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 4</>\n\n<g>- Immutable.Set []</>\n<r>+ Immutable.Set [</>\n<r>+   1,</>\n<r>+   2,</>\n<r>+ ]</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Immutable.Set [1, 2]).toEqual(Immutable.Set [1, 2, 3]) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 0</>\n\n<d>  Immutable.Set [</>\n<d>    1,</>\n<d>    2,</>\n<g>-   3,</>\n<d>  ]</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Map {\"a\" => 0}).toEqual(Map {\"b\" => 0}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Map {</>\n<g>-   \"b\" => 0,</>\n<r>+   \"a\" => 0,</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Map {\"v\" => 1}).toEqual(Map {\"v\" => 2}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Map {</>\n<g>-   \"v\" => 2,</>\n<r>+   \"v\" => 1,</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Map {[\"v\"] => 1}).toEqual(Map {[\"v\"] => 2}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Map {</>\n<d>    Array [</>\n<d>      \"v\",</>\n<g>-   ] => 2,</>\n<r>+   ] => 1,</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Map {[1] => Map {[1] => \"one\"}}).toEqual(Map {[1] => Map {[1] => \"two\"}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<y>@@ -2,8 +2,8 @@</>\n<d>    Array [</>\n<d>      1,</>\n<d>    ] => Map {</>\n<d>      Array [</>\n<d>        1,</>\n<g>-     ] => \"two\",</>\n<r>+     ] => \"one\",</>\n<d>    },</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Map {}).toEqual(Set {}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>Set {}</>\nReceived: <r>Map {}</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Map {1 => \"one\", 2 => \"two\"}).toEqual(Map {1 => \"one\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 0</>\n<r>+ Received  + 1</>\n\n<d>  Map {</>\n<d>    1 => \"one\",</>\n<r>+   2 => \"two\",</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Set {[1], [2]}).toEqual(Set {[1], [2], [2]}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 3</>\n<r>+ Received  + 0</>\n\n<y>@@ -3,9 +3,6 @@</>\n<d>      1,</>\n<d>    ],</>\n<d>    Array [</>\n<d>      2,</>\n<d>    ],</>\n<g>-   Array [</>\n<g>-     2,</>\n<g>-   ],</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Set {[1], [2]}).toEqual(Set {[1], [2], [3]}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 3</>\n<r>+ Received  + 0</>\n\n<y>@@ -3,9 +3,6 @@</>\n<d>      1,</>\n<d>    ],</>\n<d>    Array [</>\n<d>      2,</>\n<d>    ],</>\n<g>-   Array [</>\n<g>-     3,</>\n<g>-   ],</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Set {1, 2}).toEqual(Set {}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 4</>\n\n<g>- Set {}</>\n<r>+ Set {</>\n<r>+   1,</>\n<r>+   2,</>\n<r>+ }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Set {1, 2}).toEqual(Set {1, 2, 3}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 0</>\n\n<d>  Set {</>\n<d>    1,</>\n<d>    2,</>\n<g>-   3,</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(Set {Set {1}, Set {2}}).toEqual(Set {Set {1}, Set {3}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Set {</>\n<d>    Set {</>\n<d>      1,</>\n<d>    },</>\n<d>    Set {</>\n<g>-     3,</>\n<r>+     2,</>\n<d>    },</>\n<d>  }</>\n`;\n\nexports[`.toEqual() {pass: false} expect(false).toEqual(ObjectContaining {\"a\": 2}) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>ObjectContaining {\"a\": 2}</>\nReceived: <r>false</>\n`;\n\nexports[`.toEqual() {pass: false} expect(null).toEqual(undefined) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>undefined</>\nReceived: <r>null</>\n`;\n\nexports[`.toEqual() {pass: false} expect(true).toEqual(false) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>false</>\nReceived: <r>true</>\n`;\n\nexports[`.toEqual() {pass: false} expect(undefined).toEqual(Any<Function>) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>Any<Function></>\nReceived: <r>undefined</>\n`;\n\nexports[`.toEqual() {pass: false} expect(undefined).toEqual(Anything) 1`] = `\n<d>expect(</><r>received</><d>).</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>Anything</>\nReceived: <r>undefined</>\n`;\n\nexports[`.toEqual() {pass: true} expect(\"Alice\").not.toEqual({\"asymmetricMatch\": [Function asymmetricMatch]}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>{\"asymmetricMatch\": [Function asymmetricMatch]}</>\nReceived:     <r>\"Alice\"</>\n`;\n\nexports[`.toEqual() {pass: true} expect(\"abc\").not.toEqual(\"abc\") 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>\"abc\"</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(\"abc\").not.toEqual(\"abc\") 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>\"abc\"</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(\"abc\").not.toEqual(\"abc\") 3`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>\"abc\"</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(\"abcd\").not.toEqual(StringContaining \"bc\") 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>StringContaining \"bc\"</>\nReceived:     <r>\"abcd\"</>\n`;\n\nexports[`.toEqual() {pass: true} expect(\"abcd\").not.toEqual(StringMatching /bc/) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>StringMatching /bc/</>\nReceived:     <r>\"abcd\"</>\n`;\n\nexports[`.toEqual() {pass: true} expect([, , 1, , ]).not.toEqual([, , 1, undefined, ]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>[, , 1, undefined, ]</>\nReceived:     <r>[, , 1, , ]</>\n`;\n\nexports[`.toEqual() {pass: true} expect([, , 1, ]).not.toEqual([, , 1, ]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>[, , 1, ]</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect([1, [Function anonymous]]).not.toEqual([1, optionalFn<>]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>[1, optionalFn<>]</>\nReceived:     <r>[1, [Function anonymous]]</>\n`;\n\nexports[`.toEqual() {pass: true} expect([1, 2, 3]).not.toEqual(ArrayContaining [2, 3]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>ArrayContaining [2, 3]</>\nReceived:     <r>[1, 2, 3]</>\n`;\n\nexports[`.toEqual() {pass: true} expect([1, 2]).not.toEqual([1, 2]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>[1, 2]</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect([1, optionalFn<>]).not.toEqual([1, [Function anonymous]]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>[1, [Function anonymous]]</>\nReceived:     <r>[1, optionalFn<>]</>\n`;\n\nexports[`.toEqual() {pass: true} expect([1, optionalFn<>]).not.toEqual([1, undefined]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>[1, undefined]</>\nReceived:     <r>[1, optionalFn<>]</>\n`;\n\nexports[`.toEqual() {pass: true} expect([1, optionalFn<>]).not.toEqual([1]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>[1]</>\nReceived:     <r>[1, optionalFn<>]</>\n`;\n\nexports[`.toEqual() {pass: true} expect([1, undefined]).not.toEqual([1, optionalFn<>]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>[1, optionalFn<>]</>\nReceived:     <r>[1, undefined]</>\n`;\n\nexports[`.toEqual() {pass: true} expect([1]).not.toEqual([1, optionalFn<>]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>[1, optionalFn<>]</>\nReceived:     <r>[1]</>\n`;\n\nexports[`.toEqual() {pass: true} expect([1]).not.toEqual([1]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>[1]</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect([97, 98, 99]).not.toEqual([97, 98, 99]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>[97, 98, 99]</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect([Function anonymous]).not.toEqual(Any<Function>) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Any<Function></>\nReceived:     <r>[Function anonymous]</>\n`;\n\nexports[`.toEqual() {pass: true} expect({\"a\": 1, \"b\": [Function b], \"c\": true}).not.toEqual({\"a\": 1, \"b\": Any<Function>, \"c\": Anything}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>{\"a\": 1, \"b\": Any<Function>, \"c\": Anything}</>\nReceived:     <r>{\"a\": 1, \"b\": [Function b], \"c\": true}</>\n`;\n\nexports[`.toEqual() {pass: true} expect({\"a\": 1, \"b\": [Function b]}).not.toEqual({\"a\": 1, \"b\": optionalFn<>}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>{\"a\": 1, \"b\": optionalFn<>}</>\nReceived:     <r>{\"a\": 1, \"b\": [Function b]}</>\n`;\n\nexports[`.toEqual() {pass: true} expect({\"a\": 1, \"b\": 2}).not.toEqual(ObjectContaining {\"a\": 1}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>ObjectContaining {\"a\": 1}</>\nReceived:     <r>{\"a\": 1, \"b\": 2}</>\n`;\n\nexports[`.toEqual() {pass: true} expect({\"a\": 1, \"b\": optionalFn<>}).not.toEqual({\"a\": 1, \"b\": [Function b]}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>{\"a\": 1, \"b\": [Function b]}</>\nReceived:     <r>{\"a\": 1, \"b\": optionalFn<>}</>\n`;\n\nexports[`.toEqual() {pass: true} expect({\"a\": 1, \"b\": optionalFn<>}).not.toEqual({\"a\": 1, \"b\": undefined}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>{\"a\": 1, \"b\": undefined}</>\nReceived:     <r>{\"a\": 1, \"b\": optionalFn<>}</>\n`;\n\nexports[`.toEqual() {pass: true} expect({\"a\": 1, \"b\": optionalFn<>}).not.toEqual({\"a\": 1}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>{\"a\": 1}</>\nReceived:     <r>{\"a\": 1, \"b\": optionalFn<>}</>\n`;\n\nexports[`.toEqual() {pass: true} expect({\"a\": 1, \"b\": undefined}).not.toEqual({\"a\": 1, \"b\": optionalFn<>}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>{\"a\": 1, \"b\": optionalFn<>}</>\nReceived:     <r>{\"a\": 1, \"b\": undefined}</>\n`;\n\nexports[`.toEqual() {pass: true} expect({\"a\": 1}).not.toEqual({\"a\": 1, \"b\": optionalFn<>}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>{\"a\": 1, \"b\": optionalFn<>}</>\nReceived:     <r>{\"a\": 1}</>\n`;\n\nexports[`.toEqual() {pass: true} expect({\"a\": 99}).not.toEqual({\"a\": 99}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>{\"a\": 99}</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect({\"nodeName\": \"div\", \"nodeType\": 1}).not.toEqual({\"nodeName\": \"div\", \"nodeType\": 1}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>{\"nodeName\": \"div\", \"nodeType\": 1}</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect({}).not.toEqual({}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>{}</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect({}).not.toEqual({}) 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>{}</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect({Symbol(foo): 1, Symbol(bar): 2}).not.toEqual({Symbol(foo): Any<Number>, Symbol(bar): 2}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>{Symbol(foo): Any<Number>, Symbol(bar): 2}</>\nReceived:     <r>{Symbol(foo): 1, Symbol(bar): 2}</>\n`;\n\nexports[`.toEqual() {pass: true} expect(0).not.toEqual(0) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>0</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(0).not.toEqual(0) 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>0</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(1).not.toEqual(1) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>1</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Immutable.List [1, 2]).not.toEqual(Immutable.List [1, 2]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Immutable.List [1, 2]</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Immutable.List [1]).not.toEqual(Immutable.List [1]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Immutable.List [1]</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Immutable.Map {\"1\": Immutable.Map {\"2\": {\"a\": 99}}}).not.toEqual(Immutable.Map {\"1\": Immutable.Map {\"2\": {\"a\": 99}}}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Immutable.Map {\"1\": Immutable.Map {\"2\": {\"a\": 99}}}</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Immutable.Map {}).not.toEqual(Immutable.Map {}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Immutable.Map {}</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Immutable.Map {1: \"one\", 2: \"two\"}).not.toEqual(Immutable.Map {1: \"one\", 2: \"two\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Immutable.Map {1: \"one\", 2: \"two\"}</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Immutable.Map {1: \"one\", 2: \"two\"}).not.toEqual(Immutable.Map {2: \"two\", 1: \"one\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Immutable.Map {2: \"two\", 1: \"one\"}</>\nReceived:     <r>Immutable.Map {1: \"one\", 2: \"two\"}</>\n`;\n\nexports[`.toEqual() {pass: true} expect(Immutable.OrderedMap {1: \"one\", 2: \"two\"}).not.toEqual(Immutable.OrderedMap {1: \"one\", 2: \"two\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Immutable.OrderedMap {1: \"one\", 2: \"two\"}</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Immutable.OrderedSet []).not.toEqual(Immutable.OrderedSet []) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Immutable.OrderedSet []</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Immutable.OrderedSet [1, 2]).not.toEqual(Immutable.OrderedSet [1, 2]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Immutable.OrderedSet [1, 2]</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Immutable.Set []).not.toEqual(Immutable.Set []) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Immutable.Set []</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Immutable.Set [1, 2]).not.toEqual(Immutable.Set [1, 2]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Immutable.Set [1, 2]</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Immutable.Set [1, 2]).not.toEqual(Immutable.Set [2, 1]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Immutable.Set [2, 1]</>\nReceived:     <r>Immutable.Set [1, 2]</>\n`;\n\nexports[`.toEqual() {pass: true} expect(Map {[1] => \"one\", [2] => \"two\", [3] => \"three\", [3] => \"four\"}).not.toEqual(Map {[3] => \"three\", [3] => \"four\", [2] => \"two\", [1] => \"one\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Map {[3] => \"three\", [3] => \"four\", [2] => \"two\", [1] => \"one\"}</>\nReceived:     <r>Map {[1] => \"one\", [2] => \"two\", [3] => \"three\", [3] => \"four\"}</>\n`;\n\nexports[`.toEqual() {pass: true} expect(Map {[1] => \"one\", [2] => \"two\"}).not.toEqual(Map {[2] => \"two\", [1] => \"one\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Map {[2] => \"two\", [1] => \"one\"}</>\nReceived:     <r>Map {[1] => \"one\", [2] => \"two\"}</>\n`;\n\nexports[`.toEqual() {pass: true} expect(Map {[1] => Map {[1] => \"one\"}, [2] => Map {[2] => \"two\"}}).not.toEqual(Map {[2] => Map {[2] => \"two\"}, [1] => Map {[1] => \"one\"}}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Map {[2] => Map {[2] => \"two\"}, [1] => Map {[1] => \"one\"}}</>\nReceived:     <r>Map {[1] => Map {[1] => \"one\"}, [2] => Map {[2] => \"two\"}}</>\n`;\n\nexports[`.toEqual() {pass: true} expect(Map {{\"a\": 1} => \"one\", {\"b\": 2} => \"two\"}).not.toEqual(Map {{\"b\": 2} => \"two\", {\"a\": 1} => \"one\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Map {{\"b\": 2} => \"two\", {\"a\": 1} => \"one\"}</>\nReceived:     <r>Map {{\"a\": 1} => \"one\", {\"b\": 2} => \"two\"}</>\n`;\n\nexports[`.toEqual() {pass: true} expect(Map {}).not.toEqual(Map {}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Map {}</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Map {1 => \"one\", 2 => \"two\"}).not.toEqual(Map {1 => \"one\", 2 => \"two\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Map {1 => \"one\", 2 => \"two\"}</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Map {1 => \"one\", 2 => \"two\"}).not.toEqual(Map {2 => \"two\", 1 => \"one\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Map {2 => \"two\", 1 => \"one\"}</>\nReceived:     <r>Map {1 => \"one\", 2 => \"two\"}</>\n`;\n\nexports[`.toEqual() {pass: true} expect(Map {1 => [\"one\"], 2 => [\"two\"]}).not.toEqual(Map {2 => [\"two\"], 1 => [\"one\"]}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Map {2 => [\"two\"], 1 => [\"one\"]}</>\nReceived:     <r>Map {1 => [\"one\"], 2 => [\"two\"]}</>\n`;\n\nexports[`.toEqual() {pass: true} expect(NaN).not.toEqual(NaN) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>NaN</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Set {[1], [2], [3], [3]}).not.toEqual(Set {[3], [3], [2], [1]}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Set {[3], [3], [2], [1]}</>\nReceived:     <r>Set {[1], [2], [3], [3]}</>\n`;\n\nexports[`.toEqual() {pass: true} expect(Set {[1], [2]}).not.toEqual(Set {[2], [1]}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Set {[2], [1]}</>\nReceived:     <r>Set {[1], [2]}</>\n`;\n\nexports[`.toEqual() {pass: true} expect(Set {{\"a\": 1}, {\"b\": 2}}).not.toEqual(Set {{\"b\": 2}, {\"a\": 1}}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Set {{\"b\": 2}, {\"a\": 1}}</>\nReceived:     <r>Set {{\"a\": 1}, {\"b\": 2}}</>\n`;\n\nexports[`.toEqual() {pass: true} expect(Set {}).not.toEqual(Set {}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Set {}</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Set {1, 2}).not.toEqual(Set {1, 2}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Set {1, 2}</>\n\n`;\n\nexports[`.toEqual() {pass: true} expect(Set {1, 2}).not.toEqual(Set {2, 1}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Set {2, 1}</>\nReceived:     <r>Set {1, 2}</>\n`;\n\nexports[`.toEqual() {pass: true} expect(Set {Set {[1]}, Set {[2]}}).not.toEqual(Set {Set {[2]}, Set {[1]}}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Set {Set {[2]}, Set {[1]}}</>\nReceived:     <r>Set {Set {[1]}, Set {[2]}}</>\n`;\n\nexports[`.toEqual() {pass: true} expect(true).not.toEqual(Anything) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>Anything</>\nReceived:     <r>true</>\n`;\n\nexports[`.toEqual() {pass: true} expect(true).not.toEqual(true) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>true</>\n\n`;\n\nexports[`.toHaveLength {pass: false} expect(\"\").toHaveLength(1) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveLength<d>(</><g>expected</><d>)</>\n\nExpected length: <g>1</>\nReceived length: <r>0</>\nReceived string: <r>\"\"</>\n`;\n\nexports[`.toHaveLength {pass: false} expect(\"abc\").toHaveLength(66) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveLength<d>(</><g>expected</><d>)</>\n\nExpected length: <g>66</>\nReceived length: <r>3</>\nReceived string: <r>\"abc\"</>\n`;\n\nexports[`.toHaveLength {pass: false} expect([\"a\", \"b\"]).toHaveLength(99) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveLength<d>(</><g>expected</><d>)</>\n\nExpected length: <g>99</>\nReceived length: <r>2</>\nReceived array:  <r>[\"a\", \"b\"]</>\n`;\n\nexports[`.toHaveLength {pass: false} expect([]).toHaveLength(1) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveLength<d>(</><g>expected</><d>)</>\n\nExpected length: <g>1</>\nReceived length: <r>0</>\nReceived array:  <r>[]</>\n`;\n\nexports[`.toHaveLength {pass: false} expect([1, 2]).toHaveLength(3) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveLength<d>(</><g>expected</><d>)</>\n\nExpected length: <g>3</>\nReceived length: <r>2</>\nReceived array:  <r>[1, 2]</>\n`;\n\nexports[`.toHaveLength {pass: true} expect(\"\").toHaveLength(0) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveLength<d>(</><g>expected</><d>)</>\n\nExpected length: not <g>0</>\nReceived string:     <r>\"\"</>\n`;\n\nexports[`.toHaveLength {pass: true} expect(\"abc\").toHaveLength(3) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveLength<d>(</><g>expected</><d>)</>\n\nExpected length: not <g>3</>\nReceived string:     <r>\"abc\"</>\n`;\n\nexports[`.toHaveLength {pass: true} expect([\"a\", \"b\"]).toHaveLength(2) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveLength<d>(</><g>expected</><d>)</>\n\nExpected length: not <g>2</>\nReceived array:      <r>[\"a\", \"b\"]</>\n`;\n\nexports[`.toHaveLength {pass: true} expect([]).toHaveLength(0) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveLength<d>(</><g>expected</><d>)</>\n\nExpected length: not <g>0</>\nReceived array:      <r>[]</>\n`;\n\nexports[`.toHaveLength {pass: true} expect([1, 2]).toHaveLength(2) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveLength<d>(</><g>expected</><d>)</>\n\nExpected length: not <g>2</>\nReceived array:      <r>[1, 2]</>\n`;\n\nexports[`.toHaveLength {pass: true} expect([Function anonymous]).toHaveLength(0) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveLength<d>(</><g>expected</><d>)</>\n\nExpected length:   not <g>0</>\nReceived function:     <r>[Function anonymous]</>\n`;\n\nexports[`.toHaveLength error cases 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveLength<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must have a length property whose value must be a number\n\nReceived has type:  object\nReceived has value: <r>{\"a\": 9}</>\n`;\n\nexports[`.toHaveLength error cases 2`] = `\n<d>expect(</><r>received</><d>).</>toHaveLength<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must have a length property whose value must be a number\n\nReceived has type:  number\nReceived has value: <r>0</>\n`;\n\nexports[`.toHaveLength error cases 3`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveLength<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must have a length property whose value must be a number\n\nReceived has value: <r>undefined</>\n`;\n\nexports[`.toHaveLength matcher error expected length not number 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveLength<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  string\nExpected has value: <g>\"3\"</>\n`;\n\nexports[`.toHaveLength matcher error expected length number Infinity 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>toHaveLength<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  number\nExpected has value: <g>Infinity</>\n`;\n\nexports[`.toHaveLength matcher error expected length number NaN 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>not<d>.</>toHaveLength<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  number\nExpected has value: <g>NaN</>\n`;\n\nexports[`.toHaveLength matcher error expected length number float 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>toHaveLength<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  number\nExpected has value: <g>0.5</>\n`;\n\nexports[`.toHaveLength matcher error expected length number negative integer 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>not<d>.</>toHaveLength<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  number\nExpected has value: <g>-3</>\n`;\n\nexports[`.toHaveProperty() {error} expect({\"a\": {\"b\": {}}}).toHaveProperty('1') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\n<b>Matcher error</>: <g>expected</> path must be a string or array\n\nExpected has type:  number\nExpected has value: <g>1</>\n`;\n\nexports[`.toHaveProperty() {error} expect({\"a\": {\"b\": {}}}).toHaveProperty('null') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\n<b>Matcher error</>: <g>expected</> path must be a string or array\n\nExpected has value: <g>null</>\n`;\n\nexports[`.toHaveProperty() {error} expect({\"a\": {\"b\": {}}}).toHaveProperty('undefined') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\n<b>Matcher error</>: <g>expected</> path must be a string or array\n\nExpected has value: <g>undefined</>\n`;\n\nexports[`.toHaveProperty() {error} expect({}).toHaveProperty('') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\n<b>Matcher error</>: <g>expected</> path must not be an empty array\n\nExpected has type:  array\nExpected has value: <g>[]</>\n`;\n\nexports[`.toHaveProperty() {error} expect(null).toHaveProperty('a.b') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must not be null nor undefined\n\nReceived has value: <r>null</>\n`;\n\nexports[`.toHaveProperty() {error} expect(undefined).toHaveProperty('a') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must not be null nor undefined\n\nReceived has value: <r>undefined</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect(\"\").toHaveProperty('key') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: <g>\"key\"</>\nReceived path: <r>[]</>\n\nReceived value: <r>\"\"</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect(\"abc\").toHaveProperty('a.b.c') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: <g>\"a.b.c\"</>\nReceived path: <r>[]</>\n\nReceived value: <r>\"abc\"</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect(\"abc\").toHaveProperty('a.b.c', {\"a\": 5}) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b.c\"</>\nReceived path: <r>[]</>\n\nExpected value: <g>{\"a\": 5}</>\nReceived value: <r>\"abc\"</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"a\": {\"b\": {\"c\": {\"d\": 1}}}}).toHaveProperty('a,b,c,d', 2) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>[\"a\", \"b\", \"c\", \"d\"]</>\n\nExpected value: <g>2</>\nReceived value: <r>1</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"a\": {\"b\": {\"c\": {\"d\": 1}}}}).toHaveProperty('a.b.c.d', 2) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b.c.d\"</>\n\nExpected value: <g>2</>\nReceived value: <r>1</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"a\": {\"b\": {\"c\": {\"d\": 1}}}}).toHaveProperty('a.b.ttt.d', 1) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b.ttt.d\"</>\nReceived path: <r>\"a.b\"</>\n\nExpected value: <g>1</>\nReceived value: <r>{\"c\": {\"d\": 1}}</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"a\": {\"b\": {\"c\": {}}}}).toHaveProperty('.a.b.c') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: <g>\".a.b.c\"</>\nReceived path: <r>[]</>\n\nReceived value: <r>{\"a\": {\"b\": {\"c\": {}}}}</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"a\": {\"b\": {\"c\": {}}}}).toHaveProperty('a.b.c.d') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: <g>\"a.b.c.d\"</>\nReceived path: <r>\"a.b.c\"</>\n\nReceived value: <r>{}</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"a\": {\"b\": {\"c\": {}}}}).toHaveProperty('a.b.c.d', 1) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b.c.d\"</>\nReceived path: <r>\"a.b.c\"</>\n\nExpected value: <g>1</>\nReceived value: <r>{}</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"a\": {\"b\": {\"c\": 5}}}).toHaveProperty('a.b', {\"c\": 4}) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b\"</>\n\n<g>- Expected value  - 1</>\n<r>+ Received value  + 1</>\n\n<d>  Object {</>\n<g>-   \"c\": 4,</>\n<r>+   \"c\": 5,</>\n<d>  }</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"a\": {\"b\": 3}}).toHaveProperty('a.b', undefined) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b\"</>\n\nExpected value: <g>undefined</>\nReceived value: <r>3</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"a\": {}}).toHaveProperty('a.b', undefined) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b\"</>\nReceived path: <r>\"a\"</>\n\nExpected value: <g>undefined</>\nReceived value: <r>{}</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"a\": 1}).toHaveProperty('a.b.c.d') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: <g>\"a.b.c.d\"</>\nReceived path: <r>\"a\"</>\n\nReceived value: <r>1</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"a\": 1}).toHaveProperty('a.b.c.d', 5) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b.c.d\"</>\nReceived path: <r>\"a\"</>\n\nExpected value: <g>5</>\nReceived value: <r>1</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"a.b.c.d\": 1}).toHaveProperty('a.b.c.d', 2) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b.c.d\"</>\nReceived path: <r>[]</>\n\nExpected value: <g>2</>\nReceived value: <r>{\"a.b.c.d\": 1}</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"a.b.c.d\": 1}).toHaveProperty('a.b.c.d', 2) 2`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>[\"a.b.c.d\"]</>\n\nExpected value: <g>2</>\nReceived value: <r>1</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"children\": [\"\\\\\"That cartoon\\\\\"\"], \"props\": null, \"type\": \"p\"}).toHaveProperty('children,0', \"\\\\\"That cat cartoon\\\\\"\") 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>[\"children\", 0]</>\n\nExpected value: <g>\"\\\\\"That <i>cat </i>cartoon\\\\\"\"</>\nReceived value: <r>\"\\\\\"That cartoon\\\\\"\"</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"children\": [\"Roses are red.\nViolets are blue.\nTesting with Jest is good for you.\"], \"props\": null, \"type\": \"pre\"}).toHaveProperty('children,0', \"Roses are red, violets are blue.\nTesting with Jest\nIs good for you.\") 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>[\"children\", 0]</>\n\n<g>- Expected value  - 3</>\n<r>+ Received value  + 3</>\n\n<g>- Roses are red<i>, v</i>iolets are blue.</>\n<r>+ Roses are red<i>.</i></>\n<r>+ <i>V</i>iolets are blue.</>\n<g>- Testing with Jest</>\n<g>- <i>I</i>s good for you.</>\n<r>+ Testing with Jest<i> i</i>s good for you.</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({\"key\": 1}).toHaveProperty('not') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: <g>\"not\"</>\nReceived path: <r>[]</>\n\nReceived value: <r>{\"key\": 1}</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({}).toHaveProperty('a') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: <g>\"a\"</>\nReceived path: <r>[]</>\n\nReceived value: <r>{}</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({}).toHaveProperty('a', \"a\") 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a\"</>\n\nExpected value: <g>\"a\"</>\nReceived value: <r>undefined</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({}).toHaveProperty('a', \"test\") 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a\"</>\nReceived path: <r>[]</>\n\nExpected value: <g>\"test\"</>\nReceived value: <r>{}</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect({}).toHaveProperty('b', undefined) 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"b\"</>\n\nExpected value: <g>undefined</>\nReceived value: <r>\"b\"</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect(0).toHaveProperty('key') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: <g>\"key\"</>\nReceived path: <r>[]</>\n\nReceived value: <r>0</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect(1).toHaveProperty('a.b.c') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: <g>\"a.b.c\"</>\nReceived path: <r>[]</>\n\nReceived value: <r>1</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect(1).toHaveProperty('a.b.c', \"test\") 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b.c\"</>\nReceived path: <r>[]</>\n\nExpected value: <g>\"test\"</>\nReceived value: <r>1</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect(Symbol()).toHaveProperty('key') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: <g>\"key\"</>\nReceived path: <r>[]</>\n\nReceived value: <r>Symbol()</>\n`;\n\nexports[`.toHaveProperty() {pass: false} expect(false).toHaveProperty('key') 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: <g>\"key\"</>\nReceived path: <r>[]</>\n\nReceived value: <r>false</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect(\"\").toHaveProperty('length', 0) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"length\"</>\n\nExpected value: not <g>0</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect([Function memoized]).toHaveProperty('memo', []) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"memo\"</>\n\nExpected value: not <g>[]</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"\": 1}).toHaveProperty('', 1) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"\"</>\n\nExpected value: not <g>1</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": {\"b\": [[{\"c\": [{\"d\": 1}]}]]}}).toHaveProperty('a.b[0][0].c[0].d', 1) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b[0][0].c[0].d\"</>\n\nExpected value: not <g>1</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": {\"b\": [{\"c\": [{\"d\": 1}]}]}}).toHaveProperty('a.b[0].c[0].d', 1) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b[0].c[0].d\"</>\n\nExpected value: not <g>1</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": {\"b\": [{\"c\": {\"d\": [{\"e\": 1}, {\"f\": 2}]}}]}}).toHaveProperty('a.b[0].c.d[1].f', 2) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b[0].c.d[1].f\"</>\n\nExpected value: not <g>2</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": {\"b\": [1, 2, 3]}}).toHaveProperty('a,b,1') 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: not <g>[\"a\", \"b\", 1]</>\n\nReceived value: <r>2</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": {\"b\": [1, 2, 3]}}).toHaveProperty('a,b,1', 2) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>[\"a\", \"b\", 1]</>\n\nExpected value: not <g>2</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": {\"b\": [1, 2, 3]}}).toHaveProperty('a,b,1', Any<Number>) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>[\"a\", \"b\", 1]</>\n\nExpected value: not <g>Any<Number></>\nReceived value:     <r>2</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": {\"b\": {\"c\": {\"d\": 1}}}}).toHaveProperty('a,b,c,d') 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: not <g>[\"a\", \"b\", \"c\", \"d\"]</>\n\nReceived value: <r>1</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": {\"b\": {\"c\": {\"d\": 1}}}}).toHaveProperty('a,b,c,d', 1) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>[\"a\", \"b\", \"c\", \"d\"]</>\n\nExpected value: not <g>1</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": {\"b\": {\"c\": {\"d\": 1}}}}).toHaveProperty('a.b.c.d') 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: not <g>\"a.b.c.d\"</>\n\nReceived value: <r>1</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": {\"b\": {\"c\": {\"d\": 1}}}}).toHaveProperty('a.b.c.d', 1) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b.c.d\"</>\n\nExpected value: not <g>1</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": {\"b\": {\"c\": 5}}}).toHaveProperty('a.b', {\"c\": 5}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b\"</>\n\nExpected value: not <g>{\"c\": 5}</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": {\"b\": undefined}}).toHaveProperty('a.b') 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: not <g>\"a.b\"</>\n\nReceived value: <r>undefined</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": {\"b\": undefined}}).toHaveProperty('a.b', undefined) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a.b\"</>\n\nExpected value: not <g>undefined</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": 0}).toHaveProperty('a') 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: not <g>\"a\"</>\n\nReceived value: <r>0</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a\": 0}).toHaveProperty('a', 0) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a\"</>\n\nExpected value: not <g>0</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a.b.c.d\": 1}).toHaveProperty('a.b.c.d') 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>)</>\n\nExpected path: not <g>[\"a.b.c.d\"]</>\n\nReceived value: <r>1</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"a.b.c.d\": 1}).toHaveProperty('a.b.c.d', 1) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>[\"a.b.c.d\"]</>\n\nExpected value: not <g>1</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"nodeName\": \"DIV\"}).toHaveProperty('nodeType', 1) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"nodeType\"</>\n\nExpected value: not <g>1</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"property\": 1}).toHaveProperty('property', 1) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"property\"</>\n\nExpected value: not <g>1</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"val\": true}).toHaveProperty('a', undefined) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a\"</>\n\nExpected value: not <g>undefined</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"val\": true}).toHaveProperty('c', \"c\") 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"c\"</>\n\nExpected value: not <g>\"c\"</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({\"val\": true}).toHaveProperty('val', true) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"val\"</>\n\nExpected value: not <g>true</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({}).toHaveProperty('a', undefined) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"a\"</>\n\nExpected value: not <g>undefined</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({}).toHaveProperty('b', \"b\") 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"b\"</>\n\nExpected value: not <g>\"b\"</>\n`;\n\nexports[`.toHaveProperty() {pass: true} expect({}).toHaveProperty('setter', undefined) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveProperty<d>(</><g>path</><d>, </><g>value</><d>)</>\n\nExpected path: <g>\"setter\"</>\n\nExpected value: not <g>undefined</>\n`;\n\nexports[`.toMatch() {pass: true} expect(Foo bar).toMatch(/^foo/i) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatch<d>(</><g>expected</><d>)</>\n\nExpected pattern: not <g>/^foo/i</>\nReceived string:      <r>\"<i>Foo</i> bar\"</>\n`;\n\nexports[`.toMatch() {pass: true} expect(foo).toMatch(foo) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatch<d>(</><g>expected</><d>)</>\n\nExpected substring: not <g>\"foo\"</>\nReceived string:        <r>\"<i>foo</i>\"</>\n`;\n\nexports[`.toMatch() throws if non String actual value passed: [/foo/i, \"foo\"] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a string\n\nReceived has type:  regexp\nReceived has value: <r>/foo/i</>\n`;\n\nexports[`.toMatch() throws if non String actual value passed: [[], \"foo\"] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a string\n\nReceived has type:  array\nReceived has value: <r>[]</>\n`;\n\nexports[`.toMatch() throws if non String actual value passed: [[Function anonymous], \"foo\"] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a string\n\nReceived has type:  function\nReceived has value: <r>[Function anonymous]</>\n`;\n\nexports[`.toMatch() throws if non String actual value passed: [{}, \"foo\"] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a string\n\nReceived has type:  object\nReceived has value: <r>{}</>\n`;\n\nexports[`.toMatch() throws if non String actual value passed: [1, \"foo\"] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a string\n\nReceived has type:  number\nReceived has value: <r>1</>\n`;\n\nexports[`.toMatch() throws if non String actual value passed: [true, \"foo\"] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a string\n\nReceived has type:  boolean\nReceived has value: <r>true</>\n`;\n\nexports[`.toMatch() throws if non String actual value passed: [undefined, \"foo\"] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a string\n\nReceived has value: <r>undefined</>\n`;\n\nexports[`.toMatch() throws if non String/RegExp expected value passed: [\"foo\", []] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a string or regular expression\n\nExpected has type:  array\nExpected has value: <g>[]</>\n`;\n\nexports[`.toMatch() throws if non String/RegExp expected value passed: [\"foo\", [Function anonymous]] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a string or regular expression\n\nExpected has type:  function\nExpected has value: <g>[Function anonymous]</>\n`;\n\nexports[`.toMatch() throws if non String/RegExp expected value passed: [\"foo\", {}] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a string or regular expression\n\nExpected has type:  object\nExpected has value: <g>{}</>\n`;\n\nexports[`.toMatch() throws if non String/RegExp expected value passed: [\"foo\", 1] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a string or regular expression\n\nExpected has type:  number\nExpected has value: <g>1</>\n`;\n\nexports[`.toMatch() throws if non String/RegExp expected value passed: [\"foo\", true] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a string or regular expression\n\nExpected has type:  boolean\nExpected has value: <g>true</>\n`;\n\nexports[`.toMatch() throws if non String/RegExp expected value passed: [\"foo\", undefined] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a string or regular expression\n\nExpected has value: <g>undefined</>\n`;\n\nexports[`.toMatch() throws: [bar, /foo/] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\nExpected pattern: <g>/foo/</>\nReceived string:  <r>\"bar\"</>\n`;\n\nexports[`.toMatch() throws: [bar, foo] 1`] = `\n<d>expect(</><r>received</><d>).</>toMatch<d>(</><g>expected</><d>)</>\n\nExpected substring: <g>\"foo\"</>\nReceived string:    <r>\"bar\"</>\n`;\n\nexports[`.toStrictEqual() displays substring diff 1`] = `\n<d>expect(</><r>received</><d>).</>toStrictEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: <g>\"<i>Another caveat is that</i> Jest will not typecheck your tests.\"</>\nReceived: <r>\"<i>Because TypeScript support in Babel is just transpilation,</i> Jest will not type<i>-</i>check your tests<i> as they run</i>.\"</>\n`;\n\nexports[`.toStrictEqual() displays substring diff for multiple lines 1`] = `\n<d>expect(</><r>received</><d>).</>toStrictEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 7</>\n<r>+ Received  + 7</>\n\n<g>-     6<i>9</i> |<Y> </></>\n<r>+     6<i>8</i> |<Y> </></>\n<g>-     <i>70</i> | test('assert.doesNotThrow', () => {</>\n<r>+     <i>69</i> | test('assert.doesNotThrow', () => {</>\n<g>-   > 7<i>1</i> |   assert.doesNotThrow(() => {</>\n<r>+   > 7<i>0</i> |   assert.doesNotThrow(() => {</>\n<d>         |          ^</>\n<g>-     7<i>2</i> |     throw Error('err!');</>\n<r>+     7<i>1</i> |     throw Error('err!');</>\n<g>-     7<i>3</i> |   });</>\n<r>+     7<i>2</i> |   });</>\n<g>-     7<i>4</i> | });</>\n<r>+     7<i>3</i> | });</>\n<g>-     at Object.doesNotThrow (__tests__/assertionError.test.js:7<i>1</i>:10)</>\n<r>+     at Object.doesNotThrow (__tests__/assertionError.test.js:7<i>0</i>:10)</>\n`;\n\nexports[`.toStrictEqual() matches the expected snapshot when it fails 1`] = `\n<d>expect(</><r>received</><d>).</>toStrictEqual<d>(</><g>expected</><d>) // deep equality</>\n\n<g>- Expected  - 4</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"test\": TestClassA {</>\n<g>-     \"a\": 1,</>\n<g>-     \"b\": 2,</>\n<g>-   },</>\n<r>+   \"test\": 2,</>\n<d>  }</>\n`;\n\nexports[`.toStrictEqual() matches the expected snapshot when it fails 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toStrictEqual<d>(</><g>expected</><d>) // deep equality</>\n\nExpected: not <g>{\"test\": {\"a\": 1, \"b\": 2}}</>\n\n`;\n\nexports[`toMatchObject() {pass: false} expect([0]).toMatchObject([-0]) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Array [</>\n<g>-   -0,</>\n<r>+   0,</>\n<d>  ]</>\n`;\n\nexports[`toMatchObject() {pass: false} expect([1, 2, 3]).toMatchObject([1, 2, 2]) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Array [</>\n<d>    1,</>\n<d>    2,</>\n<g>-   2,</>\n<r>+   3,</>\n<d>  ]</>\n`;\n\nexports[`toMatchObject() {pass: false} expect([1, 2, 3]).toMatchObject([2, 3, 1]) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Array [</>\n<r>+   1,</>\n<d>    2,</>\n<d>    3,</>\n<g>-   1,</>\n<d>  ]</>\n`;\n\nexports[`toMatchObject() {pass: false} expect([1, 2]).toMatchObject([1, 3]) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Array [</>\n<d>    1,</>\n<g>-   3,</>\n<r>+   2,</>\n<d>  ]</>\n`;\n\nexports[`toMatchObject() {pass: false} expect([Error: foo]).toMatchObject([Error: bar]) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: <g>[Error: bar]</>\nReceived: <r>[Error: foo]</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": \"a\", \"c\": \"d\"}).toMatchObject({\"a\": Any<Number>}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": Any<Number>,</>\n<r>+   \"a\": \"a\",</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": \"b\", \"c\": \"d\", Symbol(jest): \"jest\"}).toMatchObject({\"a\": \"c\", Symbol(jest): Any<String>}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": \"c\",</>\n<r>+   \"a\": \"b\",</>\n<d>    Symbol(jest): Any<String>,</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": \"b\", \"c\": \"d\"}).toMatchObject({\"a\": \"b!\", \"c\": \"d\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": \"b!\",</>\n<r>+   \"a\": \"b\",</>\n<d>    \"c\": \"d\",</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": \"b\", \"c\": \"d\"}).toMatchObject({\"e\": \"b\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 2</>\n\n<d>  Object {</>\n<g>-   \"e\": \"b\",</>\n<r>+   \"a\": \"b\",</>\n<r>+   \"c\": \"d\",</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": \"b\", \"t\": {\"x\": {\"r\": \"r\"}, \"z\": \"z\"}}).toMatchObject({\"a\": \"b\", \"t\": {\"z\": [3]}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 3</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<d>    \"a\": \"b\",</>\n<d>    \"t\": Object {</>\n<g>-     \"z\": Array [</>\n<g>-       3,</>\n<g>-     ],</>\n<r>+     \"z\": \"z\",</>\n<d>    },</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": \"b\", \"t\": {\"x\": {\"r\": \"r\"}, \"z\": \"z\"}}).toMatchObject({\"t\": {\"l\": {\"r\": \"r\"}}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 2</>\n\n<d>  Object {</>\n<d>    \"t\": Object {</>\n<g>-     \"l\": Object {</>\n<r>+     \"x\": Object {</>\n<d>        \"r\": \"r\",</>\n<d>      },</>\n<r>+     \"z\": \"z\",</>\n<d>    },</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": \"b\"}).toMatchObject({\"c\": \"d\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"c\": \"d\",</>\n<r>+   \"a\": \"b\",</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": \"b\"}).toMatchObject({\"toString\": Any<Function>}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 0</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<r>+   \"a\": \"b\",</>\n<d>    \"toString\": Any<Function>,</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": [{\"a\": \"a\", \"b\": \"b\"}]}).toMatchObject({\"a\": [{\"a\": \"c\"}]}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<d>    \"a\": Array [</>\n<d>      Object {</>\n<g>-       \"a\": \"c\",</>\n<r>+       \"a\": \"a\",</>\n<d>      },</>\n<d>    ],</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": [3, 4, \"v\"], \"b\": \"b\"}).toMatchObject({\"a\": [\"v\"]}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 0</>\n<r>+ Received  + 2</>\n\n<d>  Object {</>\n<d>    \"a\": Array [</>\n<r>+     3,</>\n<r>+     4,</>\n<d>      \"v\",</>\n<d>    ],</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": [3, 4, 5], \"b\": \"b\"}).toMatchObject({\"a\": [3, 4, 5, 6]}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 0</>\n\n<d>  Object {</>\n<d>    \"a\": Array [</>\n<d>      3,</>\n<d>      4,</>\n<d>      5,</>\n<g>-     6,</>\n<d>    ],</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": [3, 4, 5], \"b\": \"b\"}).toMatchObject({\"a\": [3, 4]}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 0</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<d>    \"a\": Array [</>\n<d>      3,</>\n<d>      4,</>\n<r>+     5,</>\n<d>    ],</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": [3, 4, 5], \"b\": \"b\"}).toMatchObject({\"a\": {\"b\": 4}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 3</>\n<r>+ Received  + 5</>\n\n<d>  Object {</>\n<g>-   \"a\": Object {</>\n<g>-     \"b\": 4,</>\n<g>-   },</>\n<r>+   \"a\": Array [</>\n<r>+     3,</>\n<r>+     4,</>\n<r>+     5,</>\n<r>+   ],</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": [3, 4, 5], \"b\": \"b\"}).toMatchObject({\"a\": {\"b\": Any<String>}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 3</>\n<r>+ Received  + 5</>\n\n<d>  Object {</>\n<g>-   \"a\": Object {</>\n<g>-     \"b\": Any<String>,</>\n<g>-   },</>\n<r>+   \"a\": Array [</>\n<r>+     3,</>\n<r>+     4,</>\n<r>+     5,</>\n<r>+   ],</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": 1, \"b\": 1, \"c\": 1, \"d\": {\"e\": {\"f\": 555}}}).toMatchObject({\"d\": {\"e\": {\"f\": 222}}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<d>    \"d\": Object {</>\n<d>      \"e\": Object {</>\n<g>-       \"f\": 222,</>\n<r>+       \"f\": 555,</>\n<d>      },</>\n<d>    },</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": 2015-11-30T00:00:00.000Z, \"b\": \"b\"}).toMatchObject({\"a\": 2015-10-10T00:00:00.000Z}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": 2015-10-10T00:00:00.000Z,</>\n<r>+   \"a\": 2015-11-30T00:00:00.000Z,</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": null, \"b\": \"b\"}).toMatchObject({\"a\": \"4\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": \"4\",</>\n<r>+   \"a\": null,</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": null, \"b\": \"b\"}).toMatchObject({\"a\": undefined}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": undefined,</>\n<r>+   \"a\": null,</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({\"a\": undefined}).toMatchObject({\"a\": null}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": null,</>\n<r>+   \"a\": undefined,</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: false} expect({}).toMatchObject({\"a\": undefined}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 3</>\n<r>+ Received  + 1</>\n\n<g>- Object {</>\n<g>-   \"a\": undefined,</>\n<g>- }</>\n<r>+ Object {}</>\n`;\n\nexports[`toMatchObject() {pass: false} expect(2015-11-30T00:00:00.000Z).toMatchObject(2015-10-10T00:00:00.000Z) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: <g>2015-10-10T00:00:00.000Z</>\nReceived: <r>2015-11-30T00:00:00.000Z</>\n`;\n\nexports[`toMatchObject() {pass: false} expect(Set {1, 2}).toMatchObject(Set {2}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 0</>\n<r>+ Received  + 1</>\n\n<d>  Set {</>\n<r>+   1,</>\n<d>    2,</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() {pass: true} expect([]).toMatchObject([]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>[]</>\n`;\n\nexports[`toMatchObject() {pass: true} expect([1, 2]).toMatchObject([1, 2]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>[1, 2]</>\n`;\n\nexports[`toMatchObject() {pass: true} expect([Error: bar]).toMatchObject({\"message\": \"bar\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"message\": \"bar\"}</>\nReceived:     <r>[Error: bar]</>\n`;\n\nexports[`toMatchObject() {pass: true} expect([Error: foo]).toMatchObject([Error: foo]) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>[Error: foo]</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": \"b\", \"c\": \"d\", Symbol(jest): \"jest\"}).toMatchObject({\"a\": \"b\", \"c\": \"d\", Symbol(jest): \"jest\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": \"b\", \"c\": \"d\", Symbol(jest): \"jest\"}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": \"b\", \"c\": \"d\", Symbol(jest): \"jest\"}).toMatchObject({\"a\": \"b\", Symbol(jest): \"jest\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": \"b\", Symbol(jest): \"jest\"}</>\nReceived:     <r>{\"a\": \"b\", \"c\": \"d\", Symbol(jest): \"jest\"}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": \"b\", \"c\": \"d\"}).toMatchObject({\"a\": \"b\", \"c\": \"d\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": \"b\", \"c\": \"d\"}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": \"b\", \"c\": \"d\"}).toMatchObject({\"a\": \"b\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": \"b\"}</>\nReceived:     <r>{\"a\": \"b\", \"c\": \"d\"}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": \"b\", \"t\": {\"x\": {\"r\": \"r\"}, \"z\": \"z\"}}).toMatchObject({\"a\": \"b\", \"t\": {\"z\": \"z\"}}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": \"b\", \"t\": {\"z\": \"z\"}}</>\nReceived:     <r>{\"a\": \"b\", \"t\": {\"x\": {\"r\": \"r\"}, \"z\": \"z\"}}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": \"b\", \"t\": {\"x\": {\"r\": \"r\"}, \"z\": \"z\"}}).toMatchObject({\"t\": {\"x\": {\"r\": \"r\"}}}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"t\": {\"x\": {\"r\": \"r\"}}}</>\nReceived:     <r>{\"a\": \"b\", \"t\": {\"x\": {\"r\": \"r\"}, \"z\": \"z\"}}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": \"b\", \"toString\": [Function toString]}).toMatchObject({\"toString\": Any<Function>}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"toString\": Any<Function>}</>\nReceived:     <r>{\"a\": \"b\", \"toString\": [Function toString]}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": \"b\"}).toMatchObject({\"a\": \"b\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": \"b\"}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": [{\"a\": \"a\", \"b\": \"b\"}]}).toMatchObject({\"a\": [{\"a\": \"a\"}]}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": [{\"a\": \"a\"}]}</>\nReceived:     <r>{\"a\": [{\"a\": \"a\", \"b\": \"b\"}]}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": [3, 4, 5, \"v\"], \"b\": \"b\"}).toMatchObject({\"a\": [3, 4, 5, \"v\"]}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": [3, 4, 5, \"v\"]}</>\nReceived:     <r>{\"a\": [3, 4, 5, \"v\"], \"b\": \"b\"}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": [3, 4, 5], \"b\": \"b\"}).toMatchObject({\"a\": [3, 4, 5]}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": [3, 4, 5]}</>\nReceived:     <r>{\"a\": [3, 4, 5], \"b\": \"b\"}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": {\"x\": \"x\", \"y\": \"y\"}}).toMatchObject({\"a\": {\"x\": Any<String>}}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": {\"x\": Any<String>}}</>\nReceived:     <r>{\"a\": {\"x\": \"x\", \"y\": \"y\"}}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": 1, \"c\": 2}).toMatchObject({\"a\": Any<Number>}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": Any<Number>}</>\nReceived:     <r>{\"a\": 1, \"c\": 2}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": 2015-11-30T00:00:00.000Z, \"b\": \"b\"}).toMatchObject({\"a\": 2015-11-30T00:00:00.000Z}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": 2015-11-30T00:00:00.000Z}</>\nReceived:     <r>{\"a\": 2015-11-30T00:00:00.000Z, \"b\": \"b\"}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": null, \"b\": \"b\"}).toMatchObject({\"a\": null}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": null}</>\nReceived:     <r>{\"a\": null, \"b\": \"b\"}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": undefined, \"b\": \"b\"}).toMatchObject({\"a\": undefined}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": undefined}</>\nReceived:     <r>{\"a\": undefined, \"b\": \"b\"}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({\"a\": undefined}).toMatchObject({\"a\": undefined}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": undefined}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({}).toMatchObject({\"a\": undefined, \"b\": \"b\", \"c\": \"c\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": undefined, \"b\": \"b\", \"c\": \"c\"}</>\nReceived:     <r>{}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({}).toMatchObject({\"a\": undefined, \"b\": \"b\"}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": undefined, \"b\": \"b\"}</>\nReceived:     <r>{}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect({}).toMatchObject({\"d\": 4}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"d\": 4}</>\nReceived:     <r>{}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect(2015-11-30T00:00:00.000Z).toMatchObject(2015-11-30T00:00:00.000Z) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>2015-11-30T00:00:00.000Z</>\n`;\n\nexports[`toMatchObject() {pass: true} expect(Set {1, 2}).toMatchObject(Set {1, 2}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>Set {1, 2}</>\n`;\n\nexports[`toMatchObject() {pass: true} expect(Set {1, 2}).toMatchObject(Set {2, 1}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>Set {2, 1}</>\nReceived:     <r>Set {1, 2}</>\n`;\n\nexports[`toMatchObject() circular references simple circular references {pass: false} expect({\"a\": \"hello\", \"ref\": [Circular]}).toMatchObject({\"a\": \"world\", \"ref\": [Circular]}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": \"world\",</>\n<r>+   \"a\": \"hello\",</>\n<d>    \"ref\": [Circular],</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() circular references simple circular references {pass: false} expect({\"ref\": \"not a ref\"}).toMatchObject({\"a\": \"hello\", \"ref\": [Circular]}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 2</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": \"hello\",</>\n<g>-   \"ref\": [Circular],</>\n<r>+   \"ref\": \"not a ref\",</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() circular references simple circular references {pass: false} expect({}).toMatchObject({\"a\": \"hello\", \"ref\": [Circular]}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 4</>\n<r>+ Received  + 1</>\n\n<g>- Object {</>\n<g>-   \"a\": \"hello\",</>\n<g>-   \"ref\": [Circular],</>\n<g>- }</>\n<r>+ Object {}</>\n`;\n\nexports[`toMatchObject() circular references simple circular references {pass: true} expect({\"a\": \"hello\", \"ref\": [Circular]}).toMatchObject({\"a\": \"hello\", \"ref\": [Circular]}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": \"hello\", \"ref\": [Circular]}</>\n`;\n\nexports[`toMatchObject() circular references simple circular references {pass: true} expect({\"a\": \"hello\", \"ref\": [Circular]}).toMatchObject({}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{}</>\nReceived:     <r>{\"a\": \"hello\", \"ref\": [Circular]}</>\n`;\n\nexports[`toMatchObject() circular references transitive circular references {pass: false} expect({\"a\": \"world\", \"nestedObj\": {\"parentObj\": [Circular]}}).toMatchObject({\"a\": \"hello\", \"nestedObj\": {\"parentObj\": [Circular]}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": \"hello\",</>\n<r>+   \"a\": \"world\",</>\n<d>    \"nestedObj\": Object {</>\n<d>      \"parentObj\": [Circular],</>\n<d>    },</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() circular references transitive circular references {pass: false} expect({\"nestedObj\": {\"parentObj\": \"not the parent ref\"}}).toMatchObject({\"a\": \"hello\", \"nestedObj\": {\"parentObj\": [Circular]}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 2</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": \"hello\",</>\n<d>    \"nestedObj\": Object {</>\n<g>-     \"parentObj\": [Circular],</>\n<r>+     \"parentObj\": \"not the parent ref\",</>\n<d>    },</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() circular references transitive circular references {pass: false} expect({}).toMatchObject({\"a\": \"hello\", \"nestedObj\": {\"parentObj\": [Circular]}}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 6</>\n<r>+ Received  + 1</>\n\n<g>- Object {</>\n<g>-   \"a\": \"hello\",</>\n<g>-   \"nestedObj\": Object {</>\n<g>-     \"parentObj\": [Circular],</>\n<g>-   },</>\n<g>- }</>\n<r>+ Object {}</>\n`;\n\nexports[`toMatchObject() circular references transitive circular references {pass: true} expect({\"a\": \"hello\", \"nestedObj\": {\"parentObj\": [Circular]}}).toMatchObject({\"a\": \"hello\", \"nestedObj\": {\"parentObj\": [Circular]}}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{\"a\": \"hello\", \"nestedObj\": {\"parentObj\": [Circular]}}</>\n`;\n\nexports[`toMatchObject() circular references transitive circular references {pass: true} expect({\"a\": \"hello\", \"nestedObj\": {\"parentObj\": [Circular]}}).toMatchObject({}) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchObject<d>(</><g>expected</><d>)</>\n\nExpected: not <g>{}</>\nReceived:     <r>{\"a\": \"hello\", \"nestedObj\": {\"parentObj\": [Circular]}}</>\n`;\n\nexports[`toMatchObject() does not match properties up in the prototype chain 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<g>- Expected  - 1</>\n<r>+ Received  + 0</>\n\n<d>  Object {</>\n<d>    \"other\": \"child\",</>\n<g>-   \"ref\": [Circular],</>\n<d>  }</>\n`;\n\nexports[`toMatchObject() throws expect(\"44\").toMatchObject({}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a non-null object\n\nReceived has type:  string\nReceived has value: <r>\"44\"</>\n`;\n\nexports[`toMatchObject() throws expect({}).toMatchObject(\"some string\") 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-null object\n\nExpected has type:  string\nExpected has value: <g>\"some string\"</>\n`;\n\nexports[`toMatchObject() throws expect({}).toMatchObject(4) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-null object\n\nExpected has type:  number\nExpected has value: <g>4</>\n`;\n\nexports[`toMatchObject() throws expect({}).toMatchObject(null) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-null object\n\nExpected has value: <g>null</>\n`;\n\nexports[`toMatchObject() throws expect({}).toMatchObject(true) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-null object\n\nExpected has type:  boolean\nExpected has value: <g>true</>\n`;\n\nexports[`toMatchObject() throws expect({}).toMatchObject(undefined) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-null object\n\nExpected has value: <g>undefined</>\n`;\n\nexports[`toMatchObject() throws expect(4).toMatchObject({}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a non-null object\n\nReceived has type:  number\nReceived has value: <r>4</>\n`;\n\nexports[`toMatchObject() throws expect(null).toMatchObject({}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a non-null object\n\nReceived has value: <r>null</>\n`;\n\nexports[`toMatchObject() throws expect(true).toMatchObject({}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a non-null object\n\nReceived has type:  boolean\nReceived has value: <r>true</>\n`;\n\nexports[`toMatchObject() throws expect(undefined).toMatchObject({}) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchObject<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a non-null object\n\nReceived has value: <r>undefined</>\n`;"}
{"prompt":"Error wh cause not supported in legacy versions of node, we just polyfill it","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {readFileSync} from 'graceful-fs';\nimport slash = require('slash');\nimport tempy = require('tempy');\nimport {\n  formatExecError,\n  formatResultsErrors,\n  formatStackTrace,\n  getTopFrame,\n} from '..';\n\nconst rootDir = tempy.directory();\n\njest.mock('graceful-fs', () => ({\n  ...jest.requireActual<typeof import('fs')>('fs'),\n  readFileSync: jest.fn(),\n}));\n\nconst unixStackTrace =\n  '  ' +\n  `at stack (../jest-jasmine2/build/jasmine-2.4.1.js:1580:17)\n  at Object.addResult (../jest-jasmine2/build/jasmine-2.4.1.js:1550:14)\n  at jasmine.addResult (../jest-jasmine2/build/index.js:82:44)\n  at Spec.Env.factory (../jest-jasmine2/build/jasmine-2.4.1.js:641:18)\n  at Spec.addResult (../jest-jasmine2/build/jasmine-2.4.1.js:333:34)\n  at Expectation.addResult (../jest-jasmine2/build/jasmine-2.4.1.js:591:21)\n  at Expectation.toBe (../jest-jasmine2/build/jasmine-2.4.1.js:1504:12)\n  at Object.it (build/__tests__/messages-test.js:45:41)\n  at Object.<anonymous> (../jest-jasmine2/build/jasmine-pit.js:35:32)\n  at attemptAsync (../jest-jasmine2/build/jasmine-2.4.1.js:1919:24)`;\nconst unixError = new Error(unixStackTrace.replace(/\\n\\s*at \\s*/m, ''));\nunixError.stack = unixStackTrace;\n\nconst assertionStack =\n  '  ' +\n  `\n    Expected value to be of type:\n      \"number\"\n    Received:\n      \"\"\n    type:\n      \"string\"\n\n      at Object.it (__tests__/test.js:8:14)\n      at Object.asyncFn (node_modules/jest-jasmine2/build/jasmine_async.js:124:345)\n      at resolve (node_modules/jest-jasmine2/build/queue_runner.js:46:12)\n          at Promise (<anonymous>)\n      at mapper (node_modules/jest-jasmine2/build/queue_runner.js:34:499)\n      at promise.then (node_modules/jest-jasmine2/build/queue_runner.js:74:39)\n          at <anonymous>\n      at process._tickCallback (internal/process/next_tick.js:188:7)\n      at internal/process/next_tick.js:188:7\n`;\nconst assertionError = new Error(assertionStack.replace(/\\n\\s*at \\s*/m, ''));\nassertionError.stack = assertionStack;\n\nconst vendorStack =\n  '  ' +\n  `\n    Expected value to be of type:\n      \"number\"\n    Received:\n      \"\"\n    type:\n      \"string\"\n\n      at Object.it (__tests__/vendor/cool_test.js:6:666)\n      at Object.asyncFn (__tests__/vendor/sulu/node_modules/sulu-content-bundle/best_component.js:1:5)\n`;\n\nconst babelStack =\n  '  ' +\n  `\n    packages/react/src/forwardRef.js: Unexpected token, expected , (20:10)\n    \\u001B[0m \\u001B[90m 18 | \\u001B[39m        \\u001B[36mfalse\\u001B[39m\\u001B[33m,\\u001B[39m\n     \\u001B[90m 19 | \\u001B[39m        \\u001B[32m'forwardRef requires a render function but received a \\`memo\\` '\\u001B[39m\n    \\u001B[31m\\u001B[1m>\\u001B[22m\\u001B[39m\\u001B[90m 20 | \\u001B[39m          \\u001B[32m'component. Instead of forwardRef(memo(...)), use '\\u001B[39m \\u001B[33m+\\u001B[39m\n     \\u001B[90m    | \\u001B[39m          \\u001B[31m\\u001B[1m^\\u001B[22m\\u001B[39m\n     \\u001B[90m 21 | \\u001B[39m          \\u001B[32m'memo(forwardRef(...)).'\\u001B[39m\\u001B[33m,\\u001B[39m\n     \\u001B[90m 22 | \\u001B[39m      )\\u001B[33m;\\u001B[39m\n     \\u001B[90m 23 | \\u001B[39m    } \\u001B[36melse\\u001B[39m \\u001B[36mif\\u001B[39m (\\u001B[36mtypeof\\u001B[39m render \\u001B[33m!==\\u001B[39m \\u001B[32m'function'\\u001B[39m) {\\u001B[0m\n`;\nconst babelError = new Error(babelStack.replace(/\\n\\s*at \\s*/m, ''));\nbabelError.stack = babelStack;\n\nfunction buildErrorWithCause(message: string, opts: {cause: unknown}): Error {\n  const error = new Error(message, opts);\n  if (opts.cause !== error.cause) {\n    // Error with cause not supported in legacy versions of node, we just polyfill it\n    Object.assign(error, opts);\n  }\n  return error;\n}\n\nconst errorWithCauseNestedNested = new Error('boom');\nerrorWithCauseNestedNested.stack = `Error: boom\n    at h (cause.test.js:2:9)\n    at h (cause.test.js:6:5)\n    at g (cause.test.js:13:5)\n    at Object.f (cause.test.js:20:5)\n    at Promise.then.completed (node_modules/jest-circus/build/utils.js:293:28)\n    at new Promise (<anonymous>)\n    at callAsyncCircusFn (node_modules/jest-circus/build/utils.js:226:10)\n    at _callCircusTest (node_modules/jest-circus/build/run.js:248:40)\n    at _runTest (node_modules/jest-circus/build/run.js:184:3)\n    at _runTestsForDescribeBlock (node_modules/jest-circus/build/run.js:86:9)\n    at run (node_modules/jest-circus/build/run.js:26:3)\n    at runAndTransformResultsToJestFormat (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:120:21)\n    at jestAdapter (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:74:19)\n    at runTestInternal (node_modules/jest-runner/build/runTest.js:281:16)\n    at runTest (node_modules/jest-runner/build/runTest.js:341:7)`;\n\nconst errorWithCauseNested = buildErrorWithCause('intercepted by g', {\n  cause: errorWithCauseNestedNested,\n});\nerrorWithCauseNested.stack = `Error: intercepted by g\n    at g (cause.test.js:8:11)\n    at g (cause.test.js:13:5)\n    at Object.f (cause.test.js:20:5)\n    at Promise.then.completed (node_modules/jest-circus/build/utils.js:293:28)\n    at new Promise (<anonymous>)\n    at callAsyncCircusFn (node_modules/jest-circus/build/utils.js:226:10)\n    at _callCircusTest (node_modules/jest-circus/build/run.js:248:40)\n    at _runTest (node_modules/jest-circus/build/run.js:184:3)\n    at _runTestsForDescribeBlock (node_modules/jest-circus/build/run.js:86:9)\n    at run (node_modules/jest-circus/build/run.js:26:3)\n    at runAndTransformResultsToJestFormat (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:120:21)\n    at jestAdapter (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:74:19)\n    at runTestInternal (node_modules/jest-runner/build/runTest.js:281:16)\n    at runTest (node_modules/jest-runner/build/runTest.js:341:7)`;\n\nconst errorWithCause = buildErrorWithCause('intercepted by f', {\n  cause: errorWithCauseNested,\n});\nerrorWithCause.stack = `Error: intercepted by f\n    at f (cause.test.js:15:11)\n    at Object.f (cause.test.js:20:5)\n    at Promise.then.completed (node_modules/jest-circus/build/utils.js:293:28)\n    at new Promise (<anonymous>)\n    at callAsyncCircusFn (node_modules/jest-circus/build/utils.js:226:10)\n    at _callCircusTest (node_modules/jest-circus/build/run.js:248:40)\n    at _runTest (node_modules/jest-circus/build/run.js:184:3)\n    at _runTestsForDescribeBlock (node_modules/jest-circus/build/run.js:86:9)\n    at run (node_modules/jest-circus/build/run.js:26:3)\n    at runAndTransformResultsToJestFormat (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:120:21)\n    at jestAdapter (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:74:19)\n    at runTestInternal (node_modules/jest-runner/build/runTest.js:281:16)\n    at runTest (node_modules/jest-runner/build/runTest.js:341:7)`;\n\nconst errorWithStringCause = buildErrorWithCause('boom', {\n  cause: 'string cause',\n});\nerrorWithStringCause.stack = `Error: boom\n    at f (cause.test.js:15:11)\n    at Object.f (cause.test.js:20:5)\n    at Promise.then.completed (node_modules/jest-circus/build/utils.js:293:28)\n    at new Promise (<anonymous>)\n    at callAsyncCircusFn (node_modules/jest-circus/build/utils.js:226:10)\n    at _callCircusTest (node_modules/jest-circus/build/run.js:248:40)\n    at _runTest (node_modules/jest-circus/build/run.js:184:3)\n    at _runTestsForDescribeBlock (node_modules/jest-circus/build/run.js:86:9)\n    at run (node_modules/jest-circus/build/run.js:26:3)\n    at runAndTransformResultsToJestFormat (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:120:21)\n    at jestAdapter (node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:74:19)\n    at runTestInternal (node_modules/jest-runner/build/runTest.js:281:16)\n    at runTest (node_modules/jest-runner/build/runTest.js:341:7)`;\n\nbeforeEach(() => {\n  jest.clearAllMocks();\n});\n\nit('should exclude jasmine from stack trace for Unix paths.', () => {\n  const messages = formatResultsErrors(\n    [\n      {\n        ancestorTitles: [],\n        duration: undefined,\n        failureDetails: [unixError],\n        failureMessages: [unixStackTrace],\n        fullName: 'full name',\n        invocations: undefined,\n        location: null,\n        numPassingAsserts: 0,\n        retryReasons: undefined,\n        status: 'failed',\n        title: 'Unix test',\n      },\n    ],\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n\n  expect(messages).toMatchSnapshot();\n});\n\nit('.formatExecError()', () => {\n  const message = formatExecError(\n    {\n      message: 'Whoops!',\n      stack: '',\n    },\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n    'path_test',\n  );\n\n  expect(message).toMatchSnapshot();\n});\n\nit('formatStackTrace should strip node internals', () => {\n  const messages = formatResultsErrors(\n    [\n      {\n        ancestorTitles: [],\n        duration: undefined,\n        failureDetails: [assertionError],\n        failureMessages: [assertionStack],\n        fullName: 'full name',\n        invocations: undefined,\n        location: null,\n        numPassingAsserts: 0,\n        retryReasons: undefined,\n        status: 'failed',\n        title: 'Unix test',\n      },\n    ],\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n\n  expect(messages).toMatchSnapshot();\n});\n\nit('should not exclude vendor from stack trace', () => {\n  const messages = formatResultsErrors(\n    [\n      {\n        ancestorTitles: [],\n        duration: undefined,\n        failureDetails: [],\n        failureMessages: [vendorStack],\n        fullName: 'full name',\n        invocations: undefined,\n        location: null,\n        numPassingAsserts: 0,\n        retryReasons: undefined,\n        status: 'failed',\n        title: 'Vendor test',\n      },\n    ],\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n\n  expect(messages).toMatchSnapshot();\n});\n\nit('retains message in babel code frame error', () => {\n  const messages = formatResultsErrors(\n    [\n      {\n        ancestorTitles: [],\n        duration: undefined,\n        failureDetails: [babelError],\n        failureMessages: [babelStack],\n        fullName: 'full name',\n        invocations: undefined,\n        location: null,\n        numPassingAsserts: 0,\n        retryReasons: undefined,\n        status: 'failed',\n        title: 'Babel test',\n      },\n    ],\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n\n  expect(messages).toMatchSnapshot();\n});\n\nit('formatStackTrace should properly handle deeply nested causes', () => {\n  const messages = formatResultsErrors(\n    [\n      {\n        ancestorTitles: [],\n        duration: undefined,\n        failureDetails: [errorWithCause],\n        failureMessages: [errorWithCause.stack || ''],\n        fullName: 'full name',\n        invocations: undefined,\n        location: null,\n        numPassingAsserts: 0,\n        retryReasons: undefined,\n        status: 'failed',\n        title: 'Error with cause test',\n      },\n    ],\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n\n  expect(messages).toMatchSnapshot();\n});\n\nit('formatStackTrace should properly handle string causes', () => {\n  const messages = formatResultsErrors(\n    [\n      {\n        ancestorTitles: [],\n        duration: undefined,\n        failureDetails: [errorWithStringCause],\n        failureMessages: [errorWithStringCause.stack || ''],\n        fullName: 'full name',\n        invocations: undefined,\n        location: null,\n        numPassingAsserts: 0,\n        retryReasons: undefined,\n        status: 'failed',\n        title: 'Error with string cause test',\n      },\n    ],\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n\n  expect(messages).toMatchSnapshot();\n});\n\nit('codeframe', () => {\n  jest\n    .mocked(readFileSync)\n    .mockImplementationOnce(() => 'throw new Error(\"Whoops!\");');\n\n  const message = formatExecError(\n    {\n      message: 'Whoops!',\n      stack: `\n    at Object.<anonymous> (${slash(rootDir)}/file.js:1:7)\n    at Module._compile (internal/modules/cjs/loader.js:1158:30)\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1178:10)\n    at Module.load (internal/modules/cjs/loader.js:1002:32)\n    at Function.Module._load (internal/modules/cjs/loader.js:901:14)\n    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)\n`,\n    },\n    {\n      rootDir,\n      testMatch: [],\n    },\n    {\n      noCodeFrame: false,\n      noStackTrace: false,\n    },\n    'path_test',\n  );\n\n  expect(message).toMatchSnapshot();\n});\n\nit('no codeframe', () => {\n  jest\n    .mocked(readFileSync)\n    .mockImplementationOnce(() => 'throw new Error(\"Whoops!\");');\n\n  const message = formatExecError(\n    {\n      message: 'Whoops!',\n      stack: `\n    at Object.<anonymous> (${slash(rootDir)}/file.js:1:7)\n    at Module._compile (internal/modules/cjs/loader.js:1158:30)\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1178:10)\n    at Module.load (internal/modules/cjs/loader.js:1002:32)\n    at Function.Module._load (internal/modules/cjs/loader.js:901:14)\n    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)\n`,\n    },\n    {\n      rootDir,\n      testMatch: [],\n    },\n    {\n      noCodeFrame: true,\n      noStackTrace: false,\n    },\n    'path_test',\n  );\n\n  expect(message).toMatchSnapshot();\n});\n\nit('no stack', () => {\n  jest\n    .mocked(readFileSync)\n    .mockImplementationOnce(() => 'throw new Error(\"Whoops!\");');\n\n  const message = formatExecError(\n    {\n      message: 'Whoops!',\n      stack: `\n    at Object.<anonymous> (${slash(rootDir)}/file.js:1:7)\n    at Module._compile (internal/modules/cjs/loader.js:1158:30)\n    at Object.Module._extensions..js (internal/modules/cjs/loader.js:1178:10)\n    at Module.load (internal/modules/cjs/loader.js:1002:32)\n    at Function.Module._load (internal/modules/cjs/loader.js:901:14)\n    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)\n`,\n    },\n    {\n      rootDir,\n      testMatch: [],\n    },\n    {\n      // if no stack, no codeframe is implied\n      noCodeFrame: true,\n      noStackTrace: true,\n    },\n    'path_test',\n  );\n\n  expect(message).toMatchSnapshot();\n});\n\ndescribe('formatStackTrace', () => {\n  it('prints code frame and stacktrace', () => {\n    jest\n      .mocked(readFileSync)\n      .mockImplementationOnce(() => 'throw new Error(\"Whoops!\");');\n    const message = formatStackTrace(\n      `\n      at Object.<anonymous> (${slash(rootDir)}/file.js:1:7)\n      at Module._compile (internal/modules/cjs/loader.js:1158:30)\n      at Object.Module._extensions..js (internal/modules/cjs/loader.js:1178:10)\n      at Module.load (internal/modules/cjs/loader.js:1002:32)\n      at Function.Module._load (internal/modules/cjs/loader.js:901:14)\n      at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)\n  `,\n      {\n        rootDir,\n        testMatch: [],\n      },\n      {\n        noCodeFrame: false,\n        noStackTrace: false,\n      },\n      'path_test',\n    );\n\n    expect(message).toMatchSnapshot();\n  });\n\n  it('does not print code frame when noCodeFrame = true', () => {\n    jest\n      .mocked(readFileSync)\n      .mockImplementationOnce(() => 'throw new Error(\"Whoops!\");');\n    const message = formatStackTrace(\n      `\n      at Object.<anonymous> (${slash(rootDir)}/file.js:1:7)\n      at Module._compile (internal/modules/cjs/loader.js:1158:30)\n      at Object.Module._extensions..js (internal/modules/cjs/loader.js:1178:10)\n      at Module.load (internal/modules/cjs/loader.js:1002:32)\n      at Function.Module._load (internal/modules/cjs/loader.js:901:14)\n      at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)\n  `,\n      {\n        rootDir,\n        testMatch: [],\n      },\n      {\n        noCodeFrame: true,\n        noStackTrace: false,\n      },\n      'path_test',\n    );\n\n    expect(message).toMatchSnapshot();\n  });\n\n  it('does not print codeframe when noStackTrace = true', () => {\n    jest\n      .mocked(readFileSync)\n      .mockImplementationOnce(() => 'throw new Error(\"Whoops!\");');\n    const message = formatStackTrace(\n      `\n      at Object.<anonymous> (${slash(rootDir)}/file.js:1:7)\n      at Module._compile (internal/modules/cjs/loader.js:1158:30)\n      at Object.Module._extensions..js (internal/modules/cjs/loader.js:1178:10)\n      at Module.load (internal/modules/cjs/loader.js:1002:32)\n      at Function.Module._load (internal/modules/cjs/loader.js:901:14)\n      at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:74:12)\n  `,\n      {\n        rootDir,\n        testMatch: [],\n      },\n      {\n        noStackTrace: true,\n      },\n      'path_test',\n    );\n\n    expect(message).toMatchSnapshot();\n  });\n});\n\nit('getTopFrame should return a path for mjs files', () => {\n  let stack: Array<string>;\n  let expectedFile: string;\n  if (process.platform === 'win32') {\n    stack = ['  at stack (file:///C:/Users/user/project/inline.mjs:1:1)'];\n    expectedFile = 'C:/Users/user/project/inline.mjs';\n  } else {\n    stack = ['  at stack (file:///Users/user/project/inline.mjs:1:1)'];\n    expectedFile = '/Users/user/project/inline.mjs';\n  }\n  const frame = getTopFrame(stack);\n\n  expect(frame!.file).toBe(expectedFile);\n});\n\nit('should return the error cause if there is one', () => {\n  const error = new Error('Test exception');\n  // TODO pass `cause` to the `Error` constructor when lowest supported Node version is 16.9.0 and above\n  // See https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V16.md#error-cause\n  error.cause = new Error('Cause Error');\n  const message = formatExecError(\n    error,\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n  expect(message).toMatchSnapshot();\n});\n\nit('should return the inner errors of an AggregateError', () => {\n  // See https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V15.md#v8-86---35415\n  const aggError = new AggregateError([new Error('Err 1'), new Error('Err 2')]);\n  const message = formatExecError(\n    aggError,\n    {\n      rootDir: '',\n      testMatch: [],\n    },\n    {\n      noStackTrace: false,\n    },\n  );\n  expect(message).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`.formatExecError() 1`] = `\n\"  <bold>● </intensity>Test suite failed to run\n\n    Whoops!\n\"\n`;\n\nexports[`codeframe 1`] = `\n\"  <bold>● </intensity>Test suite failed to run\n\n    Whoops!\n\n    </><red><bold>></intensity></color><gray> 1 |</color> <cyan>throw</color> <cyan>new</color> <yellow>Error</color>(<green>\"Whoops!\"</color>)<yellow>;</color>\n     <gray>   |</color>       <red><bold>^</intensity></color></>\n\n      <dim>at Object.<anonymous> (</intensity>file.js<dim>:1:7)</intensity>\n\"\n`;\n\nexports[`formatStackTrace does not print code frame when noCodeFrame = true 1`] = `\n\"\n      <dim>at Object.<anonymous> (</intensity>file.js<dim>:1:7)</intensity>\n        \"\n`;\n\nexports[`formatStackTrace does not print codeframe when noStackTrace = true 1`] = `\n\"\n      <dim>at Object.<anonymous> (</intensity>file.js<dim>:1:7)</intensity>\n        \"\n`;\n\nexports[`formatStackTrace prints code frame and stacktrace 1`] = `\n\"\n    </><red><bold>></intensity></color><gray> 1 |</color> <cyan>throw</color> <cyan>new</color> <yellow>Error</color>(<green>\"Whoops!\"</color>)<yellow>;</color>\n     <gray>   |</color>       <red><bold>^</intensity></color></>\n\n      <dim>at Object.<anonymous> (</intensity>file.js<dim>:1:7)</intensity>\n        \"\n`;\n\nexports[`formatStackTrace should properly handle deeply nested causes 1`] = `\n\"<bold><red>  <bold>● </intensity><bold>Error with cause test</color></intensity>\n\n    intercepted by f\n<dim></intensity>\n<dim>      <dim>at f (</intensity><dim>cause.test.js<dim>:15:11)</intensity><dim></intensity>\n<dim>      <dim>at Object.f (</intensity><dim>cause.test.js<dim>:20:5)</intensity><dim></intensity>\n\n    Cause:\n    intercepted by g\n<dim></intensity>\n<dim>      <dim>at g (</intensity><dim>cause.test.js<dim>:8:11)</intensity><dim></intensity>\n<dim>      <dim>at g (</intensity><dim>cause.test.js<dim>:13:5)</intensity><dim></intensity>\n<dim>      <dim>at Object.f (</intensity><dim>cause.test.js<dim>:20:5)</intensity><dim></intensity>\n\n    Cause:\n    boom\n<dim></intensity>\n<dim>      <dim>at h (</intensity><dim>cause.test.js<dim>:2:9)</intensity><dim></intensity>\n<dim>      <dim>at h (</intensity><dim>cause.test.js<dim>:6:5)</intensity><dim></intensity>\n<dim>      <dim>at g (</intensity><dim>cause.test.js<dim>:13:5)</intensity><dim></intensity>\n<dim>      <dim>at Object.f (</intensity><dim>cause.test.js<dim>:20:5)</intensity><dim></intensity>\n\"\n`;\n\nexports[`formatStackTrace should properly handle string causes 1`] = `\n\"<bold><red>  <bold>● </intensity><bold>Error with string cause test</color></intensity>\n\n    boom\n<dim></intensity>\n<dim>      <dim>at f (</intensity><dim>cause.test.js<dim>:15:11)</intensity><dim></intensity>\n<dim>      <dim>at Object.f (</intensity><dim>cause.test.js<dim>:20:5)</intensity><dim></intensity>\n\n    Cause:\n    string cause\n<dim></intensity>\n<dim></intensity>\n\"\n`;\n\nexports[`formatStackTrace should strip node internals 1`] = `\n\"<bold><red>  <bold>● </intensity><bold>Unix test</color></intensity>\n\n      \n        Expected value to be of type:\n          \"number\"\n        Received:\n          \"\"\n        type:\n          \"string\"\n<dim></intensity>\n<dim>      <dim>at Object.it (</intensity><dim>__tests__/test.js<dim>:8:14)</intensity><dim></intensity>\n\"\n`;\n\nexports[`no codeframe 1`] = `\n\"  <bold>● </intensity>Test suite failed to run\n\n    Whoops!\n\n      <dim>at Object.<anonymous> (</intensity>file.js<dim>:1:7)</intensity>\n\"\n`;\n\nexports[`no stack 1`] = `\n\"  <bold>● </intensity>Test suite failed to run\n\n    Whoops!\n\"\n`;\n\nexports[`retains message in babel code frame error 1`] = `\n\"<bold><red>  <bold>● </intensity><bold>Babel test</color></intensity>\n\n      \n        packages/react/src/forwardRef.js: Unexpected token, expected , (20:10)\n<dim></intensity>\n<dim>          </> <gray> 18 | </color>        <cyan>false</color><yellow>,</color></intensity>\n<dim>           <gray> 19 | </color>        <green>'forwardRef requires a render function but received a \\`memo\\` '</color></intensity>\n<dim>          <red><bold>></intensity><dim></color><gray> 20 | </color>          <green>'component. Instead of forwardRef(memo(...)), use '</color> <yellow>+</color></intensity>\n<dim>           <gray>    | </color>          <red><bold>^</intensity><dim></color></intensity>\n<dim>           <gray> 21 | </color>          <green>'memo(forwardRef(...)).'</color><yellow>,</color></intensity>\n<dim>           <gray> 22 | </color>      )<yellow>;</color></intensity>\n<dim>           <gray> 23 | </color>    } <cyan>else</color> <cyan>if</color> (<cyan>typeof</color> render <yellow>!==</color> <green>'function'</color>) {</></intensity>\n\"\n`;\n\nexports[`should exclude jasmine from stack trace for Unix paths. 1`] = `\n\"<bold><red>  <bold>● </intensity><bold>Unix test</color></intensity>\n\n      at stack (../jest-jasmine2/build/jasmine-2.4.1.js:1580:17)\n<dim></intensity>\n<dim>      <dim>at Object.addResult (</intensity><dim>../jest-jasmine2/build/jasmine-2.4.1.js<dim>:1550:14)</intensity><dim></intensity>\n<dim>      <dim>at Object.it (</intensity><dim>build/__tests__/messages-test.js<dim>:45:41)</intensity><dim></intensity>\n\"\n`;\n\nexports[`should not exclude vendor from stack trace 1`] = `\n\"<bold><red>  <bold>● </intensity><bold>Vendor test</color></intensity>\n\n      \n        Expected value to be of type:\n          \"number\"\n        Received:\n          \"\"\n        type:\n          \"string\"\n<dim></intensity>\n<dim>      <dim>at Object.it (</intensity><dim>__tests__/vendor/cool_test.js<dim>:6:666)</intensity><dim></intensity>\n<dim>      <dim>at Object.asyncFn (</intensity><dim>__tests__/vendor/sulu/node_modules/sulu-content-bundle/best_component.js<dim>:1:5)</intensity><dim></intensity>\n\"\n`;\n\nexports[`should return the error cause if there is one 1`] = `\n\"  <bold>● </intensity>Test suite failed to run\n\n    Test exception\n\n      <dim>at Object.<anonymous> (</intensity>packages/jest-message-util/src/__tests__/messages.test.ts<dim>:564:17)</intensity>\n\n    Cause:\n     Cause Error\n\n          <dim>at Object.<anonymous> (</intensity>packages/jest-message-util/src/__tests__/messages.test.ts<dim>:567:17)</intensity>\n\n\"\n`;\n\nexports[`should return the inner errors of an AggregateError 1`] = `\n\"  <bold>● </intensity>Test suite failed to run\n\n    AggregateError:\n\n      <dim>at Object.<anonymous> (</intensity>packages/jest-message-util/src/__tests__/messages.test.ts<dim>:583:20)</intensity>\n\n    Errors contained in AggregateError:\n     Err 1\n\n          <dim>at Object.<anonymous> (</intensity>packages/jest-message-util/src/__tests__/messages.test.ts<dim>:583:40)</intensity>\n\n     Err 2\n\n          <dim>at Object.<anonymous> (</intensity>packages/jest-message-util/src/__tests__/messages.test.ts<dim>:583:60)</intensity>\n\n\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nexports.isManualMockModule = true;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('supports instanceof Promise', () => {\n  const {exitCode} = runJest('mock-functions');\n\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('suite without mock name, mock called', () => {\n  const {stderr, exitCode} = runJest('mock-names/without-mock-name');\n\n  expect(exitCode).toBe(0);\n  expect(stderr).toMatch(/PASS/);\n});\n\ntest('suite without mock name, mock not called', () => {\n  const {stderr, exitCode} = runJest('mock-names/without-mock-name-not-called');\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toMatch(/expect\\(jest\\.fn\\(\\)\\)\\.toHaveBeenCalled/);\n});\n\ntest('suite with mock name, expect mock not called', () => {\n  const {stderr, exitCode} = runJest(\n    'mock-names/with-mock-name-not-called-pass',\n  );\n\n  expect(exitCode).toBe(0);\n  expect(stderr).toMatch(/PASS/);\n});\n\ntest('suite with mock name, mock called, expect fail', () => {\n  const {stderr, exitCode} = runJest(\n    'mock-names/with-mock-name-not-called-fail',\n  );\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toMatch(/expect\\(myMockedFunction\\)\\.not\\.toHaveBeenCalled/);\n});\n\ntest('suite with mock name, mock called 5 times', () => {\n  const {stderr, exitCode} = runJest(\n    'mock-names/with-mock-name-call-times-pass',\n  );\n\n  expect(exitCode).toBe(0);\n  expect(stderr).toMatch(/PASS/);\n});\n\ntest('suite with mock name, mock not called 5 times, expect fail', () => {\n  const {stderr, exitCode} = runJest(\n    'mock-names/with-mock-name-call-times-fail',\n  );\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toMatch(/expect\\(myMockedFunction\\)\\.toHaveBeenCalledTimes/);\n});\n\ntest('suite with mock name, mock called', () => {\n  const {stderr, exitCode} = runJest('mock-names/with-mock-name');\n\n  expect(exitCode).toBe(0);\n  expect(stderr).toMatch(/PASS/);\n});\n\ntest('suite with mock name, mock not called', () => {\n  const {stderr, exitCode} = runJest('mock-names/with-mock-name-not-called');\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toMatch(/expect\\(myMockedFunction\\)\\.toHaveBeenCalled/);\n});"}
{"prompt":"ignore error","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {format as prettyFormat} from 'pretty-format';\nimport plugin from '../mockSerializer';\n\ntest('mock with 0 calls and default name', () => {\n  const fn = jest.fn();\n  expect(fn).toMatchSnapshot();\n});\n\ntest('mock with 2 calls, 1 return, 1 throw', () => {\n  const fn = jest.fn((value: number) => {\n    if (value % 2 === 0) {\n      return value * 2;\n    } else {\n      throw new Error('Error Message!');\n    }\n  });\n\n  fn(2);\n\n  try {\n    fn(3);\n  } catch {\n    // ignore error\n  }\n\n  expect(fn).toMatchSnapshot();\n});\n\ntest('mock with 0 calls and default name in React element', () => {\n  const fn = jest.fn();\n  const val = {\n    $$typeof: Symbol.for('react.test.json'),\n    children: ['Mock me!'],\n    props: {\n      onClick: fn,\n    },\n    type: 'button',\n  };\n  expect(val).toMatchSnapshot();\n});\n\ntest('mock with 0 calls and non-default name', () => {\n  const fn = jest.fn();\n  fn.mockName('MyConstructor');\n  expect(fn).toMatchSnapshot();\n});\n\ntest('mock with 1 calls and non-default name via new in object', () => {\n  const fn = jest.fn();\n  fn.mockName('MyConstructor');\n  // eslint-disable-next-line no-new\n  new fn({name: 'some fine name'});\n  const val = {\n    fn,\n  };\n  expect(val).toMatchSnapshot();\n});\n\ntest('mock with 1 calls in React element', () => {\n  const fn = jest.fn();\n  fn('Mocking you!');\n  const val = {\n    $$typeof: Symbol.for('react.test.json'),\n    children: ['Mock me!'],\n    props: {\n      onClick: fn,\n    },\n    type: 'button',\n  };\n  expect(val).toMatchSnapshot();\n});\n\ntest('mock with 2 calls', () => {\n  const fn = jest.fn();\n  fn();\n  fn({foo: 'bar'}, 42);\n  expect(fn).toMatchSnapshot();\n});\n\ntest('indent option', () => {\n  const fn = jest.fn((val: {key: string}) => val);\n  fn({key: 'value'});\n  const expected = [\n    '[MockFunction] {',\n    '\"calls\": Array [',\n    'Array [',\n    'Object {',\n    '\"key\": \"value\",',\n    '},',\n    '],',\n    '],',\n    '\"results\": Array [',\n    'Object {',\n    '\"type\": \"return\",',\n    '\"value\": Object {',\n    '\"key\": \"value\",',\n    '},',\n    '},',\n    '],',\n    '}',\n  ].join('\\n');\n  expect(prettyFormat(fn, {indent: 0, plugins: [plugin]})).toBe(expected);\n});\n\ntest('min option', () => {\n  const fn = jest.fn((val: {key: string}) => val);\n  fn({key: 'value'});\n  const expected =\n    '[MockFunction] {\"calls\": [[{\"key\": \"value\"}]], \"results\": [{\"type\": \"return\", \"value\": {\"key\": \"value\"}}]}';\n  expect(prettyFormat(fn, {min: true, plugins: [plugin]})).toBe(expected);\n});\n\ntest('maxDepth option', () => {\n  const fn1 = jest.fn();\n  fn1.mockName('atDepth1');\n  fn1('primitive', {key: 'value'});\n  const fn2 = jest.fn();\n  fn2.mockName('atDepth2');\n  fn2('primitive', {key: 'value'});\n  const fn3 = jest.fn();\n  fn3.mockName('atDepth3');\n  fn3('primitive', {key: 'value'});\n  const val = {\n    fn1,\n    greaterThan1: {\n      fn2,\n      greaterThan2: {\n        fn3,\n      },\n    },\n  };\n  const expected = [\n    'Object {', // ++depth === 1\n    '  \"fn1\": [MockFunction atDepth1] {',\n    '    \"calls\": Array [', // ++depth === 2\n    '      Array [', // ++depth === 3\n    '        \"primitive\",',\n    '        [Object],', // ++depth === 4\n    '      ],',\n    '    ],',\n    '    \"results\": Array [', // ++depth === 2\n    '      Object {', // ++depth === 3\n    '        \"type\": \"return\",',\n    '        \"value\": undefined,',\n    '      },',\n    '    ],',\n    '  },',\n    '  \"greaterThan1\": Object {', // ++depth === 2\n    '    \"fn2\": [MockFunction atDepth2] {',\n    '      \"calls\": Array [', // ++depth === 3\n    '        [Array],', // ++depth === 4\n    '      ],',\n    '      \"results\": Array [', // ++depth === 3\n    '        [Object],', // ++depth === 4\n    '      ],',\n    '    },',\n    '    \"greaterThan2\": Object {', // ++depth === 3\n    '      \"fn3\": [MockFunction atDepth3] {',\n    '        \"calls\": [Array],', // ++depth === 4\n    '        \"results\": [Array],', // ++depth === 4\n    '      },',\n    '    },',\n    '  },',\n    '}',\n  ].join('\\n');\n  expect(prettyFormat(val, {maxDepth: 3, plugins: [plugin]})).toBe(expected);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`mock with 0 calls and default name 1`] = `[MockFunction]`;\n\nexports[`mock with 0 calls and default name in React element 1`] = `\n<button\n  onClick={[MockFunction]}\n>\n  Mock me!\n</button>\n`;\n\nexports[`mock with 0 calls and non-default name 1`] = `[MockFunction MyConstructor]`;\n\nexports[`mock with 1 calls and non-default name via new in object 1`] = `\nObject {\n  \"fn\": [MockFunction MyConstructor] {\n    \"calls\": Array [\n      Array [\n        Object {\n          \"name\": \"some fine name\",\n        },\n      ],\n    ],\n    \"results\": Array [\n      Object {\n        \"type\": \"return\",\n        \"value\": undefined,\n      },\n    ],\n  },\n}\n`;\n\nexports[`mock with 1 calls in React element 1`] = `\n<button\n  onClick={\n    [MockFunction] {\n      \"calls\": Array [\n        Array [\n          \"Mocking you!\",\n        ],\n      ],\n      \"results\": Array [\n        Object {\n          \"type\": \"return\",\n          \"value\": undefined,\n        },\n      ],\n    }\n  }\n>\n  Mock me!\n</button>\n`;\n\nexports[`mock with 2 calls 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [],\n    Array [\n      Object {\n        \"foo\": \"bar\",\n      },\n      42,\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": undefined,\n    },\n    Object {\n      \"type\": \"return\",\n      \"value\": undefined,\n    },\n  ],\n}\n`;\n\nexports[`mock with 2 calls, 1 return, 1 throw 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [\n      2,\n    ],\n    Array [\n      3,\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": 4,\n    },\n    Object {\n      \"type\": \"throw\",\n      \"value\": [Error: Error Message!],\n    },\n  ],\n}\n`;"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\n/**\n * This file illustrates how to define a custom mock per test.\n *\n * The file contains two test cases:\n * - One where the fruit module is mocked.\n * - One where the fruit module is not mocked.\n */\ndescribe('define mock per test', () => {\n  beforeEach(() => {\n    jest.resetModules();\n  });\n\n  it('uses mocked module', () => {\n    jest.doMock('../fruit', () => ({\n      apple: 'mocked apple',\n      default: jest.fn(() => 'mocked fruit'),\n      strawberry: jest.fn(() => 'mocked strawberry'),\n    }));\n    const {apple, strawberry, default: defaultExport} = require('../fruit');\n\n    const defaultExportResult = defaultExport();\n    expect(defaultExportResult).toBe('mocked fruit');\n    expect(defaultExport).toHaveBeenCalled();\n\n    expect(apple).toBe('mocked apple');\n    expect(strawberry()).toBe('mocked strawberry');\n  });\n\n  it('uses actual module', () => {\n    jest.dontMock('../fruit');\n    const {apple, strawberry, default: defaultExport} = require('../fruit');\n\n    const defaultExportResult = defaultExport();\n    expect(defaultExportResult).toBe('banana');\n\n    expect(apple).toBe('apple');\n    expect(strawberry()).toBe('strawberry');\n  });\n});"}
{"prompt":"FakeTimers,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {makeProjectConfig} from '@jest/test-utils';\nimport FakeTimers from '../modernFakeTimers';\n\ndescribe('FakeTimers', () => {\n  describe('construction', () => {\n    it('installs setTimeout mock', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.setTimeout).toBeDefined();\n    });\n\n    it('installs clearTimeout mock', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.clearTimeout).toBeDefined();\n    });\n\n    it('installs setInterval mock', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.setInterval).toBeDefined();\n    });\n\n    it('installs clearInterval mock', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.clearInterval).toBeDefined();\n    });\n\n    it('mocks process.nextTick if it exists on global', () => {\n      const origNextTick = () => {};\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {\n          nextTick: origNextTick,\n        },\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.process.nextTick).not.toBe(origNextTick);\n    });\n\n    it('mocks setImmediate if it exists on global', () => {\n      const origSetImmediate = () => {};\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setImmediate: origSetImmediate,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.setImmediate).not.toBe(origSetImmediate);\n    });\n\n    it('mocks clearImmediate if setImmediate is on global', () => {\n      const origSetImmediate = () => {};\n      const origClearImmediate = () => {};\n      const global = {\n        Date,\n        clearImmediate: origClearImmediate,\n        clearInterval,\n        clearTimeout,\n        process,\n        setImmediate: origSetImmediate,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.clearImmediate).not.toBe(origClearImmediate);\n    });\n\n    it('mocks requestAnimationFrame if it exists on global', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.requestAnimationFrame).toBeDefined();\n    });\n\n    it('mocks cancelAnimationFrame if it exists on global', () => {\n      const global = {\n        Date,\n        cancelAnimationFrame: () => {},\n        clearInterval,\n        clearTimeout,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      expect(global.cancelAnimationFrame).toBeDefined();\n    });\n  });\n\n  describe('runAllTicks', () => {\n    it('runs all ticks, in order', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {\n          nextTick: () => {},\n        },\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n\n      global.process.nextTick(mock1);\n      global.process.nextTick(mock2);\n\n      expect(mock1).toHaveBeenCalledTimes(0);\n      expect(mock2).toHaveBeenCalledTimes(0);\n\n      timers.runAllTicks();\n\n      expect(mock1).toHaveBeenCalledTimes(1);\n      expect(mock2).toHaveBeenCalledTimes(1);\n      expect(runOrder).toEqual(['mock1', 'mock2']);\n    });\n\n    it('does nothing when no ticks have been scheduled', () => {\n      const nextTick = jest.fn();\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {\n          nextTick,\n        },\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      timers.runAllTicks();\n\n      expect(nextTick).toHaveBeenCalledTimes(0);\n    });\n\n    it('only runs a scheduled callback once', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {\n          nextTick: () => {},\n        },\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.process.nextTick(mock1);\n      expect(mock1).toHaveBeenCalledTimes(0);\n\n      timers.runAllTicks();\n      expect(mock1).toHaveBeenCalledTimes(1);\n\n      timers.runAllTicks();\n      expect(mock1).toHaveBeenCalledTimes(1);\n    });\n\n    it('throws before allowing infinite recursion', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {\n          nextTick: () => {},\n        },\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({\n        config: makeProjectConfig({fakeTimers: {timerLimit: 100}}),\n        global,\n      });\n\n      timers.useFakeTimers();\n\n      global.process.nextTick(function infinitelyRecursingCallback() {\n        global.process.nextTick(infinitelyRecursingCallback);\n      });\n\n      expect(() => {\n        timers.runAllTicks();\n      }).toThrow(\n        'Aborting after running 100 timers, assuming an infinite loop!',\n      );\n    });\n  });\n\n  describe('runAllTimers', () => {\n    it('runs all timers in order', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n      const mock5 = jest.fn(() => runOrder.push('mock5'));\n      const mock6 = jest.fn(() => runOrder.push('mock6'));\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, Number.NaN);\n      global.setTimeout(mock3, 0);\n      const intervalHandler = global.setInterval(() => {\n        mock4();\n        global.clearInterval(intervalHandler);\n      }, 200);\n      global.setTimeout(mock5, Number.POSITIVE_INFINITY);\n      global.setTimeout(mock6, Number.NEGATIVE_INFINITY);\n\n      timers.runAllTimers();\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        'mock5',\n        'mock6',\n        'mock1',\n        'mock4',\n      ]);\n    });\n\n    it('warns when trying to advance timers while real timers are used', () => {\n      const consoleWarnSpy = jest\n        .spyOn(console, 'warn')\n        .mockImplementation(() => {\n          // nothing\n        });\n      const timers = new FakeTimers({\n        config: makeProjectConfig({rootDir: __dirname}),\n        global: globalThis,\n      });\n      timers.runAllTimers();\n      expect(\n        consoleWarnSpy.mock.calls[0][0].split('\\nStack Trace')[0],\n      ).toMatchSnapshot();\n      consoleWarnSpy.mockRestore();\n      timers.useRealTimers();\n    });\n\n    it('does nothing when no timers have been scheduled', () => {\n      const nativeSetTimeout = jest.fn();\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval: nativeSetTimeout,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      timers.runAllTimers();\n    });\n\n    it('only runs a setTimeout callback once (ever)', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      global.setTimeout(fn, 0);\n      expect(fn).toHaveBeenCalledTimes(0);\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n    });\n\n    it('runs callbacks with arguments after the interval', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      global.setTimeout(fn, 0, 'mockArg1', 'mockArg2');\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n      expect(fn).toHaveBeenCalledWith('mockArg1', 'mockArg2');\n    });\n\n    it(\"doesn't pass the callback to native setTimeout\", () => {\n      const nativeSetTimeout = jest.fn();\n\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval: nativeSetTimeout,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      // @sinonjs/fake-timers uses `setTimeout` during init to figure out if it's in Node or\n      // browser env. So clear its calls before we install them into the env\n      nativeSetTimeout.mockClear();\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setTimeout(mock1, 0);\n\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(1);\n      expect(nativeSetTimeout).toHaveBeenCalledTimes(0);\n    });\n\n    it('throws before allowing infinite recursion', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({\n        config: makeProjectConfig({fakeTimers: {timerLimit: 1000}}),\n        global,\n      });\n      timers.useFakeTimers();\n\n      global.setTimeout(function infinitelyRecursingCallback() {\n        global.setTimeout(infinitelyRecursingCallback, 0);\n      }, 0);\n\n      expect(() => {\n        timers.runAllTimers();\n      }).toThrow(\n        new Error(\n          'Aborting after running 1000 timers, assuming an infinite loop!',\n        ),\n      );\n    });\n\n    it('also clears ticks', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      global.setTimeout(() => {\n        process.nextTick(fn);\n      }, 0);\n      expect(fn).toHaveBeenCalledTimes(0);\n\n      timers.runAllTimers();\n      expect(fn).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('advanceTimersByTime', () => {\n    it('runs timers in order', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      global.setInterval(() => {\n        mock4();\n      }, 200);\n\n      // Move forward to t=50\n      timers.advanceTimersByTime(50);\n      expect(runOrder).toEqual(['mock2', 'mock3']);\n\n      // Move forward to t=60\n      timers.advanceTimersByTime(10);\n      expect(runOrder).toEqual(['mock2', 'mock3']);\n\n      // Move forward to t=100\n      timers.advanceTimersByTime(40);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1']);\n\n      // Move forward to t=200\n      timers.advanceTimersByTime(100);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1', 'mock4']);\n\n      // Move forward to t=400\n      timers.advanceTimersByTime(200);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1', 'mock4', 'mock4']);\n    });\n\n    it('does nothing when no timers have been scheduled', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      timers.advanceTimersByTime(100);\n    });\n  });\n\n  describe('advanceTimersToNextTimer', () => {\n    it('runs timers in order', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      global.setInterval(() => {\n        mock4();\n      }, 200);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=0\n      expect(runOrder).toEqual(['mock2', 'mock3']);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=100\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1']);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=200\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1', 'mock4']);\n\n      timers.advanceTimersToNextTimer();\n      // Move forward to t=400\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1', 'mock4', 'mock4']);\n    });\n\n    it('run correct amount of steps', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n\n      global.setTimeout(mock1, 100);\n      global.setTimeout(mock2, 0);\n      global.setTimeout(mock3, 0);\n      global.setInterval(() => {\n        mock4();\n      }, 200);\n\n      // Move forward to t=100\n      timers.advanceTimersToNextTimer(2);\n      expect(runOrder).toEqual(['mock2', 'mock3', 'mock1']);\n\n      // Move forward to t=600\n      timers.advanceTimersToNextTimer(3);\n      expect(runOrder).toEqual([\n        'mock2',\n        'mock3',\n        'mock1',\n        'mock4',\n        'mock4',\n        'mock4',\n      ]);\n    });\n\n    it('setTimeout inside setTimeout', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n      const mock4 = jest.fn(() => runOrder.push('mock4'));\n\n      global.setTimeout(mock1, 0);\n      global.setTimeout(() => {\n        mock2();\n        global.setTimeout(mock3, 50);\n      }, 25);\n      global.setTimeout(mock4, 100);\n\n      // Move forward to t=75\n      timers.advanceTimersToNextTimer(3);\n      expect(runOrder).toEqual(['mock1', 'mock2', 'mock3']);\n    });\n\n    it('does nothing when no timers have been scheduled', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      timers.advanceTimersToNextTimer();\n    });\n  });\n\n  describe('advanceTimersToNextFrame', () => {\n    it('runs scheduled animation frame callbacks in order', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const mock1 = jest.fn(() => runOrder.push('mock1'));\n      const mock2 = jest.fn(() => runOrder.push('mock2'));\n      const mock3 = jest.fn(() => runOrder.push('mock3'));\n\n      global.requestAnimationFrame(mock1);\n      global.requestAnimationFrame(mock2);\n      global.requestAnimationFrame(mock3);\n\n      timers.advanceTimersToNextFrame();\n\n      expect(runOrder).toEqual(['mock1', 'mock2', 'mock3']);\n    });\n\n    it('should only run currently scheduled animation frame callbacks', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      function run() {\n        runOrder.push('first-frame');\n\n        // scheduling another animation frame in the first frame\n        global.requestAnimationFrame(() => runOrder.push('second-frame'));\n      }\n\n      global.requestAnimationFrame(run);\n\n      // only the first frame should be executed\n      timers.advanceTimersToNextFrame();\n\n      expect(runOrder).toEqual(['first-frame']);\n\n      timers.advanceTimersToNextFrame();\n\n      expect(runOrder).toEqual(['first-frame', 'second-frame']);\n    });\n\n    it('should allow cancelling of scheduled animation frame callbacks', () => {\n      const global = {\n        Date,\n        cancelAnimationFrame: () => {},\n        clearInterval,\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      const callback = jest.fn();\n      timers.useFakeTimers();\n\n      const timerId = global.requestAnimationFrame(callback);\n      global.cancelAnimationFrame(timerId);\n\n      timers.advanceTimersToNextFrame();\n\n      expect(callback).not.toHaveBeenCalled();\n    });\n\n    it('should only advance as much time is needed to get to the next frame', () => {\n      const global = {\n        Date,\n        cancelAnimationFrame: () => {},\n        clearInterval,\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n      const start = global.Date.now();\n\n      const callback = () => runOrder.push('frame');\n      global.requestAnimationFrame(callback);\n\n      // Advancing timers less than a frame (which is 16ms)\n      timers.advanceTimersByTime(6);\n      expect(global.Date.now()).toEqual(start + 6);\n\n      // frame not yet executed\n      expect(runOrder).toEqual([]);\n\n      // move timers forward to execute frame\n      timers.advanceTimersToNextFrame();\n\n      // frame has executed as time has moved forward 10ms to get to the 16ms frame time\n      expect(runOrder).toEqual(['frame']);\n      expect(global.Date.now()).toEqual(start + 16);\n    });\n\n    it('should execute any timers on the way to the animation frame', () => {\n      const global = {\n        Date,\n        cancelAnimationFrame: () => {},\n        clearInterval,\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n\n      global.requestAnimationFrame(() => runOrder.push('frame'));\n\n      // scheduling a timeout that will be executed on the way to the frame\n      global.setTimeout(() => runOrder.push('timeout'), 10);\n\n      // move timers forward to execute frame\n      timers.advanceTimersToNextFrame();\n\n      expect(runOrder).toEqual(['timeout', 'frame']);\n    });\n\n    it('should not execute any timers scheduled inside of an animation frame callback', () => {\n      const global = {\n        Date,\n        cancelAnimationFrame: () => {},\n        clearInterval,\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n\n      global.requestAnimationFrame(() => {\n        runOrder.push('frame');\n        // scheduling a timer inside of a frame\n        global.setTimeout(() => runOrder.push('timeout'), 1);\n      });\n\n      timers.advanceTimersToNextFrame();\n\n      // timeout not yet executed\n      expect(runOrder).toEqual(['frame']);\n\n      // validating that the timer will still be executed\n      timers.advanceTimersByTime(1);\n      expect(runOrder).toEqual(['frame', 'timeout']);\n    });\n\n    it('should call animation frame callbacks with the latest system time', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        performance,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const callback = jest.fn();\n\n      global.requestAnimationFrame(callback);\n\n      timers.advanceTimersToNextFrame();\n\n      // `requestAnimationFrame` callbacks are called with a `DOMHighResTimeStamp`\n      expect(callback).toHaveBeenCalledWith(global.performance.now());\n    });\n  });\n\n  describe('reset', () => {\n    it('resets all pending setTimeouts', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setTimeout(mock1, 100);\n\n      timers.reset();\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets all pending setIntervals', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setInterval(mock1, 200);\n\n      timers.reset();\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets all pending ticks callbacks', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {\n          nextTick: () => {},\n        },\n        setImmediate: () => {},\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.process.nextTick(mock1);\n      global.setImmediate(mock1);\n\n      timers.reset();\n      timers.runAllTicks();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets current advanceTimersByTime time cursor', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.setTimeout(mock1, 100);\n      timers.advanceTimersByTime(50);\n\n      timers.reset();\n      global.setTimeout(mock1, 100);\n\n      timers.advanceTimersByTime(50);\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n\n    it('resets all scheduled animation frames', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        requestAnimationFrame: () => -1,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const mock1 = jest.fn();\n      global.requestAnimationFrame(mock1);\n\n      timers.reset();\n      timers.runAllTimers();\n      expect(mock1).toHaveBeenCalledTimes(0);\n    });\n  });\n\n  describe('runOnlyPendingTimers', () => {\n    it('runs all timers in order', () => {\n      const nativeSetImmediate = jest.fn();\n\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setImmediate: nativeSetImmediate,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const runOrder: Array<string> = [];\n\n      global.setTimeout(function cb() {\n        runOrder.push('mock1');\n        global.setTimeout(cb, 100);\n      }, 100);\n\n      global.setTimeout(function cb() {\n        runOrder.push('mock2');\n        global.setTimeout(cb, 50);\n      }, 0);\n\n      global.setInterval(() => {\n        runOrder.push('mock3');\n      }, 200);\n\n      global.setImmediate(() => {\n        runOrder.push('mock4');\n      });\n\n      global.setImmediate(function cb() {\n        runOrder.push('mock5');\n        global.setTimeout(cb, 400);\n      });\n\n      timers.runOnlyPendingTimers();\n      const firsRunOrder = [\n        'mock4',\n        'mock5',\n        'mock2',\n        'mock2',\n        'mock1',\n        'mock2',\n        'mock2',\n        'mock3',\n        'mock1',\n        'mock2',\n      ];\n\n      expect(runOrder).toEqual(firsRunOrder);\n\n      timers.runOnlyPendingTimers();\n      expect(runOrder).toEqual([\n        ...firsRunOrder,\n        'mock2',\n        'mock1',\n        'mock2',\n        'mock2',\n        'mock3',\n        'mock5',\n        'mock1',\n        'mock2',\n      ]);\n    });\n\n    it('does not run timers that were cleared in another timer', () => {\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const fn = jest.fn();\n      const timer = global.setTimeout(fn, 10);\n      global.setTimeout(() => {\n        global.clearTimeout(timer);\n      }, 0);\n\n      timers.runOnlyPendingTimers();\n      expect(fn).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('useRealTimers', () => {\n    it('resets native timer APIs', () => {\n      const nativeSetTimeout = jest.fn();\n      const nativeSetInterval = jest.fn();\n      const nativeClearTimeout = jest.fn();\n      const nativeClearInterval = jest.fn();\n\n      const global = {\n        Date,\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        process,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      // Ensure that timers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.setTimeout).not.toBe(nativeSetTimeout);\n      expect(global.setInterval).not.toBe(nativeSetInterval);\n      expect(global.clearTimeout).not.toBe(nativeClearTimeout);\n      expect(global.clearInterval).not.toBe(nativeClearInterval);\n\n      timers.useRealTimers();\n\n      expect(global.setTimeout).toBe(nativeSetTimeout);\n      expect(global.setInterval).toBe(nativeSetInterval);\n      expect(global.clearTimeout).toBe(nativeClearTimeout);\n      expect(global.clearInterval).toBe(nativeClearInterval);\n    });\n\n    it('resets native process.nextTick when present', () => {\n      const nativeProcessNextTick = jest.fn();\n\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {nextTick: nativeProcessNextTick},\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      // Ensure that timers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.process.nextTick).not.toBe(nativeProcessNextTick);\n\n      timers.useRealTimers();\n\n      expect(global.process.nextTick).toBe(nativeProcessNextTick);\n    });\n\n    it('resets native setImmediate when present', () => {\n      const nativeSetImmediate = jest.fn();\n      const nativeClearImmediate = jest.fn();\n\n      const global = {\n        Date,\n        clearImmediate: nativeClearImmediate,\n        clearInterval,\n        clearTimeout,\n        process,\n        setImmediate: nativeSetImmediate,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      // Ensure that timers has overridden the native timer APIs\n      // (because if it didn't, this test might pass when it shouldn't)\n      expect(global.setImmediate).not.toBe(nativeSetImmediate);\n      expect(global.clearImmediate).not.toBe(nativeClearImmediate);\n\n      timers.useRealTimers();\n\n      expect(global.setImmediate).toBe(nativeSetImmediate);\n      expect(global.clearImmediate).toBe(nativeClearImmediate);\n    });\n  });\n\n  describe('useFakeTimers', () => {\n    it('resets mock timer APIs', () => {\n      const nativeSetTimeout = jest.fn();\n      const nativeSetInterval = jest.fn();\n      const nativeClearTimeout = jest.fn();\n      const nativeClearInterval = jest.fn();\n\n      const global = {\n        Date,\n        clearInterval: nativeClearInterval,\n        clearTimeout: nativeClearTimeout,\n        process,\n        setInterval: nativeSetInterval,\n        setTimeout: nativeSetTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.setTimeout).toBe(nativeSetTimeout);\n      expect(global.setInterval).toBe(nativeSetInterval);\n      expect(global.clearTimeout).toBe(nativeClearTimeout);\n      expect(global.clearInterval).toBe(nativeClearInterval);\n\n      timers.useFakeTimers();\n\n      expect(global.setTimeout).not.toBe(nativeSetTimeout);\n      expect(global.setInterval).not.toBe(nativeSetInterval);\n      expect(global.clearTimeout).not.toBe(nativeClearTimeout);\n      expect(global.clearInterval).not.toBe(nativeClearInterval);\n    });\n\n    it('resets mock process.nextTick when present', () => {\n      const nativeProcessNextTick = jest.fn();\n\n      const global = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process: {nextTick: nativeProcessNextTick},\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.process.nextTick).toBe(nativeProcessNextTick);\n\n      timers.useFakeTimers();\n\n      expect(global.process.nextTick).not.toBe(nativeProcessNextTick);\n    });\n\n    it('resets mock setImmediate when present', () => {\n      const nativeSetImmediate = jest.fn();\n      const nativeClearImmediate = jest.fn();\n\n      const global = {\n        Date,\n        clearImmediate: nativeClearImmediate,\n        clearInterval,\n        clearTimeout,\n        process,\n        setImmediate: nativeSetImmediate,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const fakeTimers = new FakeTimers({config: makeProjectConfig(), global});\n      fakeTimers.useRealTimers();\n\n      // Ensure that the real timers are installed at this point\n      // (because if they aren't, this test might pass when it shouldn't)\n      expect(global.setImmediate).toBe(nativeSetImmediate);\n      expect(global.clearImmediate).toBe(nativeClearImmediate);\n\n      fakeTimers.useFakeTimers();\n\n      expect(global.setImmediate).not.toBe(nativeSetImmediate);\n      expect(global.clearImmediate).not.toBe(nativeClearImmediate);\n    });\n  });\n\n  describe('getTimerCount', () => {\n    let timers: FakeTimers;\n    let fakedGlobal: typeof globalThis;\n    beforeEach(() => {\n      fakedGlobal = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setImmediate,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      timers = new FakeTimers({\n        config: makeProjectConfig(),\n        global: fakedGlobal,\n      });\n\n      timers.useFakeTimers();\n    });\n\n    afterEach(() => {\n      timers.useRealTimers();\n    });\n\n    it('returns the correct count', () => {\n      fakedGlobal.setTimeout(() => {}, 0);\n      fakedGlobal.setTimeout(() => {}, 0);\n      fakedGlobal.setTimeout(() => {}, 10);\n\n      expect(timers.getTimerCount()).toBe(3);\n\n      timers.advanceTimersByTime(5);\n\n      expect(timers.getTimerCount()).toBe(1);\n\n      timers.advanceTimersByTime(5);\n\n      expect(timers.getTimerCount()).toBe(0);\n    });\n\n    it('includes immediates and ticks', () => {\n      fakedGlobal.setTimeout(() => {}, 0);\n      fakedGlobal.setImmediate(() => {});\n      process.nextTick(() => {});\n\n      expect(timers.getTimerCount()).toBe(3);\n    });\n\n    it('not includes cancelled immediates', () => {\n      fakedGlobal.setImmediate(() => {});\n      expect(timers.getTimerCount()).toBe(1);\n      timers.clearAllTimers();\n\n      expect(timers.getTimerCount()).toBe(0);\n    });\n  });\n\n  describe('advanceTimersToNextTimerAsync', () => {\n    it('should advance the clock at the moment of the first scheduled timer', async () => {\n      const global = {\n        Date,\n        Promise,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      timers.setSystemTime(0);\n\n      const spy = jest.fn();\n      global.setTimeout(async () => {\n        await Promise.resolve();\n        global.setTimeout(spy, 100);\n      }, 100);\n\n      await timers.advanceTimersToNextTimerAsync();\n      expect(timers.now()).toBe(100);\n\n      await timers.advanceTimersToNextTimerAsync();\n      expect(timers.now()).toBe(200);\n      expect(spy).toHaveBeenCalled();\n    });\n\n    it('should advance the clock at the moment of the n-th scheduled timer', async () => {\n      const global = {\n        Date,\n        Promise,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      timers.setSystemTime(0);\n\n      const spy = jest.fn();\n      global.setTimeout(async () => {\n        await Promise.resolve();\n        global.setTimeout(spy, 100);\n      }, 100);\n\n      await timers.advanceTimersToNextTimerAsync(2);\n\n      expect(timers.now()).toBe(200);\n      expect(spy).toHaveBeenCalled();\n    });\n  });\n\n  describe('runAllTimersAsync', () => {\n    it('should advance the clock to the last scheduled timer', async () => {\n      const global = {\n        Date,\n        Promise,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      timers.setSystemTime(0);\n\n      const spy = jest.fn();\n      const spy2 = jest.fn();\n      global.setTimeout(async () => {\n        await Promise.resolve();\n        global.setTimeout(spy, 100);\n        global.setTimeout(spy2, 200);\n      }, 100);\n\n      await timers.runAllTimersAsync();\n      expect(timers.now()).toBe(300);\n      expect(spy).toHaveBeenCalled();\n      expect(spy2).toHaveBeenCalled();\n    });\n  });\n\n  describe('runOnlyPendingTimersAsync', () => {\n    it('should advance the clock to the last scheduled timer', async () => {\n      const global = {\n        Date,\n        Promise,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n      timers.setSystemTime(0);\n\n      const spy = jest.fn();\n      const spy2 = jest.fn();\n      global.setTimeout(spy, 50);\n      global.setTimeout(spy2, 50);\n      global.setTimeout(async () => {\n        await Promise.resolve();\n      }, 100);\n\n      await timers.runOnlyPendingTimersAsync();\n      expect(timers.now()).toBe(100);\n      expect(spy).toHaveBeenCalled();\n      expect(spy2).toHaveBeenCalled();\n    });\n  });\n\n  describe('advanceTimersByTimeAsync', () => {\n    it('should advance the clock', async () => {\n      const global = {\n        Date,\n        Promise,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      const timers = new FakeTimers({config: makeProjectConfig(), global});\n      timers.useFakeTimers();\n\n      const spy = jest.fn();\n      global.setTimeout(async () => {\n        await Promise.resolve();\n        global.setTimeout(spy, 100);\n      }, 100);\n\n      await timers.advanceTimersByTimeAsync(200);\n      expect(spy).toHaveBeenCalled();\n    });\n  });\n\n  describe('now', () => {\n    let timers: FakeTimers;\n    let fakedGlobal: typeof globalThis;\n\n    beforeEach(() => {\n      fakedGlobal = {\n        Date,\n        clearInterval,\n        clearTimeout,\n        process,\n        setInterval,\n        setTimeout,\n      } as unknown as typeof globalThis;\n      timers = new FakeTimers({\n        config: makeProjectConfig(),\n        global: fakedGlobal,\n      });\n    });\n\n    it('returns the current clock', () => {\n      timers.useFakeTimers();\n      timers.setSystemTime(0);\n      fakedGlobal.setTimeout(() => {}, 2);\n      fakedGlobal.setTimeout(() => {}, 100);\n\n      expect(timers.now()).toBe(0);\n\n      // This should run the 2ms timer, and then advance _now by 3ms\n      timers.advanceTimersByTime(5);\n      expect(timers.now()).toBe(5);\n\n      // Advance _now even though there are no timers to run\n      timers.advanceTimersByTime(5);\n      expect(timers.now()).toBe(10);\n\n      // Run up to the 100ms timer\n      timers.runAllTimers();\n      expect(timers.now()).toBe(100);\n\n      // Verify that runOnlyPendingTimers advances now only up to the first\n      // recursive timer\n      fakedGlobal.setTimeout(function infinitelyRecursingCallback() {\n        fakedGlobal.setTimeout(infinitelyRecursingCallback, 20);\n      }, 10);\n      timers.runOnlyPendingTimers();\n      expect(timers.now()).toBe(110);\n\n      // For modern timers, reset() explicitly preserves the clock time\n      timers.reset();\n      expect(timers.now()).toBe(110);\n    });\n\n    it('returns the real time if useFakeTimers is not called', () => {\n      const before = Date.now();\n      const now = timers.now();\n      const after = Date.now();\n      expect(now).toBeGreaterThanOrEqual(before);\n      expect(now).toBeLessThanOrEqual(after);\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`FakeTimers runAllTimers warns when trying to advance timers while real timers are used 1`] = `\"A function to advance timers was called but the timers APIs are not replaced with fake timers. Call \\`jest.useFakeTimers()\\` in this test file or enable fake timers for all tests by setting 'fakeTimers': {'enableGlobally': true} in Jest configuration file.\"`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport modifyPackageJson from '../modifyPackageJson';\n\ntest('should remove jest config if exists', () => {\n  expect(\n    modifyPackageJson({\n      projectPackageJson: {\n        jest: {\n          collectCoverage: true,\n        },\n      },\n      shouldModifyScripts: true,\n    }),\n  ).toMatchSnapshot();\n});\n\ntest('should add test script when there are no scripts', () => {\n  expect(\n    modifyPackageJson({\n      projectPackageJson: {},\n      shouldModifyScripts: true,\n    }),\n  ).toMatchSnapshot();\n});\n\ntest('should add test script when there are scripts', () => {\n  expect(\n    modifyPackageJson({\n      projectPackageJson: {\n        scripts: {\n          lint: 'eslint .',\n          test: 'jasmine',\n        },\n      },\n      shouldModifyScripts: true,\n    }),\n  ).toMatchSnapshot();\n});\n\ntest('should not add test script when { shouldModifyScripts: false }', () => {\n  expect(\n    modifyPackageJson({\n      projectPackageJson: {},\n      shouldModifyScripts: false,\n    }),\n  ).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`should add test script when there are no scripts 1`] = `\n\"{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n\"\n`;\n\nexports[`should add test script when there are scripts 1`] = `\n\"{\n  \"scripts\": {\n    \"lint\": \"eslint .\",\n    \"test\": \"jest\"\n  }\n}\n\"\n`;\n\nexports[`should not add test script when { shouldModifyScripts: false } 1`] = `\n\"{}\n\"\n`;\n\nexports[`should remove jest config if exists 1`] = `\n\"{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jest-environment-jsdom\n */\n\nimport {fn} from 'fake-dual-dep2';\n\ntest('returns correct message', () => {\n  expect(fn()).toBe('from browser');\n});"}
{"prompt":"module.foobar","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// module.foobar"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nexports.isHastePackage = true;"}
{"prompt":"module.jsx","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// module.jsx"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports = 'in_mapped';"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport runJest, {json as runWithJson} from '../runJest';\n\ntest('moduleNameMapper wrong configuration', () => {\n  const {stderr, exitCode} = runJest('module-name-mapper-wrong-config');\n  const {rest} = extractSummary(stderr);\n\n  expect(exitCode).toBe(1);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('moduleNameMapper wrong array configuration', () => {\n  const {stderr, exitCode} = runJest('module-name-mapper-wrong-array-config');\n  const {rest} = extractSummary(stderr);\n\n  expect(exitCode).toBe(1);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('moduleNameMapper correct configuration', () => {\n  const {stderr, exitCode} = runJest('module-name-mapper-correct-config', [], {\n    stripAnsi: true,\n  });\n  const {rest} = extractSummary(stderr);\n\n  expect(exitCode).toBe(0);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('moduleNameMapper correct configuration mocking module of absolute path', () => {\n  const {stderr, exitCode} = runJest(\n    'module-name-mapper-correct-mock-absolute-path',\n    [],\n    {\n      stripAnsi: true,\n    },\n  );\n  const {rest} = extractSummary(stderr);\n\n  expect(exitCode).toBe(0);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('moduleNameMapper with mocking', () => {\n  const {json} = runWithJson('module-name-mapper-mock');\n  expect(json.numTotalTests).toBe(2);\n  expect(json.success).toBe(true);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`moduleNameMapper correct configuration 1`] = `\n\"PASS __tests__/index.js\n  ✓ moduleNameMapping correct configuration\"\n`;\n\nexports[`moduleNameMapper correct configuration mocking module of absolute path 1`] = `\n\"PASS __tests__/index.js\n  ✓ moduleNameMapping correct configuration\"\n`;\n\nexports[`moduleNameMapper wrong array configuration 1`] = `\n\"FAIL __tests__/index.js\n  ● Test suite failed to run\n\n    Configuration error:\n\n    Could not locate module ./style.css mapped as:\n    [\n      \"no-such-module\",\n      \"no-such-module-2\"\n    ].\n\n    Please check your configuration for these entries:\n    {\n      \"moduleNameMapper\": {\n        \"/\\\\.(css|less)$/\": \"[\n          \"no-such-module\",\n          \"no-such-module-2\"\n        ]\"\n      },\n      \"resolver\": undefined\n    }\n\n       8 | 'use strict';\n       9 |\n    > 10 | require('./style.css');\n         | ^\n      11 |\n      12 | module.exports = () => 'test';\n      13 |\n\n      at createNoMappedModuleFoundError (../../packages/jest-resolve/build/index.js:1182:17)\n      at Object.require (index.js:10:1)\n      at Object.require (__tests__/index.js:10:20)\"\n`;\n\nexports[`moduleNameMapper wrong configuration 1`] = `\n\"FAIL __tests__/index.js\n  ● Test suite failed to run\n\n    Configuration error:\n\n    Could not locate module ./style.css mapped as:\n    no-such-module.\n\n    Please check your configuration for these entries:\n    {\n      \"moduleNameMapper\": {\n        \"/\\\\.(css|less)$/\": \"no-such-module\"\n      },\n      \"resolver\": undefined\n    }\n\n       8 | 'use strict';\n       9 |\n    > 10 | require('./style.css');\n         | ^\n      11 |\n      12 | module.exports = () => 'test';\n      13 |\n\n      at createNoMappedModuleFoundError (../../packages/jest-resolve/build/index.js:1182:17)\n      at Object.require (index.js:10:1)\n      at Object.require (__tests__/index.js:10:20)\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('module.parent should be null in test files', () => {\n  const {exitCode} = runJest('module-parent-null-in-test');\n\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nconst RegularModule = require('RegularModule');\n\nRegularModule.setModuleStateValue('Side effect value');\n\nexports.fn = () => '42';"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet state = 1;\n\nexport const set = i => {\n  state = i;\n};\n\nexport const increment = () => {\n  state += 1;\n};\n\nexport const getState = () => state;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nexports.modulePath = 'invalid path';"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nexports.modulePath = 'subdir2/module_dir/module_dir_module.js';"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport slash = require('slash');\nimport runJest from '../runJest';\n\nconst MULTIPLE_CONFIGS_WARNING_TEXT = 'Multiple configurations found';\n\ntest('multiple configs will throw error', () => {\n  const rootDir = slash(path.resolve(__dirname, '../..'));\n  const {exitCode, stderr} = runJest('multiple-configs', [], {\n    skipPkgJsonCheck: true,\n  });\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toContain(MULTIPLE_CONFIGS_WARNING_TEXT);\n\n  const cleanStdErr = stderr.replaceAll(new RegExp(rootDir, 'g'), '<rootDir>');\n  expect(cleanStdErr).toMatchSnapshot();\n});\n\ntest('multiple configs error can be suppressed by using --config', () => {\n  const {exitCode} = runJest(\n    'multiple-configs',\n    ['--config', 'jest.config.json'],\n    {\n      skipPkgJsonCheck: true,\n    },\n  );\n  expect(exitCode).toBe(0);\n});\n\ntest('should works correctly when using different loaders in different projects', () => {\n  const {exitCode, stdout, stderr} = runJest(\n    'multi-project-multiple-configs',\n    ['--projects', 'prj-1', 'prj-2'],\n    {\n      skipPkgJsonCheck: true,\n    },\n  );\n  expect(exitCode).toBe(0);\n  console.log(stdout);\n  console.log(stderr);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`multiple configs will throw error 1`] = `\n\"● Multiple configurations found:\n\n    * <rootDir>/e2e/multiple-configs/jest.config.js\n    * <rootDir>/e2e/multiple-configs/jest.config.json\n    * \\`jest\\` key in <rootDir>/e2e/multiple-configs/package.json\n\n  Implicit config resolution does not allow multiple configuration files.\n  Either remove unused config files or select one explicitly with \\`--config\\`.\n\n  Configuration Documentation:\n  https://jestjs.io/docs/configuration\n\"\n`;"}
{"prompt":"a block,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('a block', () => {\n  beforeEach(() => {});\n  afterEach(() => {});\n  afterAll(() => {});\n  beforeAll(() => {});\n});\n\ndescribe('another block with tests', () => {\n  test('this test prevents us from failing due to zero tests', () => {});\n});"}
{"prompt":"generates a snapshot with correctly transformed dependencies,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport React from 'react';\nimport renderer from 'react-test-renderer';\nimport App from '../src/App';\n\nit('generates a snapshot with correctly transformed dependencies', () => {\n  const tree = renderer.create(<App />).toJSON();\n  expect(tree).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`generates a snapshot with correctly transformed dependencies 1`] = `\n<div\n  className=\"App-root\"\n>\n  <div\n    className=\"App-header\"\n  >\n    <img\n      alt=\"logo\"\n      className=\"App-logo\"\n      src=\"logo.svg\"\n    />\n    <h2>\n      Welcome to React\n    </h2>\n  </div>\n  <p\n    className=\"App-intro\"\n  >\n    To get started, edit \n    <code>\n      src/App.js\n    </code>\n     and save to reload.\n  </p>\n</div>\n`;"}
{"prompt":"make sure different ways of passing projects work exactly the same","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, extractSummary, sortLines, writeFiles} from '../Utils';\nimport runJest, {getConfig} from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'multi-project-runner-test');\n\nconst SAMPLE_FILE_CONTENT = 'module.exports = {};';\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ntest(\"--listTests doesn't duplicate the test files\", () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '{}',\n    '/project1.js': \"module.exports = {rootDir: './', displayName: 'BACKEND'}\",\n    '/project2.js': \"module.exports = {rootDir: './', displayName: 'BACKEND'}\",\n    '__tests__/inBothProjectsTest.js': \"test('test', () => {});\",\n    'package.json': JSON.stringify({\n      jest: {projects: ['<rootDir>/project1.js', '<rootDir>/project2.js']},\n    }),\n  });\n\n  const {stdout} = runJest(DIR, ['--listTests']);\n  expect(stdout.split('\\n')).toHaveLength(1);\n  expect(stdout).toMatch('inBothProjectsTest.js');\n});\n\ntest('can pass projects or global config', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '{}',\n    'base_config.js': `\n      module.exports = {\n        haste: {\n          hasteImplModulePath: '<rootDir>/hasteImpl.js',\n        },\n      };\n    `,\n    'hasteImpl.js': `\n      const path = require('path');\n      module.exports = {\n        getHasteName(filename) {\n          return filename\n            .substr(filename.lastIndexOf(path.sep) + 1)\n            .replace(/\\\\.js$/, '');\n        },\n      };\n    `,\n    'package.json': '{}',\n    'project1/__tests__/file1.test.js': `\n      const file1 = require('file1');\n      test('file1', () => {});\n    `,\n    'project1/file1.js': SAMPLE_FILE_CONTENT,\n    'project1/jest.config.js': `module.exports = {rootDir: './', displayName: 'BACKEND',         haste: {\n              hasteImplModulePath: '<rootDir>/../hasteImpl.js',\n            },}`,\n    'project2/__tests__/file1.test.js': `\n      const file1 = require('file1');\n      test('file1', () => {});\n    `,\n    'project2/file1.js': SAMPLE_FILE_CONTENT,\n    'project2/jest.config.js': `module.exports = {rootDir: './',         haste: {\n              hasteImplModulePath: '<rootDir>/../hasteImpl.js',\n            },}`,\n    'project3/__tests__/file1.test.js': `\n      const file1 = require('file1');\n      test('file1', () => {});\n    `,\n    'project3/file1.js': SAMPLE_FILE_CONTENT,\n    'project3/jest.config.js': `module.exports = {rootDir: './', displayName: 'UI',         haste: {\n              hasteImplModulePath: '<rootDir>/../hasteImpl.js',\n            },}`,\n  });\n  let stderr;\n\n  ({stderr} = runJest(DIR, ['--no-watchman', '--config', 'base_config.js']));\n  expect(stderr).toMatch(\n    'The name `file1` was looked up in the Haste module map. It cannot be resolved, because there exists several different files',\n  );\n\n  expect(extractSummary(stderr).summary).toMatchSnapshot();\n\n  writeFiles(DIR, {\n    'global_config.js': `\n      module.exports = {\n        projects: ['project1/', 'project2/', 'project3/'],\n        haste: {\n          hasteImplModulePath: '<rootDir>/hasteImpl.js',\n        },\n      };\n    `,\n  });\n\n  ({stderr} = runJest(DIR, [\n    '--no-watchman',\n    '-i',\n    '--projects',\n    'project1',\n    'project2',\n    'project3',\n    '--config',\n    'base_config.js',\n  ]));\n\n  const result1 = extractSummary(stderr);\n  expect(result1.summary).toMatchSnapshot();\n  expect(sortLines(result1.rest)).toMatchSnapshot();\n\n  ({stderr} = runJest(DIR, [\n    '--no-watchman',\n    '-i',\n    '--config',\n    'global_config.js',\n  ]));\n  const result2 = extractSummary(stderr);\n\n  expect(result2.summary).toMatchSnapshot();\n  expect(sortLines(result2.rest)).toMatchSnapshot();\n\n  // make sure different ways of passing projects work exactly the same\n  expect(result1.summary).toBe(result2.summary);\n  expect(sortLines(result1.rest)).toBe(sortLines(result2.rest));\n});\n\ntest('\"No tests found\" message for projects', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '{}',\n    'package.json': '{}',\n    'project1/__tests__/file1.test.js': `\n      const file1 = require('../file1');\n      test('file1', () => {});\n    `,\n    'project1/file1.js': SAMPLE_FILE_CONTENT,\n    'project1/jest.config.js': \"module.exports = {rootDir: './'}\",\n    'project2/__tests__/file1.test.js': `\n      const file1 = require('../file1');\n      test('file1', () => {});\n    `,\n    'project2/file1.js': SAMPLE_FILE_CONTENT,\n    'project2/jest.config.js': \"module.exports = {rootDir: './'}\",\n  });\n  const {stdout: verboseOutput} = runJest(DIR, [\n    '--no-watchman',\n    'xyz321',\n    '--verbose',\n    '--projects',\n    'project1',\n    'project2',\n  ]);\n  expect(verboseOutput).toContain('Pattern: xyz321 - 0 matches');\n  const {stdout} = runJest(DIR, [\n    '--no-watchman',\n    'xyz321',\n    '--projects',\n    'project1',\n    'project2',\n  ]);\n  expect(stdout).toContain(\n    '  6 files checked across 2 projects. ' +\n      'Run with `--verbose` for more details.',\n  );\n});\n\ntest.each([{projectPath: 'packages/somepackage'}, {projectPath: 'packages/*'}])(\n  'allows a single non-root project',\n  ({projectPath}: {projectPath: string}) => {\n    writeFiles(DIR, {\n      'package.json': `\n        {\n          \"jest\": {\n            \"testMatch\": [\"<rootDir>/packages/somepackage/test.js\"],\n            \"projects\": [\n              \"${projectPath}\"\n            ]\n          }\n        }\n      `,\n      'packages/somepackage/package.json': `\n        {\n          \"jest\": {\n            \"displayName\": \"somepackage\"\n          }\n        }\n      `,\n      'packages/somepackage/test.js': `\n        test('1+1', () => {\n          expect(1).toBe(1);\n        });\n      `,\n    });\n\n    const {stdout, stderr, exitCode} = runJest(DIR, ['--no-watchman']);\n    expect(stderr).toContain('PASS somepackage packages/somepackage/test.js');\n    expect(stderr).toContain('Test Suites: 1 passed, 1 total');\n    expect(stdout).toBe('');\n    expect(exitCode).toBe(0);\n  },\n);\n\ntest.each([\n  {displayName: 'p1', projectPath: 'packages/p1'},\n  {displayName: 'p2', projectPath: 'packages/p2'},\n])(\n  'correctly runs a single non-root project',\n  ({projectPath, displayName}: {projectPath: string; displayName: string}) => {\n    writeFiles(DIR, {\n      'package.json': `\n        {\n          \"jest\": {\n            \"projects\": [\n              \"${projectPath}\"\n            ]\n          }\n        }\n      `,\n      'packages/p1/package.json': `\n        {\n          \"jest\": {\n            \"displayName\": \"p1\"\n          }\n        }\n      `,\n      'packages/p1/test.js': `\n        test('1+1', () => {\n          expect(1).toBe(1);\n        });\n      `,\n      'packages/p2/package.json': `\n        {\n          \"jest\": {\n            \"displayName\": \"p2\"\n          }\n        }\n      `,\n      'packages/p2/test.js': `\n        test('1+1', () => {\n          expect(1).toBe(1);\n        });\n      `,\n    });\n\n    const {stdout, stderr, exitCode} = runJest(DIR, ['--no-watchman']);\n    expect(stderr).toContain(`PASS ${displayName} ${projectPath}/test.js`);\n    expect(stderr).toContain('Test Suites: 1 passed, 1 total');\n    expect(stdout).toBe('');\n    expect(exitCode).toBe(0);\n  },\n);\n\ntest('projects can be workspaces with non-JS/JSON files', () => {\n  writeFiles(DIR, {\n    'package.json': JSON.stringify({\n      jest: {\n        projects: ['packages/*'],\n      },\n    }),\n    'packages/README.md': '# Packages README',\n    'packages/project1/README.md': '# Project1 README',\n    'packages/project1/__tests__/file1.test.js': `\n    const file1 = require('../file1');\n    test('file1', () => {});\n    `,\n    'packages/project1/file1.js': SAMPLE_FILE_CONTENT,\n    'packages/project1/package.json': '{}',\n    'packages/project2/__tests__/file2.test.js': `\n    const file2 = require('../file2');\n    test('file2', () => {});\n    `,\n    'packages/project2/file2.js': SAMPLE_FILE_CONTENT,\n    'packages/project2/package.json': '{}',\n  });\n\n  const {exitCode, stdout, stderr} = runJest(DIR, ['--no-watchman']);\n\n  expect(stderr).toContain('Test Suites: 2 passed, 2 total');\n  expect(stderr).toContain('PASS packages/project1/__tests__/file1.test.js');\n  expect(stderr).toContain('PASS packages/project2/__tests__/file2.test.js');\n  expect(stderr).toContain('Ran all test suites in 2 projects.');\n  expect(stdout).toBe('');\n  expect(exitCode).toBe(0);\n});\n\ntest('objects in project configuration', () => {\n  writeFiles(DIR, {\n    '__tests__/file1.test.js': `\n      test('foo', () => {});\n    `,\n    '__tests__/file2.test.js': `\n      test('bar', () => {});\n    `,\n    'jest.config.js': `module.exports = {\n      projects: [\n        { testMatch: ['<rootDir>/__tests__/file1.test.js'] },\n        { testMatch: ['<rootDir>/__tests__/file2.test.js'] },\n      ]\n    };`,\n    'package.json': '{}',\n  });\n\n  const {stdout, stderr, exitCode} = runJest(DIR, ['--no-watchman']);\n  expect(stderr).toContain('Test Suites: 2 passed, 2 total');\n  expect(stderr).toContain('PASS __tests__/file1.test.js');\n  expect(stderr).toContain('PASS __tests__/file2.test.js');\n  expect(stderr).toContain('Ran all test suites in 2 projects.');\n  expect(stdout).toBe('');\n  expect(exitCode).toBe(0);\n});\n\ntest('allows a single project', () => {\n  writeFiles(DIR, {\n    '__tests__/file1.test.js': `\n      test('foo', () => {});\n    `,\n    'jest.config.js': `module.exports = {\n      projects: [\n        { testMatch: ['<rootDir>/__tests__/file1.test.js'] },\n      ]\n    };`,\n    'package.json': '{}',\n  });\n\n  const {stdout, stderr, exitCode} = runJest(DIR, ['--no-watchman']);\n  expect(stderr).toContain('PASS __tests__/file1.test.js');\n  expect(stderr).toContain('Test Suites: 1 passed, 1 total');\n  expect(stdout).toBe('');\n  expect(exitCode).toBe(0);\n});\n\ntest('resolves projects and their <rootDir> properly', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '{}',\n    'package.json': JSON.stringify({\n      jest: {\n        projects: [\n          'project1.conf.json',\n          '<rootDir>/project2/project2.conf.json',\n        ],\n      },\n    }),\n    'project1.conf.json': JSON.stringify({\n      id: 'project1',\n      rootDir: './project1',\n      // root dir should be this project's directory\n      setupFiles: ['<rootDir>/project1_setup.js'],\n      testEnvironment: 'node',\n    }),\n    'project1/__tests__/test.test.js':\n      \"test('project1', () => expect(globalThis.project1).toBe(true))\",\n    'project1/project1_setup.js': 'global.project1 = true;',\n    'project2/__tests__/test.test.js':\n      \"test('project2', () => expect(globalThis.project2).toBe(true))\",\n    'project2/project2.conf.json': JSON.stringify({\n      id: 'project2',\n      rootDir: '../', // root dir is set to the top level\n      setupFiles: ['<rootDir>/project2/project2_setup.js'], // rootDir should be of the\n      testEnvironment: 'node',\n      testPathIgnorePatterns: ['project1'],\n    }),\n    'project2/project2_setup.js': 'global.project2 = true;',\n  });\n\n  let stderr;\n  ({stderr} = runJest(DIR, ['--no-watchman']));\n\n  expect(stderr).toMatch('Ran all test suites in 2 projects.');\n  expect(stderr).toMatch('PASS project1/__tests__/test.test.js');\n  expect(stderr).toMatch('PASS project2/__tests__/test.test.js');\n\n  // Use globs\n  writeFiles(DIR, {\n    'dir1/random_file': '',\n    'dir2/random_file': '',\n    'package.json': JSON.stringify({\n      jest: {\n        projects: ['**/*.conf.json'],\n      },\n    }),\n  });\n\n  ({stderr} = runJest(DIR, ['--no-watchman']));\n  expect(stderr).toMatch('Ran all test suites in 2 projects.');\n  expect(stderr).toMatch('PASS project1/__tests__/test.test.js');\n  expect(stderr).toMatch('PASS project2/__tests__/test.test.js');\n\n  // Include two projects that will resolve to the same config\n  writeFiles(DIR, {\n    'dir1/random_file': '',\n    'dir2/random_file': '',\n    'package.json': JSON.stringify({\n      jest: {\n        projects: [\n          'dir1',\n          'dir2',\n          'project1.conf.json',\n          '<rootDir>/project2/project2.conf.json',\n        ],\n      },\n    }),\n  });\n\n  ({stderr} = runJest(DIR, ['--no-watchman']));\n  expect(stderr).toMatch(\n    /Whoops! Two projects resolved to the same config path/,\n  );\n  expect(stderr).toMatch(`${path.join(DIR, 'package.json')}`);\n  expect(stderr).toMatch(/Project 1|2: dir1/);\n  expect(stderr).toMatch(/Project 1|2: dir2/);\n\n  // project with a directory/file that does not exist\n  writeFiles(DIR, {\n    'package.json': JSON.stringify({\n      jest: {\n        projects: [\n          'banana',\n          'project1.conf.json',\n          '<rootDir>/project2/project2.conf.json',\n        ],\n      },\n    }),\n  });\n\n  ({stderr} = runJest(DIR, ['--no-watchman']));\n  expect(stderr).toMatch(\n    \"Can't find a root directory while resolving a config file path.\",\n  );\n  expect(stderr).toMatch(/banana/);\n});\n\ntest('Does transform files with the corresponding project transformer', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '{}',\n    'file.js': SAMPLE_FILE_CONTENT,\n    'package.json': '{}',\n    'project1/__tests__/project1.test.js': `\n      const file = require('../../file.js');\n      test('file', () => expect(file).toBe('PROJECT1'));\n    `,\n    'project1/jest.config.js': `\n      module.exports = {\n        rootDir: './',\n        transform: {'file\\\\.js': './transformer.js'},\n      };`,\n    'project1/transformer.js': `\n      module.exports = {\n        process: () => ({code: 'module.exports = \"PROJECT1\";'}),\n        getCacheKey: () => 'PROJECT1_CACHE_KEY',\n      }\n    `,\n    'project2/__tests__/project2.test.js': `\n      const file = require('../../file.js');\n      test('file', () => expect(file).toBe('PROJECT2'));\n    `,\n    'project2/jest.config.js': `\n      module.exports = {\n        rootDir: './',\n        transform: {'file\\\\.js': './transformer.js'},\n      };`,\n    'project2/transformer.js': `\n      module.exports = {\n        process: () => ({code: 'module.exports = \"PROJECT2\";'}),\n        getCacheKey: () => 'PROJECT2_CACHE_KEY',\n      }\n    `,\n  });\n\n  const {stderr} = runJest(DIR, [\n    '--no-watchman',\n    '-i',\n    '--projects',\n    'project1',\n    'project2',\n  ]);\n\n  expect(stderr).toMatch('Ran all test suites in 2 projects.');\n  expect(stderr).toMatch('PASS project1/__tests__/project1.test.js');\n  expect(stderr).toMatch('PASS project2/__tests__/project2.test.js');\n});\n\ndescribe(\"doesn't bleed module file extensions resolution with multiple workers\", () => {\n  test('external config files', () => {\n    writeFiles(DIR, {\n      '.watchmanconfig': '{}',\n      'file.js': 'module.exports = \"file1\"',\n      'file.p2.js': 'module.exports = \"file2\"',\n      'package.json': '{}',\n      'project1/__tests__/project1.test.js': `\n      const file = require('../../file');\n      test('file 1', () => expect(file).toBe('file1'));\n    `,\n      'project1/jest.config.js': `\n      module.exports = {\n        rootDir: '..',\n      };`,\n      'project2/__tests__/project2.test.js': `\n      const file = require('../../file');\n      test('file 2', () => expect(file).toBe('file2'));\n    `,\n      'project2/jest.config.js': `\n      module.exports = {\n        rootDir: '..',\n        moduleFileExtensions: ['p2.js', 'js']\n      };`,\n    });\n\n    const {configs} = getConfig(DIR, ['--projects', 'project1', 'project2']);\n\n    expect(configs).toHaveLength(2);\n\n    const [{id: id1}, {id: id2}] = configs;\n\n    expect(id1).toEqual(expect.any(String));\n    expect(id2).toEqual(expect.any(String));\n    expect(id1).toHaveLength(32);\n    expect(id2).toHaveLength(32);\n    expect(id1).not.toEqual(id2);\n\n    const {stderr} = runJest(DIR, [\n      '--no-watchman',\n      '-w=2',\n      '--projects',\n      'project1',\n      'project2',\n    ]);\n\n    expect(stderr).toMatch('Ran all test suites in 2 projects.');\n    expect(stderr).toMatch('PASS project1/__tests__/project1.test.js');\n    expect(stderr).toMatch('PASS project2/__tests__/project2.test.js');\n  });\n\n  test('inline config files', () => {\n    writeFiles(DIR, {\n      '.watchmanconfig': '{}',\n      'file.js': 'module.exports = \"file1\"',\n      'file.p2.js': 'module.exports = \"file2\"',\n      'package.json': JSON.stringify({\n        jest: {projects: [{}, {moduleFileExtensions: ['p2.js', 'js']}]},\n      }),\n      'project1/__tests__/project1.test.js': `\n      const file = require('../../file');\n      test('file 1', () => expect(file).toBe('file1'));\n    `,\n      'project2/__tests__/project2.test.js': `\n      const file = require('../../file');\n      test('file 2', () => expect(file).toBe('file2'));\n    `,\n    });\n\n    const {configs} = getConfig(DIR);\n\n    expect(configs).toHaveLength(2);\n\n    const [{id: id1}, {id: id2}] = configs;\n\n    expect(id1).toEqual(expect.any(String));\n    expect(id2).toEqual(expect.any(String));\n    expect(id1).toHaveLength(32);\n    expect(id2).toHaveLength(32);\n    expect(id1).not.toEqual(id2);\n\n    const {stderr} = runJest(DIR, ['--no-watchman', '-w=2']);\n\n    expect(stderr).toMatch('Ran all test suites in 2 projects.');\n    expect(stderr).toMatch('PASS project1/__tests__/project1.test.js');\n    expect(stderr).toMatch('PASS project2/__tests__/project2.test.js');\n  });\n});\n\ndescribe('Babel config in individual project works in multi-project', () => {\n  it('Prj-1 works individually', () => {\n    const result = runJest('multi-project-babel/prj-1');\n    expect(result.stderr).toMatch('PASS ./index.test.js');\n    expect(result.exitCode).toBe(0);\n  });\n  it('Prj-2 works individually', () => {\n    const result = runJest('multi-project-babel/prj-2');\n    expect(result.stderr).toMatch('PASS ./index.test.js');\n    expect(result.exitCode).toBe(0);\n  });\n  it('Prj-3 works individually', () => {\n    const result = runJest('multi-project-babel/prj-3');\n    expect(result.stderr).toMatch('PASS src/index.test.js');\n    expect(result.exitCode).toBe(0);\n  });\n  it('Prj-4 works individually', () => {\n    const result = runJest('multi-project-babel/prj-4');\n    expect(result.stderr).toMatch('PASS src/index.test.js');\n    expect(result.exitCode).toBe(0);\n  });\n  it('Prj-5 works individually', () => {\n    const result = runJest('multi-project-babel/prj-5');\n    expect(result.stderr).toMatch('PASS src/index.test.js');\n    expect(result.exitCode).toBe(0);\n  });\n  it('All project work when running from multiproject', () => {\n    const result = runJest('multi-project-babel');\n    expect(result.stderr).toMatch('PASS prj-1/index.test.js');\n    expect(result.stderr).toMatch('PASS prj-2/index.test.js');\n    expect(result.stderr).toMatch('PASS prj-3/src/index.test.js');\n    expect(result.stderr).toMatch('PASS prj-4/src/index.test.js');\n    expect(result.stderr).toMatch('PASS prj-5/src/index.test.js');\n    expect(result.stderr).toMatch('PASS prj-3/src/index.test.js');\n    expect(result.exitCode).toBe(0);\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`can pass projects or global config 1`] = `\n\"Test Suites: 3 failed, 3 total\nTests:       0 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`can pass projects or global config 2`] = `\n\"Test Suites: 3 passed, 3 total\nTests:       3 passed, 3 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites in 3 projects.\"\n`;\n\nexports[`can pass projects or global config 3`] = `\n\"PASS BACKEND project1/__tests__/file1.test.js\nPASS UI project3/__tests__/file1.test.js\nPASS project2/__tests__/file1.test.js\"\n`;\n\nexports[`can pass projects or global config 4`] = `\n\"Test Suites: 3 passed, 3 total\nTests:       3 passed, 3 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites in 3 projects.\"\n`;\n\nexports[`can pass projects or global config 5`] = `\n\"PASS BACKEND project1/__tests__/file1.test.js\nPASS UI project3/__tests__/file1.test.js\nPASS project2/__tests__/file1.test.js\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nexports.modulePath = 'subdir2/__mocks__/my_module.js';"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {Constants} from '../coreReexport.js';\n\ntest('can reexport core CJS requires', () => {\n  expect(Constants).toHaveProperty('TLS1_VERSION');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {Constants} from '../deepReexport.js';\n\ntest('can reexport deep CJS requires', () => {\n  expect(Constants).toHaveProperty('NonSystemMessageTypes');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport json from '../package.json' assert {type: 'json'};\n\ntest('supports static import', () => {\n  expect(json).toHaveProperty('jest.testEnvironment', 'node');\n});\n\ntest('supports dynamic import', async () => {\n  const {default: json} = await import('../package.json', {\n    assert: {type: 'json'},\n  });\n  expect(json).toHaveProperty('jest.testEnvironment', 'node');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport json from '../package.json';\n\ntest('supports static import', () => {\n  expect(json).toHaveProperty('jest.testEnvironment', 'node');\n});\n\ntest('supports dynamic import', async () => {\n  const {default: json} = await import('../package.json');\n  expect(json).toHaveProperty('jest.testEnvironment', 'node');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {jest as jestObject} from '@jest/globals';\n\nafterEach(() => {\n  jestObject.resetModules();\n});\n\ntest('can mock module', async () => {\n  jestObject.unstable_mockModule('../mockedModule.mjs', () => ({foo: 'bar'}), {\n    virtual: true,\n  });\n\n  const importedMock = await import('../mockedModule.mjs');\n\n  expect(Object.keys(importedMock)).toEqual(['foo']);\n  expect(importedMock.foo).toBe('bar');\n});\n\ntest('can mock transitive module', async () => {\n  jestObject.unstable_mockModule('../index.js', () => ({foo: 'bar'}));\n\n  const importedMock = await import('../reexport.js');\n\n  expect(Object.keys(importedMock)).toEqual(['foo']);\n  expect(importedMock.foo).toBe('bar');\n});\n\ntest('can unmock module', async () => {\n  jestObject.unstable_mockModule('../index.js', () => ({\n    double: () => 1000,\n  }));\n\n  const importedMock = await import('../index.js');\n  expect(importedMock.double()).toBe(1000);\n\n  jestObject.unstable_unmockModule('../index.js');\n\n  const importedMockAfterUnmock = await import('../index.js');\n  expect(importedMockAfterUnmock.double(2)).toBe(4);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport ivm from 'isolated-vm';\n\ntest('supports native modules exported via CJS', () => {\n  expect(ivm).toBeDefined();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst value = await Promise.resolve('hello!');\n\ntest('supports top level await', () => {\n  expect(value).toBe('hello!');\n});"}
{"prompt":"file origin: https://ghub.com/mdn/webassembly-examples/blob/2f2163287f86fe29deb162335bccca7d5d95ca4f/understanding-text-format/add.wasm","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {readFileSync} from 'node:fs';\nimport {jest} from '@jest/globals';\n// file origin: https://github.com/mdn/webassembly-examples/blob/2f2163287f86fe29deb162335bccca7d5d95ca4f/understanding-text-format/add.wasm\n// source code: https://github.com/mdn/webassembly-examples/blob/2f2163287f86fe29deb162335bccca7d5d95ca4f/understanding-text-format/add.was\nimport {add} from '../add.wasm';\n\nconst wasmFileBuffer = readFileSync('add.wasm');\n\ntest('supports native wasm imports', () => {\n  expect(add(1, 2)).toBe(3);\n\n  // because arguments are i32 (signed), fractional part is truncated\n  expect(add(0.99, 1.01)).toBe(1);\n\n  // because return value is i32 (signed), (2^31 - 1) + 1 overflows and becomes -2^31\n  expect(add(Math.pow(2, 31) - 1, 1)).toBe(-Math.pow(2, 31));\n\n  // invalid or missing arguments are treated as 0\n  expect(add('hello', 'world')).toBe(0);\n  expect(add()).toBe(0);\n  expect(add(null)).toBe(0);\n  expect(add({}, [])).toBe(0);\n\n  // redundant arguments are silently ignored\n  expect(add(1, 2, 3)).toBe(3);\n});\n\ntest('supports dynamic wasm imports', async () => {\n  const {add: dynamicAdd} = await import('../add.wasm');\n  expect(dynamicAdd(1, 2)).toBe(3);\n});\n\ntest('supports imports from \"data:application/wasm\" URI with base64 encoding', async () => {\n  const importedWasmModule = await import(\n    `data:application/wasm;base64,${wasmFileBuffer.toString('base64')}`\n  );\n  expect(importedWasmModule.add(0, 42)).toBe(42);\n});\n\ntest('imports from \"data:application/wasm\" URI without explicit encoding fail', async () => {\n  await expect(\n    () => import(`data:application/wasm,${wasmFileBuffer.toString('base64')}`),\n  ).rejects.toThrow('Missing data URI encoding');\n});\n\ntest('imports from \"data:application/wasm\" URI with invalid encoding fail', async () => {\n  await expect(\n    () => import('data:application/wasm;charset=utf-8,oops'),\n  ).rejects.toThrow('Invalid data URI encoding: charset=utf-8');\n});\n\ntest('supports wasm files that import js resources (wasm-bindgen)', async () => {\n  globalThis.alert = jest.fn();\n\n  const {greet} = await import('../wasm-bindgen/index.js');\n  greet('World');\n\n  expect(globalThis.alert).toHaveBeenCalledWith('Hello, World!');\n});"}
{"prompt":"the point here is that s the node core module","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport dns from 'dns';\n// the point here is that it's the node core module\n// eslint-disable-next-line no-restricted-imports\nimport {readFileSync} from 'fs';\nimport {createRequire} from 'module';\nimport prefixDns from 'node:dns';\nimport {dirname, resolve} from 'path';\nimport {fileURLToPath} from 'url';\nimport {jest as jestObject} from '@jest/globals';\nimport staticImportedStatefulFromCjs from '../fromCjs.mjs';\nimport {double} from '../index';\nimport defaultFromCjs, {half, namedFunction} from '../namedExport.cjs';\nimport {bag} from '../namespaceExport.js';\n/* eslint-disable import/no-duplicates */\nimport staticImportedStateful from '../stateful.mjs';\nimport staticImportedStatefulWithQuery from '../stateful.mjs?query=1';\nimport staticImportedStatefulWithAnotherQuery from '../stateful.mjs?query=2';\n/* eslint-enable */\n\ntest('should have correct import.meta', () => {\n  expect(typeof require).toBe('undefined');\n  expect(typeof jest).toBe('undefined');\n  expect(import.meta).toEqual({\n    dirname: expect.any(String),\n    filename: expect.any(String),\n    jest: expect.anything(),\n    resolve: expect.any(Function),\n    url: expect.any(String),\n  });\n  expect(import.meta.jest).toBe(jestObject);\n  expect(\n    import.meta.url.endsWith('/e2e/native-esm/__tests__/native-esm.test.js'),\n  ).toBe(true);\n  if (process.platform === 'win32') {\n    expect(\n      import.meta.filename.endsWith(\n        '\\\\e2e\\\\native-esm\\\\__tests__\\\\native-esm.test.js',\n      ),\n    ).toBe(true);\n    expect(import.meta.dirname.endsWith('\\\\e2e\\\\native-esm\\\\__tests__')).toBe(\n      true,\n    );\n  } else {\n    expect(\n      import.meta.filename.endsWith(\n        '/e2e/native-esm/__tests__/native-esm.test.js',\n      ),\n    ).toBe(true);\n    expect(import.meta.dirname.endsWith('/e2e/native-esm/__tests__')).toBe(\n      true,\n    );\n  }\n  expect(\n    import.meta\n      .resolve('colors')\n      .endsWith('jest/e2e/native-esm/node_modules/colors/lib/index.js'),\n  ).toBe(true);\n  expect(\n    import.meta\n      .resolve('./native-esm.test')\n      .endsWith('jest/e2e/native-esm/__tests__/native-esm.test.js'),\n  ).toBe(true);\n});\n\ntest('should double stuff', () => {\n  expect(double(1)).toBe(2);\n});\n\ntest('should support importing node core modules', () => {\n  const dir = dirname(fileURLToPath(import.meta.url));\n  const packageJsonPath = resolve(dir, '../package.json');\n\n  expect(JSON.parse(readFileSync(packageJsonPath, 'utf8'))).toEqual({\n    devDependencies: {\n      colors: '^1.4.0',\n      'discord.js': '14.3.0',\n      'iso-constants': '^0.1.2',\n      yargs: '^17.5.1',\n    },\n    jest: {\n      testEnvironment: 'node',\n      transform: {},\n    },\n    optionalDependencies: {\n      'isolated-vm': '^4.6.0',\n    },\n    type: 'module',\n  });\n});\n\ntest('should support importing node core modules dynamically', async () => {\n  // it's important that this module has _not_ been imported at the top level\n  const assert = await import('assert');\n\n  expect(typeof assert.strictEqual).toBe('function');\n});\n\ntest('dynamic import should work', async () => {\n  const {double: importedDouble} = await import('../index');\n\n  expect(importedDouble).toBe(double);\n  expect(importedDouble(1)).toBe(2);\n});\n\ntest('import cjs', async () => {\n  const {default: half} = await import('../commonjs.cjs');\n\n  expect(half(4)).toBe(2);\n});\n\ntest('import esm from cjs', async () => {\n  const {default: halfPromise} = await import('../fromEsm.cjs');\n  expect(await halfPromise(1)).toBe(2);\n});\n\ntest('require(cjs) and import(cjs) should share caches', async () => {\n  const require = createRequire(import.meta.url);\n\n  const {default: importedStateful} = await import('../stateful.cjs');\n  const requiredStateful = require('../stateful.cjs');\n\n  expect(importedStateful()).toBe(1);\n  expect(importedStateful()).toBe(2);\n  expect(requiredStateful()).toBe(3);\n  expect(importedStateful()).toBe(4);\n  expect(requiredStateful()).toBe(5);\n  expect(requiredStateful()).toBe(6);\n});\n\ntest('import from mjs and import(mjs) should share caches', async () => {\n  const {default: importedStateful} = await import('../stateful.mjs');\n\n  expect(importedStateful()).toBe(1);\n  expect(importedStateful()).toBe(2);\n  expect(staticImportedStateful()).toBe(3);\n  expect(importedStateful()).toBe(4);\n  expect(staticImportedStateful()).toBe(5);\n  expect(staticImportedStateful()).toBe(6);\n});\n\ntest('import cjs via import statement', () => {\n  expect(staticImportedStatefulFromCjs(4)).toBe(2);\n});\n\ntest('handle unlinked dynamic imports', async () => {\n  const {double: deepDouble} = await import('../dynamicImport');\n\n  expect(deepDouble).toBe(double);\n\n  expect(deepDouble(4)).toBe(8);\n});\n\ntest('can import `jest` object', () => {\n  expect(jestObject).toBeDefined();\n});\n\ntest('handle dynamic imports of the same module in parallel', async () => {\n  const [{double: first}, {double: second}] = await Promise.all([\n    import('../anotherDynamicImport.js'),\n    import('../anotherDynamicImport.js'),\n  ]);\n\n  expect(first).toBe(second);\n  expect(first(2)).toBe(4);\n});\n\ntest('varies module cache by query', () => {\n  expect(staticImportedStatefulWithQuery).not.toBe(\n    staticImportedStatefulWithAnotherQuery,\n  );\n\n  expect(staticImportedStatefulWithQuery()).toBe(1);\n  expect(staticImportedStatefulWithQuery()).toBe(2);\n  expect(staticImportedStatefulWithAnotherQuery()).toBe(1);\n  expect(staticImportedStatefulWithQuery()).toBe(3);\n  expect(staticImportedStatefulWithAnotherQuery()).toBe(2);\n  expect(staticImportedStatefulWithAnotherQuery()).toBe(3);\n});\n\ntest('supports named imports from CJS', () => {\n  expect(half(4)).toBe(2);\n  expect(namedFunction()).toBe('hello from a named CJS function!');\n  expect(defaultFromCjs.default()).toBe('\"default\" export');\n\n  expect(Object.keys(defaultFromCjs)).toEqual([\n    'half',\n    'namedFunction',\n    'default',\n  ]);\n});\n\ntest('supports file urls as imports', async () => {\n  const dynamic = await import(new URL('../stateful.mjs', import.meta.url));\n\n  expect(dynamic.default).toBe(staticImportedStateful);\n});\n\ntest('namespace export', () => {\n  expect(bag.double).toBe(double);\n});\n\ntest('handle circular dependency', async () => {\n  const moduleA = (await import('../circularDependentA.mjs')).default;\n  expect(moduleA.id).toBe('circularDependentA');\n  expect(moduleA.moduleB.id).toBe('circularDependentB');\n  expect(moduleA.moduleB.moduleA).toBe(moduleA);\n});\n\ntest('require of ESM should throw correct error', () => {\n  const require = createRequire(import.meta.url);\n\n  expect(() => require('../fromCjs.mjs')).toThrow(\n    expect.objectContaining({\n      code: 'ERR_REQUIRE_ESM',\n      message: expect.stringContaining('Must use import to load ES Module'),\n    }),\n  );\n});\n\ntest('supports imports using \"node:\" prefix', () => {\n  expect(dns).toBe(prefixDns);\n});\n\ntest('supports imports from \"data:text/javascript\" URI with charset=utf-8 encoding', async () => {\n  const code = 'export const something = \"some value\"';\n  const importedEncoded = await import(\n    `data:text/javascript;charset=utf-8,${encodeURIComponent(code)}`\n  );\n  expect(importedEncoded.something).toBe('some value');\n});\n\ntest('supports imports from \"data:text/javascript\" URI with base64 encoding', async () => {\n  const code = 'export const something = \"some value\"';\n  const importedBase64 = await import(\n    `data:text/javascript;base64,${Buffer.from(code).toString('base64')}`\n  );\n  expect(importedBase64.something).toBe('some value');\n});\n\ntest('supports imports from \"data:text/javascript\" URI without explicit encoding', async () => {\n  const code = 'export const something = \"some value\"';\n  const importedEncoded = await import(\n    `data:text/javascript,${encodeURIComponent(code)}`\n  );\n  expect(importedEncoded.something).toBe('some value');\n});\n\ntest('imports from \"data:text/javascript\" URI with invalid encoding fail', async () => {\n  const code = 'export const something = \"some value\"';\n  await expect(\n    () =>\n      import(\n        `data:text/javascript;charset=badEncoding,${encodeURIComponent(code)}`\n      ),\n  ).rejects.toThrow('Invalid data URI');\n});\n\ntest('imports from \"data:\" URI with invalid mime type fail', async () => {\n  const code = 'export const something = \"some value\"';\n  await expect(\n    () => import(`data:something/else,${encodeURIComponent(code)}`),\n  ).rejects.toThrow('Invalid data URI');\n});\n\ntest('imports from \"data:text/javascript\" URI with invalid data fail', async () => {\n  await expect(\n    () => import('data:text/javascript;charset=utf-8,so(me)+.-gibberish'),\n  ).rejects.toThrow(\"Unexpected token '.'\");\n});\n\ntest('supports imports from \"data:application/json\" URI', async () => {\n  const data = await import('data:application/json,{\"foo\": \"bar\"}');\n  expect(data.default).toEqual({foo: 'bar'});\n});\n\ntest('supports static \"data:\" URI import', async () => {\n  const module = await import('../staticDataImport.js');\n  expect(module.value()).toEqual({bar: {obj: 456}, foo: '123'});\n});\n\ntest('imports from \"data:\" URI is properly cached', async () => {\n  const code =\n    'export const wrapper = {value: 123}\\nexport const set = (value) => wrapper.value = value';\n  const data1 = await import(\n    `data:text/javascript;charset=utf-8,${encodeURIComponent(code)}`\n  );\n  expect(data1.wrapper.value).toBe(123);\n  data1.set(234);\n  expect(data1.wrapper.value).toBe(234);\n  const data2 = await import(\n    `data:text/javascript;base64,${Buffer.from(code).toString('base64')}`\n  );\n  expect(data2.wrapper.value).toBe(123);\n  const data3 = await import(\n    `data:text/javascript;charset=utf-8,${encodeURIComponent(code)}`\n  );\n  expect(data3.wrapper.value).toBe(234);\n});\n\ntest('can mock \"data:\" URI module', async () => {\n  const code = 'export const something = \"some value\"';\n  const dataModule = `data:text/javascript;base64,${Buffer.from(code).toString(\n    'base64',\n  )}`;\n  jestObject.unstable_mockModule(dataModule, () => ({foo: 'bar'}), {\n    virtual: true,\n  });\n  const mocked = await import(dataModule);\n  expect(mocked.foo).toBe('bar');\n});\n\ntest('can import with module reset', async () => {\n  const {default: yargs} = await import('yargs');\n  const {default: yargsAgain} = await import('yargs');\n\n  expect(yargs).toBe(yargsAgain);\n\n  let args = yargs().parse([]);\n\n  expect(args._).toEqual([]);\n\n  jestObject.resetModules();\n\n  const {default: yargsYetAgain} = await import('yargs');\n\n  expect(yargs).not.toBe(yargsYetAgain);\n\n  args = yargsYetAgain().parse([]);\n\n  expect(args._).toEqual([]);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\njest.mock('../Native');\n\nconst native = require('../Native');\n\ntest('mock works with native async', () => {\n  expect(native.asyncMethod).toBeDefined();\n});"}
{"prompt":"--no-cache because babel can cache stuff and result in false green","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nconst dir = path.resolve(__dirname, '..', 'native-async-mock');\n\ntest('mocks async functions', () => {\n  // --no-cache because babel can cache stuff and result in false green\n  const {stderr} = runJest(dir, ['--no-cache']);\n  expect(extractSummary(stderr).summary).toMatch(\n    'Test Suites: 1 passed, 1 total',\n  );\n});"}
{"prompt":"for unknown reason the runs test wh native ESM test occasionally ends up","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {createRequire} from 'module';\nimport {resolve} from 'path';\nimport {isNativeError} from 'util/types';\nimport {onNodeVersions} from '@jest/test-utils';\nimport {extractSummary, runYarnInstall} from '../Utils';\nimport runJest, {getConfig} from '../runJest';\n\n// for unknown reason the \"runs test with native ESM\" test occasionally ends up\n// with process being killed with SIGSEGV (Segmentation fault) signal\njest.retryTimes(3);\n\nconst DIR = resolve(__dirname, '../native-esm');\n\nlet isolatedVmInstalled = false;\n\nbeforeAll(() => {\n  runYarnInstall(DIR);\n\n  const require = createRequire(`${DIR}/index.js`);\n\n  try {\n    const ivm = require('isolated-vm');\n    isolatedVmInstalled = ivm != null;\n  } catch (error) {\n    if (\n      isNativeError(error) &&\n      (error as NodeJS.ErrnoException).code === 'MODULE_NOT_FOUND'\n    ) {\n      console.warn('`isolated-vm` is not installed, skipping its test');\n    } else {\n      throw error;\n    }\n  }\n});\n\ntest('test config is without transform', () => {\n  const {configs} = getConfig(DIR);\n\n  expect(configs).toHaveLength(1);\n  expect(configs[0].transform).toEqual([]);\n});\n\ntest('runs test with native ESM', () => {\n  const {exitCode, stderr, stdout} = runJest(DIR, ['native-esm.test.js'], {\n    nodeOptions: '--experimental-vm-modules --no-warnings',\n  });\n\n  const {summary} = extractSummary(stderr);\n\n  expect(summary).toMatchSnapshot();\n  expect(stdout).toBe('');\n  expect(exitCode).toBe(0);\n});\n\ntest('runs test with native mock ESM', () => {\n  const {exitCode, stderr, stdout} = runJest(\n    DIR,\n    ['native-esm-mocks.test.js'],\n    {\n      nodeOptions: '--experimental-vm-modules --no-warnings',\n    },\n  );\n\n  const {summary} = extractSummary(stderr);\n\n  expect(summary).toMatchSnapshot();\n  expect(stdout).toBe('');\n  expect(exitCode).toBe(0);\n});\n\ntest('supports top-level await', () => {\n  const {exitCode, stderr, stdout} = runJest(DIR, ['native-esm.tla.test.js'], {\n    nodeOptions: '--experimental-vm-modules --no-warnings',\n  });\n\n  const {summary} = extractSummary(stderr);\n\n  expect(summary).toMatchSnapshot();\n  expect(stdout).toBe('');\n  expect(exitCode).toBe(0);\n});\n\n// minimum version supported by discord.js is 16.9, but they use syntax from 16.11\nonNodeVersions('>=16.11.0', () => {\n  test('support re-exports from CJS of dual packages', () => {\n    const {exitCode, stderr, stdout} = runJest(\n      DIR,\n      ['native-esm-deep-cjs-reexport.test.js'],\n      {nodeOptions: '--experimental-vm-modules --no-warnings'},\n    );\n\n    const {summary} = extractSummary(stderr);\n\n    expect(summary).toMatchSnapshot();\n    expect(stdout).toBe('');\n    expect(exitCode).toBe(0);\n  });\n});\n\ntest('support re-exports from CJS of core module', () => {\n  const {exitCode, stderr, stdout} = runJest(\n    DIR,\n    ['native-esm-core-cjs-reexport.test.js'],\n    {nodeOptions: '--experimental-vm-modules --no-warnings'},\n  );\n\n  const {summary} = extractSummary(stderr);\n\n  expect(summary).toMatchSnapshot();\n  expect(stdout).toBe('');\n  expect(exitCode).toBe(0);\n});\n\ntest('runs WebAssembly (Wasm) test with native ESM', () => {\n  const {exitCode, stderr, stdout} = runJest(DIR, ['native-esm-wasm.test.js'], {\n    nodeOptions: '--experimental-vm-modules --no-warnings',\n  });\n\n  const {summary} = extractSummary(stderr);\n\n  expect(summary).toMatchSnapshot();\n  expect(stdout).toBe('');\n  expect(exitCode).toBe(0);\n});\n\ntest('does not enforce import assertions', () => {\n  const {exitCode, stderr, stdout} = runJest(\n    DIR,\n    ['native-esm-missing-import-assertions.test.js'],\n    {nodeOptions: '--experimental-vm-modules --no-warnings'},\n  );\n\n  const {summary} = extractSummary(stderr);\n\n  expect(summary).toMatchSnapshot();\n  expect(stdout).toBe('');\n  expect(exitCode).toBe(0);\n});\n\n(isolatedVmInstalled ? test : test.skip)(\n  'properly handle re-exported native modules in ESM via CJS',\n  () => {\n    const {exitCode, stderr, stdout} = runJest(\n      DIR,\n      ['native-esm-native-module.test.js'],\n      {nodeOptions: '--experimental-vm-modules --no-warnings'},\n    );\n\n    const {summary} = extractSummary(stderr);\n\n    expect(summary).toMatchSnapshot();\n    expect(stdout).toBe('');\n    expect(exitCode).toBe(0);\n  },\n);\n\n// support for import assertions in dynamic imports was added in Node.js 16.12.0\n// support for import assertions was removed in Node.js 22.0.0\nonNodeVersions('>=16.12.0 <22.0.0', () => {\n  test('supports import assertions', () => {\n    const {exitCode, stderr, stdout} = runJest(\n      DIR,\n      ['native-esm-import-assertions.test.js'],\n      {nodeOptions: '--experimental-vm-modules --no-warnings'},\n    );\n\n    const {summary} = extractSummary(stderr);\n\n    expect(summary).toMatchSnapshot();\n    expect(stdout).toBe('');\n    expect(exitCode).toBe(0);\n  });\n});\n\nonNodeVersions('<16.12.0 || >=22.0.0', () => {\n  test('syntax error for import assertions', () => {\n    const {exitCode, stderr, stdout} = runJest(\n      DIR,\n      ['native-esm-import-assertions.test.js'],\n      {nodeOptions: '--experimental-vm-modules --no-warnings'},\n    );\n\n    const {rest} = extractSummary(stderr);\n\n    expect(rest).toContain('SyntaxError: Unexpected identifier');\n    expect(stdout).toBe('');\n    expect(exitCode).toBe(1);\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`does not enforce import assertions 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching native-esm-missing-import-assertions.test.js.\"\n`;\n\nexports[`on node >=16.11.0 support re-exports from CJS of dual packages 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching native-esm-deep-cjs-reexport.test.js.\"\n`;\n\nexports[`on node >=16.12.0 <22.0.0 supports import assertions 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching native-esm-import-assertions.test.js.\"\n`;\n\nexports[`properly handle re-exported native modules in ESM via CJS 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching native-esm-native-module.test.js.\"\n`;\n\nexports[`runs WebAssembly (Wasm) test with native ESM 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       6 passed, 6 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching native-esm-wasm.test.js.\"\n`;\n\nexports[`runs test with native ESM 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       31 passed, 31 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching native-esm.test.js.\"\n`;\n\nexports[`runs test with native mock ESM 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       3 passed, 3 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching native-esm-mocks.test.js.\"\n`;\n\nexports[`support re-exports from CJS of core module 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching native-esm-core-cjs-reexport.test.js.\"\n`;\n\nexports[`supports top-level await 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching native-esm.tla.test.js.\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {resolve} from 'path';\nimport {json as runJest} from '../runJest';\n\nconst DIR = resolve(__dirname, '../native-esm-typescript');\n\ntest('runs TS test with native ESM', () => {\n  const {exitCode, json} = runJest(DIR, [], {\n    nodeOptions: '--experimental-vm-modules --no-warnings',\n  });\n\n  expect(exitCode).toBe(0);\n\n  expect(json.numTotalTests).toBe(2);\n  expect(json.numPassedTests).toBe(2);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nexports.isMock = true;"}
{"prompt":"inner describe,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst {getTruthy} = require('../index');\n\ntest('test', () => {\n  expect(getTruthy()).toBeTruthy();\n\n  describe('inner describe', () => {\n    // nothing to see here\n  });\n});"}
{"prompt":"can assert on errors across nested event loops,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n/* global document */\n\n'use strict';\n\nit('can assert on errors across nested event loops', () => {\n  const el = document.createElement('div');\n  el.addEventListener('fake', () => {\n    throw new Error('This should be caught.');\n  });\n  let caught = null;\n  globalThis.addEventListener('error', e => {\n    caught = e.error;\n  });\n  expect(() => {\n    const evt = document.createEvent('Event');\n    evt.initEvent('fake', false, false);\n    el.dispatchEvent(evt);\n    if (caught) {\n      throw caught;\n    }\n  }).toThrow('This should be caught.');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('works with nested event loops', () => {\n  const result = runJest('nested-event-loop');\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"nothing to see here","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst {getTruthy} = require('../index');\n\ntest('test', () => {\n  expect(getTruthy()).toBeTruthy();\n\n  beforeEach(() => {\n    // nothing to see here\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {isJestJasmineRun} from '@jest/test-utils';\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nconst cleanupRunnerStack = (stderr: string) =>\n  stderr\n    .split('\\n')\n    .filter(\n      line =>\n        !line.includes('packages/jest-jasmine2/build') &&\n        !line.includes('packages/jest-circus/build'),\n    )\n    .join('\\n');\n\ntest('print correct error message with nested test definitions outside describe', () => {\n  const result = runJest('nested-test-definitions', ['outside']);\n\n  expect(result.exitCode).toBe(1);\n\n  const summary = extractSummary(result.stderr);\n\n  expect(cleanupRunnerStack(summary.rest)).toMatchSnapshot();\n});\n\ntest('print correct error message with nested test definitions inside describe', () => {\n  const result = runJest('nested-test-definitions', ['within']);\n\n  expect(result.exitCode).toBe(1);\n\n  const summary = extractSummary(result.stderr);\n\n  expect(cleanupRunnerStack(summary.rest)).toMatchSnapshot();\n});\n\n(isJestJasmineRun() ? test.skip : test)(\n  'print correct message when nesting describe inside it',\n  () => {\n    const result = runJest('nested-test-definitions', ['nestedDescribeInTest']);\n\n    expect(result.exitCode).toBe(1);\n\n    expect(result.stderr).toContain(\n      'Cannot nest a describe inside a test. Describe block \"inner describe\" cannot run because it is nested within \"test\".',\n    );\n  },\n);\n\n(isJestJasmineRun() ? test.skip : test)(\n  'print correct message when nesting a hook inside it',\n  () => {\n    const result = runJest('nested-test-definitions', ['nestedHookInTest']);\n\n    expect(result.exitCode).toBe(1);\n\n    expect(result.stderr).toContain(\n      'Hooks cannot be defined inside tests. Hook of type \"beforeEach\" is nested within \"test\".',\n    );\n  },\n);"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`print correct error message with nested test definitions inside describe 1`] = `\n\"FAIL __tests__/nestedTestWithinDescribe.js\n  in describe\n    ✕ outer test\n\n  ● in describe › outer test\n\n    Tests cannot be nested. Test \"inner test\" cannot run because it is nested within \"outer test\".\n\n      14 |     expect(getTruthy()).toBeTruthy();\n      15 |\n    > 16 |     test('inner test', () => {\n         |     ^\n      17 |       expect(getTruthy()).toBeTruthy();\n      18 |     });\n      19 |   });\n\n      at Object.test (__tests__/nestedTestWithinDescribe.js:16:5)\"\n`;\n\nexports[`print correct error message with nested test definitions outside describe 1`] = `\n\"FAIL __tests__/nestedTestOutsideDescribe.js\n  ✕ outer test\n\n  ● outer test\n\n    Tests cannot be nested. Test \"inner test\" cannot run because it is nested within \"outer test\".\n\n      13 |   expect(getTruthy()).toBeTruthy();\n      14 |\n    > 15 |   test('inner test', () => {\n         |   ^\n      16 |     expect(getTruthy()).toBe('This test should not have run');\n      17 |   });\n      18 | });\n\n      at Object.test (__tests__/nestedTestOutsideDescribe.js:15:3)\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst {getTruthy} = require('../index');\n\ntest('outer test', () => {\n  expect(getTruthy()).toBeTruthy();\n\n  test('inner test', () => {\n    expect(getTruthy()).toBe('This test should not have run');\n  });\n});"}
{"prompt":"in describe,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst {getTruthy} = require('../index');\n\ndescribe('in describe', () => {\n  test('outer test', () => {\n    expect(getTruthy()).toBeTruthy();\n\n    test('inner test', () => {\n      expect(getTruthy()).toBeTruthy();\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jest-environment-node\n * @jest-environment-options {\"customExportConditions\": [\"special\"]}\n */\n\nimport {fn} from 'fake-dual-dep';\n\ntest('returns correct message', () => {\n  expect(fn()).toBe('hello from special');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nmodule.exports.isBrowser = false;"}
{"prompt":"readdir has an optional options arg thats in the middle of the args list.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\njest.mock('child_process', () => ({\n  spawn: jest.fn((cmd, args) => {\n    let closeCallback;\n    return {\n      on: jest.fn().mockImplementation((event, callback) => {\n        if (event === 'exit') {\n          callback(mockSpawnExit, null);\n        }\n      }),\n      stdout: {\n        on: jest.fn().mockImplementation((event, callback) => {\n          if (event === 'data') {\n            setTimeout(() => {\n              callback(mockResponse);\n              setTimeout(closeCallback, 0);\n            }, 0);\n          } else if (event === 'close') {\n            closeCallback = callback;\n          }\n        }),\n        setEncoding: jest.fn(),\n      },\n    };\n  }),\n}));\n\njest.mock('graceful-fs', () => {\n  const slash = require('slash');\n  let mtime = 32;\n  const size = 42;\n  const stat = (path, callback) => {\n    setTimeout(\n      () =>\n        callback(null, {\n          isDirectory() {\n            return slash(path).endsWith('/directory');\n          },\n          isSymbolicLink() {\n            return slash(path).endsWith('symlink');\n          },\n          mtime: {\n            getTime() {\n              return mtime++;\n            },\n          },\n          size,\n        }),\n      0,\n    );\n  };\n  return {\n    lstat: jest.fn(stat),\n    readdir: jest.fn((dir, options, callback) => {\n      // readdir has an optional `options` arg that's in the middle of the args list.\n      // we always provide it in practice, but let's try to handle the case where it's not\n      // provided too\n      if (callback === undefined) {\n        if (typeof options === 'function') {\n          callback = options;\n        }\n        throw new Error('readdir: callback is not a function!');\n      }\n\n      if (slash(dir) === '/project/fruits') {\n        setTimeout(\n          () =>\n            callback(null, [\n              {\n                isDirectory: () => true,\n                isSymbolicLink: () => false,\n                name: 'directory',\n              },\n              {\n                isDirectory: () => false,\n                isSymbolicLink: () => false,\n                name: 'tomato.js',\n              },\n              {\n                isDirectory: () => false,\n                isSymbolicLink: () => true,\n                name: 'symlink',\n              },\n            ]),\n          0,\n        );\n      } else if (slash(dir) === '/project/fruits/directory') {\n        setTimeout(\n          () =>\n            callback(null, [\n              {\n                isDirectory: () => false,\n                isSymbolicLink: () => false,\n                name: 'strawberry.js',\n              },\n            ]),\n          0,\n        );\n      } else if (slash(dir) === '/error') {\n        setTimeout(() => callback({code: 'ENOTDIR'}, undefined), 0);\n      }\n    }),\n    stat: jest.fn(stat),\n  };\n});\n\nconst pearMatcher = path => /pear/.test(path);\nconst normalize = path =>\n  process.platform === 'win32' ? path.replaceAll('/', '\\\\') : path;\nconst createMap = obj =>\n  new Map(Object.keys(obj).map(key => [normalize(key), obj[key]]));\n\nconst rootDir = '/project';\nlet mockResponse;\nlet mockSpawnExit;\nlet nodeCrawl;\nlet childProcess;\n\ndescribe('node crawler', () => {\n  beforeEach(() => {\n    jest.resetModules();\n\n    mockResponse = [\n      '/project/fruits/pear.js',\n      '/project/fruits/strawberry.js',\n      '/project/fruits/tomato.js',\n    ].join('\\n');\n\n    mockSpawnExit = 0;\n  });\n\n  it('crawls for files based on patterns', async () => {\n    childProcess = require('child_process');\n    nodeCrawl = require('../node').nodeCrawl;\n\n    mockResponse = [\n      '/project/fruits/pear.js',\n      '/project/fruits/strawberry.js',\n      '/project/fruits/tomato.js',\n      '/project/vegetables/melon.json',\n    ].join('\\n');\n\n    const {hasteMap, removedFiles} = await nodeCrawl({\n      data: {\n        files: new Map(),\n      },\n      extensions: ['js', 'json'],\n      ignore: pearMatcher,\n      rootDir,\n      roots: ['/project/fruits', '/project/vegetables'],\n    });\n\n    expect(childProcess.spawn).toHaveBeenLastCalledWith('find', [\n      '/project/fruits',\n      '/project/vegetables',\n      '-type',\n      'f',\n      '(',\n      '-iname',\n      '*.js',\n      '-o',\n      '-iname',\n      '*.json',\n      ')',\n    ]);\n\n    expect(hasteMap.files).not.toBeNull();\n\n    expect(hasteMap.files).toEqual(\n      createMap({\n        'fruits/strawberry.js': ['', 32, 42, 0, '', null],\n        'fruits/tomato.js': ['', 33, 42, 0, '', null],\n        'vegetables/melon.json': ['', 34, 42, 0, '', null],\n      }),\n    );\n\n    expect(removedFiles).toEqual(new Map());\n  });\n\n  it('updates only changed files', async () => {\n    nodeCrawl = require('../node').nodeCrawl;\n\n    // In this test sample, strawberry is changed and tomato is unchanged\n    const tomato = ['', 33, 42, 1, '', null];\n    const files = createMap({\n      'fruits/strawberry.js': ['', 30, 40, 1, '', null],\n      'fruits/tomato.js': tomato,\n    });\n\n    const {hasteMap, removedFiles} = await nodeCrawl({\n      data: {files},\n      extensions: ['js'],\n      ignore: pearMatcher,\n      rootDir,\n      roots: ['/project/fruits'],\n    });\n\n    expect(hasteMap.files).toEqual(\n      createMap({\n        'fruits/strawberry.js': ['', 32, 42, 0, '', null],\n        'fruits/tomato.js': tomato,\n      }),\n    );\n\n    // Make sure it is the *same* unchanged object.\n    expect(hasteMap.files.get(normalize('fruits/tomato.js'))).toBe(tomato);\n\n    expect(removedFiles).toEqual(new Map());\n  });\n\n  it('returns removed files', async () => {\n    nodeCrawl = require('../node').nodeCrawl;\n\n    // In this test sample, previouslyExisted was present before and will not be\n    // when crawling this directory.\n    const files = createMap({\n      'fruits/previouslyExisted.js': ['', 30, 40, 1, '', null],\n      'fruits/strawberry.js': ['', 33, 42, 0, '', null],\n      'fruits/tomato.js': ['', 32, 42, 0, '', null],\n    });\n\n    const {hasteMap, removedFiles} = await nodeCrawl({\n      data: {files},\n      extensions: ['js'],\n      ignore: pearMatcher,\n      rootDir,\n      roots: ['/project/fruits'],\n    });\n\n    expect(hasteMap.files).toEqual(\n      createMap({\n        'fruits/strawberry.js': ['', 32, 42, 0, '', null],\n        'fruits/tomato.js': ['', 33, 42, 0, '', null],\n      }),\n    );\n    expect(removedFiles).toEqual(\n      createMap({\n        'fruits/previouslyExisted.js': ['', 30, 40, 1, '', null],\n      }),\n    );\n  });\n\n  it('uses node fs APIs with incompatible find binary', async () => {\n    mockResponse = '';\n    mockSpawnExit = 1;\n    childProcess = require('child_process');\n\n    nodeCrawl = require('../node').nodeCrawl;\n\n    const {hasteMap, removedFiles} = await nodeCrawl({\n      data: {\n        files: new Map(),\n      },\n      extensions: ['js'],\n      ignore: pearMatcher,\n      rootDir,\n      roots: ['/project/fruits'],\n    });\n\n    expect(childProcess.spawn).toHaveBeenLastCalledWith(\n      'find',\n      ['.', '-type', 'f', '(', '-iname', '*.ts', '-o', '-iname', '*.js', ')'],\n      {cwd: expect.any(String)},\n    );\n    expect(hasteMap.files).toEqual(\n      createMap({\n        'fruits/directory/strawberry.js': ['', 33, 42, 0, '', null],\n        'fruits/tomato.js': ['', 32, 42, 0, '', null],\n      }),\n    );\n    expect(removedFiles).toEqual(new Map());\n  });\n\n  it('uses node fs APIs without find binary', async () => {\n    childProcess = require('child_process');\n    childProcess.spawn.mockImplementationOnce(() => {\n      throw new Error();\n    });\n    nodeCrawl = require('../node').nodeCrawl;\n\n    const {hasteMap, removedFiles} = await nodeCrawl({\n      data: {\n        files: new Map(),\n      },\n      extensions: ['js'],\n      ignore: pearMatcher,\n      rootDir,\n      roots: ['/project/fruits'],\n    });\n\n    expect(hasteMap.files).toEqual(\n      createMap({\n        'fruits/directory/strawberry.js': ['', 33, 42, 0, '', null],\n        'fruits/tomato.js': ['', 32, 42, 0, '', null],\n      }),\n    );\n    expect(removedFiles).toEqual(new Map());\n  });\n\n  it('uses node fs APIs if \"forceNodeFilesystemAPI\" is set to true, regardless of platform', async () => {\n    childProcess = require('child_process');\n    nodeCrawl = require('../node').nodeCrawl;\n\n    const files = new Map();\n    const {hasteMap, removedFiles} = await nodeCrawl({\n      data: {files},\n      extensions: ['js'],\n      forceNodeFilesystemAPI: true,\n      ignore: pearMatcher,\n      rootDir,\n      roots: ['/project/fruits'],\n    });\n\n    expect(childProcess.spawn).toHaveBeenCalledTimes(0);\n    expect(hasteMap.files).toEqual(\n      createMap({\n        'fruits/directory/strawberry.js': ['', 33, 42, 0, '', null],\n        'fruits/tomato.js': ['', 32, 42, 0, '', null],\n      }),\n    );\n    expect(removedFiles).toEqual(new Map());\n  });\n\n  it('completes with empty roots', async () => {\n    nodeCrawl = require('../node').nodeCrawl;\n\n    const files = new Map();\n    const {hasteMap, removedFiles} = await nodeCrawl({\n      data: {files},\n      extensions: ['js'],\n      forceNodeFilesystemAPI: true,\n      ignore: pearMatcher,\n      rootDir,\n      roots: [],\n    });\n\n    expect(hasteMap.files).toEqual(new Map());\n    expect(removedFiles).toEqual(new Map());\n  });\n\n  it('completes with fs.readdir throwing an error', async () => {\n    nodeCrawl = require('../node').nodeCrawl;\n\n    const files = new Map();\n    const {hasteMap, removedFiles} = await nodeCrawl({\n      data: {files},\n      extensions: ['js'],\n      forceNodeFilesystemAPI: true,\n      ignore: pearMatcher,\n      rootDir,\n      roots: ['/error'],\n    });\n\n    expect(hasteMap.files).toEqual(new Map());\n    expect(removedFiles).toEqual(new Map());\n  });\n\n  it('avoids calling lstat for directories and symlinks', async () => {\n    nodeCrawl = require('../node').nodeCrawl;\n    const fs = require('graceful-fs');\n\n    const files = new Map();\n    const {hasteMap, removedFiles} = await nodeCrawl({\n      data: {files},\n      extensions: ['js'],\n      forceNodeFilesystemAPI: true,\n      ignore: pearMatcher,\n      rootDir,\n      roots: ['/project/fruits'],\n    });\n\n    expect(hasteMap.files).toEqual(\n      createMap({\n        'fruits/directory/strawberry.js': ['', 33, 42, 0, '', null],\n        'fruits/tomato.js': ['', 32, 42, 0, '', null],\n      }),\n    );\n    expect(removedFiles).toEqual(new Map());\n    // once for /project/fruits, once for /project/fruits/directory\n    expect(fs.readdir).toHaveBeenCalledTimes(2);\n    // once for strawberry.js, once for tomato.js\n    expect(fs.lstat).toHaveBeenCalledTimes(2);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jest-environment-node\n */\n\nimport {fn} from 'fake-dual-dep';\n\ntest('returns correct message', () => {\n  expect(fn()).toBe('hello from node');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('can require by absolute path', () => {\n  expect(require('path/file.js')).toBe(42);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('supports NODE_PATH', () => {\n  const result = runJest('node-path', [], {\n    nodePath: '../node-path/src',\n  });\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"passes fork options down to worker_threads.Worker, adding the defaults,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EventEmitter} from 'events';\nimport {PassThrough} from 'stream';\nimport getStream = require('get-stream');\nimport {\n  CHILD_MESSAGE_CALL,\n  CHILD_MESSAGE_INITIALIZE,\n  type ChildMessageCall,\n  PARENT_MESSAGE_CLIENT_ERROR,\n  PARENT_MESSAGE_CUSTOM,\n  PARENT_MESSAGE_OK,\n  type WorkerOptions,\n} from '../../types';\n\nlet Worker: typeof import('../NodeThreadsWorker').default;\nlet workerThreads: typeof import('worker_threads').Worker;\nlet originalExecArgv: typeof process.execArgv;\n\nclass MockedWorker extends EventEmitter {\n  postMessage = jest.fn();\n  terminate = jest.fn();\n  stdout = new PassThrough();\n  stderr = new PassThrough();\n}\n\nbeforeEach(() => {\n  jest.mock('worker_threads', () => {\n    return {\n      Worker: jest.fn(() => new MockedWorker()),\n    };\n  });\n  originalExecArgv = process.execArgv;\n\n  workerThreads = (require('worker_threads') as typeof import('worker_threads'))\n    .Worker;\n\n  Worker = (\n    require('../NodeThreadsWorker') as typeof import('../NodeThreadsWorker')\n  ).default;\n});\n\nafterEach(() => {\n  jest.resetModules();\n  process.execArgv = originalExecArgv;\n});\n\nit('passes fork options down to worker_threads.Worker, adding the defaults', () => {\n  const thread = require.resolve('../threadChild');\n\n  // eslint-disable-next-line no-new\n  new Worker({\n    forkOptions: {\n      execArgv: ['--inspect', '-p'],\n      execPath: 'hello',\n    },\n    maxRetries: 3,\n    workerData: {\n      foo: 'bar',\n    },\n    workerId: Number(process.env.JEST_WORKER_ID) - 1,\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  expect(jest.mocked(workerThreads).mock.calls[0][0]).toBe(thread);\n  expect(jest.mocked(workerThreads).mock.calls[0][1]).toEqual({\n    eval: false,\n    execArgv: ['--inspect', '-p'],\n    execPath: 'hello', // Added option.\n    resourceLimits: undefined,\n    stderr: true,\n    stdout: true,\n    workerData: {\n      // Added option.\n      foo: 'bar',\n    },\n  });\n});\n\nit('initializes the thread with the given workerPath and workerId', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    setupArgs: ['foo', 'bar'],\n    workerId: 2,\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  // @ts-expect-error: Testing internal method\n  expect(jest.mocked(worker._worker.postMessage).mock.calls[0][0]).toEqual([\n    CHILD_MESSAGE_INITIALIZE,\n    false,\n    '/tmp/foo/bar/baz.js',\n    ['foo', 'bar'],\n    '3',\n  ]);\n});\n\nit('stops initializing the worker after the amount of retries is exceeded', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  const request = [CHILD_MESSAGE_CALL, false, 'foo', []] as ChildMessageCall;\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n\n  worker.send(request, onProcessStart, onProcessEnd, () => {});\n\n  // We fail four times (initial + three retries).\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit');\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit');\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit');\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit');\n\n  expect(workerThreads).toHaveBeenCalledTimes(5);\n  expect(onProcessStart).toHaveBeenCalledWith(worker);\n  expect(onProcessEnd).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd.mock.calls[0][0]).toBeInstanceOf(Error);\n  expect(onProcessEnd.mock.calls[0][0]).toMatchObject({type: 'WorkerError'});\n  expect(onProcessEnd.mock.calls[0][1]).toBeNull();\n});\n\nit('provides stdout and stderr from the threads', async () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const stdout = worker.getStdout();\n  const stderr = worker.getStderr();\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.stdout.end('Hello ', 'utf8');\n  // @ts-expect-error: Testing internal method\n  worker._worker.stderr.end('Jest ', 'utf8');\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit');\n  // @ts-expect-error: Testing internal method\n  worker._worker.stdout.end('World!', 'utf8');\n  // @ts-expect-error: Testing internal method\n  worker._worker.stderr.end('Workers!', 'utf8');\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit', 0);\n\n  await expect(getStream(stdout!)).resolves.toBe('Hello World!');\n  await expect(getStream(stderr!)).resolves.toBe('Jest Workers!');\n});\n\nit('sends the task to the thread', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const request = [CHILD_MESSAGE_CALL, false, 'foo', []] as ChildMessageCall;\n\n  worker.send(\n    request,\n    () => {},\n    () => {},\n    () => {},\n  );\n\n  // Skipping call \"0\" because it corresponds to the \"initialize\" one.\n  // @ts-expect-error: Testing internal method\n  expect(jest.mocked(worker._worker.postMessage).mock.calls[1][0]).toEqual(\n    request,\n  );\n});\n\nit('resends the task to the thread after a retry', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo/bar/baz.js',\n  } as WorkerOptions);\n\n  const request = [CHILD_MESSAGE_CALL, false, 'foo', []] as ChildMessageCall;\n\n  worker.send(\n    request,\n    () => {},\n    () => {},\n    () => {},\n  );\n\n  // Skipping call \"0\" because it corresponds to the \"initialize\" one.\n  // @ts-expect-error: Testing internal method\n  expect(jest.mocked(worker._worker.postMessage).mock.calls[1][0]).toEqual(\n    request,\n  );\n\n  // @ts-expect-error: Testing internal method\n  const previousWorker = worker._worker;\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit');\n\n  // @ts-expect-error: Testing internal method\n  expect(worker._worker).not.toBe(previousWorker);\n\n  // Skipping call \"0\" because it corresponds to the \"initialize\" one.\n  // @ts-expect-error: Testing internal method\n  expect(jest.mocked(worker._worker.postMessage).mock.calls[1][0]).toEqual(\n    request,\n  );\n});\n\nit('calls the onProcessStart method synchronously if the queue is empty', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'foo', []],\n    onProcessStart,\n    onProcessEnd,\n    () => {},\n  );\n\n  // Only onProcessStart has been called\n  expect(onProcessStart).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).not.toHaveBeenCalled();\n\n  // then first call replies...\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', [PARENT_MESSAGE_OK]);\n\n  expect(onProcessEnd).toHaveBeenCalledTimes(1);\n});\n\nit('can send multiple messages to parent', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const onProcessStart = jest.fn();\n  const onProcessEnd = jest.fn();\n  const onCustomMessage = jest.fn();\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'foo', []],\n    onProcessStart,\n    onProcessEnd,\n    onCustomMessage,\n  );\n\n  // Only onProcessStart has been called\n  expect(onProcessStart).toHaveBeenCalledTimes(1);\n  expect(onProcessEnd).not.toHaveBeenCalled();\n  expect(onCustomMessage).not.toHaveBeenCalled();\n\n  // then first call replies...\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', [\n    PARENT_MESSAGE_CUSTOM,\n    {message: 'foo bar', otherKey: 1},\n  ]);\n\n  expect(onProcessEnd).not.toHaveBeenCalled();\n  expect(onCustomMessage).toHaveBeenCalledTimes(1);\n  expect(onCustomMessage).toHaveBeenCalledWith({\n    message: 'foo bar',\n    otherKey: 1,\n  });\n});\n\nit('creates error instances for known errors', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  const callback1 = jest.fn();\n  const callback2 = jest.fn();\n  const callback3 = jest.fn();\n\n  // Testing a generic ECMAScript error.\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    callback1,\n    () => {},\n  );\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', [\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'TypeError',\n    'bar',\n    'TypeError: bar',\n    {},\n  ]);\n\n  expect(callback1.mock.calls[0][0]).toBeInstanceOf(TypeError);\n  expect(callback1.mock.calls[0][0]).toMatchObject({\n    message: 'bar',\n    stack: 'TypeError: bar',\n    type: 'TypeError',\n  });\n\n  // Testing a custom error.\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    callback2,\n    () => {},\n  );\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', [\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'RandomCustomError',\n    'bar',\n    'RandomCustomError: bar',\n    {qux: 'extra property'},\n  ]);\n\n  expect(callback2.mock.calls[0][0]).toBeInstanceOf(Error);\n  expect(callback2.mock.calls[0][0]).toMatchObject({\n    message: 'bar',\n    qux: 'extra property',\n    stack: 'RandomCustomError: bar',\n    type: 'RandomCustomError',\n  });\n\n  // Testing a non-object throw.\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    callback3,\n    () => {},\n  );\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', [\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'Number',\n    null,\n    null,\n    412,\n  ]);\n\n  expect(callback3.mock.calls[0][0]).toBe(412);\n});\n\nit('does not throw when the thread returns a strange message', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.send(\n    [CHILD_MESSAGE_CALL, false, 'method', []],\n    () => {},\n    () => {},\n    () => {},\n  );\n\n  // Type 27 does not exist.\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', [27]);\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', 'test');\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', {foo: 'bar'});\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', 0);\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', null);\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', Symbol('test'));\n\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('message', true);\n});\n\nit('does not restart the thread if it cleanly exited', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(workerThreads).toHaveBeenCalledTimes(1);\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit', 0);\n  expect(workerThreads).toHaveBeenCalledTimes(1);\n});\n\nit('resolves waitForExit() after the thread cleanly exited', async () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(workerThreads).toHaveBeenCalledTimes(1);\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit', 0);\n  await worker.waitForExit(); // should not timeout\n});\n\nit('restarts the thread when the thread dies', () => {\n  const worker = new Worker({\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  expect(workerThreads).toHaveBeenCalledTimes(1);\n  // @ts-expect-error: Testing internal method\n  worker._worker.emit('exit', 1);\n  expect(workerThreads).toHaveBeenCalledTimes(2);\n});\n\nit('terminates the thread when forceExit() is called', () => {\n  const worker = new Worker({\n    forkOptions: {},\n    maxRetries: 3,\n    workerPath: '/tmp/foo',\n  } as WorkerOptions);\n\n  worker.forceExit();\n  // @ts-expect-error: Testing internal method\n  expect(worker._worker.terminate).toHaveBeenCalled();\n});"}
{"prompt":"NodeEnvironment,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {EnvironmentContext} from '@jest/environment';\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport NodeEnvironment from '..';\n\nconst context: EnvironmentContext = {\n  console,\n  docblockPragmas: {},\n  testPath: __filename,\n};\n\ndescribe('NodeEnvironment', () => {\n  it('uses a copy of the process object', () => {\n    const testEnvConfig = {\n      globalConfig: makeGlobalConfig(),\n      projectConfig: makeProjectConfig(),\n    };\n    const env1 = new NodeEnvironment(testEnvConfig, context);\n    const env2 = new NodeEnvironment(testEnvConfig, context);\n\n    expect(env1.global.process).not.toBe(env2.global.process);\n  });\n\n  it('exposes process.on', () => {\n    const env1 = new NodeEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      context,\n    );\n\n    expect(env1.global.process.on).not.toBeNull();\n  });\n\n  it('exposes global.global', () => {\n    const env1 = new NodeEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      context,\n    );\n\n    expect(env1.global.global).toBe(env1.global);\n  });\n\n  it('should configure setTimeout/setInterval to use the node api', () => {\n    const env1 = new NodeEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      context,\n    );\n\n    env1.fakeTimers!.useFakeTimers();\n\n    const timer1 = env1.global.setTimeout(() => {}, 0);\n    const timer2 = env1.global.setInterval(() => {}, 0);\n\n    for (const timer of [timer1, timer2]) {\n      expect(timer.id).toBeDefined();\n      expect(typeof timer.ref).toBe('function');\n      expect(typeof timer.unref).toBe('function');\n    }\n  });\n\n  it('has modern fake timers implementation', () => {\n    const env = new NodeEnvironment(\n      {\n        globalConfig: makeGlobalConfig(),\n        projectConfig: makeProjectConfig(),\n      },\n      context,\n    );\n\n    expect(env.fakeTimersModern).toBeDefined();\n  });\n\n  test('TextEncoder references the same global Uint8Array constructor', () => {\n    expect(new TextEncoder().encode('abc')).toBeInstanceOf(Uint8Array);\n  });\n});"}
{"prompt":"timeout in case the waUntil below doesnt fire","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {\n  cleanup,\n  createEmptyPackage,\n  extractSortedSummary,\n  writeFiles,\n} from '../Utils';\nimport {runContinuous} from '../runJest';\n\nconst tempDir = path.resolve(tmpdir(), 'bigint-inequality-test');\n\nconst testIn2Workers = async (\n  testFileContent: string,\n  extraOptions: Array<string> = [],\n) => {\n  writeFiles(tempDir, {\n    '__tests__/test-1.js': testFileContent,\n    '__tests__/test-2.js': testFileContent,\n  });\n\n  const {end, waitUntil} = runContinuous(\n    tempDir,\n    ['--no-watchman', '--watch-all', ...extraOptions],\n    // timeout in case the `waitUntil` below doesn't fire\n    {stripAnsi: true, timeout: 5000},\n  );\n\n  await waitUntil(({stderr}) => stderr.includes('Ran all test suites.'));\n\n  const {stderr} = await end();\n\n  return extractSortedSummary(stderr);\n};\n\nbeforeEach(() => {\n  createEmptyPackage(tempDir);\n});\n\nafterEach(() => {\n  cleanup(tempDir);\n});\n\ndescribe.each([\n  {name: 'processChild'},\n  {extraOptions: ['--workerThreads'], name: 'workerThreads'},\n])('$name', ({extraOptions}) => {\n  test('handles circular inequality properly', async () => {\n    const {summary, rest} = await testIn2Workers(\n      `\n    it('test', () => {\n      const foo = {};\n      foo.ref = foo;\n\n      expect(foo).toEqual({});\n    });\n  `,\n      extraOptions,\n    );\n    expect(rest).toMatchSnapshot();\n    expect(summary).toMatchSnapshot();\n  });\n\n  test('handles `Map`', async () => {\n    const {summary, rest} = await testIn2Workers(\n      `\n    it('test', () => {\n      expect(new Map([[1, \"2\"]])).toEqual(new Map([[1, \"3\"]]));\n    });\n  `,\n      extraOptions,\n    );\n    expect(rest).toMatchSnapshot();\n    expect(summary).toMatchSnapshot();\n  });\n\n  test('handles `BigInt`', async () => {\n    const {summary, rest} = await testIn2Workers(\n      `\n    it('test', () => {\n      expect(BigInt(42)).toBe(BigInt(73));\n    });\n  `,\n      extraOptions,\n    );\n    expect(rest).toMatchSnapshot();\n    expect(summary).toMatchSnapshot();\n  });\n\n  test('handles `Symbol`', async () => {\n    const {summary, rest} = await testIn2Workers(\n      `\n    it('test', () => {\n      expect(Symbol('a')).toEqual(Symbol('b'));\n    });\n  `,\n      extraOptions,\n    );\n    expect(rest).toMatchSnapshot();\n    expect(summary).toMatchSnapshot();\n  });\n\n  test('handles functions', async () => {\n    const {summary, rest} = await testIn2Workers(\n      `\n    it('test', () => {\n      const fn1 = () => {};\n      const fn2 = () => {};\n      expect(fn1).toEqual(fn2);\n    });\n  `,\n      extraOptions,\n    );\n    expect(rest).toMatchSnapshot();\n    expect(summary).toMatchSnapshot();\n  });\n\n  test('handles mixed structure', async () => {\n    const {summary, rest} = await testIn2Workers(\n      `\n    it('test', () => {\n      class Class {\n        constructor() {\n          this.ref = this;\n          this.bigInt = BigInt(42);\n          this.map = new Map([[1, \"2\"]]);\n          this.symbol = Symbol('asd');\n          this[Symbol('qwe')] = Symbol('zxc');\n          this.fn = () => {};\n        }\n        method() {}\n      }\n      expect(new Class()).toEqual(false);\n    });\n  `,\n      extraOptions,\n    );\n    expect(rest).toMatchSnapshot();\n    expect(summary).toMatchSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`processChild handles \\`BigInt\\` 1`] = `\n\"FAIL __tests__/test-1.js\n  ● test\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 73n\n    Received: 42n\n\n      1 | it('test', () => {\n    > 2 |   expect(BigInt(42)).toBe(BigInt(73));\n        |                      ^\n      3 | });\n\n      at Object.toBe (__tests__/test-1.js:2:22)\n\nFAIL __tests__/test-2.js\n  ● test\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 73n\n    Received: 42n\n\n      1 | it('test', () => {\n    > 2 |   expect(BigInt(42)).toBe(BigInt(73));\n        |                      ^\n      3 | });\n\n      at Object.toBe (__tests__/test-2.js:2:22)\"\n`;\n\nexports[`processChild handles \\`BigInt\\` 2`] = `\n\"Test Suites: 2 failed, 2 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`processChild handles \\`Map\\` 1`] = `\n\"FAIL __tests__/test-1.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    - Expected  - 1\n    + Received  + 1\n\n      Map {\n    -   1 => \"3\",\n    +   1 => \"2\",\n      }\n\n      1 | it('test', () => {\n    > 2 |   expect(new Map([[1, \"2\"]])).toEqual(new Map([[1, \"3\"]]));\n        |                               ^\n      3 | });\n\n      at Object.toEqual (__tests__/test-1.js:2:31)\n\nFAIL __tests__/test-2.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    - Expected  - 1\n    + Received  + 1\n\n      Map {\n    -   1 => \"3\",\n    +   1 => \"2\",\n      }\n\n      1 | it('test', () => {\n    > 2 |   expect(new Map([[1, \"2\"]])).toEqual(new Map([[1, \"3\"]]));\n        |                               ^\n      3 | });\n\n      at Object.toEqual (__tests__/test-2.js:2:31)\"\n`;\n\nexports[`processChild handles \\`Map\\` 2`] = `\n\"Test Suites: 2 failed, 2 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`processChild handles \\`Symbol\\` 1`] = `\n\"FAIL __tests__/test-1.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: Symbol(b)\n    Received: Symbol(a)\n\n      1 | it('test', () => {\n    > 2 |   expect(Symbol('a')).toEqual(Symbol('b'));\n        |                       ^\n      3 | });\n\n      at Object.toEqual (__tests__/test-1.js:2:23)\n\nFAIL __tests__/test-2.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: Symbol(b)\n    Received: Symbol(a)\n\n      1 | it('test', () => {\n    > 2 |   expect(Symbol('a')).toEqual(Symbol('b'));\n        |                       ^\n      3 | });\n\n      at Object.toEqual (__tests__/test-2.js:2:23)\"\n`;\n\nexports[`processChild handles \\`Symbol\\` 2`] = `\n\"Test Suites: 2 failed, 2 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`processChild handles circular inequality properly 1`] = `\n\"FAIL __tests__/test-1.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    - Expected  - 1\n    + Received  + 3\n\n    - Object {}\n    + Object {\n    +   \"ref\": [Circular],\n    + }\n\n      3 |   foo.ref = foo;\n      4 |\n    > 5 |   expect(foo).toEqual({});\n        |               ^\n      6 | });\n\n      at Object.toEqual (__tests__/test-1.js:5:15)\n\nFAIL __tests__/test-2.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    - Expected  - 1\n    + Received  + 3\n\n    - Object {}\n    + Object {\n    +   \"ref\": [Circular],\n    + }\n\n      3 |   foo.ref = foo;\n      4 |\n    > 5 |   expect(foo).toEqual({});\n        |               ^\n      6 | });\n\n      at Object.toEqual (__tests__/test-2.js:5:15)\"\n`;\n\nexports[`processChild handles circular inequality properly 2`] = `\n\"Test Suites: 2 failed, 2 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`processChild handles functions 1`] = `\n\"FAIL __tests__/test-1.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: [Function fn2]\n    Received: [Function fn1]\n\n      2 |   const fn1 = () => {};\n      3 |   const fn2 = () => {};\n    > 4 |   expect(fn1).toEqual(fn2);\n        |               ^\n      5 | });\n\n      at Object.toEqual (__tests__/test-1.js:4:15)\n\nFAIL __tests__/test-2.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: [Function fn2]\n    Received: [Function fn1]\n\n      2 |   const fn1 = () => {};\n      3 |   const fn2 = () => {};\n    > 4 |   expect(fn1).toEqual(fn2);\n        |               ^\n      5 | });\n\n      at Object.toEqual (__tests__/test-2.js:4:15)\"\n`;\n\nexports[`processChild handles functions 2`] = `\n\"Test Suites: 2 failed, 2 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`processChild handles mixed structure 1`] = `\n\"FAIL __tests__/test-1.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: false\n    Received: {\"bigInt\": 42n, \"fn\": [Function anonymous], \"map\": Map {1 => \"2\"}, \"ref\": [Circular], \"symbol\": Symbol(asd), Symbol(qwe): Symbol(zxc)}\n\n      11 |     method() {}\n      12 |   }\n    > 13 |   expect(new Class()).toEqual(false);\n         |                       ^\n      14 | });\n\n      at Object.toEqual (__tests__/test-1.js:13:23)\n\nFAIL __tests__/test-2.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: false\n    Received: {\"bigInt\": 42n, \"fn\": [Function anonymous], \"map\": Map {1 => \"2\"}, \"ref\": [Circular], \"symbol\": Symbol(asd), Symbol(qwe): Symbol(zxc)}\n\n      11 |     method() {}\n      12 |   }\n    > 13 |   expect(new Class()).toEqual(false);\n         |                       ^\n      14 | });\n\n      at Object.toEqual (__tests__/test-2.js:13:23)\"\n`;\n\nexports[`processChild handles mixed structure 2`] = `\n\"Test Suites: 2 failed, 2 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`workerThreads handles \\`BigInt\\` 1`] = `\n\"FAIL __tests__/test-1.js\n  ● test\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 73n\n    Received: 42n\n\n      1 | it('test', () => {\n    > 2 |   expect(BigInt(42)).toBe(BigInt(73));\n        |                      ^\n      3 | });\n\n      at Object.toBe (__tests__/test-1.js:2:22)\n\nFAIL __tests__/test-2.js\n  ● test\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 73n\n    Received: 42n\n\n      1 | it('test', () => {\n    > 2 |   expect(BigInt(42)).toBe(BigInt(73));\n        |                      ^\n      3 | });\n\n      at Object.toBe (__tests__/test-2.js:2:22)\"\n`;\n\nexports[`workerThreads handles \\`BigInt\\` 2`] = `\n\"Test Suites: 2 failed, 2 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`workerThreads handles \\`Map\\` 1`] = `\n\"FAIL __tests__/test-1.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    - Expected  - 1\n    + Received  + 1\n\n      Map {\n    -   1 => \"3\",\n    +   1 => \"2\",\n      }\n\n      1 | it('test', () => {\n    > 2 |   expect(new Map([[1, \"2\"]])).toEqual(new Map([[1, \"3\"]]));\n        |                               ^\n      3 | });\n\n      at Object.toEqual (__tests__/test-1.js:2:31)\n\nFAIL __tests__/test-2.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    - Expected  - 1\n    + Received  + 1\n\n      Map {\n    -   1 => \"3\",\n    +   1 => \"2\",\n      }\n\n      1 | it('test', () => {\n    > 2 |   expect(new Map([[1, \"2\"]])).toEqual(new Map([[1, \"3\"]]));\n        |                               ^\n      3 | });\n\n      at Object.toEqual (__tests__/test-2.js:2:31)\"\n`;\n\nexports[`workerThreads handles \\`Map\\` 2`] = `\n\"Test Suites: 2 failed, 2 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`workerThreads handles \\`Symbol\\` 1`] = `\n\"FAIL __tests__/test-1.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: Symbol(b)\n    Received: Symbol(a)\n\n      1 | it('test', () => {\n    > 2 |   expect(Symbol('a')).toEqual(Symbol('b'));\n        |                       ^\n      3 | });\n\n      at Object.toEqual (__tests__/test-1.js:2:23)\n\nFAIL __tests__/test-2.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: Symbol(b)\n    Received: Symbol(a)\n\n      1 | it('test', () => {\n    > 2 |   expect(Symbol('a')).toEqual(Symbol('b'));\n        |                       ^\n      3 | });\n\n      at Object.toEqual (__tests__/test-2.js:2:23)\"\n`;\n\nexports[`workerThreads handles \\`Symbol\\` 2`] = `\n\"Test Suites: 2 failed, 2 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`workerThreads handles circular inequality properly 1`] = `\n\"FAIL __tests__/test-1.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    - Expected  - 1\n    + Received  + 3\n\n    - Object {}\n    + Object {\n    +   \"ref\": [Circular],\n    + }\n\n      3 |   foo.ref = foo;\n      4 |\n    > 5 |   expect(foo).toEqual({});\n        |               ^\n      6 | });\n\n      at Object.toEqual (__tests__/test-1.js:5:15)\n\nFAIL __tests__/test-2.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    - Expected  - 1\n    + Received  + 3\n\n    - Object {}\n    + Object {\n    +   \"ref\": [Circular],\n    + }\n\n      3 |   foo.ref = foo;\n      4 |\n    > 5 |   expect(foo).toEqual({});\n        |               ^\n      6 | });\n\n      at Object.toEqual (__tests__/test-2.js:5:15)\"\n`;\n\nexports[`workerThreads handles circular inequality properly 2`] = `\n\"Test Suites: 2 failed, 2 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`workerThreads handles functions 1`] = `\n\"FAIL __tests__/test-1.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: [Function fn2]\n    Received: [Function fn1]\n\n      2 |   const fn1 = () => {};\n      3 |   const fn2 = () => {};\n    > 4 |   expect(fn1).toEqual(fn2);\n        |               ^\n      5 | });\n\n      at Object.toEqual (__tests__/test-1.js:4:15)\n\nFAIL __tests__/test-2.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: [Function fn2]\n    Received: [Function fn1]\n\n      2 |   const fn1 = () => {};\n      3 |   const fn2 = () => {};\n    > 4 |   expect(fn1).toEqual(fn2);\n        |               ^\n      5 | });\n\n      at Object.toEqual (__tests__/test-2.js:4:15)\"\n`;\n\nexports[`workerThreads handles functions 2`] = `\n\"Test Suites: 2 failed, 2 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`workerThreads handles mixed structure 1`] = `\n\"FAIL __tests__/test-1.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: false\n    Received: {\"bigInt\": 42n, \"fn\": [Function anonymous], \"map\": Map {1 => \"2\"}, \"ref\": [Circular], \"symbol\": Symbol(asd), Symbol(qwe): Symbol(zxc)}\n\n      11 |     method() {}\n      12 |   }\n    > 13 |   expect(new Class()).toEqual(false);\n         |                       ^\n      14 | });\n\n      at Object.toEqual (__tests__/test-1.js:13:23)\n\nFAIL __tests__/test-2.js\n  ● test\n\n    expect(received).toEqual(expected) // deep equality\n\n    Expected: false\n    Received: {\"bigInt\": 42n, \"fn\": [Function anonymous], \"map\": Map {1 => \"2\"}, \"ref\": [Circular], \"symbol\": Symbol(asd), Symbol(qwe): Symbol(zxc)}\n\n      11 |     method() {}\n      12 |   }\n    > 13 |   expect(new Class()).toEqual(false);\n         |                       ^\n      14 | });\n\n      at Object.toEqual (__tests__/test-2.js:13:23)\"\n`;\n\nexports[`workerThreads handles mixed structure 2`] = `\n\"Test Suites: 2 failed, 2 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"Windows uses backslashes for path separators, which need to be escaped in","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {createHash} from 'crypto';\nimport * as path from 'path';\nimport semver = require('semver');\nimport type {Config} from '@jest/types';\nimport {escapeStrForRegex} from 'jest-regex-util';\nimport Defaults from '../Defaults';\nimport {DEFAULT_JS_PATTERN} from '../constants';\nimport normalize, {type AllOptions} from '../normalize';\n\nconst DEFAULT_CSS_PATTERN = '\\\\.(css)$';\n\njest\n  .mock('path', () => jest.requireActual<typeof import('path')>('path').posix)\n  .mock('graceful-fs', () => {\n    const realFs = jest.requireActual<typeof import('fs')>('fs');\n\n    return {\n      ...realFs,\n      statSync: () => ({isDirectory: () => true}),\n    };\n  })\n  .mock('jest-util', () => {\n    const realUtil =\n      jest.requireActual<typeof import('jest-util')>('jest-util');\n\n    return {\n      ...realUtil,\n      requireOrImportModule: (filePath: string, interop = true) => {\n        const result = require(filePath);\n\n        if (interop) {\n          return realUtil.interopRequireDefault(result).default;\n        }\n\n        return result;\n      },\n    };\n  });\n\nlet root: string;\nlet expectedPathFooBar: string;\nlet expectedPathFooQux: string;\nlet expectedPathAbs: string;\nlet expectedPathAbsAnother: string;\n\nlet virtualModuleRegexes: Array<RegExp>;\nbeforeEach(() => {\n  virtualModuleRegexes = [/jest-circus/, /babel-jest/];\n});\nconst findNodeModule = jest.fn((name: string) => {\n  if (virtualModuleRegexes.some(regex => regex.test(name))) {\n    return name;\n  }\n  return null;\n});\n\n// Windows uses backslashes for path separators, which need to be escaped in\n// regular expressions. This little helper function helps us generate the\n// expected strings for checking path patterns.\nfunction joinForPattern(...args: Array<string>) {\n  return args.join(escapeStrForRegex(path.sep));\n}\n\nbeforeEach(() => {\n  root = path.resolve('/');\n  expectedPathFooBar = path.join(root, 'root', 'path', 'foo', 'bar', 'baz');\n  expectedPathFooQux = path.join(root, 'root', 'path', 'foo', 'qux', 'quux');\n  expectedPathAbs = path.join(root, 'an', 'abs', 'path');\n  expectedPathAbsAnother = path.join(root, 'another', 'abs', 'path');\n\n  (\n    require('jest-resolve') as typeof import('jest-resolve')\n  ).default.findNodeModule = findNodeModule;\n\n  jest.spyOn(console, 'warn');\n});\n\nafterEach(() => {\n  jest.mocked(console.warn).mockRestore();\n});\n\nit('picks an id based on the rootDir', async () => {\n  const rootDir = '/root/path/foo';\n  const expected = createHash('sha1')\n    .update('/root/path/foo')\n    .update(String(Number.POSITIVE_INFINITY))\n    .digest('hex')\n    .slice(0, 32);\n  const {options} = await normalize(\n    {\n      rootDir,\n    },\n    {} as Config.Argv,\n  );\n  expect(options.id).toBe(expected);\n});\n\nit('keeps custom project id based on the projects rootDir', async () => {\n  const id = 'test';\n  const {options} = await normalize(\n    {\n      projects: [{id, rootDir: '/path/to/foo'}],\n      rootDir: '/root/path/baz',\n    },\n    {} as Config.Argv,\n  );\n\n  expect((options.projects as Array<Config.InitialProjectOptions>)[0].id).toBe(\n    id,\n  );\n});\n\nit('validation warning occurs when options not for projects is set', async () => {\n  const mockWarn = jest.mocked(console.warn).mockImplementation(() => {});\n  const rootDir = '/root/path/foo';\n  await normalize(\n    {\n      bail: true, // an option not for projects\n      rootDir,\n    },\n    {} as Config.Argv,\n    rootDir,\n    1,\n    true, // isProjectOptions\n  );\n\n  expect(mockWarn).toHaveBeenCalledTimes(1);\n});\n\nit('keeps custom ids based on the rootDir', async () => {\n  const {options} = await normalize(\n    {\n      id: 'custom-id',\n      rootDir: '/root/path/foo',\n    },\n    {} as Config.Argv,\n  );\n\n  expect(options.id).toBe('custom-id');\n});\n\nit('minimal config is stable across runs', async () => {\n  const firstNormalization = await normalize({rootDir: '/root/path/foo'}, {\n    seed: 55_555,\n  } as Config.Argv);\n  const secondNormalization = await normalize({rootDir: '/root/path/foo'}, {\n    seed: 55_555,\n  } as Config.Argv);\n\n  expect(firstNormalization).toEqual(secondNormalization);\n  expect(JSON.stringify(firstNormalization)).toBe(\n    JSON.stringify(secondNormalization),\n  );\n});\n\nit('sets coverageReporters correctly when argv.json is set', async () => {\n  const {options} = await normalize(\n    {\n      rootDir: '/root/path/foo',\n    },\n    {\n      json: true,\n    } as Config.Argv,\n  );\n\n  expect(options.coverageReporters).toEqual(['json', 'lcov', 'clover']);\n});\n\ndescribe('rootDir', () => {\n  it('throws if the options is missing a rootDir property', async () => {\n    expect.assertions(1);\n\n    await expect(\n      normalize({}, {} as Config.Argv),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe('automock', () => {\n  it('falsy automock is not overwritten', async () => {\n    jest.mocked(console.warn).mockImplementation(() => {});\n    const {options} = await normalize(\n      {\n        automock: false,\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.automock).toBe(false);\n  });\n});\n\ndescribe('collectCoverageFrom', () => {\n  it('ignores <rootDir> tokens', async () => {\n    const barBaz = 'bar/baz';\n    const quxQuux = 'qux/quux/';\n    const notQuxQuux = `!${quxQuux}`;\n\n    const {options} = await normalize(\n      {\n        collectCoverageFrom: [\n          barBaz,\n          notQuxQuux,\n          `<rootDir>/${barBaz}`,\n          `!<rootDir>/${quxQuux}`,\n        ],\n        rootDir: '/root/path/foo/',\n      },\n      {} as Config.Argv,\n    );\n\n    const expected = [barBaz, notQuxQuux, barBaz, notQuxQuux];\n\n    expect(options.collectCoverageFrom).toEqual(expected);\n  });\n});\n\ndescribe('findRelatedTests', () => {\n  it('it generates --coverageCoverageFrom patterns when needed', async () => {\n    const sourceFile = 'file1.js';\n\n    const {options} = await normalize(\n      {\n        collectCoverage: true,\n        rootDir: '/root/path/foo/',\n      },\n      {\n        _: [\n          `/root/path/${sourceFile}`,\n          sourceFile,\n          `<rootDir>/bar/${sourceFile}`,\n        ],\n        findRelatedTests: true,\n      } as Config.Argv,\n    );\n\n    const expected = [`../${sourceFile}`, `${sourceFile}`, `bar/${sourceFile}`];\n\n    expect(options.collectCoverageFrom).toEqual(expected);\n  });\n});\n\nfunction testPathArray(key: keyof AllOptions) {\n  it('normalizes all paths relative to rootDir', async () => {\n    const {options} = await normalize(\n      {\n        [key]: ['bar/baz', 'qux/quux/'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options[key]).toEqual([expectedPathFooBar, expectedPathFooQux]);\n  });\n\n  it('does not change absolute paths', async () => {\n    const {options} = await normalize(\n      {\n        [key]: ['/an/abs/path', '/another/abs/path'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options[key]).toEqual([expectedPathAbs, expectedPathAbsAnother]);\n  });\n\n  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        [key]: ['<rootDir>/bar/baz'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options[key]).toEqual([expectedPathFooBar]);\n  });\n}\n\ndescribe('roots', () => {\n  testPathArray('roots');\n});\n\ndescribe('reporters', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => name);\n  });\n\n  it('allows empty list', async () => {\n    const {options} = await normalize(\n      {\n        reporters: [],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.reporters).toEqual([]);\n  });\n\n  it('normalizes the path and options object', async () => {\n    const {options} = await normalize(\n      {\n        reporters: [\n          'default',\n          'github-actions',\n          '<rootDir>/custom-reporter.js',\n          ['<rootDir>/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],\n          ['jest-junit', {outputName: 'report.xml'}],\n        ],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.reporters).toEqual([\n      ['default', {}],\n      ['github-actions', {}],\n      ['/root/custom-reporter.js', {}],\n      ['/root/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],\n      ['jest-junit', {outputName: 'report.xml'}],\n    ]);\n  });\n\n  it('throws an error if value is neither string nor array', async () => {\n    expect.assertions(1);\n    await expect(\n      normalize(\n        {\n          // @ts-expect-error: Testing runtime error\n          reporters: [123],\n          rootDir: '/root/',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('throws an error if first value in the tuple is not a string', async () => {\n    expect.assertions(1);\n    await expect(\n      normalize(\n        {\n          // @ts-expect-error: Testing runtime error\n          reporters: [[123]],\n          rootDir: '/root/',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('throws an error if second value is missing in the tuple', async () => {\n    expect.assertions(1);\n    await expect(\n      normalize(\n        {\n          // @ts-expect-error: Testing runtime error\n          reporters: [['some-reporter']],\n          rootDir: '/root/',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('throws an error if second value in the tuple is not an object', async () => {\n    expect.assertions(1);\n    await expect(\n      normalize(\n        {\n          // @ts-expect-error: Testing runtime error\n          reporters: [['some-reporter', true]],\n          rootDir: '/root/',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe('transform', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => name);\n  });\n\n  it('normalizes the path', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        transform: {\n          [DEFAULT_CSS_PATTERN]: '<rootDir>/node_modules/jest-regex-util',\n          [DEFAULT_JS_PATTERN]: 'babel-jest',\n          'abs-path': '/qux/quux',\n        },\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.transform).toEqual([\n      [DEFAULT_CSS_PATTERN, '/root/node_modules/jest-regex-util', {}],\n      [DEFAULT_JS_PATTERN, require.resolve('babel-jest'), {}],\n      ['abs-path', '/qux/quux', {}],\n    ]);\n  });\n  it(\"pulls in config if it's passed as an array, and defaults to empty object\", async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        transform: {\n          [DEFAULT_CSS_PATTERN]: '<rootDir>/node_modules/jest-regex-util',\n          [DEFAULT_JS_PATTERN]: ['babel-jest', {rootMode: 'upward'}],\n          'abs-path': '/qux/quux',\n        },\n      },\n      {} as Config.Argv,\n    );\n    expect(options.transform).toEqual([\n      [DEFAULT_CSS_PATTERN, '/root/node_modules/jest-regex-util', {}],\n      [DEFAULT_JS_PATTERN, require.resolve('babel-jest'), {rootMode: 'upward'}],\n      ['abs-path', '/qux/quux', {}],\n    ]);\n  });\n});\n\ndescribe('haste', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => name);\n  });\n\n  it('normalizes the path for hasteImplModulePath', async () => {\n    const {options} = await normalize(\n      {\n        haste: {\n          hasteImplModulePath: '<rootDir>/haste_impl.js',\n        },\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.haste).toEqual({\n      hasteImplModulePath: '/root/haste_impl.js',\n    });\n  });\n});\n\ndescribe('setupFilesAfterEnv', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) =>\n      name.startsWith('/') ? name : `/root/path/foo${path.sep}${name}`,\n    );\n  });\n\n  it('normalizes the path according to rootDir', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        setupFilesAfterEnv: ['bar/baz'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.setupFilesAfterEnv).toEqual([expectedPathFooBar]);\n  });\n\n  it('does not change absolute paths', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        setupFilesAfterEnv: ['/an/abs/path'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.setupFilesAfterEnv).toEqual([expectedPathAbs]);\n  });\n\n  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        setupFilesAfterEnv: ['<rootDir>/bar/baz'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.setupFilesAfterEnv).toEqual([expectedPathFooBar]);\n  });\n});\n\ndescribe('coveragePathIgnorePatterns', () => {\n  it('does not normalize paths relative to rootDir', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        coveragePathIgnorePatterns: ['bar/baz', 'qux/quux'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.coveragePathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux'),\n    ]);\n  });\n\n  it('does not normalize trailing slashes', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        coveragePathIgnorePatterns: ['bar/baz', 'qux/quux/'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.coveragePathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux', ''),\n    ]);\n  });\n\n  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        coveragePathIgnorePatterns: ['hasNoToken', '<rootDir>/hasAToken'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.coveragePathIgnorePatterns).toEqual([\n      'hasNoToken',\n      joinForPattern('', 'root', 'path', 'foo', 'hasAToken'),\n    ]);\n  });\n});\n\ndescribe('watchPathIgnorePatterns', () => {\n  it('does not normalize paths relative to rootDir', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        watchPathIgnorePatterns: ['bar/baz', 'qux/quux'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux'),\n    ]);\n  });\n\n  it('does not normalize trailing slashes', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        watchPathIgnorePatterns: ['bar/baz', 'qux/quux/'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux', ''),\n    ]);\n  });\n\n  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        watchPathIgnorePatterns: ['hasNoToken', '<rootDir>/hasAToken'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPathIgnorePatterns).toEqual([\n      'hasNoToken',\n      joinForPattern('', 'root', 'path', 'foo', 'hasAToken'),\n    ]);\n  });\n});\n\ndescribe('testPathIgnorePatterns', () => {\n  it('does not normalize paths relative to rootDir', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        testPathIgnorePatterns: ['bar/baz', 'qux/quux'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testPathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux'),\n    ]);\n  });\n\n  it('does not normalize trailing slashes', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        testPathIgnorePatterns: ['bar/baz', 'qux/quux/'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testPathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux', ''),\n    ]);\n  });\n\n  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n        testPathIgnorePatterns: ['hasNoToken', '<rootDir>/hasAToken'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testPathIgnorePatterns).toEqual([\n      'hasNoToken',\n      joinForPattern('', 'root', 'path', 'foo', 'hasAToken'),\n    ]);\n  });\n});\n\ndescribe('modulePathIgnorePatterns', () => {\n  it('does not normalize paths relative to rootDir', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        modulePathIgnorePatterns: ['bar/baz', 'qux/quux'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.modulePathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux'),\n    ]);\n  });\n\n  it('does not normalize trailing slashes', async () => {\n    // This is a list of patterns, so we can't assume any of them are\n    // directories\n    const {options} = await normalize(\n      {\n        modulePathIgnorePatterns: ['bar/baz', 'qux/quux/'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.modulePathIgnorePatterns).toEqual([\n      joinForPattern('bar', 'baz'),\n      joinForPattern('qux', 'quux', ''),\n    ]);\n  });\n\n  it('substitutes <rootDir> tokens', async () => {\n    const {options} = await normalize(\n      {\n        modulePathIgnorePatterns: ['hasNoToken', '<rootDir>/hasAToken'],\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.modulePathIgnorePatterns).toEqual([\n      'hasNoToken',\n      joinForPattern('', 'root', 'path', 'foo', 'hasAToken'),\n    ]);\n  });\n});\n\ndescribe('testRunner', () => {\n  it('defaults to Circus', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRunner).toMatch('jest-circus');\n  });\n\n  it('resolves jasmine', async () => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => name);\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n      },\n      {\n        testRunner: 'jasmine2',\n      } as Config.Argv,\n    );\n\n    expect(options.testRunner).toMatch('jest-jasmine2');\n  });\n\n  it('is overwritten by argv', async () => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => name);\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n      },\n      {\n        testRunner: 'mocha',\n      } as Config.Argv,\n    );\n\n    expect(options.testRunner).toBe('mocha');\n  });\n});\n\ndescribe('coverageDirectory', () => {\n  it('defaults to <rootDir>/coverage', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.coverageDirectory).toBe('/root/path/foo/coverage');\n  });\n});\n\ndescribe('testEnvironment', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => {\n      if (['jsdom', 'jest-environment-jsdom'].includes(name)) {\n        return `node_modules/${name}`;\n      }\n      if (name.startsWith('/root')) {\n        return name;\n      }\n      return findNodeModule(name);\n    });\n  });\n\n  it('resolves to an environment and prefers jest-environment-`name`', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testEnvironment: 'jsdom',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testEnvironment).toBe('node_modules/jest-environment-jsdom');\n  });\n\n  it('resolves to node environment by default', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testEnvironment).toEqual(\n      require.resolve('jest-environment-node'),\n    );\n  });\n\n  it('throws on invalid environment names', async () => {\n    await expect(\n      normalize(\n        {\n          rootDir: '/root',\n          testEnvironment: 'phantom',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('works with rootDir', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testEnvironment: '<rootDir>/testEnvironment.js',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testEnvironment).toBe('/root/testEnvironment.js');\n  });\n});\n\ndescribe('babel-jest', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) =>\n      name.includes('babel-jest')\n        ? name\n        : `${path.sep}node_modules${path.sep}${name}`,\n    );\n  });\n\n  it('correctly identifies and uses babel-jest', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.transform[0][0]).toBe(DEFAULT_JS_PATTERN);\n    expect(options.transform[0][1]).toEqual(require.resolve('babel-jest'));\n  });\n\n  it('uses babel-jest if babel-jest is explicitly specified in a custom transform options', async () => {\n    const customJSPattern = '\\\\.js$';\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        transform: {\n          [customJSPattern]: 'babel-jest',\n        },\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.transform[0][0]).toBe(customJSPattern);\n    expect(options.transform[0][1]).toEqual(require.resolve('babel-jest'));\n  });\n});\n\ndescribe('testRegex', () => {\n  it('testRegex empty string is mapped to empty array', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testRegex: '',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRegex).toEqual([]);\n  });\n  it('testRegex string is mapped to an array', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testRegex: '.*',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRegex).toEqual(['.*']);\n  });\n  it('testRegex array is preserved', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testRegex: ['.*', 'foo\\\\.bar'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRegex).toEqual(['.*', 'foo\\\\.bar']);\n  });\n});\n\ndescribe('testMatch', () => {\n  it('testMatch default not applied if testRegex is set', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testRegex: '.*',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testMatch).toHaveLength(0);\n  });\n\n  it('testRegex default not applied if testMatch is set', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testMatch: ['**/*.js'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testRegex).toEqual([]);\n  });\n\n  it('throws if testRegex and testMatch are both specified', async () => {\n    await expect(\n      normalize(\n        {\n          rootDir: '/root',\n          testMatch: ['**/*.js'],\n          testRegex: '.*',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('normalizes testMatch', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root',\n        testMatch: ['<rootDir>/**/*.js'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.testMatch).toEqual(['/root/**/*.js']);\n  });\n});\n\ndescribe('moduleDirectories', () => {\n  it('defaults to node_modules', async () => {\n    const {options} = await normalize({rootDir: '/root'}, {} as Config.Argv);\n\n    expect(options.moduleDirectories).toEqual(['node_modules']);\n  });\n\n  it('normalizes moduleDirectories', async () => {\n    const {options} = await normalize(\n      {\n        moduleDirectories: ['<rootDir>/src', '<rootDir>/node_modules'],\n        rootDir: '/root',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.moduleDirectories).toEqual([\n      '/root/src',\n      '/root/node_modules',\n    ]);\n  });\n});\n\ndescribe('preset', () => {\n  beforeEach(() => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => {\n      if (name === 'react-native/jest-preset') {\n        return '/node_modules/react-native/jest-preset.json';\n      }\n\n      if (name === 'react-native-js-preset/jest-preset') {\n        return '/node_modules/react-native-js-preset/jest-preset.js';\n      }\n\n      if (name === 'cjs-preset/jest-preset') {\n        return '/node_modules/cjs-preset/jest-preset.cjs';\n      }\n\n      if (name === 'mjs-preset/jest-preset') {\n        return '/node_modules/mjs-preset/jest-preset.mjs';\n      }\n\n      if (name.includes('doesnt-exist')) {\n        return null;\n      }\n\n      return `/node_modules/${name}`;\n    });\n    jest.doMock(\n      '/node_modules/react-native/jest-preset.json',\n      () => ({\n        moduleNameMapper: {b: 'b'},\n        modulePathIgnorePatterns: ['b'],\n        setupFiles: ['b'],\n        setupFilesAfterEnv: ['b'],\n        transform: {b: 'b'},\n      }),\n      {virtual: true},\n    );\n    jest.doMock(\n      '/node_modules/react-native-js-preset/jest-preset.js',\n      () => ({\n        moduleNameMapper: {\n          json: true,\n        },\n      }),\n      {virtual: true},\n    );\n    jest.doMock(\n      '/node_modules/cjs-preset/jest-preset.cjs',\n      () => ({\n        moduleNameMapper: {\n          cjs: true,\n        },\n      }),\n      {virtual: true},\n    );\n    jest.doMock(\n      '/node_modules/mjs-preset/jest-preset.mjs',\n      () => ({\n        moduleNameMapper: {\n          mjs: true,\n        },\n      }),\n      {virtual: true},\n    );\n  });\n\n  afterEach(() => {\n    jest.dontMock('/node_modules/react-native/jest-preset.json');\n    jest.dontMock('/node_modules/react-native-js-preset/jest-preset.js');\n    jest.dontMock('/node_modules/cjs-preset/jest-preset.cjs');\n    jest.dontMock('/node_modules/mjs-preset/jest-preset.mjs');\n  });\n\n  test('throws when preset not found', async () => {\n    await expect(\n      normalize(\n        {\n          preset: 'doesnt-exist',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  test('throws when module was found but no \"jest-preset.js\" or \"jest-preset.json\" files', async () => {\n    await expect(\n      normalize(\n        {\n          preset: 'exist-but-no-jest-preset',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  test('throws when a dependency is missing in the preset', async () => {\n    jest.doMock(\n      '/node_modules/react-native-js-preset/jest-preset.js',\n      () => {\n        require('library-that-is-not-installed');\n        return {\n          transform: {} as Config.Argv,\n        };\n      },\n      {virtual: true},\n    );\n\n    await expect(\n      normalize(\n        {\n          preset: 'react-native-js-preset',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow(/Cannot find module 'library-that-is-not-installed'/);\n  });\n\n  test('throws when preset is invalid', async () => {\n    jest.doMock('/node_modules/react-native/jest-preset.json', () =>\n      jest.requireActual('./jest-preset.json'),\n    );\n\n    const errorMessage = semver.satisfies(process.versions.node, '<19.0.0')\n      ? /Unexpected token } in JSON at position (104|110)[\\S\\s]* at /\n      : 'SyntaxError: Expected double-quoted property name in JSON at position 104';\n\n    await expect(\n      normalize(\n        {\n          preset: 'react-native',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow(errorMessage);\n  });\n\n  test('throws when preset evaluation throws type error', async () => {\n    jest.doMock(\n      '/node_modules/react-native-js-preset/jest-preset.js',\n      () => ({\n        // @ts-expect-error: Testing runtime error\n        // eslint-disable-next-line unicorn/prefer-prototype-methods\n        transform: {}.nonExistingProp.call(),\n      }),\n      {virtual: true},\n    );\n\n    const errorMessage = semver.satisfies(process.versions.node, '<16.9.1')\n      ? /TypeError: Cannot read property 'call' of undefined[\\S\\s]* at /\n      : \"TypeError: Cannot read properties of undefined (reading 'call')\";\n\n    await expect(\n      normalize(\n        {\n          preset: 'react-native-js-preset',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow(errorMessage);\n  });\n\n  test('works with \"react-native\"', async () => {\n    await expect(\n      normalize(\n        {\n          preset: 'react-native',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).resolves.not.toThrow();\n  });\n\n  test.each(['react-native-js-preset', 'cjs-preset'])(\n    'works with cjs preset',\n    async preset => {\n      await expect(\n        normalize(\n          {\n            preset,\n            rootDir: '/root/path/foo',\n          },\n          {} as Config.Argv,\n        ),\n      ).resolves.not.toThrow();\n    },\n  );\n\n  test('works with esm preset', async () => {\n    await expect(\n      normalize(\n        {\n          preset: 'mjs-preset',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      ),\n    ).resolves.not.toThrow();\n  });\n\n  test('searches for .json, .js, .cjs, .mjs preset files', async () => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n\n    await normalize(\n      {\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    const options = jest.mocked(Resolver.findNodeModule).mock.calls[0][1];\n    expect(options.extensions).toEqual(['.json', '.js', '.cjs', '.mjs']);\n  });\n\n  test('merges with options', async () => {\n    const {options} = await normalize(\n      {\n        moduleNameMapper: {a: 'a'},\n        modulePathIgnorePatterns: ['a'],\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n        setupFiles: ['a'],\n        setupFilesAfterEnv: ['a'],\n        transform: {a: 'a'},\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.moduleNameMapper).toEqual([\n      ['a', 'a'],\n      ['b', 'b'],\n    ]);\n    expect(options.modulePathIgnorePatterns).toEqual(['b', 'a']);\n    expect(options.setupFiles.sort()).toEqual([\n      '/node_modules/a',\n      '/node_modules/b',\n    ]);\n    expect(options.setupFilesAfterEnv.sort()).toEqual([\n      '/node_modules/a',\n      '/node_modules/b',\n    ]);\n    expect(options.transform).toEqual([\n      ['a', '/node_modules/a', {}],\n      ['b', '/node_modules/b', {}],\n    ]);\n  });\n\n  test('merges with options and moduleNameMapper preset is overridden by options', async () => {\n    // Object initializer not used for properties as a workaround for\n    //  sort-keys eslint rule while specifying properties in\n    //  non-alphabetical order for a better test\n    const moduleNameMapper = {} as Record<string, string>;\n    moduleNameMapper.e = 'ee';\n    moduleNameMapper.b = 'bb';\n    moduleNameMapper.c = 'cc';\n    moduleNameMapper.a = 'aa';\n    const {options} = await normalize(\n      {\n        moduleNameMapper,\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.moduleNameMapper).toEqual([\n      ['e', 'ee'],\n      ['b', 'bb'],\n      ['c', 'cc'],\n      ['a', 'aa'],\n    ]);\n  });\n\n  test('merges with options and transform preset is overridden by options', async () => {\n    /* eslint-disable sort-keys */\n    const transform = {\n      e: 'ee',\n      b: 'bb',\n      c: 'cc',\n      a: 'aa',\n    };\n    /* eslint-enable */\n    const {options} = await normalize(\n      {\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n        transform,\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.transform).toEqual([\n      ['e', '/node_modules/ee', {}],\n      ['b', '/node_modules/bb', {}],\n      ['c', '/node_modules/cc', {}],\n      ['a', '/node_modules/aa', {}],\n    ]);\n  });\n\n  test('extracts setupFilesAfterEnv from preset', async () => {\n    const {options} = await normalize(\n      {\n        preset: 'react-native',\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.setupFilesAfterEnv).toEqual(['/node_modules/b']);\n  });\n});\n\ndescribe('preset with globals', () => {\n  beforeEach(() => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => {\n      if (name === 'global-foo/jest-preset') {\n        return '/node_modules/global-foo/jest-preset.json';\n      }\n\n      return `/node_modules/${name}`;\n    });\n    jest.doMock(\n      '/node_modules/global-foo/jest-preset.json',\n      () => ({\n        globals: {\n          __DEV__: false,\n          config: {\n            hereToStay: 'This should stay here',\n          },\n          myString: 'hello world',\n        },\n      }),\n      {virtual: true},\n    );\n  });\n\n  afterEach(() => {\n    jest.dontMock('/node_modules/global-foo/jest-preset.json');\n  });\n\n  test('should merge the globals preset correctly', async () => {\n    const {options} = await normalize(\n      {\n        globals: {\n          __DEV__: true,\n          config: {\n            sideBySide: 'This should also live another day',\n          },\n          myString: 'hello sunshine',\n          textValue: 'This is just text',\n        },\n        preset: 'global-foo',\n        rootDir: '/root/path/foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.globals).toEqual({\n      __DEV__: true,\n      config: {\n        hereToStay: 'This should stay here',\n        sideBySide: 'This should also live another day',\n      },\n      myString: 'hello sunshine',\n      textValue: 'This is just text',\n    });\n  });\n});\n\ndescribe.each(['setupFiles', 'setupFilesAfterEnv'] as const)(\n  'preset without %s',\n  configKey => {\n    let Resolver;\n    beforeEach(() => {\n      Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n        .default;\n      Resolver.findNodeModule = jest.fn(\n        name => `${path.sep}node_modules${path.sep}${name}`,\n      );\n    });\n\n    beforeAll(() => {\n      jest.doMock(\n        '/node_modules/react-foo/jest-preset',\n        () => ({\n          moduleNameMapper: {b: 'b'},\n          modulePathIgnorePatterns: ['b'],\n        }),\n        {virtual: true},\n      );\n    });\n\n    afterAll(() => {\n      jest.dontMock('/node_modules/react-foo/jest-preset');\n    });\n\n    it(`should normalize ${configKey} correctly`, async () => {\n      const {options} = await normalize(\n        {\n          [configKey]: ['a'],\n          preset: 'react-foo',\n          rootDir: '/root/path/foo',\n        },\n        {} as Config.Argv,\n      );\n\n      expect(options).toEqual(\n        expect.objectContaining({[configKey]: ['/node_modules/a']}),\n      );\n    });\n  },\n);\n\ndescribe(\"preset with 'reporters' option\", () => {\n  beforeEach(() => {\n    const Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => {\n      if (name === 'with-reporters/jest-preset') {\n        return '/node_modules/with-reporters/jest-preset.json';\n      }\n\n      return `/node_modules/${name}`;\n    });\n    jest.doMock(\n      '/node_modules/with-reporters/jest-preset.json',\n      () => ({\n        reporters: ['default'],\n      }),\n      {virtual: true},\n    );\n  });\n\n  afterEach(() => {\n    jest.dontMock('/node_modules/with-reporters/jest-preset.json');\n  });\n\n  test(\"normalizes 'reporters' option defined in preset\", async () => {\n    const {options} = await normalize(\n      {\n        preset: 'with-reporters',\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.reporters).toEqual([['default', {}]]);\n  });\n\n  test(\"overrides 'reporters' option defined in preset\", async () => {\n    const {options} = await normalize(\n      {\n        preset: 'with-reporters',\n        reporters: ['summary'],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.reporters).toEqual([['summary', {}]]);\n  });\n});\n\ndescribe('runner', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => {\n      if (['eslint', 'jest-runner-eslint', 'my-runner-foo'].includes(name)) {\n        return `node_modules/${name}`;\n      }\n      if (name.startsWith('/root')) {\n        return name;\n      }\n      return findNodeModule(name);\n    });\n  });\n\n  it('defaults to `jest-runner`', async () => {\n    const {options} = await normalize({rootDir: '/root'}, {} as Config.Argv);\n\n    expect(options.runner).toBe(require.resolve('jest-runner'));\n  });\n\n  it('resolves to runners that do not have the prefix', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        runner: 'my-runner-foo',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.runner).toBe('node_modules/my-runner-foo');\n  });\n\n  it('resolves to runners and prefers jest-runner-`name`', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        runner: 'eslint',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.runner).toBe('node_modules/jest-runner-eslint');\n  });\n\n  it('throw error when a runner is not found', async () => {\n    await expect(\n      normalize(\n        {\n          rootDir: '/root/',\n          runner: 'missing-runner',\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe('watchPlugins', () => {\n  let Resolver: typeof import('jest-resolve').default;\n  beforeEach(() => {\n    Resolver = (require('jest-resolve') as typeof import('jest-resolve'))\n      .default;\n    Resolver.findNodeModule = jest.fn((name: string) => {\n      if (\n        ['typeahead', 'jest-watch-typeahead', 'my-watch-plugin'].includes(name)\n      ) {\n        return `node_modules/${name}`;\n      }\n\n      if (name.startsWith('/root')) {\n        return name;\n      }\n      return findNodeModule(name);\n    });\n  });\n\n  it('defaults to undefined', async () => {\n    const {options} = await normalize({rootDir: '/root'}, {} as Config.Argv);\n\n    expect(options.watchPlugins).toBeUndefined();\n  });\n\n  it('resolves to watch plugins and prefers jest-watch-`name`', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        watchPlugins: ['typeahead'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPlugins).toEqual([\n      {config: {} as Config.Argv, path: 'node_modules/jest-watch-typeahead'},\n    ]);\n  });\n\n  it('resolves watch plugins that do not have the prefix', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        watchPlugins: ['my-watch-plugin'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPlugins).toEqual([\n      {config: {} as Config.Argv, path: 'node_modules/my-watch-plugin'},\n    ]);\n  });\n\n  it('normalizes multiple watchPlugins', async () => {\n    const {options} = await normalize(\n      {\n        rootDir: '/root/',\n        watchPlugins: ['jest-watch-typeahead', '<rootDir>/path/to/plugin'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(options.watchPlugins).toEqual([\n      {config: {} as Config.Argv, path: 'node_modules/jest-watch-typeahead'},\n      {config: {} as Config.Argv, path: '/root/path/to/plugin'},\n    ]);\n  });\n\n  it('throw error when a watch plugin is not found', async () => {\n    await expect(\n      normalize(\n        {\n          rootDir: '/root/',\n          watchPlugins: ['missing-plugin'],\n        },\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe('testPathPatterns', () => {\n  const initialOptions = {rootDir: '/root'};\n  const consoleLog = console.log;\n\n  beforeEach(() => {\n    console.log = jest.fn();\n  });\n\n  afterEach(() => {\n    console.log = consoleLog;\n  });\n\n  it('defaults to empty', async () => {\n    const {options} = await normalize(initialOptions, {} as Config.Argv);\n\n    expect(options.testPathPatterns.patterns).toEqual([]);\n  });\n\n  const cliOptions = [\n    {name: '--testPathPatterns', property: 'testPathPatterns'},\n    {name: '<regexForTestFiles>', property: '_'},\n  ];\n  for (const opt of cliOptions) {\n    describe(opt.name, () => {\n      it(`uses ${opt.name} if set`, async () => {\n        const argv = {[opt.property]: ['a/b']} as Config.Argv;\n        const {options} = await normalize(initialOptions, argv);\n\n        expect(options.testPathPatterns.patterns).toEqual(['a/b']);\n      });\n\n      it('ignores invalid regular expressions and logs a warning', async () => {\n        const argv = {[opt.property]: ['a(']} as Config.Argv;\n        const {options} = await normalize(initialOptions, argv);\n\n        expect(options.testPathPatterns.patterns).toEqual([]);\n        expect(jest.mocked(console.log).mock.calls[0][0]).toMatchSnapshot();\n      });\n\n      it(`joins multiple ${opt.name} if set`, async () => {\n        const argv = {[opt.property]: ['a/b', 'c/d']} as Config.Argv;\n        const {options} = await normalize(initialOptions, argv);\n\n        expect(options.testPathPatterns.patterns).toEqual(['a/b', 'c/d']);\n      });\n    });\n  }\n\n  it('coerces <regexForTestFiles> patterns to strings', async () => {\n    const argv = {_: [1]} as Config.Argv;\n    const {options} = await normalize(initialOptions, argv);\n\n    expect(options.testPathPatterns.patterns).toEqual(['1']);\n  });\n\n  it('joins multiple --testPathPatterns and <regexForTestFiles>', async () => {\n    const {options} = await normalize(initialOptions, {\n      _: ['a', 'b'],\n      testPathPatterns: ['c', 'd'],\n    } as Config.Argv);\n    expect(options.testPathPatterns.patterns).toEqual(['a', 'b', 'c', 'd']);\n  });\n\n  it('gives precedence to --all', async () => {\n    const {options} = await normalize(initialOptions, {\n      all: true,\n      onlyChanged: true,\n    } as Config.Argv);\n\n    expect(options.onlyChanged).toBe(false);\n  });\n});\n\ndescribe('moduleFileExtensions', () => {\n  it('defaults to something useful', async () => {\n    const {options} = await normalize({rootDir: '/root'}, {} as Config.Argv);\n\n    expect(options.moduleFileExtensions).toEqual([\n      'js',\n      'mjs',\n      'cjs',\n      'jsx',\n      'ts',\n      'mts',\n      'cts',\n      'tsx',\n      'json',\n      'node',\n    ]);\n  });\n\n  it.each([undefined, 'jest-runner'] as const)(\n    'throws if missing `js` but using jest-runner',\n    async runner => {\n      await expect(\n        normalize(\n          {\n            moduleFileExtensions: ['json', 'jsx'],\n            rootDir: '/root/',\n            runner,\n          },\n          {} as Config.Argv,\n        ),\n      ).rejects.toThrow(\"moduleFileExtensions must include 'js'\");\n    },\n  );\n\n  it('does not throw if missing `js` with a custom runner', async () => {\n    await expect(\n      normalize(\n        {\n          moduleFileExtensions: ['json', 'jsx'],\n          rootDir: '/root/',\n          runner: './', // does not need to be a valid runner for this validation\n        },\n        {} as Config.Argv,\n      ),\n    ).resolves.not.toThrow();\n  });\n});\n\ndescribe('cwd', () => {\n  it('is set to process.cwd', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n    expect(options.cwd).toBe(process.cwd());\n  });\n\n  it('is not lost if the config has its own cwd property', async () => {\n    jest.mocked(console.warn).mockImplementation(() => {});\n    const {options} = await normalize(\n      {\n        cwd: '/tmp/config-sets-cwd-itself',\n        rootDir: '/root/',\n      } as Config.InitialOptions,\n      {} as Config.Argv,\n    );\n    expect(options.cwd).toBe(process.cwd());\n    expect(console.warn).toHaveBeenCalled();\n  });\n});\n\ndescribe('Defaults', () => {\n  it('should be accepted by normalize', async () => {\n    await normalize({...Defaults, rootDir: '/root'}, {} as Config.Argv);\n\n    expect(console.warn).not.toHaveBeenCalled();\n  });\n});\n\ndescribe('displayName', () => {\n  test.each<{displayName: Config.DisplayName; description: string}>`\n    displayName             | description\n    ${{}}                   | ${'is an empty object'}\n    ${{name: 'hello'}}      | ${'missing color'}\n    ${{color: 'green'}}     | ${'missing name'}\n    ${{color: 2, name: []}} | ${'using invalid values'}\n  `(\n    'should throw an error when displayName is $description',\n    async ({displayName}) => {\n      await expect(\n        normalize(\n          {\n            displayName,\n            rootDir: '/root/',\n          },\n          {} as Config.Argv,\n        ),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    },\n  );\n\n  it.each([\n    undefined,\n    'jest-runner',\n    'jest-runner-eslint',\n    'jest-runner-tslint',\n    'jest-runner-tsc',\n  ])('generates a default color for the runner %s', async runner => {\n    virtualModuleRegexes.push(/jest-runner-.+/);\n    const {\n      options: {displayName},\n    } = await normalize(\n      {\n        displayName: 'project',\n        rootDir: '/root/',\n        runner,\n      },\n      {} as Config.Argv,\n    );\n    expect(displayName!.name).toBe('project');\n    expect(displayName!.color).toMatchSnapshot();\n  });\n});\n\ndescribe('testTimeout', () => {\n  it('should return timeout value if defined', async () => {\n    jest.mocked(console.warn).mockImplementation(() => {});\n    const {options} = await normalize(\n      {rootDir: '/root/', testTimeout: 1000},\n      {} as Config.Argv,\n    );\n\n    expect(options.testTimeout).toBe(1000);\n    expect(console.warn).not.toHaveBeenCalled();\n  });\n\n  it('should throw an error if timeout is a negative number', async () => {\n    await expect(\n      normalize({rootDir: '/root/', testTimeout: -1}, {} as Config.Argv),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe('extensionsToTreatAsEsm', () => {\n  async function matchErrorSnapshot(callback: {\n    (): Promise<{\n      hasDeprecationWarnings: boolean;\n      options: Config.ProjectConfig & Config.GlobalConfig;\n    }>;\n    (): Promise<{\n      hasDeprecationWarnings: boolean;\n      options: Config.ProjectConfig & Config.GlobalConfig;\n    }>;\n    (): any;\n  }) {\n    await expect(callback()).rejects.toThrowErrorMatchingSnapshot();\n  }\n\n  it('should pass valid config through', async () => {\n    const {options} = await normalize(\n      {extensionsToTreatAsEsm: ['.ts'], rootDir: '/root/'},\n      {} as Config.Argv,\n    );\n\n    expect(options.extensionsToTreatAsEsm).toEqual(['.ts']);\n  });\n\n  it('should enforce leading dots', async () => {\n    await matchErrorSnapshot(async () =>\n      normalize(\n        {extensionsToTreatAsEsm: ['ts'], rootDir: '/root/'},\n        {} as Config.Argv,\n      ),\n    );\n  });\n\n  it.each(['.js', '.mjs', '.cjs'])('throws on %s', async ext => {\n    await matchErrorSnapshot(async () =>\n      normalize(\n        {extensionsToTreatAsEsm: [ext], rootDir: '/root/'},\n        {} as Config.Argv,\n      ),\n    );\n  });\n});\n\ndescribe('haste.enableSymlinks', () => {\n  it('should throw if watchman is not disabled', async () => {\n    await expect(\n      normalize(\n        {haste: {enableSymlinks: true}, rootDir: '/root/'},\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow('haste.enableSymlinks is incompatible with watchman');\n\n    await expect(\n      normalize(\n        {haste: {enableSymlinks: true}, rootDir: '/root/', watchman: true},\n        {} as Config.Argv,\n      ),\n    ).rejects.toThrow('haste.enableSymlinks is incompatible with watchman');\n\n    const {options} = await normalize(\n      {haste: {enableSymlinks: true}, rootDir: '/root/', watchman: false},\n      {} as Config.Argv,\n    );\n\n    expect(options.haste.enableSymlinks).toBe(true);\n    expect(options.watchman).toBe(false);\n  });\n});\n\ndescribe('haste.forceNodeFilesystemAPI', () => {\n  it('should pass option through', async () => {\n    const {options} = await normalize(\n      {haste: {forceNodeFilesystemAPI: true}, rootDir: '/root/'},\n      {} as Config.Argv,\n    );\n\n    expect(options.haste.forceNodeFilesystemAPI).toBe(true);\n    expect(console.warn).not.toHaveBeenCalled();\n  });\n});\n\ndescribe('updateSnapshot', () => {\n  it('should be all if updateSnapshot is true', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      updateSnapshot: true,\n    } as Config.Argv);\n    expect(options.updateSnapshot).toBe('all');\n  });\n  it('should be new if updateSnapshot is falsy', async () => {\n    {\n      const {options} = await normalize(\n        {ci: false, rootDir: '/root/'},\n        {} as Config.Argv,\n      );\n      expect(options.updateSnapshot).toBe('new');\n    }\n    {\n      const {options} = await normalize({ci: false, rootDir: '/root/'}, {\n        updateSnapshot: false,\n      } as Config.Argv);\n      expect(options.updateSnapshot).toBe('new');\n    }\n  });\n  it('should be none if updateSnapshot is falsy and ci mode is true', async () => {\n    const defaultCiConfig = Defaults.ci;\n    {\n      Defaults.ci = false;\n      const {options} = await normalize({rootDir: '/root/'}, {\n        ci: true,\n      } as Config.Argv);\n      expect(options.updateSnapshot).toBe('none');\n    }\n    {\n      Defaults.ci = true;\n      const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n      expect(options.updateSnapshot).toBe('none');\n    }\n    Defaults.ci = defaultCiConfig;\n  });\n});\n\ndescribe('shards', () => {\n  it('should be object if defined', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      shard: '1/2',\n    } as Config.Argv);\n\n    expect(options.shard).toEqual({shardCount: 2, shardIndex: 1});\n  });\n});\n\ndescribe('logs a deprecation warning', () => {\n  beforeEach(() => {\n    jest.mocked(console.warn).mockImplementation(() => {});\n  });\n\n  test(\"when 'browser' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        browser: true,\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'collectCoverageOnlyFrom' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        collectCoverageOnlyFrom: {\n          '<rootDir>/this-directory-is-covered/Covered.js': true,\n        },\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'extraGlobals' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        extraGlobals: ['Math'],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'moduleLoader' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        moduleLoader: '<rootDir>/runtime.js',\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'preprocessorIgnorePatterns' option is passed\", async () => {\n    await normalize(\n      {\n        // @ts-expect-error: Testing deprecated option\n        preprocessorIgnorePatterns: ['/node_modules/'],\n        rootDir: '/root/',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'scriptPreprocessor' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        scriptPreprocessor: 'preprocessor.js',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'setupTestFrameworkScriptFile' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        setupTestFrameworkScriptFile: 'setup.js',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'testPathDirs' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        testPathDirs: ['<rootDir>'],\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'testURL' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        testURL: 'https://jestjs.io',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n\n  test(\"when 'timers' option is passed\", async () => {\n    await normalize(\n      {\n        rootDir: '/root/',\n        // @ts-expect-error: Testing deprecated option\n        timers: 'real',\n      },\n      {} as Config.Argv,\n    );\n\n    expect(console.warn).toMatchSnapshot();\n  });\n});\n\nit('parses workerIdleMemoryLimit', async () => {\n  const {options} = await normalize(\n    {\n      rootDir: '/root/',\n      workerIdleMemoryLimit: '45MiB',\n    },\n    {} as Config.Argv,\n  );\n\n  expect(options.workerIdleMemoryLimit).toBe(47_185_920);\n});\n\ndescribe('seed', () => {\n  it('generates seed when not specified', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n    expect(options.seed).toEqual(expect.any(Number));\n  });\n\n  it('uses seed specified', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      seed: 4321,\n    } as Config.Argv);\n    expect(options.seed).toBe(4321);\n  });\n\n  it('throws if seed is too large or too small', async () => {\n    await expect(\n      normalize({rootDir: '/root/'}, {\n        seed: 2 ** 33,\n      } as Config.Argv),\n    ).rejects.toThrow(\n      'seed value must be between `-0x80000000` and `0x7fffffff` inclusive - instead it is 8589934592',\n    );\n    await expect(\n      normalize({rootDir: '/root/'}, {\n        seed: -(2 ** 33),\n      } as Config.Argv),\n    ).rejects.toThrow(\n      'seed value must be between `-0x80000000` and `0x7fffffff` inclusive - instead it is -8589934592',\n    );\n  });\n});\n\ndescribe('showSeed', () => {\n  test('showSeed is set when argv flag is set', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      showSeed: true,\n    } as Config.Argv);\n    expect(options.showSeed).toBe(true);\n  });\n\n  test('showSeed is set when the config is set', async () => {\n    const {options} = await normalize(\n      {rootDir: '/root/', showSeed: true},\n      {} as Config.Argv,\n    );\n    expect(options.showSeed).toBe(true);\n  });\n\n  test('showSeed is false when neither is set', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n    expect(options.showSeed).toBeFalsy();\n  });\n\n  test('showSeed is true when randomize is set', async () => {\n    const {options} = await normalize(\n      {randomize: true, rootDir: '/root/'},\n      {} as Config.Argv,\n    );\n    expect(options.showSeed).toBe(true);\n  });\n});\n\ndescribe('randomize', () => {\n  test('randomize is set when argv flag is set', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      randomize: true,\n    } as Config.Argv);\n    expect(options.randomize).toBe(true);\n  });\n\n  test('randomize is set when the config is set', async () => {\n    const {options} = await normalize(\n      {randomize: true, rootDir: '/root/'},\n      {} as Config.Argv,\n    );\n    expect(options.randomize).toBe(true);\n  });\n\n  test('randomize is false when neither is set', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n    expect(options.randomize).toBeFalsy();\n  });\n});\n\ndescribe('runInBand', () => {\n  test('always set it', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {} as Config.Argv);\n    expect(options.runInBand).toBe(false);\n  });\n\n  test('respect argv', async () => {\n    const {options} = await normalize({rootDir: '/root/'}, {\n      runInBand: true,\n    } as Config.Argv);\n    expect(options.runInBand).toBe(true);\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`displayName generates a default color for the runner jest-runner 1`] = `\"yellow\"`;\n\nexports[`displayName generates a default color for the runner jest-runner-eslint 1`] = `\"magenta\"`;\n\nexports[`displayName generates a default color for the runner jest-runner-tsc 1`] = `\"red\"`;\n\nexports[`displayName generates a default color for the runner jest-runner-tslint 1`] = `\"green\"`;\n\nexports[`displayName generates a default color for the runner undefined 1`] = `\"white\"`;\n\nexports[`displayName should throw an error when displayName is is an empty object 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Option \"<bold>displayName</intensity>\" must be of type:</color>\n<red></color>\n<red>  {</color>\n<red>    name: string;</color>\n<red>    color: string;</color>\n<red>  }</color>\n<red></color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`displayName should throw an error when displayName is missing color 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Option \"<bold>displayName</intensity>\" must be of type:</color>\n<red></color>\n<red>  {</color>\n<red>    name: string;</color>\n<red>    color: string;</color>\n<red>  }</color>\n<red></color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`displayName should throw an error when displayName is missing name 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Option \"<bold>displayName</intensity>\" must be of type:</color>\n<red></color>\n<red>  {</color>\n<red>    name: string;</color>\n<red>    color: string;</color>\n<red>  }</color>\n<red></color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`displayName should throw an error when displayName is using invalid values 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Option \"<bold>displayName</intensity>\" must be of type:</color>\n<red></color>\n<red>  {</color>\n<red>    name: string;</color>\n<red>    color: string;</color>\n<red>  }</color>\n<red></color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`extensionsToTreatAsEsm should enforce leading dots 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Option: <bold>extensionsToTreatAsEsm: ['ts']</intensity> includes a string that does not start with a period (<bold>.</intensity>).</color>\n<red>  Please change your configuration to <bold>extensionsToTreatAsEsm: ['.ts']</intensity>.</color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`extensionsToTreatAsEsm throws on .cjs 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Option: <bold>extensionsToTreatAsEsm: ['.cjs']</intensity> includes <bold>'.cjs'</intensity> which is always treated as CommonJS.</color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`extensionsToTreatAsEsm throws on .js 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Option: <bold>extensionsToTreatAsEsm: ['.js']</intensity> includes <bold>'.js'</intensity> which is always inferred based on <bold>type</intensity> in its nearest <bold>package.json</intensity>.</color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`extensionsToTreatAsEsm throws on .mjs 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Option: <bold>extensionsToTreatAsEsm: ['.mjs']</intensity> includes <bold>'.mjs'</intensity> which is always treated as an ECMAScript Module.</color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`logs a deprecation warning when 'browser' option is passed 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [\n      \"<yellow><bold><bold>●</intensity><bold> Deprecation Warning</intensity>:</color>\n<yellow></color>\n<yellow>  Option <bold>\"browser\"</intensity> has been deprecated. Please install \"browser-resolve\" and use the \"resolver\" option in Jest configuration as shown in the documentation: https://jestjs.io/docs/configuration#resolver-string</color>\n<yellow></color>\n<yellow>  <bold>Configuration Documentation:</intensity></color>\n<yellow>  https://jestjs.io/docs/configuration</color>\n<yellow></color>\",\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": undefined,\n    },\n  ],\n}\n`;\n\nexports[`logs a deprecation warning when 'collectCoverageOnlyFrom' option is passed 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [\n      \"<yellow><bold><bold>●</intensity><bold> Deprecation Warning</intensity>:</color>\n<yellow></color>\n<yellow>  Option <bold>\"collectCoverageOnlyFrom\"</intensity> was replaced by <bold>\"collectCoverageFrom\"</intensity>.</color>\n<yellow></color>\n<yellow>    Please update your configuration.</color>\n<yellow></color>\n<yellow>  <bold>Configuration Documentation:</intensity></color>\n<yellow>  https://jestjs.io/docs/configuration</color>\n<yellow></color>\",\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": undefined,\n    },\n  ],\n}\n`;\n\nexports[`logs a deprecation warning when 'extraGlobals' option is passed 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [\n      \"<yellow><bold><bold>●</intensity><bold> Deprecation Warning</intensity>:</color>\n<yellow></color>\n<yellow>  Option <bold>\"extraGlobals\"</intensity> was replaced by <bold>\"sandboxInjectedGlobals\"</intensity>.</color>\n<yellow></color>\n<yellow>  Please update your configuration.</color>\n<yellow></color>\n<yellow>  <bold>Configuration Documentation:</intensity></color>\n<yellow>  https://jestjs.io/docs/configuration</color>\n<yellow></color>\",\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": undefined,\n    },\n  ],\n}\n`;\n\nexports[`logs a deprecation warning when 'moduleLoader' option is passed 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [\n      \"<yellow><bold><bold>●</intensity><bold> Deprecation Warning</intensity>:</color>\n<yellow></color>\n<yellow>  Option <bold>\"moduleLoader\"</intensity> was replaced by <bold>\"runtime\"</intensity>.</color>\n<yellow></color>\n<yellow>  Please update your configuration.</color>\n<yellow></color>\n<yellow>  <bold>Configuration Documentation:</intensity></color>\n<yellow>  https://jestjs.io/docs/configuration</color>\n<yellow></color>\",\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": undefined,\n    },\n  ],\n}\n`;\n\nexports[`logs a deprecation warning when 'preprocessorIgnorePatterns' option is passed 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [\n      \"<yellow><bold><bold>●</intensity><bold> Deprecation Warning</intensity>:</color>\n<yellow></color>\n<yellow>  Option <bold>\"preprocessorIgnorePatterns\"</intensity> was replaced by <bold>\"transformIgnorePatterns\"</intensity>, which support multiple preprocessors.</color>\n<yellow></color>\n<yellow>  Please update your configuration.</color>\n<yellow></color>\n<yellow>  <bold>Configuration Documentation:</intensity></color>\n<yellow>  https://jestjs.io/docs/configuration</color>\n<yellow></color>\",\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": undefined,\n    },\n  ],\n}\n`;\n\nexports[`logs a deprecation warning when 'scriptPreprocessor' option is passed 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [\n      \"<yellow><bold><bold>●</intensity><bold> Deprecation Warning</intensity>:</color>\n<yellow></color>\n<yellow>  Option <bold>\"scriptPreprocessor\"</intensity> was replaced by <bold>\"transform\"</intensity>, which support multiple preprocessors.</color>\n<yellow></color>\n<yellow>  Please update your configuration.</color>\n<yellow></color>\n<yellow>  <bold>Configuration Documentation:</intensity></color>\n<yellow>  https://jestjs.io/docs/configuration</color>\n<yellow></color>\",\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": undefined,\n    },\n  ],\n}\n`;\n\nexports[`logs a deprecation warning when 'setupTestFrameworkScriptFile' option is passed 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [\n      \"<yellow><bold><bold>●</intensity><bold> Deprecation Warning</intensity>:</color>\n<yellow></color>\n<yellow>  Option <bold>\"setupTestFrameworkScriptFile\"</intensity> was replaced by configuration <bold>\"setupFilesAfterEnv\"</intensity>, which supports multiple paths.</color>\n<yellow></color>\n<yellow>  Please update your configuration.</color>\n<yellow></color>\n<yellow>  <bold>Configuration Documentation:</intensity></color>\n<yellow>  https://jestjs.io/docs/configuration</color>\n<yellow></color>\",\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": undefined,\n    },\n  ],\n}\n`;\n\nexports[`logs a deprecation warning when 'testPathDirs' option is passed 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [\n      \"<yellow><bold><bold>●</intensity><bold> Deprecation Warning</intensity>:</color>\n<yellow></color>\n<yellow>  Option <bold>\"testPathDirs\"</intensity> was replaced by <bold>\"roots\"</intensity>.</color>\n<yellow></color>\n<yellow>  Please update your configuration.</color>\n<yellow>  </color>\n<yellow></color>\n<yellow>  <bold>Configuration Documentation:</intensity></color>\n<yellow>  https://jestjs.io/docs/configuration</color>\n<yellow></color>\",\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": undefined,\n    },\n  ],\n}\n`;\n\nexports[`logs a deprecation warning when 'testURL' option is passed 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [\n      \"<yellow><bold><bold>●</intensity><bold> Deprecation Warning</intensity>:</color>\n<yellow></color>\n<yellow>  Option <bold>\"testURL\"</intensity> was replaced by passing the URL via <bold>\"testEnvironmentOptions.url\"</intensity>.</color>\n<yellow></color>\n<yellow>  Please update your configuration.</color>\n<yellow></color>\n<yellow>  <bold>Configuration Documentation:</intensity></color>\n<yellow>  https://jestjs.io/docs/configuration</color>\n<yellow></color>\",\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": undefined,\n    },\n  ],\n}\n`;\n\nexports[`logs a deprecation warning when 'timers' option is passed 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [\n      \"<yellow><bold><bold>●</intensity><bold> Deprecation Warning</intensity>:</color>\n<yellow></color>\n<yellow>  Option <bold>\"timers\"</intensity> was replaced by <bold>\"fakeTimers\"</intensity>.</color>\n<yellow></color>\n<yellow>  Please update your configuration.</color>\n<yellow></color>\n<yellow>  <bold>Configuration Documentation:</intensity></color>\n<yellow>  https://jestjs.io/docs/configuration</color>\n<yellow></color>\",\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": undefined,\n    },\n  ],\n}\n`;\n\nexports[`preset throws when module was found but no \"jest-preset.js\" or \"jest-preset.json\" files 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Module <bold>exist-but-no-jest-preset</intensity> should have \"jest-preset.js\" or \"jest-preset.json\" file at the root.</color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`preset throws when preset not found 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Preset <bold>doesnt-exist</intensity> not found relative to rootDir <bold>/root/path/foo</intensity>.</color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`reporters throws an error if first value in the tuple is not a string 1`] = `\n\"<red><bold><bold>● </intensity><bold>Reporter Validation Error</intensity>:</color>\n<red></color>\n<red>  Unexpected value for Path at index 0 of reporter at index 0</color>\n<red>  Expected:</color>\n<red>    <bold><red>string</color><red></intensity></color>\n<red>  Got:</color>\n<red>    <bold><green>number</color><red></intensity></color>\n<red>  Reporter configuration:</color>\n<red>    <bold><green>[</color><red></intensity></color>\n<red><bold><green>      123</color><red></intensity></color>\n<red><bold><green>    ]</color><red></intensity></color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`reporters throws an error if second value in the tuple is not an object 1`] = `\n\"<red><bold><bold>● </intensity><bold>Reporter Validation Error</intensity>:</color>\n<red></color>\n<red>  Unexpected value for Reporter Configuration at index 1 of reporter at index 0</color>\n<red>  Expected:</color>\n<red>    <bold><red>object</color><red></intensity></color>\n<red>  Got:</color>\n<red>    <bold><green>boolean</color><red></intensity></color>\n<red>  Reporter configuration:</color>\n<red>    <bold><green>[</color><red></intensity></color>\n<red><bold><green>      \"some-reporter\",</color><red></intensity></color>\n<red><bold><green>      true</color><red></intensity></color>\n<red><bold><green>    ]</color><red></intensity></color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`reporters throws an error if second value is missing in the tuple 1`] = `\n\"<red><bold><bold>● </intensity><bold>Reporter Validation Error</intensity>:</color>\n<red></color>\n<red>  Unexpected value for Reporter Configuration at index 1 of reporter at index 0</color>\n<red>  Expected:</color>\n<red>    <bold><red>object</color><red></intensity></color>\n<red>  Got:</color>\n<red>    <bold><green>undefined</color><red></intensity></color>\n<red>  Reporter configuration:</color>\n<red>    <bold><green>[</color><red></intensity></color>\n<red><bold><green>      \"some-reporter\"</color><red></intensity></color>\n<red><bold><green>    ]</color><red></intensity></color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`reporters throws an error if value is neither string nor array 1`] = `\n\"<red><bold><bold>● </intensity><bold>Reporter Validation Error</intensity>:</color>\n<red></color>\n<red>  Reporter at index 0 must be of type:</color>\n<red>    <bold><green>array or string</color><red></intensity></color>\n<red>  but instead received:</color>\n<red>    <bold><red>number</color><red></intensity></color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`rootDir throws if the options is missing a rootDir property 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Configuration option <bold>rootDir</intensity> must be specified.</color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`runner throw error when a runner is not found 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Jest Runner <bold>missing-runner</intensity> cannot be found. Make sure the <bold>runner</intensity> configuration option points to an existing node module.</color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`testEnvironment throws on invalid environment names 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Test environment <bold>phantom</intensity> cannot be found. Make sure the <bold>testEnvironment</intensity> configuration option points to an existing node module.</color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`testMatch throws if testRegex and testMatch are both specified 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Configuration options <bold>testMatch</intensity> and <bold>testRegex</intensity> cannot be used together.</color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`testPathPatterns <regexForTestFiles> ignores invalid regular expressions and logs a warning 1`] = `\"<red>  Invalid testPattern a( supplied. Running all tests instead.</color>\"`;\n\nexports[`testPathPatterns --testPathPatterns ignores invalid regular expressions and logs a warning 1`] = `\"<red>  Invalid testPattern a( supplied. Running all tests instead.</color>\"`;\n\nexports[`testTimeout should throw an error if timeout is a negative number 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Option \"<bold>testTimeout</intensity>\" must be a natural number.</color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;\n\nexports[`watchPlugins throw error when a watch plugin is not found 1`] = `\n\"<red><bold><bold>● </intensity><bold>Validation Error</intensity>:</color>\n<red></color>\n<red>  Watch plugin <bold>missing-plugin</intensity> cannot be found. Make sure the <bold>watchPlugins</intensity> configuration option points to an existing node module.</color>\n<red></color>\n<red>  <bold>Configuration Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/configuration</color>\n<red></color>\"\n`;"}
{"prompt":"normalizePathSep,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ndescribe('normalizePathSep', () => {\n  it('does nothing on posix', () => {\n    jest.resetModules();\n    jest.mock('path', () => jest.requireActual('path').posix);\n    const normalizePathSep = require('../normalizePathSep').default;\n    expect(normalizePathSep('foo/bar/baz.js')).toBe('foo/bar/baz.js');\n  });\n\n  it('replace slashes on windows', () => {\n    jest.resetModules();\n    jest.mock('path', () => jest.requireActual('path').win32);\n    const normalizePathSep = require('../normalizePathSep').default;\n    expect(normalizePathSep('foo/bar/baz.js')).toBe('foo\\\\bar\\\\baz.js');\n  });\n});"}
{"prompt":"not-really-a-test.txt","test":"// not-really-a-test.txt\n\nrequire('../module.txt');"}
{"prompt":"Coverage Report,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ndescribe('Coverage Report', () => {\n  it('outputs coverage report', () => {\n    const {stdout} = runJest('coverage-report', ['not-a-valid-test']);\n\n    expect(stdout).toMatch('No tests found');\n\n    expect(stdout).not.toMatch('0 tests passed');\n  });\n});\n\ndescribe('File path not found in multi-project scenario', () => {\n  it('outputs coverage report', () => {\n    const {stdout} = runJest('multi-project-config-root', [\n      '--runTestsByPath',\n      'not-a-valid-test',\n    ]);\n\n    expect(stdout).toMatch('No tests found');\n    expect(stdout).toMatch(/0 files checked across 2 projects\\./);\n  });\n});"}
{"prompt":"no tests for this one","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// no tests for this one"}
{"prompt":"No tests are found,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../no-tests-found-test');\n\ndescribe('No tests are found', () => {\n  test('fails the test suite in standard situation', () => {\n    const {exitCode, stdout} = runJest(DIR, [\n      '--testPathPatterns',\n      '/non/existing/path/',\n    ]);\n\n    expect(stdout).toContain('No tests found, exiting with code 1');\n    expect(stdout).toContain(\n      'Run with `--passWithNoTests` to exit with code 0',\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test(\"doesn't fail the test suite if --passWithNoTests passed\", () => {\n    const {exitCode, stdout} = runJest(DIR, [\n      '--testPathPatterns',\n      '/non/existing/path/',\n      '--passWithNoTests',\n    ]);\n\n    expect(stdout).toContain('No tests found, exiting with code 0');\n    expect(stdout).not.toContain(\n      'Run with `--passWithNoTests` to exit with code 0',\n    );\n    expect(exitCode).toBe(0);\n  });\n\n  test(\"doesn't fail the test suite if using --lastCommit\", () => {\n    // Since there are no files in DIR no tests will be found\n    const {exitCode, stdout} = runJest(DIR, ['--lastCommit']);\n\n    expect(stdout).toContain(\n      'No tests found related to files changed since last commit.',\n    );\n    expect(stdout).not.toContain(\n      'Run with `--passWithNoTests` to exit with code 0',\n    );\n    expect(exitCode).toBe(0);\n  });\n\n  test(\"doesn't fail the test suite if using --onlyChanged\", () => {\n    // Since there are no files in DIR no tests will be found\n    const {exitCode, stdout} = runJest(DIR, ['--onlyChanged']);\n\n    expect(stdout).toContain(\n      'No tests found related to files changed since last commit.',\n    );\n    expect(stdout).not.toContain(\n      'Run with `--passWithNoTests` to exit with code 0',\n    );\n    expect(exitCode).toBe(0);\n  });\n\n  test('fails the test suite if using --findRelatedTests', () => {\n    // Since there are no files in DIR no tests will be found\n    const {exitCode, stdout} = runJest(DIR, [\n      '--findRelatedTests',\n      '/non/existing/path',\n    ]);\n\n    expect(stdout).toContain('No tests found, exiting with code 1');\n    expect(stdout).toContain(\n      'Run with `--passWithNoTests` to exit with code 0',\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test(\"doesn't fail the test suite if using --findRelatedTests and --passWithNoTests\", () => {\n    // Since there are no files in DIR no tests will be found\n    const {exitCode, stdout} = runJest(DIR, [\n      '--findRelatedTests',\n      '/non/existing/path',\n      '--passWithNoTests',\n    ]);\n\n    expect(stdout).toContain('No tests found, exiting with code 0');\n    expect(stdout).not.toContain(\n      'Run with `--passWithNoTests` to exit with code 0',\n    );\n    expect(exitCode).toBe(0);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('something', () => {\n  expect(true).toBe(true);\n});"}
{"prompt":"Simulated sequence of events for NotifyReporter","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {AggregatedResult, TestContext} from '@jest/test-result';\nimport {makeGlobalConfig} from '@jest/test-utils';\nimport type {Config} from '@jest/types';\nimport Resolver from 'jest-resolve';\nimport NotifyReporter from '../NotifyReporter';\nimport type {ReporterContext} from '../types';\n\njest.mock('../DefaultReporter');\njest.mock('node-notifier', () => ({\n  notify: jest.fn(),\n}));\n\nconst initialContext: ReporterContext = {\n  firstRun: true,\n  previousSuccess: false,\n  startRun: () => {},\n};\n\nconst aggregatedResultsSuccess = {\n  numFailedTestSuites: 0,\n  numFailedTests: 0,\n  numPassedTestSuites: 1,\n  numPassedTests: 3,\n  numRuntimeErrorTestSuites: 0,\n  numTotalTestSuites: 1,\n  numTotalTests: 3,\n  success: true,\n} as AggregatedResult;\n\nconst aggregatedResultsFailure = {\n  numFailedTestSuites: 1,\n  numFailedTests: 3,\n  numPassedTestSuites: 0,\n  numPassedTests: 9,\n  numRuntimeErrorTestSuites: 0,\n  numTotalTestSuites: 1,\n  numTotalTests: 3,\n  success: false,\n} as AggregatedResult;\n\nconst aggregatedResultsNoTests = {\n  numFailedTestSuites: 0,\n  numFailedTests: 0,\n  numPassedTestSuites: 0,\n  numPassedTests: 0,\n  numPendingTestSuites: 0,\n  numPendingTests: 0,\n  numRuntimeErrorTestSuites: 0,\n  numTotalTestSuites: 0,\n  numTotalTests: 0,\n} as AggregatedResult;\n\n// Simulated sequence of events for NotifyReporter\nconst notifyEvents = [\n  aggregatedResultsNoTests,\n  aggregatedResultsSuccess,\n  aggregatedResultsFailure,\n  aggregatedResultsSuccess,\n  aggregatedResultsSuccess,\n  aggregatedResultsFailure,\n  aggregatedResultsFailure,\n];\n\nconst testModes = ({\n  notifyMode,\n  arl,\n  rootDir,\n  moduleName,\n}: {arl: Array<AggregatedResult>; moduleName?: string} & Pick<\n  Config.GlobalConfig,\n  'notifyMode'\n> &\n  Partial<Pick<Config.ProjectConfig, 'rootDir'>>) => {\n  const notify = require('node-notifier');\n\n  const globalConfig = makeGlobalConfig({notify: true, notifyMode, rootDir});\n\n  let previousContext = initialContext;\n  for (const [i, ar] of arl.entries()) {\n    const newContext: ReporterContext = Object.assign(previousContext, {\n      firstRun: i === 0,\n      previousSuccess: previousContext.previousSuccess,\n    });\n    const reporter = new NotifyReporter(globalConfig, newContext);\n    previousContext = newContext;\n    const testContexts = new Set<TestContext>();\n\n    if (moduleName != null) {\n      testContexts.add({\n        hasteFS: {\n          getModuleName() {\n            return moduleName;\n          },\n\n          matchFiles() {\n            return ['package.json'];\n          },\n        },\n      } as unknown as TestContext);\n    }\n\n    reporter.onRunComplete(testContexts, ar);\n\n    if (ar.numTotalTests === 0) {\n      expect(notify.notify).not.toHaveBeenCalled();\n    }\n  }\n\n  const calls: Array<any> = notify.notify.mock.calls;\n  expect(\n    calls.map(([{message, title}]) => ({\n      message: message.replace('\\u26D4\\uFE0F ', '').replace('\\u2705 ', ''),\n      title,\n    })),\n  ).toMatchSnapshot();\n};\n\ntest('test always', () => {\n  testModes({arl: notifyEvents, notifyMode: 'always'});\n});\n\ntest('test success', () => {\n  testModes({arl: notifyEvents, notifyMode: 'success'});\n});\n\ntest('test change', () => {\n  testModes({arl: notifyEvents, notifyMode: 'change'});\n});\n\ntest('test success-change', () => {\n  testModes({arl: notifyEvents, notifyMode: 'success-change'});\n});\n\ntest('test failure-change', () => {\n  testModes({arl: notifyEvents, notifyMode: 'failure-change'});\n});\n\ntest('test always with rootDir', () => {\n  testModes({arl: notifyEvents, notifyMode: 'always', rootDir: 'some-test'});\n});\n\ntest('test success with rootDir', () => {\n  testModes({arl: notifyEvents, notifyMode: 'success', rootDir: 'some-test'});\n});\n\ntest('test change with rootDir', () => {\n  testModes({arl: notifyEvents, notifyMode: 'change', rootDir: 'some-test'});\n});\n\ntest('test success-change with rootDir', () => {\n  testModes({\n    arl: notifyEvents,\n    notifyMode: 'success-change',\n    rootDir: 'some-test',\n  });\n});\n\ntest('test failure-change with rootDir', () => {\n  testModes({\n    arl: notifyEvents,\n    notifyMode: 'failure-change',\n    rootDir: 'some-test',\n  });\n});\n\ntest('test always with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'always',\n  });\n});\n\ntest('test success with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'success',\n  });\n});\n\ntest('test change with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'change',\n  });\n});\n\ntest('test success-change with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'success-change',\n  });\n});\n\ntest('test failure-change with moduleName', () => {\n  testModes({\n    arl: notifyEvents,\n    moduleName: 'some-module',\n    notifyMode: 'failure-change',\n  });\n});\n\ndescribe('node-notifier is an optional dependency', () => {\n  beforeEach(() => {\n    jest.resetModules();\n  });\n\n  const ctor = () => {\n    const globalConfig = makeGlobalConfig({\n      notify: true,\n      notifyMode: 'success',\n      rootDir: 'some-test',\n    });\n    return new NotifyReporter(globalConfig, initialContext);\n  };\n\n  test('without node-notifier uses mock function that throws an error', () => {\n    jest.doMock('node-notifier', () => {\n      throw new Resolver.ModuleNotFoundError(\n        \"Cannot find module 'node-notifier'\",\n      );\n    });\n\n    expect(ctor).toThrow(\n      'notify reporter requires optional peer dependency \"node-notifier\" but it was not found',\n    );\n  });\n\n  test('throws the error when require throws an unexpected error', () => {\n    const error = new Error('unexpected require error');\n    jest.doMock('node-notifier', () => {\n      throw error;\n    });\n    expect(ctor).toThrow(error);\n  });\n\n  test('uses node-notifier when it is available', () => {\n    const mockNodeNotifier = {notify: jest.fn()};\n    jest.doMock('node-notifier', () => mockNodeNotifier);\n    const result = ctor();\n    expect(result._notifier).toBe(mockNodeNotifier);\n  });\n});\n\nafterEach(() => {\n  jest.clearAllMocks();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`test always 1`] = `\nArray [\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"100% Failed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"100% Passed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"100% Failed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"100% Failed\",\n  },\n]\n`;\n\nexports[`test always with moduleName 1`] = `\nArray [\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-module - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-module - 100% Failed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-module - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-module - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-module - 100% Failed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-module - 100% Failed\",\n  },\n]\n`;\n\nexports[`test always with rootDir 1`] = `\nArray [\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-test - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-test - 100% Failed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-test - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-test - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-test - 100% Failed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-test - 100% Failed\",\n  },\n]\n`;\n\nexports[`test change 1`] = `\nArray [\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"100% Failed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"100% Failed\",\n  },\n]\n`;\n\nexports[`test change with moduleName 1`] = `\nArray [\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-module - 100% Failed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-module - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-module - 100% Failed\",\n  },\n]\n`;\n\nexports[`test change with rootDir 1`] = `\nArray [\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-test - 100% Failed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-test - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-test - 100% Failed\",\n  },\n]\n`;\n\nexports[`test failure-change 1`] = `\nArray [\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"100% Failed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"100% Failed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"100% Failed\",\n  },\n]\n`;\n\nexports[`test failure-change with moduleName 1`] = `\nArray [\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-module - 100% Failed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-module - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-module - 100% Failed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-module - 100% Failed\",\n  },\n]\n`;\n\nexports[`test failure-change with rootDir 1`] = `\nArray [\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-test - 100% Failed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-test - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-test - 100% Failed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-test - 100% Failed\",\n  },\n]\n`;\n\nexports[`test success 1`] = `\nArray [\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"100% Passed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"100% Passed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"100% Passed\",\n  },\n]\n`;\n\nexports[`test success with moduleName 1`] = `\nArray [\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-module - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-module - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-module - 100% Passed\",\n  },\n]\n`;\n\nexports[`test success with rootDir 1`] = `\nArray [\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-test - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-test - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-test - 100% Passed\",\n  },\n]\n`;\n\nexports[`test success-change 1`] = `\nArray [\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"100% Failed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"100% Passed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"100% Failed\",\n  },\n]\n`;\n\nexports[`test success-change with moduleName 1`] = `\nArray [\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-module - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-module - 100% Failed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-module - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-module - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-module - 100% Failed\",\n  },\n]\n`;\n\nexports[`test success-change with rootDir 1`] = `\nArray [\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-test - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-test - 100% Failed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-test - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 tests passed\",\n    \"title\": \"some-test - 100% Passed\",\n  },\n  Object {\n    \"message\": \"3 of 3 tests failed\",\n    \"title\": \"some-test - 100% Failed\",\n  },\n]\n`;"}
{"prompt":".onlywith .only, should show passed, todo, todo,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable jest/no-focused-tests */\n\n'use strict';\n\ndescribe.only(\"with .only, should show 'passed', 'todo', 'todo'\", () => {\n  test('passing test', () => {});\n  test.todo('todo test 1');\n  test.todo('todo test 2');\n});"}
{"prompt":"both a.js and b.js should be in the coverage","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport semver = require('semver');\nimport {cleanup, run, testIfHg, testIfSl, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'jest_only_changed');\nconst GIT = 'git -c user.name=jest_test -c user.email=jest_test@test.com';\nconst HG = 'hg --config ui.username=jest_test';\n\nconst gitVersionSupportsInitialBranch = (() => {\n  const {stdout} = run(`${GIT} --version`);\n  const gitVersion = stdout.trim();\n\n  const match = gitVersion.match(/^git version (?<version>\\d+\\.\\d+\\.\\d+)/);\n\n  if (match?.groups?.version == null) {\n    throw new Error(`Unable to parse git version from string \"${gitVersion}\"`);\n  }\n\n  const {version} = match.groups;\n\n  return semver.gte(version, '2.28.0');\n})();\n\nconst mainBranchName = gitVersionSupportsInitialBranch ? 'main' : 'master';\n\nfunction gitInit(dir: string) {\n  const initCommand = gitVersionSupportsInitialBranch\n    ? `${GIT} init --initial-branch=${mainBranchName}`\n    : `${GIT} init`;\n\n  run(initCommand, dir);\n}\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ntest('run for \"onlyChanged\" and \"changedSince\"', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    '__tests__/file1.test.js': \"require('../file1'); test('file1', () => {});\",\n    'file1.js': 'module.exports = {}',\n    'package.json': '{}',\n  });\n\n  gitInit(DIR);\n  run(`${GIT} add .`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"first\"`, DIR);\n\n  let stdout = runJest(DIR, ['-o']).stdout;\n  expect(stdout).toMatch(\n    /No tests found related to files changed since last commit./,\n  );\n\n  stdout = runJest(DIR, [`--changedSince=${mainBranchName}`]).stdout;\n  expect(stdout).toMatch(\n    `No tests found related to files changed since \"${mainBranchName}\".`,\n  );\n});\n\ntest('run only changed files', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    '__tests__/file1.test.js': \"require('../file1'); test('file1', () => {});\",\n    'file1.js': 'module.exports = {}',\n    'package.json': '{}',\n  });\n  let stderr;\n  let stdout;\n\n  ({stdout} = runJest(DIR, ['-o']));\n  expect(stdout).toMatch(/Jest can only find uncommitted changed files/);\n\n  gitInit(DIR);\n  run(`${GIT} add .`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"first\"`, DIR);\n\n  ({stdout} = runJest(DIR, ['-o']));\n  expect(stdout).toMatch('No tests found related to files');\n\n  ({stderr} = runJest(DIR, ['-o', '--lastCommit']));\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file1.test.js/);\n\n  writeFiles(DIR, {\n    '__tests__/file2.test.js': \"require('../file2'); test('file2', () => {});\",\n    '__tests__/file3.test.js': \"require('../file3'); test('file3', () => {});\",\n    'file2.js': 'module.exports = {}',\n    'file3.js': \"require('./file2')\",\n  });\n\n  ({stderr} = runJest(DIR, ['-o']));\n\n  expect(stderr).not.toMatch(/PASS __tests__(\\/|\\\\)file1.test.js/);\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file2.test.js/);\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file3.test.js/);\n\n  run(`${GIT} add .`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"second\"`, DIR);\n\n  ({stdout} = runJest(DIR, ['-o']));\n  expect(stdout).toMatch('No tests found related to files');\n\n  writeFiles(DIR, {\n    'file2.js': 'module.exports = {modified: true}',\n  });\n\n  ({stderr} = runJest(DIR, ['-o']));\n  expect(stderr).not.toMatch(/PASS __tests__(\\/|\\\\)file1.test.j/);\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file2.test.js/);\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file3.test.js/);\n});\n\ntest('report test coverage for only changed files', () => {\n  writeFiles(DIR, {\n    '__tests__/a.test.js': `\n    require('../a');\n    require('../b');\n    test('a', () => expect(1).toBe(1));\n  `,\n    '__tests__/b.test.js': `\n    require('../b');\n    test('b', () => expect(1).toBe(1));\n  `,\n    'a.js': 'module.exports = {}',\n    'b.js': 'module.exports = {}',\n    'package.json': JSON.stringify({\n      jest: {\n        collectCoverage: true,\n        coverageReporters: ['text'],\n        testEnvironment: 'node',\n      },\n    }),\n  });\n\n  gitInit(DIR);\n  run(`${GIT} add .`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"first\"`, DIR);\n\n  writeFiles(DIR, {\n    'a.js': 'module.exports = {modified: true}',\n  });\n\n  let stdout;\n\n  ({stdout} = runJest(DIR));\n\n  // both a.js and b.js should be in the coverage\n  expect(stdout).toMatch('a.js');\n  expect(stdout).toMatch('b.js');\n\n  ({stdout} = runJest(DIR, ['-o']));\n\n  // coverage should be collected only for a.js\n  expect(stdout).toMatch('a.js');\n  expect(stdout).not.toMatch('b.js');\n});\n\ntest('report test coverage of source on test file change under only changed files', () => {\n  writeFiles(DIR, {\n    '__tests__/a.test.js': `\n    require('../a');\n    test('a1', () => expect(1).toBe(1));\n  `,\n    'a.js': 'module.exports = {}',\n    'package.json': JSON.stringify({\n      jest: {\n        collectCoverage: true,\n        coverageReporters: ['text'],\n        testEnvironment: 'node',\n      },\n    }),\n  });\n\n  gitInit(DIR);\n  run(`${GIT} add .`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"first\"`, DIR);\n\n  writeFiles(DIR, {\n    '__tests__/a.test.js': `\n    require('../a');\n    test('a1', () => expect(1).toBe(1));\n    test('a2', () => expect(2).toBe(2));\n  `,\n  });\n\n  const {stdout} = runJest(DIR, ['--only-changed']);\n\n  expect(stdout).toMatch('a.js');\n});\n\ntest('do not pickup non-tested files when reporting coverage on only changed files', () => {\n  writeFiles(DIR, {\n    'a.js': 'module.exports = {}',\n    'b.test.js': 'module.exports = {}',\n    'package.json': JSON.stringify({name: 'original name'}),\n  });\n\n  gitInit(DIR);\n  run(`${GIT} add .`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"first\"`, DIR);\n\n  writeFiles(DIR, {\n    'b.test.js': 'require(\"./package.json\"); it(\"passes\", () => {})',\n    'package.json': JSON.stringify({name: 'new name'}),\n  });\n\n  const {stderr, stdout, exitCode} = runJest(DIR, ['-o', '--coverage']);\n  expect(stderr).toEqual(\n    expect.not.stringContaining('Failed to collect coverage from'),\n  );\n  expect(stdout).toEqual(expect.not.stringContaining('package.json'));\n  expect(exitCode).toBe(0);\n});\n\ntest('collect test coverage when using onlyChanged', () => {\n  writeFiles(DIR, {\n    'a.js': 'module.exports = {}',\n    'b.test.js': 'module.exports = {}',\n    'package.json': JSON.stringify({\n      jest: {collectCoverageFrom: ['a.js']},\n      name: 'original name',\n    }),\n  });\n\n  gitInit(DIR);\n  run(`${GIT} add .`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"first\"`, DIR);\n  run(`${GIT} checkout -b new-branch`, DIR);\n\n  writeFiles(DIR, {\n    'b.test.js': 'it(\"passes\", () => {expect(1).toBe(1)})',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, ['-o', '--coverage']);\n  expect(stderr).toEqual(\n    expect.not.stringContaining('Failed to collect coverage from'),\n  );\n  expect(exitCode).toBe(0);\n});\n\ntest('onlyChanged in config is overwritten by --all or testPathPatterns', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    '__tests__/file1.test.js': \"require('../file1'); test('file1', () => {});\",\n    'file1.js': 'module.exports = {}',\n    'package.json': JSON.stringify({jest: {onlyChanged: true}}),\n  });\n  let stderr;\n  let stdout;\n\n  ({stdout} = runJest(DIR));\n  expect(stdout).toMatch(/Jest can only find uncommitted changed files/);\n\n  gitInit(DIR);\n  run(`${GIT} add .`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"first\"`, DIR);\n\n  ({stdout, stderr} = runJest(DIR));\n  expect(stdout).toMatch('No tests found related to files');\n  expect(stderr).not.toMatch(\n    'Unknown option \"onlyChanged\" with value true was found',\n  );\n\n  ({stderr} = runJest(DIR, ['--lastCommit']));\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file1.test.js/);\n\n  writeFiles(DIR, {\n    '__tests__/file2.test.js': \"require('../file2'); test('file2', () => {});\",\n    '__tests__/file3.test.js': \"require('../file3'); test('file3', () => {});\",\n    'file2.js': 'module.exports = {}',\n    'file3.js': \"require('./file2')\",\n  });\n\n  ({stderr} = runJest(DIR));\n\n  expect(stderr).not.toMatch(/PASS __tests__(\\/|\\\\)file1.test.js/);\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file2.test.js/);\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file3.test.js/);\n\n  run(`${GIT} add .`, DIR);\n  run(`${GIT} commit --no-gpg-sign -m \"second\"`, DIR);\n\n  ({stdout} = runJest(DIR));\n  expect(stdout).toMatch('No tests found related to files');\n\n  ({stderr, stdout} = runJest(DIR, ['file2.test.js']));\n  expect(stdout).not.toMatch('No tests found related to files');\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file2.test.js/);\n  expect(stderr).toMatch('1 total');\n\n  writeFiles(DIR, {\n    'file2.js': 'module.exports = {modified: true}',\n  });\n\n  ({stderr} = runJest(DIR));\n  expect(stderr).not.toMatch(/PASS __tests__(\\/|\\\\)file1.test.js/);\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file2.test.js/);\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file3.test.js/);\n\n  ({stderr} = runJest(DIR, ['--all']));\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file1.test.js/);\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file2.test.js/);\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file3.test.js/);\n});\n\ntestIfHg('gets changed files for hg', async () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    '__tests__/file1.test.js': \"require('../file1'); test('file1', () => {});\",\n    'file1.js': 'module.exports = {}',\n    'package.json': JSON.stringify({jest: {testEnvironment: 'node'}}),\n  });\n\n  run(`${HG} init`, DIR);\n  run(`${HG} add .`, DIR);\n  run(`${HG} commit -m \"test\"`, DIR);\n\n  let stdout;\n  let stderr;\n\n  ({stdout} = runJest(DIR, ['-o']));\n  expect(stdout).toMatch('No tests found related to files changed');\n\n  writeFiles(DIR, {\n    '__tests__/file2.test.js': \"require('../file2'); test('file2', () => {});\",\n    'file2.js': 'module.exports = {}',\n    'file3.js': \"require('./file2')\",\n  });\n\n  ({stderr} = runJest(DIR, ['-o']));\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file2.test.js/);\n\n  run(`${HG} add .`, DIR);\n  run(`${HG} commit -m \"test2\"`, DIR);\n\n  writeFiles(DIR, {\n    '__tests__/file3.test.js': \"require('../file3'); test('file3', () => {});\",\n  });\n\n  ({stdout, stderr} = runJest(DIR, ['-o']));\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file3.test.js/);\n  expect(stderr).not.toMatch(/PASS __tests__(\\/|\\\\)file2.test.js/);\n\n  ({stdout, stderr} = runJest(DIR, ['-o', '--changedFilesWithAncestor']));\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file2.test.js/);\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file3.test.js/);\n});\n\nconst SL = 'sl --config ui.username=jest_test';\ntestIfSl('gets changed files for sl', async () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    '__tests__/file1.test.js': \"require('../file1'); test('file1', () => {});\",\n    'file1.js': 'module.exports = {}',\n    'package.json': JSON.stringify({jest: {testEnvironment: 'node'}}),\n  });\n\n  run(`${SL} init --git`, DIR);\n  run(`${SL} add .`, DIR);\n  run(`${SL} commit -m \"test\"`, DIR);\n\n  let stdout;\n  let stderr;\n\n  ({stdout} = runJest(DIR, ['-o']));\n  expect(stdout).toMatch('No tests found related to files changed');\n\n  writeFiles(DIR, {\n    '__tests__/file2.test.js': \"require('../file2'); test('file2', () => {});\",\n    'file2.js': 'module.exports = {}',\n    'file3.js': \"require('./file2')\",\n  });\n\n  ({stderr} = runJest(DIR, ['-o']));\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file2.test.js/);\n\n  run(`${SL} add .`, DIR);\n  run(`${SL} commit -m \"test2\"`, DIR);\n\n  writeFiles(DIR, {\n    '__tests__/file3.test.js': \"require('../file3'); test('file3', () => {});\",\n  });\n\n  ({stdout, stderr} = runJest(DIR, ['-o']));\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file3.test.js/);\n  expect(stderr).not.toMatch(/PASS __tests__(\\/|\\\\)file2.test.js/);\n\n  ({stdout, stderr} = runJest(DIR, ['-o', '--changedFilesWithAncestor']));\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file2.test.js/);\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file3.test.js/);\n});\n\ntest('path on Windows is case-insensitive', () => {\n  if (process.platform !== 'win32') {\n    // This test is Windows specific, skip it on other platforms.\n    return;\n  }\n\n  const modifiedDIR = path.resolve(DIR, 'outer_dir', 'inner_dir');\n  const incorrectModifiedDIR = path.resolve(DIR, 'OUTER_dir', 'inner_dir');\n\n  writeFiles(modifiedDIR, {\n    '.watchmanconfig': '',\n    '__tests__/file1.test.js': \"require('../file1'); test('file1', () => {});\",\n    'file1.js': 'module.exports = {}',\n    'package.json': '{}',\n  });\n\n  gitInit(modifiedDIR);\n  run(`${GIT} add .`, modifiedDIR);\n  run(`${GIT} commit --no-gpg-sign -m \"first\"`, modifiedDIR);\n\n  const {stdout} = runJest(incorrectModifiedDIR, ['-o']);\n  expect(stdout).toMatch('No tests found related to files');\n\n  writeFiles(modifiedDIR, {\n    '__tests__/file2.test.js': \"require('../file2'); test('file2', () => {});\",\n    '__tests__/file3.test.js': \"require('../file3'); test('file3', () => {});\",\n    'file2.js': 'module.exports = {}',\n    'file3.js': \"require('./file2')\",\n  });\n\n  const {stderr} = runJest(incorrectModifiedDIR, ['-o']);\n\n  expect(stderr).not.toMatch(/PASS __tests__(\\/|\\\\)file1.test.js/);\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file2.test.js/);\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\)file3.test.js/);\n});"}
{"prompt":"only the failed test should run and  should fail","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'non-watch-mode-onlyFailures');\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ntest('onlyFailures flag works in non-watch mode', () => {\n  writeFiles(DIR, {\n    '__tests__/a.js': `\n    test('bar', () => { expect('bar').toBe('foo'); });\n    `,\n    '__tests__/b.js': `\n    test('foo', () => { expect('foo').toBe('foo'); });\n    `,\n    'package.json': JSON.stringify({\n      jest: {\n        testEnvironment: 'node',\n      },\n    }),\n  });\n\n  let stdout, stderr;\n\n  ({stdout, stderr} = runJest(DIR));\n  expect(stdout).toBe('');\n  expect(stderr).toMatch('FAIL __tests__/a.js');\n  expect(stderr).toMatch('PASS __tests__/b.js');\n\n  // only the failed test should run and it should fail\n  ({stdout, stderr} = runJest(DIR, ['--onlyFailures']));\n  expect(stdout).toBe('');\n  expect(stderr).toMatch('FAIL __tests__/a.js');\n  expect(stderr).not.toMatch('__tests__/b.js');\n\n  // fix the failing test\n  const data = \"test('bar 1', () => { expect('bar').toBe('bar'); })\";\n  fs.writeFileSync(path.join(DIR, '__tests__/a.js'), data);\n\n  // only the failed test should run and it should pass\n  ({stdout, stderr} = runJest(DIR, ['--onlyFailures']));\n  expect(stdout).toBe('');\n  expect(stderr).toMatch('PASS __tests__/a.js');\n  expect(stderr).not.toMatch('__tests__/b.js');\n\n  // No test should run\n  ({stdout, stderr} = runJest(DIR, ['--onlyFailures']));\n  expect(stdout).toBe('No failed test found.');\n  expect(stderr).toBe('');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nexports.value = 'banana banana banana';"}
{"prompt":"isnt actually run,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nit(\"isn't actually run\", () => {\n  // (because it is only used for --listTests)\n  expect(true).toBe(false);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nrequire('../server');\n\ntest('something', () => {\n  expect(true).toBe(true);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('overriding native promise does not freeze Jest', () => {\n  const run = runJest('override-globals');\n  expect(run.stderr).toMatch(/PASS __tests__(\\/|\\\\)index.js/);\n});\n\ntest('has a duration even if time is faked', () => {\n  const regex = /works well \\((\\d+) ms\\)/;\n  const {stderr} = runJest('override-globals', ['--verbose']);\n\n  expect(stderr).toMatch(regex);\n\n  const [, duration] = stderr.match(regex)!;\n\n  expect(Number(duration)).toBeGreaterThan(0);\n});"}
{"prompt":"Test generated from existing file","test":"{\n  \"name\": \"test_root\",\n  \"version\": \"1.0.0\",\n  \"dependencies\": {}\n}"}
{"prompt":"createRequire wh a different file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst Module = require('module');\nconst path = require('path');\n\ntest('require child from parent', () => {\n  // createRequire with a different file\n  const newRequire = Module.createRequire(path.resolve('./empty.js'));\n  expect(() => newRequire('./child')).not.toThrow();\n});"}
{"prompt":"raises an exception if shard has wrong format,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {parseShardPair} from '../parseShardPair';\n\nit('raises an exception if shard has wrong format', () => {\n  expect(() => parseShardPair('mumble')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});\n\nit('raises an exception if shard pair has to many items', () => {\n  expect(() => parseShardPair('1/2/3')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});\n\nit('raises an exception if shard has floating points', () => {\n  expect(() => parseShardPair('1.0/1')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});\n\nit('raises an exception if first item in shard pair is no number', () => {\n  expect(() => parseShardPair('a/1')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});\n\nit('raises an exception if second item in shard pair is no number', () => {\n  expect(() => parseShardPair('1/a')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});\n\nit('raises an exception if shard contains negative number', () => {\n  expect(() => parseShardPair('1/-1')).toThrow(\n    'string in the format of <n>/<m>',\n  );\n});\n\nit('raises an exception if shard is zero-indexed', () => {\n  expect(() => parseShardPair('0/1')).toThrow(\n    'requires 1-based values, received 0',\n  );\n});\n\nit('raises an exception if shard index is larger than shard count', () => {\n  expect(() => parseShardPair('2/1')).toThrow(\n    'requires <n> to be lower or equal than <m>',\n  );\n});\n\nit('allows valid shard format', () => {\n  expect(() => parseShardPair('1/2')).not.toThrow();\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\n/**\n * This file illustrates how to do a partial mock where a subset\n * of a module's exports have been mocked and the rest\n * keep their actual implementation.\n */\nimport defaultExport, {apple, strawberry} from '../fruit';\n\njest.mock('../fruit', () => {\n  const originalModule = jest.requireActual('../fruit');\n  const mockedModule = jest.createMockFromModule('../fruit');\n\n  //Mock the default export and named export 'apple'.\n  return {\n    ...mockedModule,\n    ...originalModule,\n    apple: 'mocked apple',\n    default: jest.fn(() => 'mocked fruit'),\n  };\n});\n\nit('does a partial mock', () => {\n  const defaultExportResult = defaultExport();\n  expect(defaultExportResult).toBe('mocked fruit');\n  expect(defaultExport).toHaveBeenCalled();\n\n  expect(apple).toBe('mocked apple');\n  expect(strawberry()).toBe('strawberry');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('should pass', () => {});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nrequire('../this-directory-is-covered/excludedFromCoverage');\n\ntest('1', () => {});"}
{"prompt":"eslint-disable-next-line no-constant-condion","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('pending', () => {\n  // eslint-disable-next-line no-constant-condition\n  if (true) {\n    pending('This test is pending.');\n  }\n  expect(false).toBe(true);\n});"}
{"prompt":"skips a test inside a promise,  =>","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nit('skips a test inside a promise', () =>\n  new Promise(() => {\n    pending('skipped a test inside a promise');\n  }));"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nexports.platform = 'android';"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nexports.platform = 'ios';"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nexports.platform = 'default';"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nexports.platform = 'native';"}
{"prompt":"Jest tests snapshotSerializers in order preceding built-in serializers.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Plugin} from 'pretty-format';\n\nbeforeEach(() => {\n  jest.resetModules();\n});\n\nconst testPath = (names: Array<string>) => {\n  const {addSerializer, getSerializers} =\n    require('../plugins') as typeof import('../plugins');\n  const prev = getSerializers();\n  const added = names.map(\n    name => require(require.resolve(`./plugins/${name}`)) as Plugin,\n  );\n\n  // Jest tests snapshotSerializers in order preceding built-in serializers.\n  // Therefore, add in reverse because the last added is the first tested.\n  for (const serializer of [...added].reverse()) addSerializer(serializer);\n\n  const next = getSerializers();\n  expect(next).toHaveLength(added.length + prev.length);\n  expect(next).toEqual([...added, ...prev]);\n};\n\nit('gets plugins', () => {\n  const {getSerializers} = require('../plugins') as typeof import('../plugins');\n  const plugins = getSerializers();\n  expect(plugins).toHaveLength(5);\n});\n\nit('adds plugins from an empty array', () => testPath([]));\nit('adds a single plugin path', () => testPath(['foo']));\nit('adds multiple plugin paths', () => testPath(['foo', 'bar']));"}
{"prompt":"successfully runs the tests inside pnp/,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {runYarnInstall} from '../Utils';\nimport {json as runWithJson} from '../runJest';\n\nconst DIR = path.resolve(__dirname, '..', 'pnp');\n\nbeforeEach(() => {\n  runYarnInstall(DIR, {\n    YARN_ENABLE_GLOBAL_CACHE: 'false',\n    YARN_NODE_LINKER: 'pnp',\n  });\n});\n\nit('successfully runs the tests inside `pnp/`', () => {\n  const {json} = runWithJson(DIR, ['--no-cache', '--coverage'], {\n    env: {\n      YARN_ENABLE_GLOBAL_CACHE: 'false',\n      YARN_NODE_LINKER: 'pnp',\n    },\n    nodeOptions: `--require ${DIR}/.pnp.cjs`,\n  });\n\n  expect(json.success).toBe(true);\n  expect(json.numTotalTestSuites).toBe(2);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('supports json preset', () => {\n  const result = runJest('presets/json');\n  expect(result.exitCode).toBe(0);\n});\n\ntest.each(['js', 'cjs'])('supports %s preset', presetDir => {\n  const result = runJest(`presets/${presetDir}`);\n\n  expect(result.exitCode).toBe(0);\n});\n\ntest.each(['mjs', 'js-type-module'])('supports %s preset', presetDir => {\n  const result = runJest(`presets/${presetDir}`);\n\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"array,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst noop = () => {};\n\ndescribe('array', () => {\n  it.each([\n    ['hello', 'hello'],\n    [1, 1],\n    [null, null],\n    [undefined, undefined],\n    [1.2, 1.2],\n    [{foo: 'bar'}, {foo: 'bar'}],\n    [{foo: {bar: 'baz'}}, {foo: {bar: 'baz'}}],\n    [noop, noop],\n    [[], []],\n    [[{foo: {bar: 'baz'}}], [{foo: {bar: 'baz'}}]],\n    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\n    [Number.NaN, Number.NaN],\n  ])('%p == %p', (left, right) => {\n    expect(left).toEqual(right);\n  });\n});\n\ndescribe('template', () => {\n  it.each`\n    left                        | right\n    ${'hello'}                  | ${'hello'}\n    ${1}                        | ${1}\n    ${null}                     | ${null}\n    ${undefined}                | ${undefined}\n    ${1.2}                      | ${1.2}\n    ${{foo: 'bar'}}             | ${{foo: 'bar'}}\n    ${{foo: {bar: 'baz'}}}      | ${{foo: {bar: 'baz'}}}\n    ${noop}                     | ${noop}\n    ${[]}                       | ${[]}\n    ${[{foo: {bar: 'baz'}}]}    | ${[{foo: {bar: 'baz'}}]}\n    ${Number.POSITIVE_INFINITY} | ${Number.POSITIVE_INFINITY}\n    ${Number.NEGATIVE_INFINITY} | ${Number.NEGATIVE_INFINITY}\n    ${Number.NaN}               | ${Number.NaN}\n  `('$left == $right', ({left, right}) => {\n    expect(left).toEqual(right);\n  });\n});"}
{"prompt":"@ts-expect-error","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable local/prefer-rest-params-eventually */\n\nimport prettyFormat, {type PrettyFormatOptions} from '..';\n\nfunction returnArguments(..._args: Array<unknown>) {\n  return arguments;\n}\n\nclass MyArray<T> extends Array<T> {}\n\nfunction MyObject(value: unknown) {\n  // @ts-expect-error\n  this.name = value;\n}\n\ndescribe('prettyFormat()', () => {\n  it('prints empty arguments', () => {\n    const val = returnArguments();\n    expect(prettyFormat(val)).toBe('Arguments []');\n  });\n\n  it('prints arguments', () => {\n    const val = returnArguments(1, 2, 3);\n    expect(prettyFormat(val)).toBe('Arguments [\\n  1,\\n  2,\\n  3,\\n]');\n  });\n\n  it('prints an empty array', () => {\n    const val: Array<never> = [];\n    expect(prettyFormat(val)).toBe('Array []');\n  });\n\n  it('prints an array with items', () => {\n    const val = [1, 2, 3];\n    expect(prettyFormat(val)).toBe('Array [\\n  1,\\n  2,\\n  3,\\n]');\n  });\n\n  it('prints a sparse array with only holes', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const val = [, , ,];\n    expect(prettyFormat(val)).toBe('Array [\\n  ,\\n  ,\\n  ,\\n]');\n  });\n\n  it('prints a sparse array with items', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const val = [1, , , 4];\n    expect(prettyFormat(val)).toBe('Array [\\n  1,\\n  ,\\n  ,\\n  4,\\n]');\n  });\n\n  it('prints a sparse array with value surrounded by holes', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const val = [, 5, ,];\n    expect(prettyFormat(val)).toBe('Array [\\n  ,\\n  5,\\n  ,\\n]');\n  });\n\n  it('prints a sparse array also containing undefined values', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    const val = [1, , undefined, undefined, , 4];\n    expect(prettyFormat(val)).toBe(\n      'Array [\\n  1,\\n  ,\\n  undefined,\\n  undefined,\\n  ,\\n  4,\\n]',\n    );\n  });\n\n  it('prints a empty typed array', () => {\n    const val = new Uint32Array(0);\n    expect(prettyFormat(val)).toBe('Uint32Array []');\n  });\n\n  it('prints a typed array with items', () => {\n    const val = new Uint32Array(3);\n    expect(prettyFormat(val)).toBe('Uint32Array [\\n  0,\\n  0,\\n  0,\\n]');\n  });\n\n  it('prints an array buffer', () => {\n    const val = new ArrayBuffer(3);\n    expect(prettyFormat(val)).toBe('ArrayBuffer [\\n  0,\\n  0,\\n  0,\\n]');\n  });\n\n  it('prints an data view', () => {\n    const val = new DataView(new ArrayBuffer(3));\n    expect(prettyFormat(val)).toBe('DataView [\\n  0,\\n  0,\\n  0,\\n]');\n  });\n\n  it('prints a nested array', () => {\n    const val = [[1, 2, 3]];\n    expect(prettyFormat(val)).toBe(\n      'Array [\\n  Array [\\n    1,\\n    2,\\n    3,\\n  ],\\n]',\n    );\n  });\n\n  it('prints true', () => {\n    const val = true;\n    expect(prettyFormat(val)).toBe('true');\n  });\n\n  it('prints false', () => {\n    const val = false;\n    expect(prettyFormat(val)).toBe('false');\n  });\n\n  it('prints an error', () => {\n    const val = new Error();\n    expect(prettyFormat(val)).toBe('[Error]');\n  });\n\n  it('prints a typed error with a message', () => {\n    const val = new TypeError('message');\n    expect(prettyFormat(val)).toBe('[TypeError: message]');\n  });\n\n  it('prints a function constructor', () => {\n    /* eslint-disable no-new-func */\n    const val = new Function();\n    /* eslint-enable no-new-func */\n    // In Node >=8.1.4: val.name === 'anonymous'\n    expect(prettyFormat(val)).toBe('[Function anonymous]');\n  });\n\n  it('prints an anonymous callback function', () => {\n    let val;\n    function f(cb: () => void) {\n      val = cb;\n    }\n    f(() => {});\n    // In Node >=8.1.4: val.name === ''\n    expect(prettyFormat(val)).toBe('[Function anonymous]');\n  });\n\n  it('prints an anonymous assigned function', () => {\n    const val = () => {};\n    const formatted = prettyFormat(val);\n    // Node 6.5 infers function names\n    expect(\n      formatted === '[Function anonymous]' || formatted === '[Function val]',\n    ).toBeTruthy();\n  });\n\n  it('prints a named function', () => {\n    const val = function named() {};\n    expect(prettyFormat(val)).toBe('[Function named]');\n  });\n\n  it('prints a named generator function', () => {\n    const val = function* generate() {\n      yield 1;\n      yield 2;\n      yield 3;\n    };\n    expect(prettyFormat(val)).toBe('[Function generate]');\n  });\n\n  it('can customize function names', () => {\n    const val = function named() {};\n    expect(\n      prettyFormat(val, {\n        printFunctionName: false,\n      }),\n    ).toBe('[Function]');\n  });\n\n  it('prints Infinity', () => {\n    const val = Number.POSITIVE_INFINITY;\n    expect(prettyFormat(val)).toBe('Infinity');\n  });\n\n  it('prints -Infinity', () => {\n    const val = Number.NEGATIVE_INFINITY;\n    expect(prettyFormat(val)).toBe('-Infinity');\n  });\n\n  it('prints an empty map', () => {\n    const val = new Map();\n    expect(prettyFormat(val)).toBe('Map {}');\n  });\n\n  it('prints a map with values', () => {\n    const val = new Map();\n    val.set('prop1', 'value1');\n    val.set('prop2', 'value2');\n    expect(prettyFormat(val)).toBe(\n      'Map {\\n  \"prop1\" => \"value1\",\\n  \"prop2\" => \"value2\",\\n}',\n    );\n  });\n\n  it('prints a map with non-string keys', () => {\n    const val = new Map<unknown, unknown>([\n      [false, 'boolean'],\n      ['false', 'string'],\n      [0, 'number'],\n      ['0', 'string'],\n      [null, 'null'],\n      ['null', 'string'],\n      [undefined, 'undefined'],\n      ['undefined', 'string'],\n      [Symbol('description'), 'symbol'],\n      ['Symbol(description)', 'string'],\n      [['array', 'key'], 'array'],\n      [{key: 'value'}, 'object'],\n    ]);\n    const expected = [\n      'Map {',\n      '  false => \"boolean\",',\n      '  \"false\" => \"string\",',\n      '  0 => \"number\",',\n      '  \"0\" => \"string\",',\n      '  null => \"null\",',\n      '  \"null\" => \"string\",',\n      '  undefined => \"undefined\",',\n      '  \"undefined\" => \"string\",',\n      '  Symbol(description) => \"symbol\",',\n      '  \"Symbol(description)\" => \"string\",',\n      '  Array [',\n      '    \"array\",',\n      '    \"key\",',\n      '  ] => \"array\",',\n      '  Object {',\n      '    \"key\": \"value\",',\n      '  } => \"object\",',\n      '}',\n    ].join('\\n');\n    expect(prettyFormat(val)).toEqual(expected);\n  });\n\n  it('prints NaN', () => {\n    const val = Number.NaN;\n    expect(prettyFormat(val)).toBe('NaN');\n  });\n\n  it('prints null', () => {\n    const val = null;\n    expect(prettyFormat(val)).toBe('null');\n  });\n\n  it('prints a positive number', () => {\n    const val = 123;\n    expect(prettyFormat(val)).toBe('123');\n  });\n\n  it('prints a negative number', () => {\n    const val = -123;\n    expect(prettyFormat(val)).toBe('-123');\n  });\n\n  it('prints zero', () => {\n    const val = 0;\n    expect(prettyFormat(val)).toBe('0');\n  });\n\n  it('prints negative zero', () => {\n    const val = -0;\n    expect(prettyFormat(val)).toBe('-0');\n  });\n\n  it('prints a positive bigint', () => {\n    const val = BigInt(123);\n    expect(prettyFormat(val)).toBe('123n');\n  });\n\n  it('prints a negative bigint', () => {\n    const val = BigInt(-123);\n    expect(prettyFormat(val)).toBe('-123n');\n  });\n\n  it('prints zero bigint', () => {\n    const val = BigInt(0);\n    expect(prettyFormat(val)).toBe('0n');\n  });\n\n  it('prints negative zero bigint', () => {\n    const val = BigInt(-0);\n    expect(prettyFormat(val)).toBe('0n');\n  });\n\n  it('prints a date', () => {\n    const val = new Date(10e11);\n    expect(prettyFormat(val)).toBe('2001-09-09T01:46:40.000Z');\n  });\n\n  it('prints an invalid date', () => {\n    const val = new Date(Number.POSITIVE_INFINITY);\n    expect(prettyFormat(val)).toBe('Date { NaN }');\n  });\n\n  it('prints an empty object', () => {\n    const val = {};\n    expect(prettyFormat(val)).toBe('Object {}');\n  });\n\n  it('prints an object with properties', () => {\n    const val = {prop1: 'value1', prop2: 'value2'};\n    expect(prettyFormat(val)).toBe(\n      'Object {\\n  \"prop1\": \"value1\",\\n  \"prop2\": \"value2\",\\n}',\n    );\n  });\n\n  it('prints an object with properties and symbols', () => {\n    const val: any = {};\n    val[Symbol('symbol1')] = 'value2';\n    val[Symbol('symbol2')] = 'value3';\n    val.prop = 'value1';\n    expect(prettyFormat(val)).toBe(\n      'Object {\\n  \"prop\": \"value1\",\\n  Symbol(symbol1): \"value2\",\\n  Symbol(symbol2): \"value3\",\\n}',\n    );\n  });\n\n  it('prints an object without non-enumerable properties which have string key', () => {\n    const val: unknown = {\n      enumerable: true,\n    };\n    const key = 'non-enumerable';\n    Object.defineProperty(val, key, {\n      enumerable: false,\n      value: false,\n    });\n    expect(prettyFormat(val)).toBe('Object {\\n  \"enumerable\": true,\\n}');\n  });\n\n  it('prints an object without non-enumerable properties which have symbol key', () => {\n    const val: unknown = {\n      enumerable: true,\n    };\n    const key = Symbol('non-enumerable');\n    Object.defineProperty(val, key, {\n      enumerable: false,\n      value: false,\n    });\n    expect(prettyFormat(val)).toBe('Object {\\n  \"enumerable\": true,\\n}');\n  });\n\n  it('prints an object with sorted properties', () => {\n    // eslint-disable-next-line sort-keys\n    const val = {b: 1, a: 2};\n    expect(prettyFormat(val)).toBe('Object {\\n  \"a\": 2,\\n  \"b\": 1,\\n}');\n  });\n\n  it('prints an object with keys in their original order with the appropriate comparing function', () => {\n    // eslint-disable-next-line sort-keys\n    const val = {b: 1, a: 2};\n    const compareKeys = () => 0;\n    expect(prettyFormat(val, {compareKeys})).toBe(\n      'Object {\\n  \"b\": 1,\\n  \"a\": 2,\\n}',\n    );\n  });\n\n  it('prints an object with keys in their original order with compareKeys set to null', () => {\n    // eslint-disable-next-line sort-keys\n    const val = {b: 1, a: 2};\n    expect(prettyFormat(val, {compareKeys: null})).toBe(\n      'Object {\\n  \"b\": 1,\\n  \"a\": 2,\\n}',\n    );\n  });\n\n  it('prints an object with keys sorted in reverse order', () => {\n    const val = {a: 1, b: 2};\n    const compareKeys = (a: string, b: string) => (a > b ? -1 : 1);\n    expect(prettyFormat(val, {compareKeys})).toBe(\n      'Object {\\n  \"b\": 2,\\n  \"a\": 1,\\n}',\n    );\n  });\n\n  it('prints regular expressions from constructors', () => {\n    const val = new RegExp('regexp');\n    expect(prettyFormat(val)).toBe('/regexp/');\n  });\n\n  it('prints regular expressions from literals', () => {\n    const val = /regexp/gi;\n    expect(prettyFormat(val)).toBe('/regexp/gi');\n  });\n\n  it('prints regular expressions {escapeRegex: false}', () => {\n    const val = /regexp\\d/gi;\n    expect(prettyFormat(val)).toBe('/regexp\\\\d/gi');\n  });\n\n  it('prints regular expressions {escapeRegex: true}', () => {\n    const val = /regexp\\d/gi;\n    expect(prettyFormat(val, {escapeRegex: true})).toBe('/regexp\\\\\\\\d/gi');\n  });\n\n  it('escapes regular expressions nested inside object', () => {\n    const obj = {test: /regexp\\d/gi};\n    expect(prettyFormat(obj, {escapeRegex: true})).toBe(\n      'Object {\\n  \"test\": /regexp\\\\\\\\d/gi,\\n}',\n    );\n  });\n\n  it('prints an empty set', () => {\n    const val = new Set();\n    expect(prettyFormat(val)).toBe('Set {}');\n  });\n\n  it('prints a set with values', () => {\n    const val = new Set();\n    val.add('value1');\n    val.add('value2');\n    expect(prettyFormat(val)).toBe('Set {\\n  \"value1\",\\n  \"value2\",\\n}');\n  });\n\n  it('prints a string', () => {\n    const val = 'string';\n    expect(prettyFormat(val)).toBe('\"string\"');\n  });\n\n  it('prints and escape a string', () => {\n    const val = '\"\\'\\\\';\n    expect(prettyFormat(val)).toBe('\"\\\\\"\\'\\\\\\\\\"');\n  });\n\n  it(\"doesn't escape string with {escapeString: false}\", () => {\n    const val = '\"\\'\\\\n';\n    expect(prettyFormat(val, {escapeString: false})).toBe('\"\"\\'\\\\n\"');\n  });\n\n  it('prints a string with escapes', () => {\n    expect(prettyFormat('\"-\"')).toBe('\"\\\\\"-\\\\\"\"');\n    expect(prettyFormat('\\\\ \\\\\\\\')).toBe('\"\\\\\\\\ \\\\\\\\\\\\\\\\\"');\n  });\n\n  it('prints a multiline string', () => {\n    const val = ['line 1', 'line 2', 'line 3'].join('\\n');\n    expect(prettyFormat(val)).toBe(`\"${val}\"`);\n  });\n\n  it('prints a multiline string as value of object property', () => {\n    const polyline = {\n      props: {\n        id: 'J',\n        points: ['0.5,0.460', '0.5,0.875', '0.25,0.875'].join('\\n'),\n      },\n      type: 'polyline',\n    };\n    const val = {\n      props: {\n        children: polyline,\n      },\n      type: 'svg',\n    };\n    expect(prettyFormat(val)).toEqual(\n      [\n        'Object {',\n        '  \"props\": Object {',\n        '    \"children\": Object {',\n        '      \"props\": Object {',\n        '        \"id\": \"J\",',\n        '        \"points\": \"0.5,0.460',\n        '0.5,0.875',\n        '0.25,0.875\",',\n        '      },',\n        '      \"type\": \"polyline\",',\n        '    },',\n        '  },',\n        '  \"type\": \"svg\",',\n        '}',\n      ].join('\\n'),\n    );\n  });\n\n  it('prints a symbol', () => {\n    const val = Symbol('symbol');\n    expect(prettyFormat(val)).toBe('Symbol(symbol)');\n  });\n\n  it('prints undefined', () => {\n    const val = undefined;\n    expect(prettyFormat(val)).toBe('undefined');\n  });\n\n  it('prints a WeakMap', () => {\n    const val = new WeakMap();\n    expect(prettyFormat(val)).toBe('WeakMap {}');\n  });\n\n  it('prints a WeakSet', () => {\n    const val = new WeakSet();\n    expect(prettyFormat(val)).toBe('WeakSet {}');\n  });\n\n  it('prints deeply nested objects', () => {\n    const val = {prop: {prop: {prop: 'value'}}};\n    expect(prettyFormat(val)).toBe(\n      'Object {\\n  \"prop\": Object {\\n    \"prop\": Object {\\n      \"prop\": \"value\",\\n    },\\n  },\\n}',\n    );\n  });\n\n  it('prints circular references', () => {\n    const val: any = {};\n    val.prop = val;\n    expect(prettyFormat(val)).toBe('Object {\\n  \"prop\": [Circular],\\n}');\n  });\n\n  it('prints parallel references', () => {\n    const inner = {};\n    const val = {prop1: inner, prop2: inner};\n    expect(prettyFormat(val)).toBe(\n      'Object {\\n  \"prop1\": Object {},\\n  \"prop2\": Object {},\\n}',\n    );\n  });\n\n  describe('indent option', () => {\n    const val = [\n      {\n        id: '8658c1d0-9eda-4a90-95e1-8001e8eb6036',\n        text: 'Add alternative serialize API for pretty-format plugins',\n        type: 'ADD_TODO',\n      },\n      {\n        id: '8658c1d0-9eda-4a90-95e1-8001e8eb6036',\n        type: 'TOGGLE_TODO',\n      },\n    ];\n    const expected = [\n      'Array [',\n      '  Object {',\n      '    \"id\": \"8658c1d0-9eda-4a90-95e1-8001e8eb6036\",',\n      '    \"text\": \"Add alternative serialize API for pretty-format plugins\",',\n      '    \"type\": \"ADD_TODO\",',\n      '  },',\n      '  Object {',\n      '    \"id\": \"8658c1d0-9eda-4a90-95e1-8001e8eb6036\",',\n      '    \"type\": \"TOGGLE_TODO\",',\n      '  },',\n      ']',\n    ].join('\\n');\n    test('default implicit: 2 spaces', () => {\n      expect(prettyFormat(val)).toEqual(expected);\n    });\n    test('default explicit: 2 spaces', () => {\n      expect(prettyFormat(val, {indent: 2})).toEqual(expected);\n    });\n\n    // Tests assume that no strings in val contain multiple adjacent spaces!\n    test('non-default: 0 spaces', () => {\n      const indent = 0;\n      expect(prettyFormat(val, {indent})).toEqual(\n        expected.replaceAll(/ {2}/g, ' '.repeat(indent)),\n      );\n    });\n    test('non-default: 4 spaces', () => {\n      const indent = 4;\n      expect(prettyFormat(val, {indent})).toEqual(\n        expected.replaceAll(/ {2}/g, ' '.repeat(indent)),\n      );\n    });\n  });\n\n  it('can omit basic prototypes', () => {\n    const val = {\n      deeply: {nested: {object: {}}},\n      'empty array': {},\n      'empty object': {},\n      'nested array': [[[]]],\n      'typed array': new Uint8Array(),\n    };\n    expect(prettyFormat(val, {maxDepth: 2, printBasicPrototype: false})).toBe(\n      [\n        '{',\n        '  \"deeply\": {',\n        '    \"nested\": [Object],',\n        '  },',\n        '  \"empty array\": {},',\n        '  \"empty object\": {},',\n        '  \"nested array\": [',\n        '    [Array],',\n        '  ],',\n        '  \"typed array\": Uint8Array [],',\n        '}',\n      ].join('\\n'),\n    );\n  });\n\n  describe('maxWidth option', () => {\n    it('applies to arrays', () => {\n      const val = Array.from({length: 1_000_000}).fill('x');\n      expect(prettyFormat(val, {maxWidth: 5})).toEqual(\n        [\n          'Array [',\n          '  \"x\",',\n          '  \"x\",',\n          '  \"x\",',\n          '  \"x\",',\n          '  \"x\",',\n          '  …',\n          ']',\n        ].join('\\n'),\n      );\n    });\n\n    it('applies to sets', () => {\n      const val = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9, 0]);\n      expect(prettyFormat(val, {maxWidth: 5})).toEqual(\n        ['Set {', '  1,', '  2,', '  3,', '  4,', '  5,', '  …', '}'].join(\n          '\\n',\n        ),\n      );\n    });\n\n    it('applies to maps', () => {\n      const val = new Map();\n      val.set('a', 1);\n      val.set('b', 2);\n      val.set('c', 3);\n      val.set('d', 4);\n      val.set('e', 5);\n      val.set('f', 6);\n      val.set('g', 7);\n      val.set('h', 8);\n      val.set('i', 9);\n      val.set('j', 10);\n      expect(prettyFormat(val, {maxWidth: 5})).toEqual(\n        [\n          'Map {',\n          '  \"a\" => 1,',\n          '  \"b\" => 2,',\n          '  \"c\" => 3,',\n          '  \"d\" => 4,',\n          '  \"e\" => 5,',\n          '  …',\n          '}',\n        ].join('\\n'),\n      );\n    });\n  });\n\n  it('can customize the max depth', () => {\n    const val = [\n      {\n        'arguments empty': returnArguments(),\n        'arguments non-empty': returnArguments('arg'),\n        'array literal empty': [],\n        'array literal non-empty': ['item'],\n        'extended array empty': new MyArray(),\n        'map empty': new Map(),\n        'map non-empty': new Map([['name', 'value']]),\n        'object literal empty': {},\n        'object literal non-empty': {name: 'value'},\n        // @ts-expect-error\n        'object with constructor': new MyObject('value'),\n        'object without constructor': Object.create(null),\n        'set empty': new Set(),\n        'set non-empty': new Set(['value']),\n      },\n    ];\n    expect(prettyFormat(val, {maxDepth: 2})).toEqual(\n      [\n        'Array [',\n        '  Object {',\n        '    \"arguments empty\": [Arguments],',\n        '    \"arguments non-empty\": [Arguments],',\n        '    \"array literal empty\": [Array],',\n        '    \"array literal non-empty\": [Array],',\n        '    \"extended array empty\": [MyArray],',\n        '    \"map empty\": [Map],',\n        '    \"map non-empty\": [Map],',\n        '    \"object literal empty\": [Object],',\n        '    \"object literal non-empty\": [Object],',\n        '    \"object with constructor\": [MyObject],',\n        '    \"object without constructor\": [Object],',\n        '    \"set empty\": [Set],',\n        '    \"set non-empty\": [Set],',\n        '  },',\n        ']',\n      ].join('\\n'),\n    );\n  });\n\n  it('throws on invalid options', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime error\n      prettyFormat({}, {invalidOption: true});\n    }).toThrow('Unknown option \"invalidOption\".');\n  });\n\n  it('supports plugins', () => {\n    class Foo {}\n\n    expect(\n      prettyFormat(new Foo(), {\n        plugins: [\n          {\n            print: () => 'class Foo',\n            test(object) {\n              return object.constructor.name === 'Foo';\n            },\n          },\n        ],\n      }),\n    ).toBe('class Foo');\n  });\n\n  it('supports plugins that return empty string', () => {\n    const val = {\n      payload: '',\n    };\n    const options = {\n      plugins: [\n        {\n          print(val: any) {\n            return val.payload;\n          },\n          test(val: any) {\n            return val && typeof val.payload === 'string';\n          },\n        },\n      ],\n    };\n    expect(prettyFormat(val, options)).toBe('');\n  });\n\n  it('throws if plugin does not return a string', () => {\n    const val = 123;\n    const options: PrettyFormatOptions = {\n      plugins: [\n        {\n          // @ts-expect-error: Testing runtime error\n          print(val: unknown) {\n            return val;\n          },\n          test() {\n            return true;\n          },\n        },\n      ],\n    };\n    expect(() => {\n      prettyFormat(val, options);\n    }).toThrow(\n      'Plugin must return type \"string\" but instead returned \"number\".',\n    );\n  });\n\n  it('throws PrettyFormatPluginError if test throws an error', () => {\n    expect.hasAssertions();\n    const options = {\n      plugins: [\n        {\n          print: () => '',\n          test() {\n            throw new Error('Where is the error?');\n          },\n        },\n      ],\n    };\n\n    try {\n      prettyFormat('', options);\n    } catch (error: any) {\n      expect(error.name).toBe('PrettyFormatPluginError');\n    }\n  });\n\n  it('throws PrettyFormatPluginError if print throws an error', () => {\n    expect.hasAssertions();\n    const options = {\n      plugins: [\n        {\n          print: () => {\n            throw new Error('Where is the error?');\n          },\n          test: () => true,\n        },\n      ],\n    };\n\n    try {\n      prettyFormat('', options);\n    } catch (error: any) {\n      expect(error.name).toBe('PrettyFormatPluginError');\n    }\n  });\n\n  it('throws PrettyFormatPluginError if serialize throws an error', () => {\n    expect.hasAssertions();\n    const options = {\n      plugins: [\n        {\n          serialize: () => {\n            throw new Error('Where is the error?');\n          },\n          test: () => true,\n        },\n      ],\n    };\n\n    try {\n      prettyFormat('', options);\n    } catch (error: any) {\n      expect(error.name).toBe('PrettyFormatPluginError');\n    }\n  });\n\n  it('supports plugins with deeply nested arrays (#24)', () => {\n    const val = [\n      [1, 2],\n      [3, 4],\n    ];\n    expect(\n      prettyFormat(val, {\n        plugins: [\n          {\n            print(val: unknown, print: any) {\n              return (val as Array<unknown>)\n                .map(item => print(item))\n                .join(' - ');\n            },\n            test(val: unknown) {\n              return Array.isArray(val);\n            },\n          },\n        ],\n      }),\n    ).toBe('1 - 2 - 3 - 4');\n  });\n\n  it('should call plugins on nested basic values', () => {\n    const val = {prop: 42};\n    expect(\n      prettyFormat(val, {\n        plugins: [\n          {\n            print(_val, _print) {\n              return '[called]';\n            },\n            test(val) {\n              return typeof val === 'string' || typeof val === 'number';\n            },\n          },\n        ],\n      }),\n    ).toBe('Object {\\n  [called]: [called],\\n}');\n  });\n\n  it('prints objects with no constructor', () => {\n    expect(prettyFormat(Object.create(null))).toBe('Object {}');\n  });\n\n  it('prints identity-obj-proxy with string constructor', () => {\n    const val = Object.create(null);\n    val.constructor = 'constructor'; // mock the mock object :)\n    const expected = [\n      'Object {', // Object instead of undefined\n      '  \"constructor\": \"constructor\",',\n      '}',\n    ].join('\\n');\n    expect(prettyFormat(val)).toEqual(expected);\n  });\n\n  it('calls toJSON and prints its return value', () => {\n    expect(\n      prettyFormat({\n        toJSON: () => ({value: false}),\n        value: true,\n      }),\n    ).toBe('Object {\\n  \"value\": false,\\n}');\n  });\n\n  it('calls toJSON and prints an internal representation.', () => {\n    expect(\n      prettyFormat({\n        toJSON: () => '[Internal Object]',\n        value: true,\n      }),\n    ).toBe('\"[Internal Object]\"');\n  });\n\n  it('calls toJSON only on functions', () => {\n    expect(\n      prettyFormat({\n        toJSON: false,\n        value: true,\n      }),\n    ).toBe('Object {\\n  \"toJSON\": false,\\n  \"value\": true,\\n}');\n  });\n\n  it('does not call toJSON recursively', () => {\n    expect(\n      prettyFormat({\n        toJSON: () => ({toJSON: () => ({value: true})}),\n        value: false,\n      }),\n    ).toBe('Object {\\n  \"toJSON\": [Function toJSON],\\n}');\n  });\n\n  it('calls toJSON on Sets', () => {\n    const set = new Set([1]);\n    (set as any).toJSON = () => 'map';\n    expect(prettyFormat(set)).toBe('\"map\"');\n  });\n\n  it('disables toJSON calls through options', () => {\n    const value = {apple: 'banana', toJSON: jest.fn(() => '1')};\n    const name = value.toJSON.name || 'anonymous';\n    const set = new Set([value]);\n    (set as any).toJSON = jest.fn(() => 'map');\n    expect(\n      prettyFormat(set, {\n        callToJSON: false,\n      }),\n    ).toBe(\n      `Set {\\n  Object {\\n    \"apple\": \"banana\",\\n    \"toJSON\": [Function ${name}],\\n  },\\n}`,\n    );\n    expect((set as any).toJSON).not.toHaveBeenCalled();\n    expect(value.toJSON).not.toHaveBeenCalled();\n  });\n\n  describe('min', () => {\n    it('prints some basic values in min mode', () => {\n      const val = {\n        boolean: [false, true],\n        null: null,\n        number: [\n          0,\n          -0,\n          123,\n          -123,\n          Number.POSITIVE_INFINITY,\n          Number.NEGATIVE_INFINITY,\n          Number.NaN,\n        ],\n        string: ['', 'non-empty'],\n        undefined,\n      };\n      expect(\n        prettyFormat(val, {\n          min: true,\n        }),\n      ).toBe(\n        `{${[\n          '\"boolean\": [false, true]',\n          '\"null\": null',\n          '\"number\": [0, -0, 123, -123, Infinity, -Infinity, NaN]',\n          '\"string\": [\"\", \"non-empty\"]',\n          '\"undefined\": undefined',\n        ].join(', ')}}`,\n      );\n    });\n\n    it('prints some complex values in min mode', () => {\n      const val = {\n        'arguments empty': returnArguments(),\n        'arguments non-empty': returnArguments('arg'),\n        'array literal empty': [],\n        'array literal non-empty': ['item'],\n        'extended array empty': new MyArray(),\n        'map empty': new Map(),\n        'map non-empty': new Map([['name', 'value']]),\n        'object literal empty': {},\n        'object literal non-empty': {name: 'value'},\n        // @ts-expect-error\n        'object with constructor': new MyObject('value'),\n        'object without constructor': Object.create(null),\n        'set empty': new Set(),\n        'set non-empty': new Set(['value']),\n      };\n      expect(\n        prettyFormat(val, {\n          min: true,\n        }),\n      ).toBe(\n        `{${[\n          '\"arguments empty\": []',\n          '\"arguments non-empty\": [\"arg\"]',\n          '\"array literal empty\": []',\n          '\"array literal non-empty\": [\"item\"]',\n          '\"extended array empty\": []',\n          '\"map empty\": Map {}',\n          '\"map non-empty\": Map {\"name\" => \"value\"}',\n          '\"object literal empty\": {}',\n          '\"object literal non-empty\": {\"name\": \"value\"}',\n          '\"object with constructor\": {\"name\": \"value\"}',\n          '\"object without constructor\": {}',\n          '\"set empty\": Set {}',\n          '\"set non-empty\": Set {\"value\"}',\n        ].join(', ')}}`,\n      );\n    });\n\n    it('does not allow indent !== 0 in min mode', () => {\n      expect(() => {\n        prettyFormat(1, {indent: 1, min: true});\n      }).toThrow('Options \"min\" and \"indent\" cannot be used together.');\n    });\n  });\n});"}
{"prompt":"printDiffOrStringify,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {alignedAnsiStyleSerializer} from '@jest/test-utils';\nimport {INVERTED_COLOR, printDiffOrStringify} from '../index';\n\nexpect.addSnapshotSerializer(alignedAnsiStyleSerializer);\n\ndescribe('printDiffOrStringify', () => {\n  const testDiffOrStringify = (expected: unknown, received: unknown): string =>\n    printDiffOrStringify(expected, received, 'Expected', 'Received', true);\n\n  test('expected is empty and received is single line', () => {\n    const expected = '';\n    const received = 'single line';\n    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n  });\n\n  test('expected is multi line and received is empty', () => {\n    const expected = 'multi\\nline';\n    const received = '';\n    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n  });\n\n  test('expected and received are single line with multiple changes', () => {\n    const expected = 'delete common expected common prev';\n    const received = 'insert common received common next';\n    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n  });\n\n  test('expected and received are multi line with trailing spaces', () => {\n    const expected = 'delete \\ncommon expected common\\nprev ';\n    const received = 'insert \\ncommon received common\\nnext ';\n    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n  });\n\n  test('has no common after clean up chaff multiline', () => {\n    const expected = 'delete\\ntwo';\n    const received = 'insert\\n2';\n    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n  });\n\n  test('has no common after clean up chaff one-line', () => {\n    const expected = 'delete';\n    const received = 'insert';\n    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n  });\n\n  test('object contain readonly symbol key object', () => {\n    const expected = {b: 2};\n    const received = {b: 1};\n    const symbolKey = Symbol.for('key');\n    Object.defineProperty(expected, symbolKey, {\n      configurable: true,\n      enumerable: true,\n      value: {\n        a: 1,\n      },\n      writable: false,\n    });\n    Object.defineProperty(received, symbolKey, {\n      configurable: true,\n      enumerable: true,\n      value: {\n        a: 1,\n      },\n      writable: false,\n    });\n    expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n  });\n\n  describe('MAX_DIFF_STRING_LENGTH', () => {\n    const lessChange = INVERTED_COLOR('single ');\n    const less = 'single line';\n    const more = `multi line${'\\n123456789'.repeat(2000)}`; // 10 + 20K chars\n\n    test('both are less', () => {\n      const difference = testDiffOrStringify('multi\\nline', less);\n\n      expect(difference).toMatch('- multi');\n      expect(difference).toMatch('- line');\n\n      // diffStringsUnified has substring change\n      expect(difference).not.toMatch('+ single line');\n      expect(difference).toMatch(lessChange);\n    });\n\n    test('expected is more', () => {\n      const difference = testDiffOrStringify(more, less);\n\n      expect(difference).toMatch('- multi line');\n      expect(difference).toMatch('+ single line');\n\n      // diffLinesUnified does not have substring change\n      expect(difference).not.toMatch(lessChange);\n    });\n\n    test('received is more', () => {\n      const difference = testDiffOrStringify(less, more);\n\n      expect(difference).toMatch('- single line');\n      expect(difference).toMatch('+ multi line');\n\n      // diffLinesUnified does not have substring change\n      expect(difference).not.toMatch(lessChange);\n    });\n  });\n\n  describe('asymmetricMatcher', () => {\n    test('minimal test', () => {\n      const expected = {a: expect.any(Number), b: 2};\n      const received = {a: 1, b: 1};\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('jest asymmetricMatcher', () => {\n      const expected = {\n        a: expect.any(Number),\n        b: expect.anything(),\n        c: expect.arrayContaining([1, 3]),\n        d: 'jest is awesome',\n        e: 'jest is awesome',\n        f: {\n          a: new Date(),\n          b: 'jest is awesome',\n        },\n        g: true,\n        [Symbol.for('h')]: 'jest is awesome',\n      };\n      const received = {\n        a: 1,\n        b: 'anything',\n        c: [1, 2, 3],\n        d: expect.stringContaining('jest'),\n        e: expect.stringMatching(/^jest/),\n        f: expect.objectContaining({\n          a: expect.any(Date),\n        }),\n        g: false,\n        [Symbol.for('h')]: expect.any(String),\n      };\n\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('custom asymmetricMatcher', () => {\n      expect.extend({\n        equal5(received: unknown) {\n          if (received === 5)\n            return {\n              message: () => `expected ${received} not to be 5`,\n              pass: true,\n            };\n          return {\n            message: () => `expected ${received} to be 5`,\n            pass: false,\n          };\n        },\n      });\n      const expected = {\n        a: expect.equal5(),\n        b: false,\n      };\n      const received = {\n        a: 5,\n        b: true,\n      };\n\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('nested object', () => {\n      const expected = {\n        a: 1,\n        b: {\n          a: 1,\n          b: expect.any(Number),\n        },\n        c: 2,\n      };\n      const received = {\n        a: expect.any(Number),\n        b: {\n          a: 1,\n          b: 2,\n        },\n        c: 1,\n      };\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('array', () => {\n      const expected: Array<unknown> = [1, expect.any(Number), 3];\n      const received: Array<unknown> = [1, 2, 2];\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('object in array', () => {\n      const expected: Array<unknown> = [1, {a: 1, b: expect.any(Number)}, 3];\n      const received: Array<unknown> = [1, {a: 1, b: 2}, 2];\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('map', () => {\n      const expected = new Map<string, unknown>([\n        ['a', 1],\n        ['b', expect.any(Number)],\n        ['c', 3],\n      ]);\n      const received = new Map<string, unknown>([\n        ['a', 1],\n        ['b', 2],\n        ['c', 2],\n      ]);\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('circular object', () => {\n      const expected: any = {\n        b: expect.any(Number),\n        c: 3,\n      };\n      expected.a = expected;\n      const received: any = {\n        b: 2,\n        c: 2,\n      };\n      received.a = received;\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('transitive circular', () => {\n      const expected: unknown = {\n        a: 3,\n      };\n      expected.nested = {b: expect.any(Number), parent: expected};\n      const received: any = {\n        a: 2,\n      };\n      received.nested = {b: 2, parent: received};\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('circular array', () => {\n      const expected: Array<unknown> = [1, expect.any(Number), 3];\n      expected.push(expected);\n      const received: Array<unknown> = [1, 2, 2];\n      received.push(received);\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n\n    test('circular map', () => {\n      const expected = new Map<string, unknown>([\n        ['a', 1],\n        ['b', expect.any(Number)],\n        ['c', 3],\n      ]);\n      expected.set('circular', expected);\n      const received = new Map<string, unknown>([\n        ['a', 1],\n        ['b', 2],\n        ['c', 2],\n      ]);\n      received.set('circular', received);\n      expect(testDiffOrStringify(expected, received)).toMatchSnapshot();\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`printDiffOrStringify asymmetricMatcher array 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Array [</>\n<d>    1,</>\n<d>    Any<Number>,</>\n<g>-   3,</>\n<r>+   2,</>\n<d>  ]</>\n`;\n\nexports[`printDiffOrStringify asymmetricMatcher circular array 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Array [</>\n<d>    1,</>\n<d>    Any<Number>,</>\n<g>-   3,</>\n<r>+   2,</>\n<d>    [Circular],</>\n<d>  ]</>\n`;\n\nexports[`printDiffOrStringify asymmetricMatcher circular map 1`] = `\n<g>- Expected  - 2</>\n<r>+ Received  + 2</>\n\n<d>  Map {</>\n<d>    \"a\" => 1,</>\n<d>    \"b\" => Any<Number>,</>\n<g>-   \"c\" => 3,</>\n<r>+   \"c\" => 2,</>\n<d>    \"circular\" => Map {</>\n<d>      \"a\" => 1,</>\n<d>      \"b\" => Any<Number>,</>\n<g>-     \"c\" => 3,</>\n<r>+     \"c\" => 2,</>\n<d>      \"circular\" => [Circular],</>\n<d>    },</>\n<d>  }</>\n`;\n\nexports[`printDiffOrStringify asymmetricMatcher circular object 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<d>    \"a\": [Circular],</>\n<d>    \"b\": Any<Number>,</>\n<g>-   \"c\": 3,</>\n<r>+   \"c\": 2,</>\n<d>  }</>\n`;\n\nexports[`printDiffOrStringify asymmetricMatcher custom asymmetricMatcher 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<d>    \"a\": equal5<>,</>\n<g>-   \"b\": false,</>\n<r>+   \"b\": true,</>\n<d>  }</>\n`;\n\nexports[`printDiffOrStringify asymmetricMatcher jest asymmetricMatcher 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<d>    \"a\": Any<Number>,</>\n<d>    \"b\": Anything,</>\n<d>    \"c\": ArrayContaining [</>\n<d>      1,</>\n<d>      3,</>\n<d>    ],</>\n<d>    \"d\": StringContaining \"jest\",</>\n<d>    \"e\": StringMatching /^jest/,</>\n<d>    \"f\": ObjectContaining {</>\n<d>      \"a\": Any<Date>,</>\n<d>    },</>\n<g>-   \"g\": true,</>\n<r>+   \"g\": false,</>\n<d>    Symbol(h): Any<String>,</>\n<d>  }</>\n`;\n\nexports[`printDiffOrStringify asymmetricMatcher map 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Map {</>\n<d>    \"a\" => 1,</>\n<d>    \"b\" => Any<Number>,</>\n<g>-   \"c\" => 3,</>\n<r>+   \"c\" => 2,</>\n<d>  }</>\n`;\n\nexports[`printDiffOrStringify asymmetricMatcher minimal test 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<d>    \"a\": Any<Number>,</>\n<g>-   \"b\": 2,</>\n<r>+   \"b\": 1,</>\n<d>  }</>\n`;\n\nexports[`printDiffOrStringify asymmetricMatcher nested object 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<d>    \"a\": Any<Number>,</>\n<d>    \"b\": Object {</>\n<d>      \"a\": 1,</>\n<d>      \"b\": Any<Number>,</>\n<d>    },</>\n<g>-   \"c\": 2,</>\n<r>+   \"c\": 1,</>\n<d>  }</>\n`;\n\nexports[`printDiffOrStringify asymmetricMatcher object in array 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Array [</>\n<d>    1,</>\n<d>    Object {</>\n<d>      \"a\": 1,</>\n<d>      \"b\": Any<Number>,</>\n<d>    },</>\n<g>-   3,</>\n<r>+   2,</>\n<d>  ]</>\n`;\n\nexports[`printDiffOrStringify asymmetricMatcher transitive circular 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"a\": 3,</>\n<r>+   \"a\": 2,</>\n<d>    \"nested\": Object {</>\n<d>      \"b\": Any<Number>,</>\n<d>      \"parent\": [Circular],</>\n<d>    },</>\n<d>  }</>\n`;\n\nexports[`printDiffOrStringify expected and received are multi line with trailing spaces 1`] = `\n<g>- Expected  - 3</>\n<r>+ Received  + 3</>\n\n<g>- <i>delete</i><Y> </></>\n<r>+ <i>insert</i><Y> </></>\n<g>- common <i>expect</i>ed common</>\n<r>+ common <i>receiv</i>ed common</>\n<g>- <i>prev</i><Y> </></>\n<r>+ <i>next</i><Y> </></>\n`;\n\nexports[`printDiffOrStringify expected and received are single line with multiple changes 1`] = `\nExpected: <g>\"<i>delete</i> common <i>expect</i>ed common <i>prev</i>\"</>\nReceived: <r>\"<i>insert</i> common <i>receiv</i>ed common <i>next</i>\"</>\n`;\n\nexports[`printDiffOrStringify expected is empty and received is single line 1`] = `\nExpected: <g>\"\"</>\nReceived: <r>\"single line\"</>\n`;\n\nexports[`printDiffOrStringify expected is multi line and received is empty 1`] = `\nExpected: <g>\"multi</>\n<g>line\"</>\nReceived: <r>\"\"</>\n`;\n\nexports[`printDiffOrStringify has no common after clean up chaff multiline 1`] = `\n<g>- Expected  - 2</>\n<r>+ Received  + 2</>\n\n<g>- delete</>\n<g>- two</>\n<r>+ insert</>\n<r>+ 2</>\n`;\n\nexports[`printDiffOrStringify has no common after clean up chaff one-line 1`] = `\nExpected: <g>\"delete\"</>\nReceived: <r>\"insert\"</>\n`;\n\nexports[`printDiffOrStringify object contain readonly symbol key object 1`] = `\n<g>- Expected  - 1</>\n<r>+ Received  + 1</>\n\n<d>  Object {</>\n<g>-   \"b\": 2,</>\n<r>+   \"b\": 1,</>\n<d>    Symbol(key): Object {</>\n<d>      \"a\": 1,</>\n<d>    },</>\n<d>  }</>\n`;"}
{"prompt":"Trailing spaces in common lines have yellow background color.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport ansiRegex = require('ansi-regex');\nimport styles = require('ansi-styles');\nimport chalk = require('chalk');\nimport type {SyncExpectationResult} from 'expect';\nimport format from 'pretty-format';\nimport {\n  type Context,\n  toMatchInlineSnapshot,\n  toMatchSnapshot,\n  toThrowErrorMatchingInlineSnapshot,\n  toThrowErrorMatchingSnapshot,\n} from '..';\nimport type SnapshotState from '../State';\nimport {\n  aBackground2,\n  aBackground3,\n  aForeground2,\n  aForeground3,\n  bBackground2,\n  bBackground3,\n  bForeground2,\n  bForeground3,\n} from '../colors';\nimport {\n  getReceivedColorForChalkInstance,\n  getSnapshotColorForChalkInstance,\n  noColor,\n  printPropertiesAndReceived,\n  printSnapshotAndReceived,\n} from '../printSnapshot';\nimport {serialize} from '../utils';\n\nconst aOpenForeground1 = styles.magenta.open;\nconst aOpenBackground1 = styles.bgYellowBright.open;\nconst bOpenForeground1 = styles.cyan.open;\nconst bOpenBackground1 = styles.bgWhiteBright.open;\n\nconst aOpenForeground2 = styles.color.ansi256(aForeground2);\nconst bOpenForeground2 = styles.color.ansi256(bForeground2);\nconst aOpenBackground2 = styles.bgColor.ansi256(aBackground2);\nconst bOpenBackground2 = styles.bgColor.ansi256(bBackground2);\n\nconst aOpenForeground3 = styles.color.ansi16m(\n  aForeground3[0],\n  aForeground3[1],\n  aForeground3[2],\n);\nconst bOpenForeground3 = styles.color.ansi16m(\n  bForeground3[0],\n  bForeground3[1],\n  bForeground3[2],\n);\nconst aOpenBackground3 = styles.bgColor.ansi16m(\n  aBackground3[0],\n  aBackground3[1],\n  aBackground3[2],\n);\nconst bOpenBackground3 = styles.bgColor.ansi16m(\n  bBackground3[0],\n  bBackground3[1],\n  bBackground3[2],\n);\n\nconst convertAnsi = (val: string): string => {\n  // Trailing spaces in common lines have yellow background color.\n  let isYellowBackground = false;\n\n  return val.replace(ansiRegex(), match => {\n    switch (match) {\n      case styles.inverse.open:\n        return '<i>';\n      case styles.inverse.close:\n        return '</i>';\n\n      case styles.bold.open:\n        return '<b>';\n      case styles.dim.open:\n        return '<d>';\n      case styles.bold.close:\n      case styles.dim.close:\n        return '</>';\n\n      case styles.green.open:\n        return '<g>';\n      case aOpenForeground1:\n      case aOpenForeground2:\n      case aOpenForeground3:\n        return '<m>';\n      case styles.red.open:\n        return '<r>';\n      case bOpenForeground1:\n      case bOpenForeground2:\n      case bOpenForeground3:\n        return '<t>'; // teal/cyan/aqua\n      case styles.yellow.open:\n        return '<y>';\n      case styles.cyan.close:\n      case styles.green.close:\n      case styles.magenta.close:\n      case styles.red.close:\n      case styles.yellow.close:\n        return '</>';\n\n      case styles.bgYellow.open:\n        isYellowBackground = true;\n        return '<Y>';\n\n      case aOpenBackground1:\n      case bOpenBackground1:\n      case aOpenBackground2:\n      case bOpenBackground2:\n      case aOpenBackground3:\n      case bOpenBackground3:\n        isYellowBackground = false;\n        return '';\n\n      case styles.bgYellow.close:\n        // The same code closes any background color.\n        return isYellowBackground ? '</Y>' : '';\n\n      default:\n        return match;\n    }\n  });\n};\n\nexpect.addSnapshotSerializer({\n  serialize(val: string): string {\n    return convertAnsi(val);\n  },\n  test(val: unknown): val is string {\n    return typeof val === 'string';\n  },\n});\n\ndescribe('chalk', () => {\n  // Because these tests give code coverage of get functions\n  // and give confidence that the escape sequences are correct,\n  // convertAnsi can return same serialization for any chalk level\n  // so snapshot tests pass in any environment with chalk level >= 1.\n\n  // Simulate comparison lines from printSnapshotAndReceived.\n  const formatLines = (chalkInstance: chalk.Chalk) => {\n    const aColor = getSnapshotColorForChalkInstance(chalkInstance);\n    const bColor = getReceivedColorForChalkInstance(chalkInstance);\n    const cColor = chalkInstance.dim;\n    const changeLineTrailingSpaceColor = noColor;\n    const commonLineTrailingSpaceColor = chalkInstance.bgYellow;\n\n    return [\n      aColor(`- delete 1${changeLineTrailingSpaceColor(' ')}`),\n      cColor(`  common 2${commonLineTrailingSpaceColor('  ')}`),\n      bColor('+ insert 0'),\n    ].join('\\n');\n  };\n\n  const expected0 = '- delete 1 \\n  common 2  \\n+ insert 0';\n  const expected1 =\n    '<m>- delete 1 </>\\n<d>  common 2<Y>  </Y></>\\n<t>+ insert 0</>';\n\n  test('level 0', () => {\n    const chalkInstance = new chalk.Instance({level: 0});\n    const formatted = formatLines(chalkInstance);\n    const converted = convertAnsi(formatted);\n\n    expect(converted).toBe(expected0);\n    expect(formatted).toBe(expected0);\n  });\n\n  test('level 1', () => {\n    const chalkInstance = new chalk.Instance({level: 1});\n    const formatted = formatLines(chalkInstance);\n    const converted = convertAnsi(formatted);\n\n    expect(converted).toBe(expected1);\n    expect(formatted).toMatch(`${aOpenForeground1 + aOpenBackground1}-`);\n    expect(formatted).toMatch(`${bOpenForeground1 + bOpenBackground1}+`);\n    expect(formatted).not.toMatch(chalkInstance.bgYellow(' ')); // noColor\n    expect(formatted).toMatch(chalkInstance.bgYellow('  '));\n  });\n\n  test('level 2', () => {\n    const chalkInstance = new chalk.Instance({level: 2});\n    const formatted = formatLines(chalkInstance);\n    const converted = convertAnsi(formatted);\n\n    expect(converted).toBe(expected1);\n    expect(formatted).toMatch(`${aOpenForeground2 + aOpenBackground2}-`);\n    expect(formatted).toMatch(`${bOpenForeground2 + bOpenBackground2}+`);\n    expect(formatted).not.toMatch(chalkInstance.bgYellow(' ')); // noColor\n    expect(formatted).toMatch(chalkInstance.bgYellow('  '));\n  });\n\n  test('level 3', () => {\n    const chalkInstance = new chalk.Instance({level: 3});\n    const formatted = formatLines(chalkInstance);\n    const converted = convertAnsi(formatted);\n\n    expect(converted).toBe(expected1);\n    expect(formatted).toMatch(`${aOpenForeground3 + aOpenBackground3}-`);\n    expect(formatted).toMatch(`${bOpenForeground3 + bOpenBackground3}+`);\n    expect(formatted).not.toMatch(chalkInstance.bgYellow(' ')); // noColor\n    expect(formatted).toMatch(chalkInstance.bgYellow('  '));\n  });\n});\n\ndescribe('matcher error', () => {\n  describe('toMatchInlineSnapshot', () => {\n    const received = {\n      id: 'abcdef',\n      text: 'Throw matcher error',\n      type: 'ADD_ITEM',\n    };\n\n    test('Expected properties must be an object (non-null) without snapshot', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = false;\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchInlineSnapshot.call(context, received, properties);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Expected properties must be an object (null) with snapshot', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = null;\n      const snapshot = '';\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchInlineSnapshot.call(context, received, properties, snapshot);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Inline snapshot must be a string', () => {\n      const context = {\n        isNot: false,\n        promise: 'resolves',\n      } as Context;\n      const properties = {};\n      const snapshot = Symbol('is not a string');\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchInlineSnapshot.call(context, received, properties, snapshot);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Snapshot matchers cannot be used with not', () => {\n      const context = {\n        isNot: true,\n        promise: '',\n      } as Context;\n      const received = -13;\n      const snapshot = '13';\n\n      expect(() => {\n        toMatchInlineSnapshot.call(context, received, snapshot);\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('toMatchSnapshot', () => {\n    const received = {\n      id: 'abcdef',\n      text: 'Throw matcher error',\n      type: 'ADD_ITEM',\n    };\n\n    test('Expected properties must be an object (non-null)', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = () => {};\n\n      expect(() => {\n        toMatchSnapshot.call(context, received, properties);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Expected properties must be an object (null) with hint', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = null;\n      const hint = 'reminder';\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchSnapshot.call(context, received, properties, hint);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Expected properties must be an object (null) without hint', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const properties = null;\n\n      expect(() => {\n        // @ts-expect-error: Testing runtime error\n        toMatchSnapshot.call(context, received, properties);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    describe('received value must be an object', () => {\n      const context = {\n        currentTestName: '',\n        isNot: false,\n        promise: '',\n        snapshotState: {},\n      } as Context;\n      const properties = {};\n\n      test('(non-null)', () => {\n        expect(() => {\n          toMatchSnapshot.call(context, 'string', properties);\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('(null)', () => {\n        expect(() => {\n          toMatchSnapshot.call(context, null, properties);\n        }).toThrowErrorMatchingSnapshot();\n      });\n    });\n\n    // Future test: Snapshot hint must be a string\n\n    test('Snapshot state must be initialized', () => {\n      const context = {\n        isNot: false,\n        promise: 'resolves',\n      } as Context;\n      const hint = 'initialize me';\n\n      expect(() => {\n        toMatchSnapshot.call(context, received, hint);\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('toThrowErrorMatchingInlineSnapshot', () => {\n    test('Inline snapshot must be a string', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const received = () => {\n        throw new Error('Not found');\n      };\n      const snapshot = 404;\n      const fromPromise = false;\n\n      expect(() => {\n        toThrowErrorMatchingInlineSnapshot.call(\n          context,\n          received,\n          // @ts-expect-error: Testing runtime error\n          snapshot,\n          fromPromise,\n        );\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Snapshot state must be initialized', () => {\n      const context = {\n        isNot: false,\n        promise: 'rejects',\n      } as Context;\n      const received = new Error('404');\n      const snapshot = '\"Not found\"';\n      const fromPromise = true;\n\n      expect(() => {\n        toThrowErrorMatchingInlineSnapshot.call(\n          context,\n          received,\n          snapshot,\n          fromPromise,\n        );\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('toThrowErrorMatchingSnapshot', () => {\n    test('Received value must be a function', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const received = 13;\n      const fromPromise = false;\n\n      expect(() => {\n        toThrowErrorMatchingSnapshot.call(\n          context,\n          received,\n          undefined,\n          fromPromise,\n        );\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('Snapshot matchers cannot be used with not', () => {\n      const context = {\n        isNot: true,\n        promise: '',\n      } as Context;\n      const received = new Error('received');\n      const hint = 'reminder';\n      const fromPromise = true;\n\n      expect(() => {\n        toThrowErrorMatchingSnapshot.call(context, received, hint, fromPromise);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    // Future test: Snapshot hint must be a string\n  });\n});\n\ndescribe('other error', () => {\n  describe('toThrowErrorMatchingSnapshot', () => {\n    test('Received function did not throw', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n      } as Context;\n      const received = () => {};\n      const fromPromise = false;\n\n      expect(() => {\n        toThrowErrorMatchingSnapshot.call(\n          context,\n          received,\n          undefined,\n          fromPromise,\n        );\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n});\n\ndescribe('pass false', () => {\n  describe('toMatchInlineSnapshot', () => {\n    describe('with properties', () => {\n      const id = 'abcdef';\n      const properties = {id};\n      const type = 'ADD_ITEM';\n\n      describe('equals false', () => {\n        const context = {\n          currentTestName: 'with properties',\n          equals: () => false,\n          isNot: false,\n          promise: '',\n          snapshotState: {\n            fail: (fullTestName: string) => `${fullTestName} 1`,\n          },\n          utils: {\n            iterableEquality: () => {},\n            subsetEquality: () => {},\n          },\n        } as unknown as Context;\n        const received = {\n          id: 'abcdefg',\n          text: 'Increase code coverage',\n          type,\n        };\n\n        test('with snapshot', () => {\n          const snapshot = '';\n          const {message, pass} = toMatchInlineSnapshot.call(\n            context,\n            received,\n            properties,\n            snapshot,\n          ) as SyncExpectationResult;\n          expect(pass).toBe(false);\n          expect(message()).toMatchSnapshot();\n        });\n\n        test('without snapshot', () => {\n          const {message, pass} = toMatchInlineSnapshot.call(\n            context,\n            received,\n            properties,\n          ) as SyncExpectationResult;\n          expect(pass).toBe(false);\n          expect(message()).toMatchSnapshot();\n        });\n      });\n\n      test('equals true', () => {\n        const context = {\n          currentTestName: 'with properties',\n          equals: () => true,\n          isNot: false,\n          promise: '',\n          snapshotState: {\n            expand: false,\n            match({inlineSnapshot, received}) {\n              return {\n                actual: format(received),\n                count: 1,\n                expected: inlineSnapshot,\n                pass: false,\n              };\n            },\n          } as SnapshotState,\n          utils: {\n            iterableEquality: () => {},\n            subsetEquality: () => {},\n          },\n        } as unknown as Context;\n        const received = {\n          id,\n          text: 'received',\n          type,\n        };\n        const snapshot = format({\n          id,\n          text: 'inline snapshot',\n          type,\n        });\n\n        const {message, pass} = toMatchInlineSnapshot.call(\n          context,\n          received,\n          properties,\n          snapshot,\n        ) as SyncExpectationResult;\n        expect(pass).toBe(false);\n        expect(message()).toMatchSnapshot();\n      });\n    });\n  });\n\n  describe('toMatchSnapshot', () => {\n    test('New snapshot was not written (multi line)', () => {\n      const context = {\n        currentTestName: 'New snapshot was not written',\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          match({received}) {\n            return {\n              actual: format(received),\n              count: 1,\n              expected: undefined,\n              pass: false,\n            };\n          },\n        },\n      } as Context;\n      const received = 'To write or not to write,\\nthat is the question.';\n      const hint = '(CI)';\n\n      const {message, pass} = toMatchSnapshot.call(\n        context,\n        received,\n        hint,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(false);\n      expect(message()).toMatchSnapshot();\n    });\n\n    test('New snapshot was not written (single line)', () => {\n      const context = {\n        currentTestName: 'New snapshot was not written',\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          match({received}) {\n            return {\n              actual: format(received),\n              count: 2,\n              expected: undefined,\n              pass: false,\n            };\n          },\n        },\n      } as Context;\n      const received = 'Write me if you can!';\n      const hint = '(CI)';\n\n      const {message, pass} = toMatchSnapshot.call(\n        context,\n        received,\n        hint,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(false);\n      expect(message()).toMatchSnapshot();\n    });\n\n    describe('with properties', () => {\n      const id = 'abcdef';\n      const properties = {id};\n      const type = 'ADD_ITEM';\n\n      describe('equals false', () => {\n        const context = {\n          currentTestName: 'with properties',\n          equals: () => false,\n          isNot: false,\n          promise: '',\n          snapshotState: {\n            fail: (fullTestName: string) => `${fullTestName} 1`,\n          },\n          utils: {\n            iterableEquality: () => {},\n            subsetEquality: () => {},\n          },\n        } as unknown as Context;\n\n        test('isLineDiffable false', () => {\n          const {message, pass} = toMatchSnapshot.call(\n            context,\n            new RangeError('Invalid array length'),\n            {name: 'Error'},\n          ) as SyncExpectationResult;\n          expect(pass).toBe(false);\n          expect(message()).toMatchSnapshot();\n        });\n\n        test('isLineDiffable true', () => {\n          const received = {\n            id: 'abcdefg',\n            text: 'Increase code coverage',\n            type,\n          };\n\n          const {message, pass} = toMatchSnapshot.call(\n            context,\n            received,\n            properties,\n          ) as SyncExpectationResult;\n          expect(pass).toBe(false);\n          expect(message()).toMatchSnapshot();\n        });\n      });\n\n      test('equals true', () => {\n        const context = {\n          currentTestName: 'with properties',\n          equals: () => true,\n          isNot: false,\n          promise: '',\n          snapshotState: {\n            expand: false,\n            match({received}) {\n              return {\n                actual: format(received),\n                count: 1,\n                expected: format({\n                  id,\n                  text: 'snapshot',\n                  type,\n                }),\n                pass: false,\n              };\n            },\n          } as SnapshotState,\n          utils: {\n            iterableEquality: () => {},\n            subsetEquality: () => {},\n          },\n        } as unknown as Context;\n        const received = {\n          id,\n          text: 'received',\n          type,\n        };\n        const hint = 'change text value';\n\n        const {message, pass} = toMatchSnapshot.call(\n          context,\n          received,\n          properties,\n          hint,\n        ) as SyncExpectationResult;\n        expect(pass).toBe(false);\n        expect(message()).toMatchSnapshot();\n      });\n    });\n  });\n\n  describe('toThrowErrorMatchingInlineSnapshot', () => {\n    test('with snapshot', () => {\n      const context = {\n        currentTestName: 'with snapshot',\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          expand: false,\n          match({inlineSnapshot, received}) {\n            return {\n              actual: format(received),\n              count: 1,\n              expected: inlineSnapshot,\n              pass: false,\n            };\n          },\n        },\n      } as Context;\n      const received = new Error('received');\n      const snapshot = '\"inline snapshot\"';\n      const fromPromise = true;\n\n      const {message, pass} = toThrowErrorMatchingInlineSnapshot.call(\n        context,\n        received,\n        snapshot,\n        fromPromise,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(false);\n      expect(message()).toMatchSnapshot();\n    });\n  });\n});\n\ndescribe('pass true', () => {\n  describe('toMatchSnapshot', () => {\n    test('without properties', () => {\n      const context = {\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          match() {\n            return {\n              expected: '',\n              pass: true,\n            };\n          },\n        },\n      } as unknown as Context;\n      const received = 7;\n\n      const {pass} = toMatchSnapshot.call(\n        context,\n        received,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(true);\n    });\n\n    test('array', () => {\n      const context = {\n        equals: () => true,\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          match() {\n            return {\n              expected: [],\n              pass: true,\n            };\n          },\n        },\n        utils: {\n          iterableEquality: () => [],\n          subsetEquality: () => [],\n        },\n      } as unknown as Context;\n      const received: Array<unknown> = [];\n      const properties: Array<unknown> = [];\n\n      const {pass} = toMatchSnapshot.call(\n        context,\n        received,\n        properties,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(true);\n    });\n  });\n\n  describe('toMatchInlineSnapshot', () => {\n    test('array', () => {\n      const context = {\n        equals: () => true,\n        isNot: false,\n        promise: '',\n        snapshotState: {\n          match() {\n            return {\n              expected: [],\n              pass: true,\n            };\n          },\n        },\n        utils: {\n          iterableEquality: () => [],\n          subsetEquality: () => [],\n        },\n      } as unknown as Context;\n      const received: Array<unknown> = [];\n      const properties: Array<unknown> = [];\n\n      const {pass} = toMatchInlineSnapshot.call(\n        context,\n        received,\n        properties,\n      ) as SyncExpectationResult;\n      expect(pass).toBe(true);\n    });\n  });\n});\n\ndescribe('printPropertiesAndReceived', () => {\n  test('omit missing properties', () => {\n    const received = {\n      b: {},\n      branchMap: {},\n      f: {},\n      fnMap: {},\n      // hash is missing\n      path: '…',\n      s: {},\n      statementMap: {},\n    };\n    const properties = {\n      hash: expect.any(String),\n      path: expect.any(String),\n    };\n\n    expect(\n      printPropertiesAndReceived(properties, received, false),\n    ).toMatchSnapshot();\n  });\n\n  test('only highlight non passing properties', () => {\n    const received = {\n      a: 1,\n      b: 'some string',\n      c: 'another string',\n    };\n    const properties = {\n      a: expect.any(Number),\n      b: expect.any(Number),\n    };\n    expect(\n      printPropertiesAndReceived(properties, received, false),\n    ).toMatchSnapshot();\n  });\n});\n\ndescribe('printSnapshotAndReceived', () => {\n  // Simulate default serialization.\n  const testWithStringify = (\n    expected: unknown,\n    received: unknown,\n    expand: boolean,\n  ): string =>\n    printSnapshotAndReceived(\n      serialize(expected),\n      serialize(received),\n      received,\n      expand,\n    );\n\n  // Simulate custom raw string serialization.\n  const testWithoutStringify = (\n    expected: string,\n    received: string,\n    expand: boolean,\n  ): string => printSnapshotAndReceived(expected, received, received, expand);\n\n  describe('backtick', () => {\n    test('single line expected and received', () => {\n      const expected = 'var foo = `backtick`;';\n      const received = 'var foo = tag`backtick`;';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n\n  describe('empty string', () => {\n    test('expected and received single line', () => {\n      const expected = '';\n      const received = 'single line string';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('received and expected multi line', () => {\n      const expected = 'multi\\nline\\nstring';\n      const received = '';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n\n  describe('escape', () => {\n    test('double quote marks in string', () => {\n      const expected = 'What does \"oobleck\" mean?';\n      const received = 'What does \"ewbleck\" mean?';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('backslash in multi line string', () => {\n      const expected = 'Forward / slash and back \\\\ slash';\n      const received = 'Forward / slash\\nBack \\\\ slash';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('backslash in single line string', () => {\n      const expected = 'forward / slash and back \\\\ slash';\n      const received = 'Forward / slash and back \\\\ slash';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('regexp', () => {\n      const expected = /\\\\(\")/g;\n      const received = /\\\\(\")/;\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n\n  describe('expand', () => {\n    // prettier/pull/5272\n    const expected = [\n      'type TypeName<T> =',\n      'T extends string ? \"string\" :',\n      'T extends number ? \"number\" :',\n      'T extends boolean ? \"boolean\" :',\n      'T extends undefined ? \"undefined\" :',\n      'T extends Function ? \"function\" :',\n      '\"object\";',\n      '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~',\n      'type TypeName<T> = T extends string',\n      '? \"string\"',\n      ': T extends number',\n      '? \"number\"',\n      ': T extends boolean',\n      '? \"boolean\"',\n      ': T extends undefined',\n      '? \"undefined\"',\n      ': T extends Function ? \"function\" : \"object\";',\n      '',\n    ].join('\\n');\n    const received = [\n      'type TypeName<T> =',\n      'T extends string ? \"string\" :',\n      'T extends number ? \"number\" :',\n      'T extends boolean ? \"boolean\" :',\n      'T extends undefined ? \"undefined\" :',\n      'T extends Function ? \"function\" :',\n      '\"object\";',\n      '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~',\n      'type TypeName<T> = T extends string',\n      '? \"string\"',\n      ': T extends number',\n      '? \"number\"',\n      ': T extends boolean',\n      '? \"boolean\"',\n      ': T extends undefined',\n      '? \"undefined\"',\n      ': T extends Function',\n      '? \"function\"',\n      ': \"object\";',\n      '',\n    ].join('\\n');\n\n    test('false', () => {\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('true', () => {\n      expect(testWithStringify(expected, received, true)).toMatchSnapshot();\n    });\n  });\n\n  test('fallback to line diff', () => {\n    const expected = [\n      '[...a, ...b,];',\n      '[...a, ...b];',\n      '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~',\n      '[...a, ...b];',\n      '[...a, ...b];',\n      '',\n    ].join('\\n');\n    const received = [\n      '====================================options=====================================',\n      'parsers: [\"flow\", \"typescript\"]',\n      'printWidth: 80',\n      '                                                                                | printWidth',\n      '=====================================input======================================',\n      '[...a, ...b,];',\n      '[...a, ...b];',\n      '',\n      '=====================================output=====================================',\n      '[...a, ...b];',\n      '[...a, ...b];',\n      '',\n      '================================================================================',\n    ].join('\\n');\n\n    expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n  });\n\n  describe('has no common after clean up chaff', () => {\n    test('array', () => {\n      const expected = ['delete', 'two'];\n      const received = ['insert', '2'];\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('string single line', () => {\n      const expected = 'delete';\n      const received = 'insert';\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n\n  describe('MAX_DIFF_STRING_LENGTH', () => {\n    describe('unquoted', () => {\n      // Do not call diffStringsUnified if either string is longer than max.\n      const lessChange = chalk.inverse('single ');\n      const less = 'single line';\n      const more = `multi line${'\\n123456789'.repeat(2000)}`; // 10 + 20K chars\n\n      test('both are less', () => {\n        const less2 = 'multi\\nline';\n        const difference = printSnapshotAndReceived(less2, less, less, true);\n\n        expect(difference).toMatch('- multi');\n        expect(difference).toMatch('- line');\n        expect(difference).toMatch(lessChange);\n        expect(difference).not.toMatch('+ single line');\n      });\n\n      test('expected is more', () => {\n        const difference = printSnapshotAndReceived(more, less, less, true);\n\n        expect(difference).toMatch('- multi line');\n        expect(difference).toMatch('+ single line');\n        expect(difference).not.toMatch(lessChange);\n      });\n\n      test('received is more', () => {\n        const difference = printSnapshotAndReceived(less, more, more, true);\n\n        expect(difference).toMatch('- single line');\n        expect(difference).toMatch('+ multi line');\n        expect(difference).not.toMatch(lessChange);\n      });\n    });\n\n    describe('quoted', () => {\n      // Do not call diffStringsRaw if either string is longer than max.\n      const lessChange = chalk.inverse('no');\n      const less = 'no numbers';\n      const more = `many numbers${' 123456789'.repeat(2000)}`; // 12 + 20K chars\n      const lessQuoted = `\"${less}\"`;\n      const moreQuoted = `\"${more}\"`;\n\n      test('both are less', () => {\n        const lessQuoted2 = '\"0 numbers\"';\n        const stringified = printSnapshotAndReceived(\n          lessQuoted2,\n          lessQuoted,\n          less,\n          true,\n        );\n\n        expect(stringified).toMatch('Received:');\n        expect(stringified).toMatch(lessChange);\n        expect(stringified).not.toMatch('+ Received');\n      });\n\n      test('expected is more', () => {\n        const stringified = printSnapshotAndReceived(\n          moreQuoted,\n          lessQuoted,\n          less,\n          true,\n        );\n\n        expect(stringified).toMatch('Received:');\n        expect(stringified).toMatch(less);\n        expect(stringified).not.toMatch('+ Received');\n        expect(stringified).not.toMatch(lessChange);\n      });\n\n      test('received is more', () => {\n        const stringified = printSnapshotAndReceived(\n          lessQuoted,\n          moreQuoted,\n          more,\n          true,\n        );\n\n        expect(stringified).toMatch('Snapshot:');\n        expect(stringified).toMatch(less);\n        expect(stringified).not.toMatch('- Snapshot');\n        expect(stringified).not.toMatch(lessChange);\n      });\n    });\n  });\n\n  describe('isLineDiffable', () => {\n    describe('false', () => {\n      test('asymmetric matcher', () => {\n        const expected = null;\n        const received = {asymmetricMatch: () => {}};\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('boolean', () => {\n        const expected = true;\n        const received = false;\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('date', () => {\n        const expected = new Date('2019-09-19');\n        const received = new Date('2019-09-20');\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('error', () => {\n        const expected = new Error(\n          'Cannot spread fragment \"NameAndAppearances\" within itself.',\n        );\n        const received = new Error(\n          'Cannot spread fragment \"NameAndAppearancesAndFriends\" within itself.',\n        );\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('function', () => {\n        const expected = undefined;\n        const received = () => {};\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('number', () => {\n        const expected = -0;\n        const received = Number.NaN;\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n    });\n\n    describe('true', () => {\n      test('array', () => {\n        const expected0 = {\n          code: 4011,\n          weight: 2.13,\n        };\n        const expected1 = {\n          code: 4019,\n          count: 4,\n        };\n\n        const expected = [expected0, expected1];\n        const received = [\n          {_id: 'b14680dec683e744ada1f2fe08614086', ...expected0},\n          {_id: '7fc63ff01769c4fa7d9279e97e307829', ...expected1},\n        ];\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('object', () => {\n        const type = 'img';\n        const expected = {\n          props: {\n            className: 'logo',\n            src: '/img/jest.png',\n          },\n          type,\n        };\n        const received = {\n          props: {\n            alt: 'Jest logo',\n            class: 'logo',\n            src: '/img/jest.svg',\n          },\n          type,\n        };\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('single line expected and received', () => {\n        const expected: Array<unknown> = [];\n        const received = {};\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n\n      test('single line expected and multi line received', () => {\n        const expected: Array<unknown> = [];\n        const received = [0];\n\n        expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n      });\n    });\n  });\n\n  test('multi line small change in one line and other is unchanged', () => {\n    const expected =\n      \"There is no route defined for key 'Settings'.\\nMust be one of: 'Home'\";\n    const received =\n      \"There is no route defined for key Settings.\\nMust be one of: 'Home'\";\n\n    expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n  });\n\n  test('multi line small changes', () => {\n    const expected = [\n      '    69 | ',\n      \"    70 | test('assert.doesNotThrow', () => {\",\n      '  > 71 |   assert.doesNotThrow(() => {',\n      '       |          ^',\n      \"    72 |     throw Error('err!');\",\n      '    73 |   });',\n      '    74 | });',\n      '    at Object.doesNotThrow (__tests__/assertionError.test.js:71:10)',\n    ].join('\\n');\n    const received = [\n      '    68 | ',\n      \"    69 | test('assert.doesNotThrow', () => {\",\n      '  > 70 |   assert.doesNotThrow(() => {',\n      '       |          ^',\n      \"    71 |     throw Error('err!');\",\n      '    72 |   });',\n      '    73 | });',\n      '    at Object.doesNotThrow (__tests__/assertionError.test.js:70:10)',\n    ].join('\\n');\n\n    expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n  });\n\n  test('single line large changes', () => {\n    const expected = 'Array length must be a finite positive integer';\n    const received = 'Invalid array length';\n\n    expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n  });\n\n  describe('ignore indentation', () => {\n    const $$typeof = Symbol.for('react.test.json');\n\n    test('markup delete', () => {\n      const received = {\n        $$typeof,\n        children: [\n          {\n            $$typeof,\n            children: ['Ignore indentation for most serialized objects'],\n            type: 'h3',\n          },\n          {\n            $$typeof,\n            children: [\n              'Call ',\n              {\n                $$typeof,\n                children: ['diffLinesUnified2'],\n                type: 'code',\n              },\n              ' to compare without indentation',\n            ],\n            type: 'p',\n          },\n        ],\n        type: 'div',\n      };\n      const expected = {\n        $$typeof,\n        children: [received],\n        type: 'div',\n      };\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('markup fall back', () => {\n      // Because text has more than one adjacent line.\n      const text = [\n        'for (key in foo) {',\n        '  if (Object.prototype.hasOwnProperty.call(foo, key)) {',\n        '    doSomething(key);',\n        '  }',\n        '}',\n      ].join('\\n');\n\n      const expected = {\n        $$typeof,\n        children: [text],\n        props: {\n          className: 'language-js',\n        },\n        type: 'pre',\n      };\n      const received = {\n        $$typeof,\n        children: [expected],\n        type: 'div',\n      };\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('markup insert', () => {\n      const text = 'when';\n      const expected = {\n        $$typeof,\n        children: [text],\n        type: 'th',\n      };\n      const received = {\n        $$typeof,\n        children: [\n          {\n            $$typeof,\n            children: [text],\n            type: 'span',\n          },\n          {\n            $$typeof,\n            children: ['↓'],\n            props: {\n              title: 'ascending from older to newer',\n            },\n            type: 'abbr',\n          },\n        ],\n        type: 'th',\n      };\n\n      expect(testWithStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    describe('object', () => {\n      const text = 'Ignore indentation in snapshot';\n      const time = '2019-11-11';\n      const type = 'CREATE_ITEM';\n      const less = {\n        text,\n        time,\n        type,\n      };\n      const more = {\n        payload: {\n          text,\n          time,\n        },\n        type,\n      };\n\n      test('delete', () => {\n        expect(testWithStringify(more, less, false)).toMatchSnapshot();\n      });\n\n      test('insert', () => {\n        expect(testWithStringify(less, more, false)).toMatchSnapshot();\n      });\n    });\n  });\n\n  describe('without serialize', () => {\n    test('backtick single line expected and received', () => {\n      const expected = 'var foo = `backtick`;';\n      const received = 'var foo = `back${x}tick`;';\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('backtick single line expected and multi line received', () => {\n      const expected = 'var foo = `backtick`;';\n      const received = 'var foo = `back\\ntick`;';\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('has no common after clean up chaff multi line', () => {\n      const expected = 'delete\\ntwo';\n      const received = 'insert\\n2';\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('has no common after clean up chaff single line', () => {\n      const expected = 'delete';\n      const received = 'insert';\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n\n    test('prettier/pull/5590', () => {\n      const expected = [\n        '====================================options=====================================',\n        'parsers: [\"html\"]',\n        'printWidth: 80',\n        '                                                                                | printWidth',\n        '=====================================input======================================',\n        '<img src=\"test.png\" alt=\\'John \"ShotGun\" Nelson\\'>',\n        '',\n        '=====================================output=====================================',\n        '<img src=\"test.png\" alt=\"John &quot;ShotGun&quot; Nelson\" />',\n        '',\n        '================================================================================',\n      ].join('\\n');\n      const received = [\n        '====================================options=====================================',\n        'parsers: [\"html\"]',\n        'printWidth: 80',\n        '                                                                                | printWidth',\n        '=====================================input======================================',\n        '<img src=\"test.png\" alt=\\'John \"ShotGun\" Nelson\\'>',\n        '',\n        '=====================================output=====================================',\n        '<img src=\"test.png\" alt=\\'John \"ShotGun\" Nelson\\' />',\n        '',\n        '================================================================================',\n      ].join('\\n');\n\n      expect(testWithoutStringify(expected, received, false)).toMatchSnapshot();\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`matcher error toMatchInlineSnapshot Expected properties must be an object (non-null) without snapshot 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchInlineSnapshot<d>(</><g>properties</><d>)</>\n\n<b>Matcher error</>: Expected <g>properties</> must be an object\n\nExpected properties has type:  boolean\nExpected properties has value: <g>false</>\n`;\n\nexports[`matcher error toMatchInlineSnapshot Expected properties must be an object (null) with snapshot 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchInlineSnapshot<d>(</><g>properties</><d>, </>snapshot<d>)</>\n\n<b>Matcher error</>: Expected <g>properties</> must be an object\n\nExpected properties has value: <g>null</>\n`;\n\nexports[`matcher error toMatchInlineSnapshot Inline snapshot must be a string 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>toMatchInlineSnapshot<d>(</><g>properties</><d>, </>snapshot<d>)</>\n\n<b>Matcher error</>: Inline snapshot must be a string\n\nInline snapshot has type:  symbol\nInline snapshot has value: Symbol(is not a string)\n`;\n\nexports[`matcher error toMatchInlineSnapshot Snapshot matchers cannot be used with not 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toMatchInlineSnapshot<d>(</><g>snapshot</><d>)</>\n\n<b>Matcher error</>: Snapshot matchers cannot be used with <b>not</>\n`;\n\nexports[`matcher error toMatchSnapshot Expected properties must be an object (non-null) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchSnapshot<d>(</><g>properties</><d>)</>\n\n<b>Matcher error</>: Expected <g>properties</> must be an object\n\nExpected properties has type:  function\nExpected properties has value: <g>[Function]</>\n`;\n\nexports[`matcher error toMatchSnapshot Expected properties must be an object (null) with hint 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchSnapshot<d>(</><g>properties</><d>, </><b>hint</><d>)</>\n\n<b>Matcher error</>: Expected <g>properties</> must be an object\n\nExpected properties has value: <g>null</>\n\nTo provide a hint without properties: toMatchSnapshot('hint')\n`;\n\nexports[`matcher error toMatchSnapshot Expected properties must be an object (null) without hint 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchSnapshot<d>(</><g>properties</><d>)</>\n\n<b>Matcher error</>: Expected <g>properties</> must be an object\n\nExpected properties has value: <g>null</>\n`;\n\nexports[`matcher error toMatchSnapshot Snapshot state must be initialized 1`] = `\n<d>expect(</><r>received</><d>).</>resolves<d>.</>toMatchSnapshot<d>(</><b>hint</><d>)</>\n\nSnapshot state must be initialized\n\nSnapshot state has value: undefined\n`;\n\nexports[`matcher error toMatchSnapshot received value must be an object (non-null) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchSnapshot<d>(</><g>properties</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be an object when the matcher has <g>properties</>\n\nReceived has type:  string\nReceived has value: <r>\"string\"</>\n`;\n\nexports[`matcher error toMatchSnapshot received value must be an object (null) 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchSnapshot<d>(</><g>properties</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be an object when the matcher has <g>properties</>\n\nReceived has value: <r>null</>\n`;\n\nexports[`matcher error toThrowErrorMatchingInlineSnapshot Inline snapshot must be a string 1`] = `\n<d>expect(</><r>received</><d>).</>toThrowErrorMatchingInlineSnapshot<d>(</>snapshot<d>)</>\n\n<b>Matcher error</>: Inline snapshot must be a string\n\nInline snapshot has type:  number\nInline snapshot has value: 404\n`;\n\nexports[`matcher error toThrowErrorMatchingInlineSnapshot Snapshot state must be initialized 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>toThrowErrorMatchingInlineSnapshot<d>(</><g>snapshot</><d>)</>\n\nSnapshot state must be initialized\n\nSnapshot state has value: undefined\n`;\n\nexports[`matcher error toThrowErrorMatchingSnapshot Received value must be a function 1`] = `\n<d>expect(</><r>received</><d>).</>toThrowErrorMatchingSnapshot<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a function\n\nReceived has type:  number\nReceived has value: <r>13</>\n`;\n\nexports[`matcher error toThrowErrorMatchingSnapshot Snapshot matchers cannot be used with not 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrowErrorMatchingSnapshot<d>(</><b>hint</><d>)</>\n\n<b>Matcher error</>: Snapshot matchers cannot be used with <b>not</>\n`;\n\nexports[`other error toThrowErrorMatchingSnapshot Received function did not throw 1`] = `\n<d>expect(</><r>received</><d>).</>toThrowErrorMatchingSnapshot<d>()</>\n\nReceived function did not throw\n`;\n\nexports[`pass false toMatchInlineSnapshot with properties equals false with snapshot 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchInlineSnapshot<d>(</><g>properties</><d>, </>snapshot<d>)</>\n\nSnapshot name: \\`with properties 1\\`\n\n<g>- Expected properties  - 1</>\n<r>+ Received value       + 1</>\n\n<d>  Object {</>\n<g>-   \"id\": \"abcdef\",</>\n<r>+   \"id\": \"abcdefg\",</>\n<d>  }</>\n`;\n\nexports[`pass false toMatchInlineSnapshot with properties equals false without snapshot 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchInlineSnapshot<d>(</><g>properties</><d>)</>\n\nSnapshot name: \\`with properties 1\\`\n\n<g>- Expected properties  - 1</>\n<r>+ Received value       + 1</>\n\n<d>  Object {</>\n<g>-   \"id\": \"abcdef\",</>\n<r>+   \"id\": \"abcdefg\",</>\n<d>  }</>\n`;\n\nexports[`pass false toMatchInlineSnapshot with properties equals true 1`] = `\n<d>expect(</><t>received</><d>).</>toMatchInlineSnapshot<d>(</>properties<d>, </><m>snapshot</><d>)</>\n\nSnapshot name: \\`with properties 1\\`\n\n<m>- Snapshot  - 1</>\n<t>+ Received  + 1</>\n\n<d>  Object {</>\n<d>    \"id\": \"abcdef\",</>\n<m>-   \"text\": \"inline snapshot\",</>\n<t>+   \"text\": \"received\",</>\n<d>    \"type\": \"ADD_ITEM\",</>\n<d>  }</>\n`;\n\nexports[`pass false toMatchSnapshot New snapshot was not written (multi line) 1`] = `\n<d>expect(</><t>received</><d>).</>toMatchSnapshot<d>(</><b>hint</><d>)</>\n\nSnapshot name: \\`New snapshot was not written: <b>(CI)</> 1\\`\n\nNew snapshot was <b>not written</>. The update flag must be explicitly passed to write a new snapshot.\n\nThis is likely because this test is run in a continuous integration (CI) environment in which snapshots are not written by default.\n\nReceived:\n<t>\"To write or not to write,</>\n<t>that is the question.\"</>\n`;\n\nexports[`pass false toMatchSnapshot New snapshot was not written (single line) 1`] = `\n<d>expect(</><t>received</><d>).</>toMatchSnapshot<d>(</><b>hint</><d>)</>\n\nSnapshot name: \\`New snapshot was not written: <b>(CI)</> 2\\`\n\nNew snapshot was <b>not written</>. The update flag must be explicitly passed to write a new snapshot.\n\nThis is likely because this test is run in a continuous integration (CI) environment in which snapshots are not written by default.\n\nReceived: <t>\"Write me if you can!\"</>\n`;\n\nexports[`pass false toMatchSnapshot with properties equals false isLineDiffable false 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchSnapshot<d>(</><g>properties</><d>)</>\n\nSnapshot name: \\`with properties 1\\`\n\nExpected properties: <g>{\"name\": \"Error\"}</>\nReceived value:      <r>[RangeError: Invalid array length]</>\n`;\n\nexports[`pass false toMatchSnapshot with properties equals false isLineDiffable true 1`] = `\n<d>expect(</><r>received</><d>).</>toMatchSnapshot<d>(</><g>properties</><d>)</>\n\nSnapshot name: \\`with properties 1\\`\n\n<g>- Expected properties  - 1</>\n<r>+ Received value       + 1</>\n\n<d>  Object {</>\n<g>-   \"id\": \"abcdef\",</>\n<r>+   \"id\": \"abcdefg\",</>\n<d>  }</>\n`;\n\nexports[`pass false toMatchSnapshot with properties equals true 1`] = `\n<d>expect(</><t>received</><d>).</>toMatchSnapshot<d>(</>properties<d>, </><b>hint</><d>)</>\n\nSnapshot name: \\`with properties: <b>change text value</> 1\\`\n\n<m>- Snapshot  - 1</>\n<t>+ Received  + 1</>\n\n<d>  Object {</>\n<d>    \"id\": \"abcdef\",</>\n<m>-   \"text\": \"snapshot\",</>\n<t>+   \"text\": \"received\",</>\n<d>    \"type\": \"ADD_ITEM\",</>\n<d>  }</>\n`;\n\nexports[`pass false toThrowErrorMatchingInlineSnapshot with snapshot 1`] = `\n<d>expect(</><t>received</><d>).</>toThrowErrorMatchingInlineSnapshot<d>(</><m>snapshot</><d>)</>\n\nSnapshot name: \\`with snapshot 1\\`\n\nSnapshot: <m>\"inline snapshot\"</>\nReceived: <t>\"received\"</>\n`;\n\nexports[`printPropertiesAndReceived omit missing properties 1`] = `\n<g>- Expected properties  - 1</>\n<r>+ Received value       + 0</>\n\n<d>  Object {</>\n<g>-   \"hash\": Any<String>,</>\n<d>    \"path\": Any<String>,</>\n<d>  }</>\n`;\n\nexports[`printPropertiesAndReceived only highlight non passing properties 1`] = `\n<g>- Expected properties  - 1</>\n<r>+ Received value       + 1</>\n\n<d>  Object {</>\n<d>    \"a\": Any<Number>,</>\n<g>-   \"b\": Any<Number>,</>\n<r>+   \"b\": \"some string\",</>\n<d>  }</>\n`;\n\nexports[`printSnapshotAndReceived backtick single line expected and received 1`] = `\nSnapshot: <m>\"var foo = \\`backtick\\`;\"</>\nReceived: <t>\"var foo = <i>tag</i>\\`backtick\\`;\"</>\n`;\n\nexports[`printSnapshotAndReceived empty string expected and received single line 1`] = `\nSnapshot: <m>\"\"</>\nReceived: <t>\"single line string\"</>\n`;\n\nexports[`printSnapshotAndReceived empty string received and expected multi line 1`] = `\n<m>- Snapshot  - 3</>\n<t>+ Received  + 0</>\n\n<m>- multi</>\n<m>- line</>\n<m>- string</>\n`;\n\nexports[`printSnapshotAndReceived escape backslash in multi line string 1`] = `\n<m>- Snapshot  - 1</>\n<t>+ Received  + 2</>\n\n<m>- Forward / slash<i> and b</i>ack \\\\ slash</>\n<t>+ Forward / slash</>\n<t>+ <i>B</i>ack \\\\ slash</>\n`;\n\nexports[`printSnapshotAndReceived escape backslash in single line string 1`] = `\nSnapshot: <m>\"<i>f</i>orward / slash and back \\\\\\\\ slash\"</>\nReceived: <t>\"<i>F</i>orward / slash and back \\\\\\\\ slash\"</>\n`;\n\nexports[`printSnapshotAndReceived escape double quote marks in string 1`] = `\nSnapshot: <m>\"What does \\\\\"<i>oo</i>bleck\\\\\" mean?\"</>\nReceived: <t>\"What does \\\\\"<i>ew</i>bleck\\\\\" mean?\"</>\n`;\n\nexports[`printSnapshotAndReceived escape regexp 1`] = `\nSnapshot: <m>/\\\\\\\\\\\\\\\\\\\\(\"\\\\)/g</>\nReceived: <t>/\\\\\\\\\\\\\\\\\\\\(\"\\\\)/</>\n`;\n\nexports[`printSnapshotAndReceived expand false 1`] = `\n<m>- Snapshot  - 1</>\n<t>+ Received  + 3</>\n\n<y>@@ -12,7 +12,9 @@</>\n<d>  ? \"number\"</>\n<d>  : T extends boolean</>\n<d>  ? \"boolean\"</>\n<d>  : T extends undefined</>\n<d>  ? \"undefined\"</>\n<m>- : T extends Function<i> </i>? \"function\"<i> </i>: \"object\";</>\n<t>+ : T extends Function</>\n<t>+ ? \"function\"</>\n<t>+ : \"object\";</>\n<d>  ↵</>\n`;\n\nexports[`printSnapshotAndReceived expand true 1`] = `\n<m>- Snapshot  - 1</>\n<t>+ Received  + 3</>\n\n<d>  type TypeName<T> =</>\n<d>  T extends string ? \"string\" :</>\n<d>  T extends number ? \"number\" :</>\n<d>  T extends boolean ? \"boolean\" :</>\n<d>  T extends undefined ? \"undefined\" :</>\n<d>  T extends Function ? \"function\" :</>\n<d>  \"object\";</>\n<d>  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</>\n<d>  type TypeName<T> = T extends string</>\n<d>  ? \"string\"</>\n<d>  : T extends number</>\n<d>  ? \"number\"</>\n<d>  : T extends boolean</>\n<d>  ? \"boolean\"</>\n<d>  : T extends undefined</>\n<d>  ? \"undefined\"</>\n<m>- : T extends Function<i> </i>? \"function\"<i> </i>: \"object\";</>\n<t>+ : T extends Function</>\n<t>+ ? \"function\"</>\n<t>+ : \"object\";</>\n<d>  ↵</>\n`;\n\nexports[`printSnapshotAndReceived fallback to line diff 1`] = `\n<m>- Snapshot  - 1</>\n<t>+ Received  + 8</>\n\n<t>+ ====================================options=====================================</>\n<t>+ parsers: [\"flow\", \"typescript\"]</>\n<t>+ printWidth: 80</>\n<t>+                                                                                 | printWidth</>\n<t>+ =====================================input======================================</>\n<d>  [...a, ...b,];</>\n<d>  [...a, ...b];</>\n<m>- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</>\n<t>+</>\n<t>+ =====================================output=====================================</>\n<d>  [...a, ...b];</>\n<d>  [...a, ...b];</>\n\n<t>+ ================================================================================</>\n`;\n\nexports[`printSnapshotAndReceived has no common after clean up chaff array 1`] = `\n<m>- Snapshot  - 2</>\n<t>+ Received  + 2</>\n\n<d>  Array [</>\n<m>-   \"delete\",</>\n<m>-   \"two\",</>\n<t>+   \"insert\",</>\n<t>+   \"2\",</>\n<d>  ]</>\n`;\n\nexports[`printSnapshotAndReceived has no common after clean up chaff string single line 1`] = `\nSnapshot: <m>\"delete\"</>\nReceived: <t>\"insert\"</>\n`;\n\nexports[`printSnapshotAndReceived ignore indentation markup delete 1`] = `\n<m>- Snapshot  - 2</>\n<t>+ Received  + 0</>\n\n<d>  <div></>\n<m>-   <div></>\n<d>    <h3></>\n<d>      Ignore indentation for most serialized objects</>\n<d>    </h3></>\n<d>    <p></>\n<d>      Call<Y> </Y></>\n<d>      <code></>\n<d>        diffLinesUnified2</>\n<d>      </code></>\n<d>       to compare without indentation</>\n<d>    </p></>\n<m>-   </div></>\n<d>  </div></>\n`;\n\nexports[`printSnapshotAndReceived ignore indentation markup fall back 1`] = `\n<m>- Snapshot  - 5</>\n<t>+ Received  + 7</>\n\n<m>- <pre</>\n<m>-   className=\"language-js\"</>\n<m>- ></>\n<m>-   for (key in foo) {</>\n<t>+ <div></>\n<t>+   <pre</>\n<t>+     className=\"language-js\"</>\n<t>+   ></>\n<t>+     for (key in foo) {</>\n<d>    if (Object.prototype.hasOwnProperty.call(foo, key)) {</>\n<d>      doSomething(key);</>\n<d>    }</>\n<d>  }</>\n<m>- </pre></>\n<t>+   </pre></>\n<t>+ </div></>\n`;\n\nexports[`printSnapshotAndReceived ignore indentation markup insert 1`] = `\n<m>- Snapshot  - 0</>\n<t>+ Received  + 7</>\n\n<d>  <th></>\n<t>+   <span></>\n<d>      when</>\n<t>+   </span></>\n<t>+   <abbr</>\n<t>+     title=\"ascending from older to newer\"</>\n<t>+   ></>\n<t>+     ↓</>\n<t>+   </abbr></>\n<d>  </th></>\n`;\n\nexports[`printSnapshotAndReceived ignore indentation object delete 1`] = `\n<m>- Snapshot  - 2</>\n<t>+ Received  + 0</>\n\n<d>  Object {</>\n<m>-   \"payload\": Object {</>\n<d>    \"text\": \"Ignore indentation in snapshot\",</>\n<d>    \"time\": \"2019-11-11\",</>\n<m>-   },</>\n<d>    \"type\": \"CREATE_ITEM\",</>\n<d>  }</>\n`;\n\nexports[`printSnapshotAndReceived ignore indentation object insert 1`] = `\n<m>- Snapshot  - 0</>\n<t>+ Received  + 2</>\n\n<d>  Object {</>\n<t>+   \"payload\": Object {</>\n<d>      \"text\": \"Ignore indentation in snapshot\",</>\n<d>      \"time\": \"2019-11-11\",</>\n<t>+   },</>\n<d>    \"type\": \"CREATE_ITEM\",</>\n<d>  }</>\n`;\n\nexports[`printSnapshotAndReceived isLineDiffable false asymmetric matcher 1`] = `\nSnapshot: <m>null</>\nReceived: <t>Object {</>\n<t>  \"asymmetricMatch\": [Function],</>\n<t>}</>\n`;\n\nexports[`printSnapshotAndReceived isLineDiffable false boolean 1`] = `\nSnapshot: <m>true</>\nReceived: <t>false</>\n`;\n\nexports[`printSnapshotAndReceived isLineDiffable false date 1`] = `\nSnapshot: <m>2019-09-19T00:00:00.000Z</>\nReceived: <t>2019-09-20T00:00:00.000Z</>\n`;\n\nexports[`printSnapshotAndReceived isLineDiffable false error 1`] = `\nSnapshot: <m>[Error: Cannot spread fragment \"NameAndAppearances\" within itself.]</>\nReceived: <t>[Error: Cannot spread fragment \"NameAndAppearancesAndFriends\" within itself.]</>\n`;\n\nexports[`printSnapshotAndReceived isLineDiffable false function 1`] = `\nSnapshot: <m>undefined</>\nReceived: <t>[Function]</>\n`;\n\nexports[`printSnapshotAndReceived isLineDiffable false number 1`] = `\nSnapshot: <m>-0</>\nReceived: <t>NaN</>\n`;\n\nexports[`printSnapshotAndReceived isLineDiffable true array 1`] = `\n<m>- Snapshot  - 0</>\n<t>+ Received  + 2</>\n\n<d>  Array [</>\n<d>    Object {</>\n<t>+     \"_id\": \"b14680dec683e744ada1f2fe08614086\",</>\n<d>      \"code\": 4011,</>\n<d>      \"weight\": 2.13,</>\n<d>    },</>\n<d>    Object {</>\n<t>+     \"_id\": \"7fc63ff01769c4fa7d9279e97e307829\",</>\n<d>      \"code\": 4019,</>\n<d>      \"count\": 4,</>\n<d>    },</>\n<d>  ]</>\n`;\n\nexports[`printSnapshotAndReceived isLineDiffable true object 1`] = `\n<m>- Snapshot  - 2</>\n<t>+ Received  + 3</>\n\n<d>  Object {</>\n<d>    \"props\": Object {</>\n<m>-     \"className\": \"logo\",</>\n<m>-     \"src\": \"/img/jest.png\",</>\n<t>+     \"alt\": \"Jest logo\",</>\n<t>+     \"class\": \"logo\",</>\n<t>+     \"src\": \"/img/jest.svg\",</>\n<d>    },</>\n<d>    \"type\": \"img\",</>\n<d>  }</>\n`;\n\nexports[`printSnapshotAndReceived isLineDiffable true single line expected and multi line received 1`] = `\n<m>- Snapshot  - 1</>\n<t>+ Received  + 3</>\n\n<m>- Array []</>\n<t>+ Array [</>\n<t>+   0,</>\n<t>+ ]</>\n`;\n\nexports[`printSnapshotAndReceived isLineDiffable true single line expected and received 1`] = `\n<m>- Snapshot  - 1</>\n<t>+ Received  + 1</>\n\n<m>- Array []</>\n<t>+ Object {}</>\n`;\n\nexports[`printSnapshotAndReceived multi line small change in one line and other is unchanged 1`] = `\n<m>- Snapshot  - 1</>\n<t>+ Received  + 1</>\n\n<m>- There is no route defined for key <i>'</i>Settings<i>'</i>.</>\n<t>+ There is no route defined for key Settings.</>\n<d>  Must be one of: 'Home'</>\n`;\n\nexports[`printSnapshotAndReceived multi line small changes 1`] = `\n<m>- Snapshot  - 7</>\n<t>+ Received  + 7</>\n\n<m>-     6<i>9</i> | </>\n<t>+     6<i>8</i> | </>\n<m>-     <i>70</i> | test('assert.doesNotThrow', () => {</>\n<t>+     <i>69</i> | test('assert.doesNotThrow', () => {</>\n<m>-   > 7<i>1</i> |   assert.doesNotThrow(() => {</>\n<t>+   > 7<i>0</i> |   assert.doesNotThrow(() => {</>\n<d>         |          ^</>\n<m>-     7<i>2</i> |     throw Error('err!');</>\n<t>+     7<i>1</i> |     throw Error('err!');</>\n<m>-     7<i>3</i> |   });</>\n<t>+     7<i>2</i> |   });</>\n<m>-     7<i>4</i> | });</>\n<t>+     7<i>3</i> | });</>\n<m>-     at Object.doesNotThrow (__tests__/assertionError.test.js:7<i>1</i>:10)</>\n<t>+     at Object.doesNotThrow (__tests__/assertionError.test.js:7<i>0</i>:10)</>\n`;\n\nexports[`printSnapshotAndReceived single line large changes 1`] = `\nSnapshot: <m>\"<i>A</i>rray length<i> must be a finite positive integer</i>\"</>\nReceived: <t>\"<i>Invalid a</i>rray length\"</>\n`;\n\nexports[`printSnapshotAndReceived without serialize backtick single line expected and multi line received 1`] = `\n<m>- Snapshot  - 1</>\n<t>+ Received  + 2</>\n\n<m>- var foo = \\`backtick\\`;</>\n<t>+ var foo = \\`back</>\n<t>+ tick\\`;</>\n`;\n\nexports[`printSnapshotAndReceived without serialize backtick single line expected and received 1`] = `\n<m>- Snapshot  - 1</>\n<t>+ Received  + 1</>\n\n<m>- var foo = \\`backtick\\`;</>\n<t>+ var foo = \\`back<i>\\${x}</i>tick\\`;</>\n`;\n\nexports[`printSnapshotAndReceived without serialize has no common after clean up chaff multi line 1`] = `\n<m>- Snapshot  - 2</>\n<t>+ Received  + 2</>\n\n<m>- delete</>\n<m>- two</>\n<t>+ insert</>\n<t>+ 2</>\n`;\n\nexports[`printSnapshotAndReceived without serialize has no common after clean up chaff single line 1`] = `\n<m>- Snapshot  - 1</>\n<t>+ Received  + 1</>\n\n<m>- delete</>\n<t>+ insert</>\n`;\n\nexports[`printSnapshotAndReceived without serialize prettier/pull/5590 1`] = `\n<m>- Snapshot  - 1</>\n<t>+ Received  + 1</>\n\n<y>@@ -4,8 +4,8 @@</>\n<d>                                                                                  | printWidth</>\n<d>  =====================================input======================================</>\n<d>  <img src=\"test.png\" alt='John \"ShotGun\" Nelson'></>\n\n<d>  =====================================output=====================================</>\n<m>- <img src=\"test.png\" alt=<i>\"</i>John <i>&quot;</i>ShotGun<i>&quot;</i> Nelson<i>\"</i> /></>\n<t>+ <img src=\"test.png\" alt=<i>'</i>John <i>\"</i>ShotGun<i>\"</i> Nelson<i>'</i> /></>\n\n<d>  ================================================================================</>\n`;"}
{"prompt":"returns the tasks in order,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport PriorityQueue from '../PriorityQueue';\nimport {\n  CHILD_MESSAGE_CALL,\n  type ChildMessageCall,\n  type QueueChildMessage,\n} from '../types';\n\nit('returns the tasks in order', () => {\n  const computePriority = (_method: string, task: unknown) =>\n    (task as {priority: number}).priority;\n  const queue = new PriorityQueue(computePriority);\n  const priorities = [10, 3, 4, 8, 2, 9, 7, 1, 2, 6, 5];\n\n  for (const priority of priorities) {\n    queue.enqueue(createQueueChildMessage({priority}));\n  }\n\n  priorities.sort((a, b) => a - b);\n  for (const priority of priorities) {\n    expect(queue.dequeue(0)).toEqual(\n      expect.objectContaining({\n        request: [CHILD_MESSAGE_CALL, false, 'test', [{priority}]],\n      }),\n    );\n  }\n\n  expect(queue.dequeue(0)).toBeNull();\n});\n\nit('returns the task with the lowest priority value if inserted in reversed order', () => {\n  const last = createQueueChildMessage({priority: 3});\n  const mid = createQueueChildMessage({priority: 2});\n  const first = createQueueChildMessage({priority: 1});\n\n  const computePriority = (_method: string, task: unknown) =>\n    (task as {priority: number}).priority;\n  const queue = new PriorityQueue(computePriority);\n\n  queue.enqueue(last, 1);\n  queue.enqueue(first, 1);\n  queue.enqueue(mid, 1);\n\n  expect(queue.dequeue(1)).toBe(first);\n  expect(queue.dequeue(1)).toBe(mid);\n  expect(queue.dequeue(1)).toBe(last);\n  expect(queue.dequeue(1)).toBeNull();\n});\n\nit('returns the task with the lowest priority value if inserted in correct order', () => {\n  const first = createQueueChildMessage({priority: 1});\n  const mid = createQueueChildMessage({priority: 2});\n  const last = createQueueChildMessage({priority: 3});\n\n  const computePriority = (_method: string, task: unknown) =>\n    (task as {priority: number}).priority;\n  const queue = new PriorityQueue(computePriority);\n\n  queue.enqueue(last, 1);\n  queue.enqueue(first, 1);\n  queue.enqueue(mid, 1);\n\n  expect(queue.dequeue(1)).toBe(first);\n  expect(queue.dequeue(1)).toBe(mid);\n  expect(queue.dequeue(1)).toBe(last);\n  expect(queue.dequeue(1)).toBeNull();\n});\n\nit('uses different queues for each worker', () => {\n  const task1Worker1 = createQueueChildMessage({priority: 1});\n  const task2Worker1 = createQueueChildMessage({priority: 3});\n  const task1Worker2 = createQueueChildMessage({priority: 1});\n  const task2Worker2 = createQueueChildMessage({priority: 3});\n\n  const computePriority = (_method: string, task: unknown) =>\n    (task as {priority: number}).priority;\n  const queue = new PriorityQueue(computePriority);\n\n  queue.enqueue(task2Worker1, 1);\n  queue.enqueue(task1Worker1, 1);\n  queue.enqueue(task2Worker2, 2);\n  queue.enqueue(task1Worker2, 2);\n\n  expect(queue.dequeue(1)).toBe(task1Worker1);\n  expect(queue.dequeue(1)).toBe(task2Worker1);\n  expect(queue.dequeue(2)).toBe(task1Worker2);\n  expect(queue.dequeue(2)).toBe(task2Worker2);\n  expect(queue.dequeue(1)).toBeNull();\n});\n\nit('process task in the global and shared queue in order', () => {\n  const computePriority = (_method: string, task: unknown) =>\n    (task as {priority: number}).priority;\n  const queue = new PriorityQueue(computePriority);\n\n  const sharedTask1 = createQueueChildMessage({priority: 1});\n  const sharedTask2 = createQueueChildMessage({priority: 3});\n  queue.enqueue(sharedTask1);\n  queue.enqueue(sharedTask2);\n\n  const worker1Task1 = createQueueChildMessage({priority: 0});\n  const worker1Task2 = createQueueChildMessage({priority: 2});\n  queue.enqueue(worker1Task1, 1);\n  queue.enqueue(worker1Task2, 1);\n\n  const worker2Task1 = createQueueChildMessage({priority: 3});\n  queue.enqueue(worker2Task1, 2);\n\n  expect(queue.dequeue(1)).toBe(worker1Task1);\n  expect(queue.dequeue(1)).toBe(sharedTask1);\n  expect(queue.dequeue(1)).toBe(worker1Task2);\n\n  expect(queue.dequeue(2)).toBe(worker2Task1);\n  expect(queue.dequeue(2)).toBe(sharedTask2);\n\n  expect(queue.dequeue(1)).toBeNull();\n  expect(queue.dequeue(2)).toBeNull();\n});\n\nfunction createQueueChildMessage(...args: Array<unknown>): QueueChildMessage {\n  const request: ChildMessageCall = [CHILD_MESSAGE_CALL, false, 'test', args];\n\n  return {\n    onCustomMessage: () => {},\n    onEnd: () => {},\n    onStart: () => {},\n    request,\n  };\n}"}
{"prompt":"Jest Worker Integration,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EventEmitter} from 'events';\nimport type {JestWorkerFarm, Worker} from '..';\nimport {\n  CHILD_MESSAGE_CALL,\n  CHILD_MESSAGE_MEM_USAGE,\n  PARENT_MESSAGE_OK,\n} from '../types';\n\nclass MockChildProcess extends EventEmitter {\n  connected = true;\n  send = jest.fn<(message: unknown) => boolean>();\n}\n\nlet WorkerFarm: typeof Worker;\nlet mockForkedProcesses: Array<MockChildProcess>;\n\nfunction replySuccess(i: number, result: unknown) {\n  mockForkedProcesses[i].emit('message', [PARENT_MESSAGE_OK, result]);\n}\n\nfunction assertCallsToChild(\n  childNum: number,\n  ...calls: Array<[unknown, ...[unknown]]>\n) {\n  expect(mockForkedProcesses[childNum].send).toHaveBeenCalledTimes(\n    calls.length + 1,\n  );\n\n  for (const [numCall, [methodName, ...args]] of calls.entries()) {\n    expect(\n      jest.mocked(mockForkedProcesses[childNum].send).mock.calls[\n        numCall + 1\n      ][0],\n    ).toEqual([CHILD_MESSAGE_CALL, true, methodName, args]);\n  }\n}\n\ndescribe('Jest Worker Integration', () => {\n  beforeEach(() => {\n    mockForkedProcesses = [];\n\n    jest.mock('child_process', () => ({\n      fork() {\n        const forkedProcess = new MockChildProcess();\n        mockForkedProcesses.push(forkedProcess);\n\n        return forkedProcess;\n      },\n    }));\n\n    WorkerFarm = (require('../') as typeof import('..')).Worker;\n  });\n\n  afterEach(() => {\n    jest.resetModules();\n  });\n\n  it('calls a single method from the worker', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(): void}>;\n\n    const promise = farm.foo();\n\n    replySuccess(0, 42);\n\n    expect(await promise).toBe(42);\n  });\n\n  it('distributes sequential calls across child processes', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // The first call will go to the first child process.\n    const promise0 = farm.foo('param-0');\n    assertCallsToChild(0, ['foo', 'param-0']);\n    replySuccess(0, 'worker-0');\n    expect(await promise0).toBe('worker-0');\n\n    // The second call will go to the second child process.\n    const promise1 = farm.foo(1);\n    assertCallsToChild(1, ['foo', 1]);\n    replySuccess(1, 'worker-1');\n    expect(await promise1).toBe('worker-1');\n  });\n\n  it('schedules the task on the first available child processes if the scheduling policy is in-order', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n      workerSchedulingPolicy: 'in-order',\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // The first call will go to the first child process.\n    const promise0 = farm.foo('param-0');\n    assertCallsToChild(0, ['foo', 'param-0']);\n\n    // The second call will go to the second child process.\n    const promise1 = farm.foo(1);\n\n    // The first task on worker 0 completes.\n    replySuccess(0, 'worker-0');\n    expect(await promise0).toBe('worker-0');\n\n    // The second task on worker 1 completes.\n    assertCallsToChild(1, ['foo', 1]);\n    replySuccess(1, 'worker-1');\n    expect(await promise1).toBe('worker-1');\n\n    // The third call will go to the first child process.\n    const promise2 = farm.foo('param-2');\n    assertCallsToChild(0, ['foo', 'param-0'], ['foo', 'param-2']);\n    replySuccess(0, 'worker-0');\n    expect(await promise2).toBe('worker-0');\n  });\n\n  it('distributes concurrent calls across child processes', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // Do 3 calls to the farm in parallel.\n    const promise0 = farm.foo('param-0');\n    const promise1 = farm.foo('param-1');\n    const promise2 = farm.foo('param-2');\n\n    // Check that the method calls are sent to each separate child process.\n    assertCallsToChild(0, ['foo', 'param-0']);\n    assertCallsToChild(1, ['foo', 'param-1']);\n    assertCallsToChild(2, ['foo', 'param-2']);\n\n    // Send different responses from each child.\n    replySuccess(0, 'worker-0');\n    replySuccess(1, 'worker-1');\n    replySuccess(2, 'worker-2');\n\n    // Check\n    expect(await promise0).toBe('worker-0');\n    expect(await promise1).toBe('worker-1');\n    expect(await promise2).toBe('worker-2');\n  });\n\n  it('sticks parallel calls to children', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      computeWorkerKey: () => '1234567890abcdef',\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // Do 3 calls to the farm in parallel.\n    const promise0 = farm.foo('param-0');\n    const promise1 = farm.foo('param-1');\n    const promise2 = farm.foo('param-2');\n\n    // Send different responses for each call (from the same child).\n    replySuccess(0, 'worker-0');\n    replySuccess(0, 'worker-1');\n    replySuccess(0, 'worker-2');\n\n    // Check that all the calls have been received by the same child.\n    assertCallsToChild(\n      0,\n      ['foo', 'param-0'],\n      ['foo', 'param-1'],\n      ['foo', 'param-2'],\n    );\n\n    // Check that responses are correct.\n    expect(await promise0).toBe('worker-0');\n    expect(await promise1).toBe('worker-1');\n    expect(await promise2).toBe('worker-2');\n  });\n\n  it('should check for memory limits', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      exposedMethods: ['foo', 'bar'],\n      idleMemoryLimit: 0.4,\n      numWorkers: 2,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // Send a call to the farm\n    farm.foo('param-0');\n\n    // Send different responses for each call (from the same child).\n    replySuccess(0, 'worker-0');\n\n    // Check that all the calls have been received by the same child.\n    // We're not using the assertCallsToChild helper because we need to check\n    // for other send types.\n    expect(mockForkedProcesses[0].send).toHaveBeenCalledTimes(3);\n    expect(jest.mocked(mockForkedProcesses[0].send).mock.calls[1][0]).toEqual([\n      CHILD_MESSAGE_CALL,\n      true,\n      'foo',\n      ['param-0'],\n    ]);\n    expect(jest.mocked(mockForkedProcesses[0].send).mock.calls[2][0]).toEqual([\n      CHILD_MESSAGE_MEM_USAGE,\n    ]);\n  });\n});"}
{"prompt":"eslint-disable-next-line no-throw-leral","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n  CHILD_MESSAGE_CALL,\n  CHILD_MESSAGE_END,\n  CHILD_MESSAGE_INITIALIZE,\n  CHILD_MESSAGE_MEM_USAGE,\n  PARENT_MESSAGE_CLIENT_ERROR,\n  PARENT_MESSAGE_MEM_USAGE,\n  PARENT_MESSAGE_OK,\n} from '../../types';\n\nconst spyProcessSend = jest.spyOn(process, 'send');\n\nclass MockExtendedError extends ReferenceError {\n  baz = 123;\n  qux = 456;\n}\n\nconst mockError = new TypeError('Boo');\nconst mockExtendedError = new MockExtendedError('Boo extended');\nconst uninitializedParam = {};\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\nlet ended: boolean;\nlet mockCount: number;\nlet initializeParm = uninitializedParam;\n\nbeforeEach(() => {\n  mockCount = 0;\n  ended = false;\n\n  jest.mock(\n    '../my-fancy-worker',\n    () => {\n      mockCount++;\n\n      return {\n        fooCircularResult() {\n          const circular = {self: undefined as unknown};\n          circular.self = circular;\n          return {error: circular};\n        },\n\n        fooPromiseThrows() {\n          return new Promise((_resolve, reject) => {\n            setTimeout(() => reject(mockError), 5);\n          });\n        },\n\n        fooPromiseWorks() {\n          return new Promise(resolve => {\n            setTimeout(() => resolve(1989), 5);\n          });\n        },\n\n        fooThrows() {\n          throw mockError;\n        },\n\n        fooThrowsANumber() {\n          // eslint-disable-next-line no-throw-literal\n          throw 412;\n        },\n\n        fooThrowsAnErrorWithExtraProperties() {\n          mockExtendedError.baz = 123;\n          mockExtendedError.qux = 456;\n\n          throw mockExtendedError;\n        },\n\n        fooThrowsNull() {\n          // eslint-disable-next-line no-throw-literal\n          throw null;\n        },\n\n        fooWorks() {\n          return 1989;\n        },\n\n        setup(param: Record<string, unknown>) {\n          initializeParm = param;\n        },\n\n        teardown() {\n          ended = true;\n        },\n      };\n    },\n    {virtual: true},\n  );\n\n  jest.mock(\n    '../my-fancy-standalone-worker',\n    () => jest.fn().mockImplementation(() => 12_345),\n    {virtual: true},\n  );\n\n  // This mock emulates a transpiled Babel module that carries a default export\n  // that corresponds to a method.\n  jest.mock(\n    '../my-fancy-babel-worker',\n    () => ({\n      __esModule: true,\n      default: jest.fn().mockImplementation(() => 67_890),\n    }),\n    {virtual: true},\n  );\n\n  // Require the child!\n  require('../processChild');\n});\n\nafterEach(() => {\n  jest.clearAllMocks().resetModules();\n\n  process.removeAllListeners('message');\n});\n\nit('lazily requires the file', () => {\n  expect(mockCount).toBe(0);\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n    ],\n    null,\n  );\n\n  expect(mockCount).toBe(0);\n  expect(initializeParm).toBe(uninitializedParam); // Not called yet.\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooWorks',\n      [],\n    ],\n    null,\n  );\n\n  expect(mockCount).toBe(1);\n  expect(initializeParm).toBeUndefined();\n});\n\nit('should return memory usage', () => {\n  expect(mockCount).toBe(0);\n\n  process.emit('message', [CHILD_MESSAGE_MEM_USAGE], null);\n\n  expect(spyProcessSend.mock.calls[0][0]).toEqual([\n    PARENT_MESSAGE_MEM_USAGE,\n    expect.any(Number),\n  ]);\n});\n\nit('calls initialize with the correct arguments', () => {\n  expect(mockCount).toBe(0);\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n      ['foo'], // Pass empty initialize params so the initialize method is called.\n    ],\n    null,\n  );\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooWorks',\n      [],\n    ],\n    null,\n  );\n\n  expect(initializeParm).toBe('foo');\n});\n\nit('returns results immediately when function is synchronous', () => {\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n    ],\n    null,\n  );\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooWorks',\n      [],\n    ],\n    null,\n  );\n\n  expect(spyProcessSend.mock.calls[0][0]).toEqual([PARENT_MESSAGE_OK, 1989]);\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooThrows',\n      [],\n    ],\n    null,\n  );\n\n  expect(spyProcessSend.mock.calls[1][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'TypeError',\n    'Boo',\n    mockError.stack,\n    {},\n  ]);\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooThrowsANumber',\n      [],\n    ],\n    null,\n  );\n\n  expect(spyProcessSend.mock.calls[2][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'Number',\n    void 0,\n    void 0,\n    412,\n  ]);\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooThrowsAnErrorWithExtraProperties',\n      [],\n    ],\n    null,\n  );\n\n  expect(spyProcessSend.mock.calls[3][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'MockExtendedError',\n    'Boo extended',\n    mockExtendedError.stack,\n    {baz: 123, qux: 456},\n  ]);\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooThrowsNull',\n      [],\n    ],\n    null,\n  );\n\n  expect(spyProcessSend.mock.calls[4][0][0]).toBe(PARENT_MESSAGE_CLIENT_ERROR);\n  expect(spyProcessSend.mock.calls[4][0][1]).toBe('Error');\n  expect(spyProcessSend.mock.calls[4][0][2]).toBe(\n    '\"null\" or \"undefined\" thrown',\n  );\n\n  expect(spyProcessSend).toHaveBeenCalledTimes(5);\n});\n\nit('returns results when it gets resolved if function is asynchronous', async () => {\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n    ],\n    null,\n  );\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooPromiseWorks',\n      [],\n    ],\n    null,\n  );\n\n  await sleep(10);\n\n  expect(spyProcessSend.mock.calls[0][0]).toEqual([PARENT_MESSAGE_OK, 1989]);\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooPromiseThrows',\n      [],\n    ],\n    null,\n  );\n\n  await sleep(10);\n\n  expect(spyProcessSend.mock.calls[1][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'TypeError',\n    'Boo',\n    mockError.stack,\n    {},\n  ]);\n\n  expect(spyProcessSend).toHaveBeenCalledTimes(2);\n});\n\nit('returns results with circular references', () => {\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n    ],\n    null,\n  );\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'fooCircularResult',\n      [],\n    ],\n    null,\n  );\n\n  const processCallError = spyProcessSend.mock.calls[0][0][1].error;\n  expect(processCallError.self).toBe(processCallError.self.self);\n});\n\nit('calls the main module if the method call is \"default\"', () => {\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-standalone-worker',\n    ],\n    null,\n  );\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'default',\n      [],\n    ],\n    null,\n  );\n\n  expect(spyProcessSend.mock.calls[0][0]).toEqual([PARENT_MESSAGE_OK, 12_345]);\n});\n\nit('calls the main export if the method call is \"default\" and it is a Babel transpiled one', () => {\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-babel-worker',\n    ],\n    null,\n  );\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_CALL,\n      true, // Not really used here, but for type purity.\n      'default',\n      [],\n    ],\n    null,\n  );\n\n  expect(spyProcessSend.mock.calls[0][0]).toEqual([PARENT_MESSAGE_OK, 67_890]);\n});\n\nit('removes the message listener on END message', () => {\n  // So that there are no more open handles preventing Node from exiting\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n    ],\n    null,\n  );\n\n  process.emit('message', [CHILD_MESSAGE_END], null);\n\n  expect(process.listenerCount('message')).toBe(0);\n});\n\nit('calls the teardown method ', () => {\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n    ],\n    null,\n  );\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_END,\n      true, // Not really used here, but for type purity.\n    ],\n    null,\n  );\n\n  expect(ended).toBe(true);\n});\n\nit('throws if an invalid message is detected', () => {\n  // Type 27 does not exist.\n  expect(() => {\n    process.emit('message', [27], null);\n  }).toThrow(TypeError);\n});\n\nit('throws if child is not forked', () => {\n  delete process.send;\n\n  process.emit(\n    'message',\n    [\n      CHILD_MESSAGE_INITIALIZE,\n      true, // Not really used here, but for type purity.\n      './my-fancy-worker',\n    ],\n    null,\n  );\n\n  expect(() => {\n    process.emit(\n      'message',\n      [\n        CHILD_MESSAGE_CALL,\n        true, // Not really used here, but for type purity.\n        'fooWorks',\n        [],\n      ],\n      null,\n    );\n  }).toThrow('Child can only be used on a forked process');\n\n  expect(() => {\n    process.emit(\n      'message',\n      [\n        CHILD_MESSAGE_CALL,\n        true, // Not really used here, but for type purity.\n        'fooThrows',\n        [],\n      ],\n      null,\n    );\n  }).toThrow('Child can only be used on a forked process');\n});"}
{"prompt":"prints stack trace pointing to process.exit call,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\nit('prints stack trace pointing to process.exit call', () => {\n  const {stderr} = runJest('process-exit');\n\n  expect(stderr).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`prints stack trace pointing to process.exit call 1`] = `\n\"  ●  process.exit called with \"1\"\n\n       6 |  */\n       7 |\n    >  8 | process.exit(1);\n         |         ^\n       9 |\n      10 | test('something', () => {\n      11 |   expect(true).toBe(true);\n\n      at Object.exit (__tests__/test.js:8:9)\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('should match 1', () => expect(1).toBe(1));"}
{"prompt":"promise-returning test with callback, done => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nit('promise-returning test with callback', done => {\n  done();\n\n  return Promise.resolve();\n});\n\nit('async test with callback', async done => {\n  done();\n});\n\nit('test done before return value', done => {\n  done();\n\n  return 'foobar';\n});"}
{"prompt":"eslint-disable-next-line no-new","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('something', () => {\n  // eslint-disable-next-line no-new\n  new Promise(() => {});\n  expect(true).toBe(true);\n});"}
{"prompt":"promise afterAll,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ndescribe('promise afterAll', () => {\n  let localFlag = true;\n  afterAll(() => {\n    this.flag = 1;\n    localFlag = false;\n    return new Promise(resolve => {\n      process.nextTick(resolve);\n    }).then(() => {\n      console.log('unset flag');\n      this.flag = undefined;\n    });\n  });\n\n  // passing tests\n  it('runs afterAll after all tests', () => {\n    expect(this.flag).toBeUndefined();\n    expect(localFlag).toBe(true);\n  });\n\n  it('waits for afterAll to asynchronously complete before each test', () => {\n    expect(this.flag).toBeUndefined();\n    expect(localFlag).toBe(true);\n  });\n});"}
{"prompt":"promise afterEach,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ndescribe('promise afterEach', () => {\n  let localFlag = true;\n\n  afterEach(() => {\n    this.flag = 1;\n    localFlag = false;\n    return new Promise(resolve => {\n      process.nextTick(resolve);\n    }).then(() => {\n      this.flag = undefined;\n    });\n  });\n\n  // passing tests\n  it('runs afterEach after each test', () => {\n    expect(this.flag).toBeUndefined();\n    expect(localFlag).toBe(true);\n  });\n\n  it('waits for afterEach to asynchronously complete before each test', () => {\n    expect(this.flag).toBeUndefined();\n    expect(localFlag).toBe(false);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport {extractSortedSummary} from '../Utils';\nimport runJest from '../runJest';\n\nconst dir = path.resolve(__dirname, '../promise-async-handling');\n\nskipSuiteOnJasmine();\n\ntest('fails because of unhandled promise rejection in test', () => {\n  const {stderr, exitCode} = runJest(dir, ['unhandledRejectionTest.test.js']);\n\n  expect(exitCode).toBe(1);\n  const sortedSummary = extractSortedSummary(stderr);\n  expect(sortedSummary).toMatchSnapshot();\n});\n\ntest('fails because of unhandled promise rejection in beforeAll hook', () => {\n  const {stderr, exitCode} = runJest(dir, [\n    'unhandledRejectionBeforeAll.test.js',\n  ]);\n\n  expect(exitCode).toBe(1);\n  const sortedSummary = extractSortedSummary(stderr);\n  expect(sortedSummary).toMatchSnapshot();\n});\n\ntest('fails because of unhandled promise rejection in beforeEach hook', () => {\n  const {stderr, exitCode} = runJest(dir, [\n    'unhandledRejectionBeforeEach.test.js',\n  ]);\n\n  expect(exitCode).toBe(1);\n  const sortedSummary = extractSortedSummary(stderr);\n  expect(sortedSummary).toMatchSnapshot();\n});\n\ntest('fails because of unhandled promise rejection in afterEach hook', () => {\n  const {stderr, exitCode} = runJest(dir, [\n    'unhandledRejectionAfterEach.test.js',\n  ]);\n\n  expect(exitCode).toBe(1);\n  const sortedSummary = extractSortedSummary(stderr);\n  expect(sortedSummary).toMatchSnapshot();\n});\n\ntest('fails because of unhandled promise rejection in afterAll hook', () => {\n  const {stderr, exitCode} = runJest(dir, [\n    'unhandledRejectionAfterAll.test.js',\n  ]);\n\n  expect(exitCode).toBe(1);\n  const sortedSummary = extractSortedSummary(stderr);\n  expect(sortedSummary).toMatchSnapshot();\n});\n\ntest('succeeds for async handled promise rejections', () => {\n  const {stderr, exitCode} = runJest(dir, ['rejectionHandled.test.js']);\n\n  expect(exitCode).toBe(0);\n  const sortedSummary = extractSortedSummary(stderr);\n  expect(sortedSummary).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`fails because of unhandled promise rejection in afterAll hook 1`] = `\nObject {\n  \"rest\": \"FAIL __tests__/unhandledRejectionAfterAll.test.js\n\n\n  ● Test suite failed to run\n\n    REJECTED\n\n      11 |\n      12 | afterAll(async () => {\n    > 13 |   Promise.reject(new Error('REJECTED'));\n         |                  ^\n      14 |\n      15 |   await promisify(setTimeout)(0);\n      16 | });\n\n      at Object.<anonymous> (__tests__/unhandledRejectionAfterAll.test.js:13:18)\",\n  \"summary\": \"Test Suites: 1 failed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching unhandledRejectionAfterAll.test.js.\",\n}\n`;\n\nexports[`fails because of unhandled promise rejection in afterEach hook 1`] = `\nObject {\n  \"rest\": \"FAIL __tests__/unhandledRejectionAfterEach.test.js\n  ✕ foo #1\n  ✕ foo #2\n\n  ● foo #1\n\n    REJECTED\n\n      11 |\n      12 | afterEach(async () => {\n    > 13 |   Promise.reject(new Error('REJECTED'));\n         |                  ^\n      14 |\n      15 |   await promisify(setTimeout)(0);\n      16 | });\n\n      at Object.<anonymous> (__tests__/unhandledRejectionAfterEach.test.js:13:18)\n\n  ● foo #2\n\n    REJECTED\n\n      11 |\n      12 | afterEach(async () => {\n    > 13 |   Promise.reject(new Error('REJECTED'));\n         |                  ^\n      14 |\n      15 |   await promisify(setTimeout)(0);\n      16 | });\n\n      at Object.<anonymous> (__tests__/unhandledRejectionAfterEach.test.js:13:18)\",\n  \"summary\": \"Test Suites: 1 failed, 1 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching unhandledRejectionAfterEach.test.js.\",\n}\n`;\n\nexports[`fails because of unhandled promise rejection in beforeAll hook 1`] = `\nObject {\n  \"rest\": \"FAIL __tests__/unhandledRejectionBeforeAll.test.js\n  ✕ foo\n\n  ● foo\n\n    REJECTED\n\n      11 |\n      12 | beforeAll(async () => {\n    > 13 |   Promise.reject(new Error('REJECTED'));\n         |                  ^\n      14 |\n      15 |   await promisify(setTimeout)(0);\n      16 | });\n\n      at Object.<anonymous> (__tests__/unhandledRejectionBeforeAll.test.js:13:18)\",\n  \"summary\": \"Test Suites: 1 failed, 1 total\nTests:       1 failed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching unhandledRejectionBeforeAll.test.js.\",\n}\n`;\n\nexports[`fails because of unhandled promise rejection in beforeEach hook 1`] = `\nObject {\n  \"rest\": \"FAIL __tests__/unhandledRejectionBeforeEach.test.js\n  ✕ foo #1\n  ✕ foo #2\n\n  ● foo #1\n\n    REJECTED\n\n      11 |\n      12 | beforeEach(async () => {\n    > 13 |   Promise.reject(new Error('REJECTED'));\n         |                  ^\n      14 |\n      15 |   await promisify(setTimeout)(0);\n      16 | });\n\n      at Object.<anonymous> (__tests__/unhandledRejectionBeforeEach.test.js:13:18)\n\n  ● foo #2\n\n    REJECTED\n\n      11 |\n      12 | beforeEach(async () => {\n    > 13 |   Promise.reject(new Error('REJECTED'));\n         |                  ^\n      14 |\n      15 |   await promisify(setTimeout)(0);\n      16 | });\n\n      at Object.<anonymous> (__tests__/unhandledRejectionBeforeEach.test.js:13:18)\",\n  \"summary\": \"Test Suites: 1 failed, 1 total\nTests:       2 failed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching unhandledRejectionBeforeEach.test.js.\",\n}\n`;\n\nexports[`fails because of unhandled promise rejection in test 1`] = `\nObject {\n  \"rest\": \"FAIL __tests__/unhandledRejectionTest.test.js\n  ✕ w/o event loop turn after rejection\n  ✕ w/ event loop turn after rejection in async function\n  ✕ w/ event loop turn after rejection in sync function\n  ✕ combined w/ another failure _after_ promise rejection\n\n  ● w/o event loop turn after rejection\n\n    REJECTED\n\n      11 |\n      12 | test('w/o event loop turn after rejection', () => {\n    > 13 |   Promise.reject(new Error('REJECTED'));\n         |                  ^\n      14 | });\n      15 |\n      16 | test('w/ event loop turn after rejection in async function', async () => {\n\n      at Object.<anonymous> (__tests__/unhandledRejectionTest.test.js:13:18)\n\n  ● w/ event loop turn after rejection in async function\n\n    REJECTED\n\n      15 |\n      16 | test('w/ event loop turn after rejection in async function', async () => {\n    > 17 |   Promise.reject(new Error('REJECTED'));\n         |                  ^\n      18 |\n      19 |   await promisify(setTimeout)(0);\n      20 | });\n\n      at Object.<anonymous> (__tests__/unhandledRejectionTest.test.js:17:18)\n\n  ● w/ event loop turn after rejection in sync function\n\n    REJECTED\n\n      21 |\n      22 | test('w/ event loop turn after rejection in sync function', done => {\n    > 23 |   Promise.reject(new Error('REJECTED'));\n         |                  ^\n      24 |\n      25 |   setTimeout(done, 0);\n      26 | });\n\n      at Object.<anonymous> (__tests__/unhandledRejectionTest.test.js:23:18)\n\n  ● combined w/ another failure _after_ promise rejection\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: false\n    Received: true\n\n      31 |   await promisify(setTimeout)(0);\n      32 |\n    > 33 |   expect(true).toBe(false);\n         |                ^\n      34 | });\n      35 |\n\n      at Object.toBe (__tests__/unhandledRejectionTest.test.js:33:16)\n\n  ● combined w/ another failure _after_ promise rejection\n\n    REJECTED\n\n      27 |\n      28 | test('combined w/ another failure _after_ promise rejection', async () => {\n    > 29 |   Promise.reject(new Error('REJECTED'));\n         |                  ^\n      30 |\n      31 |   await promisify(setTimeout)(0);\n      32 |\n\n      at Object.<anonymous> (__tests__/unhandledRejectionTest.test.js:29:18)\",\n  \"summary\": \"Test Suites: 1 failed, 1 total\nTests:       4 failed, 4 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching unhandledRejectionTest.test.js.\",\n}\n`;\n\nexports[`succeeds for async handled promise rejections 1`] = `\nObject {\n  \"rest\": \"PASS __tests__/rejectionHandled.test.js\n  ✓ async function succeeds because the promise is eventually awaited by assertion\n  ✓ async function succeeds because the promise is eventually directly awaited\n  ✓ sync function succeeds because the promise is eventually handled by \\`.catch\\` handler\",\n  \"summary\": \"Test Suites: 1 passed, 1 total\nTests:       3 passed, 3 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching rejectionHandled.test.js.\",\n}\n`;"}
{"prompt":"promise beforeAll,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ndescribe('promise beforeAll', () => {\n  let flag;\n\n  beforeAll(() =>\n    new Promise(resolve => {\n      process.nextTick(resolve);\n    }).then(() => {\n      flag = 1;\n    }),\n  );\n\n  beforeAll(() => new Promise(resolve => setTimeout(resolve, 10)), 500);\n\n  // passing tests\n  it('runs tests after beforeAll asynchronously completes', () => {\n    expect(flag).toBe(1);\n  });\n\n  describe('with failing async', () => {\n    // failing before hook\n    beforeAll(() => new Promise(resolve => setTimeout(resolve, 100)), 11);\n\n    it('fails', () => {});\n  });\n\n  describe('done - with error thrown', () => {\n    beforeAll(done => {\n      throw new Error('fail');\n      // eslint-disable-next-line no-unreachable\n      done();\n    });\n    it('fails', () => {});\n  });\n\n  describe('done - with error called back', () => {\n    beforeAll(done => {\n      done(new Error('fail'));\n    });\n    it('fails', () => {});\n  });\n});"}
{"prompt":"promise beforeEach,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ndescribe('promise beforeEach', () => {\n  beforeEach(() =>\n    new Promise(resolve => {\n      process.nextTick(resolve);\n    }).then(() => {\n      this.flag = 1;\n    }),\n  );\n\n  // passing tests\n  it('runs tests after beforeEach asynchronously completes', () => {\n    expect(this.flag).toBe(1);\n  });\n\n  // failing tests\n  describe('done - with error thrown', () => {\n    beforeEach(done => {\n      throw new Error('fail');\n      // eslint-disable-next-line no-unreachable\n      done();\n    });\n    it('fails', () => {});\n  });\n\n  describe('done - with error called back', () => {\n    beforeEach(done => {\n      done(new Error('fail'));\n    });\n    it('fails', () => {});\n  });\n});"}
{"prompt":"promise fit,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable jest/no-focused-tests */\n\n'use strict';\n\ndescribe('promise fit', () => {\n  it('fails but will be skipped', () => {\n    expect(true).toBe(false);\n  });\n\n  fit('will run', () => Promise.resolve());\n\n  fit('will run and fail', () => Promise.reject());\n});"}
{"prompt":"promise it,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ndescribe('promise it', () => {\n  beforeEach(() => {\n    this.someContextValue = 'value';\n  });\n\n  // passing tests\n  it('passes a sync test', () => {\n    expect(1).toBe(1);\n  });\n\n  it('waits for promise to be resolved', () => Promise.resolve());\n\n  it('works with done', done => {\n    done();\n  });\n\n  it('works with async done', done => {\n    setTimeout(done, 1);\n  });\n\n  it('is bound to context object', () =>\n    new Promise(resolve => {\n      if (this.someContextValue !== 'value') {\n        throw new Error(\n          `expected this.someContextValue to be set: ${this.someContextValue}`,\n        );\n      }\n      resolve();\n    }));\n\n  // failing tests\n  it('fails if promise is rejected', () =>\n    Promise.reject(new Error('rejected promise returned')));\n\n  it('works with done.fail', done => {\n    done.fail(new Error('done.fail was called'));\n  });\n\n  it('works with done(error)', done => {\n    done(new Error('done was called with error'));\n  });\n\n  it('fails if failed expectation with done', done => {\n    expect(true).toBe(false);\n    done();\n  });\n\n  it('fails if failed expectation with done - async', done => {\n    setTimeout(() => {\n      expect(true).toBe(false);\n      done();\n    }, 1);\n  });\n\n  it('fails with thrown error with done - sync', done => {\n    throw new Error('sync fail');\n    // eslint-disable-next-line no-unreachable\n    done();\n  });\n\n  it('fails with thrown error with done - async', done => {\n    setTimeout(() => {\n      throw new Error('async fail');\n      // eslint-disable-next-line no-unreachable\n      done();\n    }, 1);\n  });\n\n  // I wish it was possible to catch this but I do not see a way.\n  // Currently both jest and mocha will pass this test.\n  it.skip('fails with thrown error - async', () => {\n    setTimeout(() => {\n      throw new Error('async fail - no done');\n    }, 1);\n  });\n\n  it('fails a sync test', () => {\n    expect('sync').toBe('failed');\n  });\n\n  it(\n    'succeeds if the test finishes in time',\n    () => new Promise(resolve => setTimeout(resolve, 10)),\n    250,\n  );\n\n  // failing tests\n  it(\n    'fails if a custom timeout is exceeded',\n    () => new Promise(resolve => setTimeout(resolve, 100)),\n    10,\n  );\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve('../promise-reject');\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ntest('', () => {\n  writeFiles(DIR, {\n    'package.json': '{}',\n    'promiseReject.test.js': `\n     test('test', () => {\n       return Promise.reject(null)\n     });\n   `,\n  });\n  const {stdout, stderr, exitCode} = runJest(DIR);\n  expect(stdout).toBe('');\n  expect(stderr).toMatch(/(Failed|thrown): null/);\n  expect(exitCode).toBe(1);\n});"}
{"prompt":"promise xit,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ndescribe('promise xit', () => {\n  xit('fails but will be skipped', () => {\n    expect(true).toBe(false);\n  });\n\n  it('will run', () => Promise.resolve());\n});"}
{"prompt":"calls handler on change value,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {KEYS} from '../../constants';\nimport Prompt from '../Prompt';\n\nit('calls handler on change value', () => {\n  const options = {max: 10, offset: -1};\n  const prompt = new Prompt();\n  const onChange = jest.fn();\n\n  prompt.enter(onChange, jest.fn(), jest.fn());\n\n  expect(onChange).toHaveBeenLastCalledWith('', options);\n\n  prompt.put('t');\n  expect(onChange).toHaveBeenLastCalledWith('t', options);\n\n  prompt.put('e');\n  expect(onChange).toHaveBeenLastCalledWith('te', options);\n\n  prompt.put('s');\n  expect(onChange).toHaveBeenLastCalledWith('tes', options);\n\n  prompt.put('t');\n  expect(onChange).toHaveBeenLastCalledWith('test', options);\n\n  expect(onChange).toHaveBeenCalledTimes(5);\n});\n\nit('calls handler on success prompt', () => {\n  const prompt = new Prompt();\n  const onSuccess = jest.fn();\n\n  prompt.enter(jest.fn(), onSuccess, jest.fn());\n\n  prompt.put('t');\n  prompt.put('e');\n  prompt.put('s');\n  prompt.put('t');\n  prompt.put(KEYS.ENTER);\n\n  expect(onSuccess).toHaveBeenCalledWith('test');\n});\n\nit('calls handler on cancel prompt', () => {\n  const prompt = new Prompt();\n  const onCancel = jest.fn();\n\n  prompt.enter(jest.fn(), jest.fn(), onCancel);\n\n  prompt.put('t');\n  prompt.put('e');\n  prompt.put('s');\n  prompt.put('t');\n  prompt.put(KEYS.ESCAPE);\n\n  expect(onCancel).toHaveBeenCalled();\n});\n\nit('clears the line when CONTROL_U is pressed', () => {\n  const prompt = new Prompt();\n  const onChange = jest.fn();\n  const options = {max: 10, offset: -1};\n\n  prompt.enter(onChange, jest.fn(), jest.fn());\n\n  prompt.put('t');\n  prompt.put('e');\n  prompt.put('s');\n  prompt.put('t');\n  expect(onChange).toHaveBeenLastCalledWith('test', options);\n\n  prompt.put(KEYS.CONTROL_U);\n  expect(onChange).toHaveBeenLastCalledWith('', options);\n});"}
{"prompt":"pTimeout,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\njest.useFakeTimers();\n\nimport pTimeout from '../pTimeout';\n\ndescribe('pTimeout', () => {\n  beforeEach(() => {\n    jest.spyOn(globalThis, 'setTimeout');\n    jest.spyOn(globalThis, 'clearTimeout');\n  });\n\n  it('calls `clearTimeout` and resolves when `promise` resolves.', async () => {\n    const onTimeout = jest.fn();\n    const promise = Promise.resolve();\n    await pTimeout(promise, 1000, clearTimeout, setTimeout, onTimeout);\n    expect(setTimeout).toHaveBeenCalled();\n    expect(clearTimeout).toHaveBeenCalled();\n    expect(onTimeout).not.toHaveBeenCalled();\n  });\n\n  it('calls `clearTimeout` and rejects when `promise` rejects.', async () => {\n    const onTimeout = jest.fn();\n    const promise = Promise.reject();\n    try {\n      await pTimeout(promise, 1000, clearTimeout, setTimeout, onTimeout);\n    } catch {}\n    expect(setTimeout).toHaveBeenCalled();\n    expect(clearTimeout).toHaveBeenCalled();\n    expect(onTimeout).not.toHaveBeenCalled();\n  });\n\n  it('calls `onTimeout` on timeout.', async () => {\n    const onTimeout = jest.fn();\n    // A Promise that never resolves or rejects.\n    const promise = new Promise<void>(() => {});\n    const timeoutPromise = pTimeout(\n      promise,\n      1000,\n      clearTimeout,\n      setTimeout,\n      onTimeout,\n    );\n    jest.runAllTimers();\n    await timeoutPromise;\n    expect(setTimeout).toHaveBeenCalled();\n    expect(onTimeout).toHaveBeenCalled();\n  });\n});"}
{"prompt":"queueRunner,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport queueRunner, {type Options, type QueueableFn} from '../queueRunner';\n\ndescribe('queueRunner', () => {\n  it('runs every function in the queue.', async () => {\n    const fnOne = jest.fn(next => next());\n    const fnTwo = jest.fn(next => next());\n    const options: Options = {\n      clearTimeout,\n      fail: jest.fn(),\n      onException: jest.fn(),\n      queueableFns: [{fn: fnOne}, {fn: fnTwo}],\n      setTimeout,\n      userContext: {} as any,\n    };\n\n    await queueRunner(options);\n    expect(fnOne).toHaveBeenCalled();\n    expect(fnTwo).toHaveBeenCalled();\n  });\n\n  it('exposes `fail` to `next`.', async () => {\n    const fail = jest.fn();\n    const fnOne = jest.fn(next => next.fail());\n    const fnTwo = jest.fn(next => next());\n    const options: Options = {\n      clearTimeout,\n      fail,\n      onException: jest.fn(),\n      queueableFns: [{fn: fnOne}, {fn: fnTwo}],\n      setTimeout,\n      userContext: {} as any,\n    };\n\n    await queueRunner(options);\n    expect(fnOne).toHaveBeenCalled();\n    expect(fail).toHaveBeenCalled();\n    // Even if `fail` is called, the queue keeps running.\n    expect(fnTwo).toHaveBeenCalled();\n  });\n\n  it('passes errors to `onException`.', async () => {\n    const error = new Error('The error a test throws.');\n    const fnOne = jest.fn(() => {\n      throw error;\n    });\n    const fnTwo = jest.fn(next => next());\n    const onException = jest.fn();\n    const options: Options = {\n      clearTimeout,\n      fail: jest.fn(),\n      onException,\n      queueableFns: [{fn: fnOne}, {fn: fnTwo}],\n      setTimeout,\n      userContext: {} as any,\n    };\n\n    await queueRunner(options);\n    expect(fnOne).toHaveBeenCalled();\n    expect(onException).toHaveBeenCalledWith(error);\n    // Even if one of them errors, the queue keeps running.\n    expect(fnTwo).toHaveBeenCalled();\n  });\n\n  it('passes an error to `onException` on timeout.', async () => {\n    const fnOne = jest.fn<QueueableFn['fn']>(_next => {});\n    const fnTwo = jest.fn<QueueableFn['fn']>(next => next());\n    const onException = jest.fn<(error: Error) => void>();\n    const options: Options = {\n      clearTimeout,\n      fail: jest.fn(),\n      onException,\n      queueableFns: [\n        {\n          fn: fnOne,\n          // It times out in zero seconds.\n          timeout: () => 0,\n        },\n        {fn: fnTwo},\n      ],\n      setTimeout,\n      userContext: {} as any,\n    };\n\n    await queueRunner(options);\n    expect(fnOne).toHaveBeenCalled();\n    expect(onException).toHaveBeenCalled();\n    // i.e. the `message` of the error passed to `onException`.\n    expect(onException.mock.calls[0][0].message).toEqual(\n      'Timeout - Async callback was not invoked within the 0 ms timeout ' +\n        'specified by jest.setTimeout.',\n    );\n    expect(fnTwo).toHaveBeenCalled();\n  });\n\n  it('calls `fail` with arguments', async () => {\n    const failFn = jest.fn(next => next.fail('miserably', 'failed'));\n    const options: Options = {\n      clearTimeout,\n      fail: jest.fn(),\n      onException: jest.fn(),\n      queueableFns: [{fn: failFn}],\n      setTimeout,\n      userContext: {} as any,\n    };\n\n    await queueRunner(options);\n\n    expect(options.fail).toHaveBeenCalledWith('miserably', 'failed');\n  });\n\n  it('calls `fail` when done(error) is invoked', async () => {\n    const error = new Error('I am an error');\n    const fail = jest.fn();\n    const fnOne = jest.fn(next => next(error));\n    const fnTwo = jest.fn(next => next());\n    const options: Options = {\n      clearTimeout,\n      fail,\n      onException: jest.fn(),\n      queueableFns: [{fn: fnOne}, {fn: fnTwo}],\n      setTimeout,\n      userContext: {} as any,\n    };\n\n    await queueRunner(options);\n    expect(fnOne).toHaveBeenCalled();\n    expect(fail).toHaveBeenCalledWith(error);\n    // Even if `fail` is called, the queue keeps running.\n    expect(fnTwo).toHaveBeenCalled();\n  });\n});"}
{"prompt":"Change in formatting could change this one","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport {extractSummary} from '../Utils';\nimport runJest, {type RunJestResult} from '../runJest';\n\nskipSuiteOnJasmine();\n\nconst dir = path.resolve(__dirname, '../randomize');\n\nconst trimFirstLine = (str: string): string =>\n  str.split('\\n').slice(1).join('\\n');\n\nfunction runJestTwice(\n  dir: string,\n  args: Array<string>,\n): [RunJestResult, RunJestResult] {\n  return [\n    runJest(dir, [...args, '--randomize']),\n    runJest(dir, [...args, '--config', 'different-config.json']),\n  ];\n}\n\ntest('works with passing tests', () => {\n  const [result1, result2] = runJestTwice(dir, [\n    'success.test.js',\n    '--seed',\n    '123',\n  ]);\n\n  const rest1 = trimFirstLine(extractSummary(result1.stderr).rest);\n  const rest2 = trimFirstLine(extractSummary(result2.stderr).rest);\n\n  expect(rest1).toEqual(rest2);\n  expect(rest1).toMatchSnapshot();\n});\n\ntest('works with each', () => {\n  const [result1, result2] = runJestTwice(dir, [\n    'each.test.js',\n    '--seed',\n    '123',\n  ]);\n\n  const rest1 = trimFirstLine(extractSummary(result1.stderr).rest);\n  const rest2 = trimFirstLine(extractSummary(result2.stderr).rest);\n\n  expect(rest1).toEqual(rest2);\n  expect(rest1).toMatchSnapshot();\n});\n\ntest('works with hooks', () => {\n  const [result1, result2] = runJestTwice(dir, [\n    'hooks.test.js',\n    '--seed',\n    '123',\n  ]);\n\n  // Change in formatting could change this one\n  const rest1 = trimFirstLine(extractSummary(result1.stderr).rest);\n  const rest2 = trimFirstLine(extractSummary(result2.stderr).rest);\n\n  expect(rest1).toEqual(rest2);\n  expect(rest1).toMatchSnapshot();\n});\n\ntest('works with snapshots', () => {\n  const [result1, result2] = runJestTwice(dir, [\n    'snapshots.test.js',\n    '--seed',\n    '123',\n  ]);\n\n  const rest1 = trimFirstLine(extractSummary(result1.stderr).rest);\n  const rest2 = trimFirstLine(extractSummary(result2.stderr).rest);\n\n  expect(rest1).toEqual(rest2);\n  expect(rest1).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`works with each 1`] = `\n\"  ✓ test1\n  ✓ test2\n  ✓ test3\n  describe2\n    ✓ test4\n    ✓ test6\n    ✓ test5\n  describe1\n    ✓ test4\n    ✓ test6\n    ✓ test5\n  describe3\n    ✓ test11\n    ✓ test12\n    ✓ test10\n    describe4\n      ✓ test14\n      ✓ test15\n      ✓ test13\"\n`;\n\nexports[`works with hooks 1`] = `\n\"  ✓ test1\n  ✓ test2\n  ✓ test3\n  describe2\n    ✓ test7\n    ✓ test9\n    ✓ test8\n  describe1\n    ✓ test4\n    ✓ test6\n    ✓ test5\n  describe3\n    ✓ test11\n    ✓ test12\n    ✓ test10\n    describe4\n      ✓ test14\n      ✓ test15\n      ✓ test13\"\n`;\n\nexports[`works with passing tests 1`] = `\n\"  ✓ test1\n  ✓ test2\n  ✓ test3\n  describe2\n    ✓ test7\n    ✓ test9\n    ✓ test8\n  describe1\n    ✓ test4\n    ✓ test6\n    ✓ test5\n  describe3\n    ✓ test11\n    ✓ test12\n    ✓ test10\n    describe4\n      ✓ test14\n      ✓ test15\n      ✓ test13\"\n`;\n\nexports[`works with snapshots 1`] = `\n\"  ✓ test1\n  ✓ test2\n  ✓ test3\n  describe2\n    ✓ test4\n    ✓ test6\n    ✓ test5\n  describe1\n    ✓ test4\n    ✓ test6\n    ✓ test5\n  describe3\n    ✓ test11\n    ✓ test12\n    ✓ test10\n    describe4\n      ✓ test14\n      ✓ test15\n      ✓ test13\"\n`;"}
{"prompt":"describe,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {runTest} from '../__mocks__/testUtils';\n\ntest('simple test', () => {\n  const {stdout} = runTest(\n    `\n    describe('describe', () => {\n      beforeEach(() => {});\n      afterEach(() => {});\n      test('one', () => {});\n      test('two', () => {});\n    })\n  `,\n    {randomize: true, seed: 3},\n  );\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('function descriptors', () => {\n  const {stdout} = runTest(\n    `\n    describe(function describer() {}, () => {\n      test(class One {}, () => {});\n    })\n  `,\n    {randomize: true, seed: 3},\n  );\n\n  expect(stdout).toMatchSnapshot();\n});\n\ntest('failures', () => {\n  const {stdout} = runTest(\n    `\n    describe('describe', () => {\n      beforeEach(() => {});\n      afterEach(() => { throw new Error('banana')});\n      test('one', () => { throw new Error('kentucky')});\n      test('two', () => {});\n    })\n  `,\n    {randomize: true, seed: 3},\n  );\n\n  expect(stdout).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`failures 1`] = `\n\"start_describe_definition: describe\nadd_hook: beforeEach\nadd_hook: afterEach\nadd_test: one\nadd_test: two\nfinish_describe_definition: describe\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe\ntest_start: one\ntest_started: one\nhook_start: beforeEach\nhook_success: beforeEach\ntest_fn_start: one\ntest_fn_failure: one\nhook_start: afterEach\nhook_failure: afterEach\ntest_done: one\ntest_start: two\ntest_started: two\nhook_start: beforeEach\nhook_success: beforeEach\ntest_fn_start: two\ntest_fn_success: two\nhook_start: afterEach\nhook_failure: afterEach\ntest_done: two\nrun_describe_finish: describe\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;\n\nexports[`function descriptors 1`] = `\n\"start_describe_definition: describer\nadd_test: One\nfinish_describe_definition: describer\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describer\ntest_start: One\ntest_started: One\ntest_fn_start: One\ntest_fn_success: One\ntest_done: One\nrun_describe_finish: describer\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;\n\nexports[`simple test 1`] = `\n\"start_describe_definition: describe\nadd_hook: beforeEach\nadd_hook: afterEach\nadd_test: one\nadd_test: two\nfinish_describe_definition: describe\nrun_start\nrun_describe_start: ROOT_DESCRIBE_BLOCK\nrun_describe_start: describe\ntest_start: one\ntest_started: one\nhook_start: beforeEach\nhook_success: beforeEach\ntest_fn_start: one\ntest_fn_success: one\nhook_start: afterEach\nhook_success: afterEach\ntest_done: one\ntest_start: two\ntest_started: two\nhook_start: beforeEach\nhook_success: beforeEach\ntest_fn_start: two\ntest_fn_success: two\nhook_start: afterEach\nhook_success: afterEach\ntest_done: two\nrun_describe_finish: describe\nrun_describe_finish: ROOT_DESCRIBE_BLOCK\nrun_finish\n\nunhandledErrors: 0\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {expect, test} from '@jest/globals';\nimport '../toBeWithinRange';\n\ntest('is within range', () => expect(100).toBeWithinRange(90, 110));\n\ntest('is NOT within range', () => expect(101).not.toBeWithinRange(0, 100));\n\ntest('asymmetric ranges', () => {\n  expect({apples: 6, bananas: 3}).toEqual({\n    apples: expect.toBeWithinRange(1, 10),\n    bananas: expect.not.toBeWithinRange(11, 20),\n  });\n});"}
{"prompt":"test object for subset match,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as React from 'react';\nimport * as renderer from 'react-test-renderer';\nimport prettyFormat, {plugins} from '..';\nimport type {OptionsReceived} from '../types';\n\nconst elementSymbol = Symbol.for('react.element');\nconst fragmentSymbol = Symbol.for('react.fragment');\nconst suspenseSymbol = Symbol.for('react.suspense');\nconst testSymbol = Symbol.for('react.test.json');\nconst {ReactElement, ReactTestComponent} = plugins;\n\nconst formatElement = (element: unknown, options?: OptionsReceived) =>\n  prettyFormat(element, {plugins: [ReactElement], ...options});\n\nconst formatTestObject = (object: unknown, options?: OptionsReceived) =>\n  prettyFormat(object, {\n    plugins: [ReactTestComponent, ReactElement],\n    ...options,\n  });\n\nfunction assertPrintedJSX(\n  val: React.ReactElement,\n  expected: string,\n  options?: OptionsReceived,\n) {\n  expect(formatElement(val, options)).toEqual(expected);\n  expect(formatTestObject(renderer.create(val).toJSON(), options)).toEqual(\n    expected,\n  );\n}\n\ntest('supports a single element with no props or children', () => {\n  assertPrintedJSX(React.createElement('Mouse'), '<Mouse />');\n});\n\ntest('supports a single element with non-empty string child', () => {\n  assertPrintedJSX(\n    React.createElement('Mouse', null, 'Hello World'),\n    '<Mouse>\\n  Hello World\\n</Mouse>',\n  );\n});\n\ntest('supports a single element with empty string child', () => {\n  assertPrintedJSX(React.createElement('Mouse', null, ''), '<Mouse />');\n});\n\ntest('supports a single element with non-zero number child', () => {\n  assertPrintedJSX(\n    React.createElement('Mouse', null, 4),\n    '<Mouse>\\n  4\\n</Mouse>',\n  );\n});\n\ntest('supports a single element with zero number child', () => {\n  assertPrintedJSX(\n    React.createElement('Mouse', null, 0),\n    '<Mouse>\\n  0\\n</Mouse>',\n  );\n});\n\ntest('supports a single element with mixed children', () => {\n  assertPrintedJSX(\n    React.createElement('Mouse', null, [[1, null], 2, undefined, [false, [3]]]),\n    '<Mouse>\\n  1\\n  2\\n  3\\n</Mouse>',\n  );\n});\n\ntest('supports props with strings', () => {\n  assertPrintedJSX(\n    React.createElement('Mouse', {style: 'color:red'}),\n    '<Mouse\\n  style=\"color:red\"\\n/>',\n  );\n});\n\ntest('supports props with multiline strings', () => {\n  const val = React.createElement(\n    'svg',\n    null,\n    React.createElement('polyline', {\n      id: 'J',\n      points: ['0.5,0.460', '0.5,0.875', '0.25,0.875'].join('\\n'),\n    }),\n  );\n  const expected = [\n    '<svg>',\n    '  <polyline',\n    '    id=\"J\"',\n    '    points=\"0.5,0.460',\n    '0.5,0.875',\n    '0.25,0.875\"',\n    '  />',\n    '</svg>',\n  ].join('\\n');\n  assertPrintedJSX(val, expected);\n});\n\ntest('supports props with numbers', () => {\n  assertPrintedJSX(\n    React.createElement('Mouse', {size: 5}),\n    '<Mouse\\n  size={5}\\n/>',\n  );\n});\n\ntest('supports a single element with a function prop', () => {\n  assertPrintedJSX(\n    React.createElement<{onclick: unknown}>('Mouse', {\n      onclick: function onclick() {},\n    }),\n    '<Mouse\\n  onclick={[Function onclick]}\\n/>',\n  );\n});\n\ntest('supports a single element with a object prop', () => {\n  assertPrintedJSX(\n    React.createElement('Mouse', {customProp: {one: '1', two: 2}}),\n    '<Mouse\\n  customProp={\\n    Object {\\n      \"one\": \"1\",\\n      \"two\": 2,\\n    }\\n  }\\n/>',\n  );\n});\n\ntest('supports an element with and object prop and children', () => {\n  assertPrintedJSX(\n    React.createElement(\n      'Mouse',\n      {customProp: {one: '1', two: 2}},\n      React.createElement('Mouse'),\n    ),\n    '<Mouse\\n  customProp={\\n    Object {\\n      \"one\": \"1\",\\n      \"two\": 2,\\n    }\\n  }\\n>\\n  <Mouse />\\n</Mouse>',\n  );\n});\n\ntest('supports an element with complex props and mixed children', () => {\n  assertPrintedJSX(\n    React.createElement<{customProp: unknown; onclick: unknown}>(\n      'Mouse',\n      {customProp: {one: '1', two: 2}, onclick: function onclick() {}},\n      'HELLO',\n      React.createElement('Mouse'),\n      'CIAO',\n    ),\n    '<Mouse\\n  customProp={\\n    Object {\\n      \"one\": \"1\",\\n      \"two\": 2,\\n    }\\n  }\\n  onclick={[Function onclick]}\\n>\\n  HELLO\\n  <Mouse />\\n  CIAO\\n</Mouse>',\n  );\n});\n\ntest('escapes children properly', () => {\n  assertPrintedJSX(\n    React.createElement(\n      'Mouse',\n      null,\n      '\"-\"',\n      React.createElement('Mouse'),\n      '\\\\ \\\\\\\\',\n    ),\n    '<Mouse>\\n  \"-\"\\n  <Mouse />\\n  \\\\ \\\\\\\\\\n</Mouse>',\n  );\n});\n\ntest('supports everything all together', () => {\n  assertPrintedJSX(\n    React.createElement<{customProp: unknown; onclick: unknown}>(\n      'Mouse',\n      {customProp: {one: '1', two: 2}, onclick: function onclick() {}},\n      'HELLO',\n      React.createElement<{customProp: unknown; onclick: unknown}>(\n        'Mouse',\n        {customProp: {one: '1', two: 2}, onclick: function onclick() {}},\n        'HELLO',\n        React.createElement('Mouse'),\n        'CIAO',\n      ),\n      'CIAO',\n    ),\n    '<Mouse\\n  customProp={\\n    Object {\\n      \"one\": \"1\",\\n      \"two\": 2,\\n    }\\n  }\\n  onclick={[Function onclick]}\\n>\\n  HELLO\\n  <Mouse\\n    customProp={\\n      Object {\\n        \"one\": \"1\",\\n        \"two\": 2,\\n      }\\n    }\\n    onclick={[Function onclick]}\\n  >\\n    HELLO\\n    <Mouse />\\n    CIAO\\n  </Mouse>\\n  CIAO\\n</Mouse>',\n  );\n});\n\ntest('sorts props in nested components', () => {\n  /* eslint-disable sort-keys */\n  assertPrintedJSX(\n    React.createElement(\n      'Mouse',\n      {\n        zeus: 'kentaromiura watched me fix this',\n        abc: {\n          one: '1',\n          two: 2,\n        },\n      },\n      React.createElement(\n        'Mouse',\n        {\n          xyz: 123,\n          acbd: {\n            one: '1',\n            two: 2,\n          },\n        },\n        'NESTED',\n      ),\n    ),\n    '<Mouse\\n  abc={\\n    Object {\\n      \"one\": \"1\",\\n      \"two\": 2,\\n    }\\n  }\\n  zeus=\"kentaromiura watched me fix this\"\\n>\\n  <Mouse\\n    acbd={\\n      Object {\\n        \"one\": \"1\",\\n        \"two\": 2,\\n      }\\n    }\\n    xyz={123}\\n  >\\n    NESTED\\n  </Mouse>\\n</Mouse>',\n  );\n  /* eslint-enable sort-keys */\n});\n\ntest('supports a single element with React elements as props', () => {\n  assertPrintedJSX(\n    React.createElement('Mouse', {\n      prop: React.createElement('div'),\n    }),\n    '<Mouse\\n  prop={<div />}\\n/>',\n  );\n});\n\ntest('supports a single element with React elements with props', () => {\n  assertPrintedJSX(\n    React.createElement('Mouse', {\n      prop: React.createElement('div', {foo: 'bar'}),\n    }),\n    '<Mouse\\n  prop={\\n    <div\\n      foo=\"bar\"\\n    />\\n  }\\n/>',\n  );\n});\n\ntest('supports a single element with custom React elements with props', () => {\n  function Cat() {\n    return React.createElement('div');\n  }\n  assertPrintedJSX(\n    React.createElement('Mouse', {\n      prop: React.createElement(Cat, {foo: 'bar'}),\n    }),\n    '<Mouse\\n  prop={\\n    <Cat\\n      foo=\"bar\"\\n    />\\n  }\\n/>',\n  );\n});\n\ntest('supports a single element with custom React elements with props (using displayName)', () => {\n  function Cat() {\n    return React.createElement('div');\n  }\n  Cat.displayName = 'CatDisplayName';\n  assertPrintedJSX(\n    React.createElement('Mouse', {\n      prop: React.createElement(Cat, {foo: 'bar'}),\n    }),\n    '<Mouse\\n  prop={\\n    <CatDisplayName\\n      foo=\"bar\"\\n    />\\n  }\\n/>',\n  );\n});\n\ntest('supports a single element with custom React elements with props (using anonymous function)', () => {\n  assertPrintedJSX(\n    React.createElement('Mouse', {\n      prop: React.createElement(() => React.createElement('div'), {foo: 'bar'}),\n    }),\n    '<Mouse\\n  prop={\\n    <Unknown\\n      foo=\"bar\"\\n    />\\n  }\\n/>',\n  );\n});\n\ntest('supports a single element with custom React elements with a child', () => {\n  function Cat(props: Record<string, unknown>) {\n    return React.createElement('div', props);\n  }\n  assertPrintedJSX(\n    React.createElement('Mouse', {\n      prop: React.createElement(Cat, {}, React.createElement('div')),\n    }),\n    '<Mouse\\n  prop={\\n    <Cat>\\n      <div />\\n    </Cat>\\n  }\\n/>',\n  );\n});\n\ntest('supports undefined element type', () => {\n  expect(formatElement({$$typeof: elementSymbol, props: {}})).toBe(\n    '<UNDEFINED />',\n  );\n});\n\ntest('supports a fragment with no children', () => {\n  expect(\n    formatElement({$$typeof: elementSymbol, props: {}, type: fragmentSymbol}),\n  ).toBe('<React.Fragment />');\n});\n\ntest('supports a fragment with string child', () => {\n  expect(\n    formatElement({\n      $$typeof: elementSymbol,\n      props: {children: 'test'},\n      type: fragmentSymbol,\n    }),\n  ).toBe('<React.Fragment>\\n  test\\n</React.Fragment>');\n});\n\ntest('supports a fragment with element child', () => {\n  expect(\n    formatElement({\n      $$typeof: elementSymbol,\n      props: {children: React.createElement('div', null, 'test')},\n      type: fragmentSymbol,\n    }),\n  ).toBe('<React.Fragment>\\n  <div>\\n    test\\n  </div>\\n</React.Fragment>');\n});\n\ntest('supports suspense', () => {\n  expect(\n    formatElement({\n      $$typeof: elementSymbol,\n      props: {\n        children: React.createElement('div', null, 'test'),\n      },\n      type: suspenseSymbol,\n    }),\n  ).toBe('<React.Suspense>\\n  <div>\\n    test\\n  </div>\\n</React.Suspense>');\n});\n\ntest('supports a single element with React elements with a child', () => {\n  assertPrintedJSX(\n    React.createElement('Mouse', {\n      prop: React.createElement('div', null, 'mouse'),\n    }),\n    '<Mouse\\n  prop={\\n    <div>\\n      mouse\\n    </div>\\n  }\\n/>',\n  );\n});\n\ntest('supports a single element with React elements with children', () => {\n  assertPrintedJSX(\n    React.createElement('Mouse', {\n      prop: React.createElement(\n        'div',\n        null,\n        'mouse',\n        React.createElement('span', null, 'rat'),\n      ),\n    }),\n    '<Mouse\\n  prop={\\n    <div>\\n      mouse\\n      <span>\\n        rat\\n      </span>\\n    </div>\\n  }\\n/>',\n  );\n});\n\ntest('supports a single element with React elements with array children', () => {\n  assertPrintedJSX(\n    React.createElement('Mouse', {\n      prop: React.createElement('div', null, 'mouse', [\n        React.createElement('span', {key: 1}, 'rat'),\n        React.createElement('span', {key: 2}, 'cat'),\n      ]),\n    }),\n    '<Mouse\\n  prop={\\n    <div>\\n      mouse\\n      <span>\\n        rat\\n      </span>\\n      <span>\\n        cat\\n      </span>\\n    </div>\\n  }\\n/>',\n  );\n});\n\ntest('supports array of elements', () => {\n  const val = [\n    React.createElement('dt', null, 'jest'),\n    React.createElement('dd', null, 'to talk in a playful manner'),\n    React.createElement(\n      'dd',\n      {style: {color: '#99424F'}},\n      'painless JavaScript testing',\n    ),\n  ];\n  const expected = [\n    'Array [',\n    '  <dt>',\n    '    jest',\n    '  </dt>,',\n    '  <dd>',\n    '    to talk in a playful manner',\n    '  </dd>,',\n    '  <dd',\n    '    style={',\n    '      Object {',\n    '        \"color\": \"#99424F\",',\n    '      }',\n    '    }',\n    '  >',\n    '    painless JavaScript testing',\n    '  </dd>,',\n    ']',\n  ].join('\\n');\n  expect(formatElement(val)).toEqual(expected);\n  expect(\n    formatTestObject(val.map(element => renderer.create(element).toJSON())),\n  ).toEqual(expected);\n});\n\ndescribe('test object for subset match', () => {\n  // Although test object returned by renderer.create(element).toJSON()\n  // has both props and children, make sure plugin allows them to be undefined.\n  test('undefined props', () => {\n    const val = {\n      $$typeof: testSymbol,\n      children: ['undefined props'],\n      type: 'span',\n    };\n    expect(formatTestObject(val)).toBe('<span>\\n  undefined props\\n</span>');\n  });\n  test('undefined children', () => {\n    const val = {\n      $$typeof: testSymbol,\n      props: {\n        className: 'undefined children',\n      },\n      type: 'span',\n    };\n    expect(formatTestObject(val)).toBe(\n      '<span\\n  className=\"undefined children\"\\n/>',\n    );\n  });\n});\n\ndescribe('indent option', () => {\n  const val = React.createElement(\n    'ul',\n    null,\n    React.createElement(\n      'li',\n      {style: {color: 'green', textDecoration: 'none'}},\n      'Test indent option',\n    ),\n  );\n  const expected = [\n    '<ul>',\n    '  <li',\n    '    style={',\n    '      Object {',\n    '        \"color\": \"green\",',\n    '        \"textDecoration\": \"none\",',\n    '      }',\n    '    }',\n    '  >',\n    '    Test indent option',\n    '  </li>',\n    '</ul>',\n  ].join('\\n');\n  test('default implicit: 2 spaces', () => {\n    assertPrintedJSX(val, expected);\n  });\n  test('default explicit: 2 spaces', () => {\n    assertPrintedJSX(val, expected, {indent: 2});\n  });\n\n  // Tests assume that no strings in val contain multiple adjacent spaces!\n  test('non-default: 0 spaces', () => {\n    const indent = 0;\n    assertPrintedJSX(val, expected.replaceAll(/ {2}/g, ' '.repeat(indent)), {\n      indent,\n    });\n  });\n  test('non-default: 4 spaces', () => {\n    const indent = 4;\n    assertPrintedJSX(val, expected.replaceAll(/ {2}/g, ' '.repeat(indent)), {\n      indent,\n    });\n  });\n});\n\ndescribe('maxDepth option', () => {\n  test('elements', () => {\n    const maxDepth = 2;\n    const val = React.createElement(\n      // ++depth === 1\n      'dl',\n      null,\n      React.createElement('dt', {id: 'jest'}, 'jest'), // ++depth === 2\n      React.createElement(\n        // ++depth === 2\n        'dd',\n        {\n          id: 'jest-1',\n        },\n        'to talk in a ',\n        React.createElement('em', null, 'playful'), // ++depth === 3\n        ' manner',\n      ),\n      React.createElement(\n        // ++ depth === 2\n        'dd',\n        {\n          id: 'jest-2',\n          style: {\n            // ++depth === 3\n            color: '#99424F',\n          },\n        },\n        React.createElement('em', null, 'painless'), // ++depth === 3\n        ' JavaScript testing',\n      ),\n    );\n    const expected = [\n      '<dl>',\n      '  <dt',\n      '    id=\"jest\"',\n      '  >',\n      '    jest',\n      '  </dt>',\n      '  <dd',\n      '    id=\"jest-1\"',\n      '  >',\n      '    to talk in a ',\n      '    <em … />',\n      '     manner',\n      '  </dd>',\n      '  <dd',\n      '    id=\"jest-2\"',\n      '    style={[Object]}',\n      '  >',\n      '    <em … />',\n      '     JavaScript testing',\n      '  </dd>',\n      '</dl>',\n    ].join('\\n');\n    assertPrintedJSX(val, expected, {maxDepth});\n  });\n  test('array of elements', () => {\n    const maxDepth = 2;\n    const array = [\n      // ++depth === 1\n      React.createElement(\n        // ++depth === 2\n        'dd',\n        {\n          id: 'jest-1',\n        },\n        'to talk in a ',\n        React.createElement('em', null, 'playful'), // ++depth === 3\n        ' manner',\n      ),\n      React.createElement(\n        // ++ depth === 2\n        'dd',\n        {\n          id: 'jest-2',\n          style: {\n            // ++depth === 3\n            color: '#99424F',\n          },\n        },\n        React.createElement('em', null, 'painless'), // ++depth === 3\n        ' JavaScript testing',\n      ),\n    ];\n    const expected = [\n      'Array [',\n      '  <dd',\n      '    id=\"jest-1\"',\n      '  >',\n      '    to talk in a ',\n      '    <em … />',\n      '     manner',\n      '  </dd>,',\n      '  <dd',\n      '    id=\"jest-2\"',\n      '    style={[Object]}',\n      '  >',\n      '    <em … />',\n      '     JavaScript testing',\n      '  </dd>,',\n      ']',\n    ].join('\\n');\n    expect(formatElement(array, {maxDepth})).toEqual(expected);\n    expect(\n      formatTestObject(\n        array.map(element => renderer.create(element).toJSON()),\n        {maxDepth},\n      ),\n    ).toEqual(expected);\n  });\n});\n\ntest('min option', () => {\n  assertPrintedJSX(\n    React.createElement<{customProp: unknown; onclick: unknown}>(\n      'Mouse',\n      {customProp: {one: '1', two: 2}, onclick: function onclick() {}},\n      'HELLO',\n      React.createElement(\n        'Mouse',\n        {customProp: {one: '1', two: 2}, onclick: function onclick() {}},\n        'HELLO',\n        React.createElement('Mouse'),\n        'CIAO',\n      ),\n      'CIAO',\n    ),\n    '<Mouse customProp={{\"one\": \"1\", \"two\": 2}} onclick={[Function onclick]}>HELLO<Mouse customProp={{\"one\": \"1\", \"two\": 2}} onclick={[Function onclick]}>HELLO<Mouse />CIAO</Mouse>CIAO</Mouse>',\n    {min: true},\n  );\n});\n\ntest('ReactElement plugin highlights syntax', () => {\n  const jsx = React.createElement('Mouse', {\n    prop: React.createElement(\n      'div',\n      null,\n      'mouse',\n      React.createElement('span', null, 'rat'),\n    ),\n  });\n  expect(\n    formatElement(jsx, {\n      highlight: true,\n    }),\n  ).toMatchSnapshot();\n});\n\ntest('ReactTestComponent plugin highlights syntax', () => {\n  const jsx = React.createElement('Mouse', {\n    prop: React.createElement(\n      'div',\n      null,\n      'mouse',\n      React.createElement('span', null, 'rat'),\n    ),\n  });\n  expect(\n    formatTestObject(renderer.create(jsx).toJSON(), {\n      highlight: true,\n    }),\n  ).toMatchSnapshot();\n});\n\ntest('throws if theme option is null', () => {\n  const jsx = React.createElement(\n    'Mouse',\n    {style: 'color:red'},\n    'Hello, Mouse!',\n  );\n  expect(() => {\n    // @ts-expect-error\n    formatElement(jsx, {highlight: true, theme: null});\n  }).toThrow('pretty-format: Option \"theme\" must not be null.');\n});\n\ntest('throws if theme option is not of type \"object\"', () => {\n  expect(() => {\n    const jsx = React.createElement(\n      'Mouse',\n      {style: 'color:red'},\n      'Hello, Mouse!',\n    );\n    // @ts-expect-error\n    formatElement(jsx, {highlight: true, theme: 'beautiful'});\n  }).toThrow(\n    'pretty-format: Option \"theme\" must be of type \"object\" but instead received \"string\".',\n  );\n});\n\ntest('throws if theme option has value that is undefined in ansi-styles', () => {\n  expect(() => {\n    const jsx = React.createElement(\n      'Mouse',\n      {style: 'color:red'},\n      'Hello, Mouse!',\n    );\n    formatElement(jsx, {\n      highlight: true,\n      theme: {\n        content: 'unknown',\n        prop: 'yellow',\n        tag: 'cyan',\n        value: 'green',\n      },\n    });\n  }).toThrow(\n    'pretty-format: Option \"theme\" has a key \"content\" whose value \"unknown\" is undefined in ansi-styles.',\n  );\n});\n\ntest('ReactElement plugin highlights syntax with color from theme option', () => {\n  const jsx = React.createElement(\n    'Mouse',\n    {style: 'color:red'},\n    'Hello, Mouse!',\n  );\n  expect(\n    formatElement(jsx, {\n      highlight: true,\n      theme: {\n        value: 'red',\n      },\n    }),\n  ).toMatchSnapshot();\n});\n\ntest('ReactTestComponent plugin highlights syntax with color from theme option', () => {\n  const jsx = React.createElement(\n    'Mouse',\n    {style: 'color:red'},\n    'Hello, Mouse!',\n  );\n  expect(\n    formatTestObject(renderer.create(jsx).toJSON(), {\n      highlight: true,\n      theme: {\n        value: 'red',\n      },\n    }),\n  ).toMatchSnapshot();\n});\n\ntest('supports forwardRef with a child', () => {\n  function Cat(props: any, _ref: any) {\n    return React.createElement('div', props, props.children);\n  }\n\n  expect(\n    formatElement(React.createElement(React.forwardRef(Cat), null, 'mouse')),\n  ).toBe('<ForwardRef(Cat)>\\n  mouse\\n</ForwardRef(Cat)>');\n});\n\ndescribe('React.memo', () => {\n  describe('without displayName', () => {\n    test('renders the component name', () => {\n      function Dog(props: any) {\n        return React.createElement('div', props, props.children);\n      }\n\n      expect(\n        formatElement(React.createElement(React.memo(Dog), null, 'cat')),\n      ).toBe('<Memo(Dog)>\\n  cat\\n</Memo(Dog)>');\n    });\n  });\n\n  describe('with displayName', () => {\n    test('renders the displayName of component before memoizing', () => {\n      const Foo = () => React.createElement('div');\n      Foo.displayName = 'DisplayNameBeforeMemoizing(Foo)';\n      const MemoFoo = React.memo(Foo);\n\n      expect(formatElement(React.createElement(MemoFoo, null, 'cat'))).toBe(\n        '<Memo(DisplayNameBeforeMemoizing(Foo))>\\n  cat\\n</Memo(DisplayNameBeforeMemoizing(Foo))>',\n      );\n    });\n\n    test('renders the displayName of memoized component', () => {\n      const Foo = () => React.createElement('div');\n      Foo.displayName = 'DisplayNameThatWillBeIgnored(Foo)';\n      const MemoFoo = React.memo(Foo);\n      MemoFoo.displayName = 'DisplayNameForMemoized(Foo)';\n\n      expect(formatElement(React.createElement(MemoFoo, null, 'cat'))).toBe(\n        '<Memo(DisplayNameForMemoized(Foo))>\\n  cat\\n</Memo(DisplayNameForMemoized(Foo))>',\n      );\n    });\n  });\n});\n\ntest('supports context Provider with a child', () => {\n  const {Provider} = React.createContext('test');\n\n  expect(\n    formatElement(\n      React.createElement(Provider, {value: 'test-value'}, 'child'),\n    ),\n  ).toBe(\n    '<Context.Provider\\n  value=\"test-value\"\\n>\\n  child\\n</Context.Provider>',\n  );\n});\n\ntest('supports context Consumer with a child', () => {\n  const {Consumer} = React.createContext('test');\n\n  expect(\n    formatElement(\n      React.createElement(Consumer, {\n        children: () => React.createElement('div', null, 'child'),\n      }),\n    ),\n  ).toBe('<Context.Consumer>\\n  [Function children]\\n</Context.Consumer>');\n});\n\ntest('ReactElement removes undefined props', () => {\n  assertPrintedJSX(\n    React.createElement('Mouse', {\n      abc: undefined,\n      xyz: true,\n    }),\n    '<Mouse\\n  xyz={true}\\n/>',\n  );\n});\n\ntest('ReactTestComponent removes undefined props', () => {\n  const jsx = React.createElement('Mouse', {\n    abc: undefined,\n    xyz: true,\n  });\n  expect(\n    formatElement(jsx, {\n      highlight: true,\n      theme: {\n        value: 'red',\n      },\n    }),\n  ).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`ReactElement plugin highlights syntax 1`] = `\n\"<cyan><Mouse</color>\n  <yellow>prop</color>=<green>{\n    <cyan><div></color>\n      </>mouse</>\n      <cyan><span></color>\n        </>rat</>\n      <cyan></span></color>\n    <cyan></div></color>\n  }</color>\n<cyan>/></color>\"\n`;\n\nexports[`ReactElement plugin highlights syntax with color from theme option 1`] = `\n\"<cyan><Mouse</color>\n  <yellow>style</color>=<red>\"color:red\"</color>\n<cyan>></color>\n  </>Hello, Mouse!</>\n<cyan></Mouse></color>\"\n`;\n\nexports[`ReactTestComponent plugin highlights syntax 1`] = `\n\"<cyan><Mouse</color>\n  <yellow>prop</color>=<green>{\n    <cyan><div></color>\n      </>mouse</>\n      <cyan><span></color>\n        </>rat</>\n      <cyan></span></color>\n    <cyan></div></color>\n  }</color>\n<cyan>/></color>\"\n`;\n\nexports[`ReactTestComponent plugin highlights syntax with color from theme option 1`] = `\n\"<cyan><Mouse</color>\n  <yellow>style</color>=<red>\"color:red\"</color>\n<cyan>></color>\n  </>Hello, Mouse!</>\n<cyan></Mouse></color>\"\n`;\n\nexports[`ReactTestComponent removes undefined props 1`] = `\n\"<cyan><Mouse</color>\n  <yellow>xyz</color>=<red>{true}</color>\n<cyan>/></color>\"\n`;"}
{"prompt":"ReactElement Plugin,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as React from 'react';\nimport {plugins} from '..';\nimport setPrettyPrint from './setPrettyPrint';\n\nconst {ReactElement} = plugins;\n\nsetPrettyPrint([ReactElement]);\n\ndescribe('ReactElement Plugin', () => {\n  let forwardRefComponent: {\n    (_props: unknown, _ref: unknown): React.ReactElement | null;\n    displayName?: string;\n  };\n\n  let forwardRefExample: ReturnType<typeof React.forwardRef>;\n\n  beforeEach(() => {\n    forwardRefComponent = (_props, _ref) => null;\n\n    forwardRefExample = React.forwardRef(forwardRefComponent);\n\n    forwardRefExample.displayName = undefined;\n  });\n\n  test('serializes forwardRef without displayName', () => {\n    forwardRefExample = React.forwardRef((_props, _ref) => null);\n    expect(React.createElement(forwardRefExample)).toPrettyPrintTo(\n      '<ForwardRef />',\n    );\n  });\n\n  test('serializes forwardRef with displayName', () => {\n    forwardRefExample.displayName = 'Display';\n    expect(React.createElement(forwardRefExample)).toPrettyPrintTo(\n      '<Display />',\n    );\n  });\n\n  test('serializes forwardRef component with displayName', () => {\n    forwardRefComponent.displayName = 'Display';\n    expect(React.createElement(forwardRefExample)).toPrettyPrintTo(\n      '<ForwardRef(Display) />',\n    );\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {readConfig} from '..';\n\ntest('readConfig() throws when an object is passed without a file path', async () => {\n  await expect(\n    readConfig(\n      {$0: '', _: []},\n      {} /* packageRootOrConfig */,\n      false /* skipArgvConfigOption */,\n      null /* parentConfigPath */,\n    ),\n  ).rejects.toThrow(\n    'Jest: Cannot use configuration as an object without a file path',\n  );\n});"}
{"prompt":"readConfigFileAndSetRootDir,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport path = require('path');\nimport * as fs from 'graceful-fs';\nimport {requireOrImportModule} from 'jest-util';\nimport readConfigFileAndSetRootDir from '../readConfigFileAndSetRootDir';\n\njest.mock('graceful-fs').mock('jest-util');\n\ndescribe('readConfigFileAndSetRootDir', () => {\n  describe('JavaScript file', () => {\n    test('reads config and sets `rootDir`', async () => {\n      jest.mocked(requireOrImportModule).mockResolvedValueOnce({notify: true});\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'jest.config.js'),\n      );\n\n      expect(config).toEqual({notify: true, rootDir});\n    });\n\n    test('handles exported function', async () => {\n      jest\n        .mocked(requireOrImportModule)\n        .mockResolvedValueOnce(() => ({bail: 1}));\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'jest.config.js'),\n      );\n\n      expect(config).toEqual({bail: 1, rootDir});\n    });\n\n    test('handles exported async function', async () => {\n      jest\n        .mocked(requireOrImportModule)\n        .mockResolvedValueOnce(async () => ({testTimeout: 10_000}));\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'jest.config.js'),\n      );\n\n      expect(config).toEqual({rootDir, testTimeout: 10_000});\n    });\n  });\n\n  describe('JSON file', () => {\n    test('reads config and sets `rootDir`', async () => {\n      jest.mocked(fs.readFileSync).mockReturnValueOnce('{ \"verbose\": true }');\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'jest.config.json'),\n      );\n\n      expect(config).toEqual({rootDir, verbose: true});\n    });\n\n    test('supports comments in JSON', async () => {\n      jest\n        .mocked(fs.readFileSync)\n        .mockReturnValueOnce('{ // test comment\\n \"bail\": true }');\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'jest.config.json'),\n      );\n\n      expect(config).toEqual({bail: true, rootDir});\n    });\n  });\n\n  describe('package.json file', () => {\n    test('reads config from \"jest\" key and sets `rootDir`', async () => {\n      jest\n        .mocked(fs.readFileSync)\n        .mockReturnValueOnce('{ \"jest\": { \"coverage\": true } }');\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'package.json'),\n      );\n\n      expect(config).toEqual({coverage: true, rootDir});\n    });\n\n    test('sets rootDir if \"jest\" is absent', async () => {\n      jest.mocked(fs.readFileSync).mockReturnValueOnce('{ \"name\": \"test\" }');\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'package.json'),\n      );\n\n      expect(config).toEqual({rootDir});\n    });\n  });\n\n  describe('sets `rootDir`', () => {\n    test('handles frozen config object', async () => {\n      jest\n        .mocked(requireOrImportModule)\n        .mockResolvedValueOnce(Object.freeze({preset: 'some-preset'}));\n\n      const rootDir = path.resolve('some', 'path', 'to');\n      const config = await readConfigFileAndSetRootDir(\n        path.join(rootDir, 'jest.config.js'),\n      );\n\n      expect(config).toEqual({preset: 'some-preset', rootDir});\n    });\n\n    test('keeps the path if it is absolute', async () => {\n      const rootDir = path.resolve('some', 'path', 'to');\n      jest.mocked(requireOrImportModule).mockResolvedValueOnce({\n        rootDir,\n        testEnvironment: 'node',\n      });\n\n      const config = await readConfigFileAndSetRootDir(\n        path.join(path.resolve('other', 'path', 'to'), 'jest.config.js'),\n      );\n\n      expect(config).toEqual({rootDir, testEnvironment: 'node'});\n    });\n\n    test('resolves the path relative to dirname of the config file', async () => {\n      jest.mocked(requireOrImportModule).mockResolvedValueOnce({\n        restoreMocks: true,\n        rootDir: path.join('path', 'to'),\n      });\n\n      const config = await readConfigFileAndSetRootDir(\n        path.join(path.resolve('some'), 'jest.config.js'),\n      );\n\n      expect(config).toEqual({\n        restoreMocks: true,\n        rootDir: path.resolve('some', 'path', 'to'),\n      });\n    });\n\n    test('resolves relative path when the read config object if frozen', async () => {\n      jest.mocked(requireOrImportModule).mockResolvedValueOnce(\n        Object.freeze({\n          resetModules: true,\n          rootDir: path.join('path', 'to'),\n        }),\n      );\n\n      const config = await readConfigFileAndSetRootDir(\n        path.join(path.resolve('some'), 'jest.config.js'),\n      );\n\n      expect(config).toEqual({\n        resetModules: true,\n        rootDir: path.resolve('some', 'path', 'to'),\n      });\n    });\n  });\n});"}
{"prompt":"@ts-expect-error","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {readConfigs} from '..';\n\njest.mock('graceful-fs', () => ({\n  ...jest.requireActual<typeof import('fs')>('fs'),\n  existsSync: jest.fn(() => true),\n  lstatSync: jest.fn(() => ({\n    isDirectory: () => false,\n  })),\n}));\n\ntest('readConfigs() throws when called without project paths', async () => {\n  await expect(\n    // @ts-expect-error\n    readConfigs(null /* argv */, [] /* projectPaths */),\n  ).rejects.toThrow('jest: No configuration found for any project.');\n});"}
{"prompt":"readInitialOptions,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport type {Config} from '@jest/types';\nimport {readInitialOptions} from '..';\n\ndescribe(readInitialOptions, () => {\n  test('should be able to use serialized jest config', async () => {\n    const inputConfig = {jestConfig: 'serialized'};\n    const {config, configPath} = await readInitialOptions(\n      JSON.stringify(inputConfig),\n    );\n    expect(config).toEqual({...inputConfig, rootDir: process.cwd()});\n    expect(configPath).toBeNull();\n  });\n\n  test('should allow deserialized options', async () => {\n    const inputConfig = {jestConfig: 'deserialized'};\n    const {config, configPath} = await readInitialOptions(undefined, {\n      packageRootOrConfig: inputConfig as Config.InitialOptions,\n      parentConfigDirname: process.cwd(),\n    });\n    expect(config).toEqual({...inputConfig, rootDir: process.cwd()});\n    expect(configPath).toBeNull();\n  });\n  // Note: actual file reading is tested in e2e test\n});"}
{"prompt":"Close server and return immediately on callback. During the close","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {createServer} from 'http';\n\ntest('a recently closed server should not be detected by --detectOpenHandles', done => {\n  const server = createServer((_, response) => response.end('ok'));\n  server.listen(0, () => {\n    expect(true).toBe(true);\n\n    // Close server and return immediately on callback. During the \"close\"\n    // callback, async hooks usually have not yet been called, but we want to\n    // make sure Jest can figure out that this server is closed.\n    server.close(done);\n  });\n});"}
{"prompt":"runs this,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nit('runs this', () => {\n  expect(true).toBe(true);\n});"}
{"prompt":"Regex Char In Path,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {json as runWithJson} from '../runJest';\n\ndescribe('Regex Char In Path', () => {\n  it('parses paths containing regex chars correctly', () => {\n    const {json} = runWithJson('regex-(char-in-path', []);\n\n    expect(json.numTotalTests).toBe(1);\n    expect(json.numPassedTests).toBe(1);\n  });\n});"}
{"prompt":"For some reason thinks s a strict violation.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\n// For some reason thinks it's a strict violation.\nif (exports !== this) {\n  throw new Error('Invalid module context');\n}\n\nlet moduleStateValue = 'default';\n\nfunction setModuleStateValue(value) {\n  moduleStateValue = value;\n}\n\nfunction getModuleStateValue() {\n  return moduleStateValue;\n}\n\nconst lazyRequire = () => {\n  // Make sure ModuleWithSideEffects is part of the module map for\n  // RegularModule.\n  require('ModuleWithSideEffects');\n};\n\nexports.filename = module.filename;\nexports.getModuleStateValue = getModuleStateValue;\nexports.isRealModule = true;\nexports.jest = jest;\nexports.lazyRequire = lazyRequire;\nexports.object = {};\nexports.parent = module.parent;\nexports.path = module.path;\nexports.paths = module.paths;\nexports.setModuleStateValue = setModuleStateValue;\nexports.module = module;\nexports.loaded = module.loaded;\nexports.isLoaded = () => module.loaded;"}
{"prompt":"Test generated from existing file","test":"some file"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nlet moduleStateValue = 'default';\n\nfunction setModuleStateValue(value) {\n  moduleStateValue = value;\n}\n\nfunction getModuleStateValue() {\n  return moduleStateValue;\n}\n\nexports.getModuleStateValue = getModuleStateValue;\nexports.isRealModule = true;\nexports.setModuleStateValue = setModuleStateValue;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nconst {promisify} = require('util');\n\nbeforeAll(async () => {\n  const promise = Promise.reject(new Error('REJECTED'));\n\n  await promisify(setTimeout)(0);\n\n  await expect(promise).rejects.toThrow(/REJECTED/);\n});\n\nbeforeEach(async () => {\n  const promise = Promise.reject(new Error('REJECTED'));\n\n  await promisify(setTimeout)(0);\n\n  await expect(promise).rejects.toThrow(/REJECTED/);\n});\n\nafterEach(async () => {\n  const promise = Promise.reject(new Error('REJECTED'));\n\n  await promisify(setTimeout)(0);\n\n  await expect(promise).rejects.toThrow(/REJECTED/);\n});\n\nafterAll(async () => {\n  const promise = Promise.reject(new Error('REJECTED'));\n\n  await promisify(setTimeout)(0);\n\n  await expect(promise).rejects.toThrow(/REJECTED/);\n});\n\ntest('async function succeeds because the promise is eventually awaited by assertion', async () => {\n  const promise = Promise.reject(new Error('REJECTED'));\n\n  await promisify(setTimeout)(0);\n\n  await expect(promise).rejects.toThrow(/REJECTED/);\n});\n\ntest('async function succeeds because the promise is eventually directly awaited', async () => {\n  const promise = Promise.reject(new Error('REJECTED'));\n\n  await promisify(setTimeout)(0);\n\n  try {\n    await promise;\n  } catch (error) {\n    expect(error).toEqual(new Error('REJECTED'));\n  }\n});\n\ntest('sync function succeeds because the promise is eventually handled by `.catch` handler', done => {\n  const promise = Promise.reject(new Error('REJECTED'));\n\n  setTimeout(() => {\n    promise\n      .catch(error => {\n        expect(error).toEqual(new Error('REJECTED'));\n      })\n      .finally(done);\n  }, 0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\ntest('sample', () => {\n  expect({}).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`sample 1`] = `Object {}`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nexports.isRelativeImageStub = true;"}
{"prompt":"Replaceable,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport Replaceable from '../Replaceable';\n\ndescribe('Replaceable', () => {\n  describe('constructor', () => {\n    test('init with object', () => {\n      const replaceable = new Replaceable({a: 1, b: 2});\n      expect(replaceable.object).toEqual({a: 1, b: 2});\n      expect(replaceable.type).toBe('object');\n    });\n\n    test('init with array', () => {\n      const replaceable = new Replaceable([1, 2, 3]);\n      expect(replaceable.object).toEqual([1, 2, 3]);\n      expect(replaceable.type).toBe('array');\n    });\n\n    test('init with Map', () => {\n      const replaceable = new Replaceable(\n        new Map([\n          ['a', 1],\n          ['b', 2],\n        ]),\n      );\n      expect(replaceable.object).toEqual(\n        new Map([\n          ['a', 1],\n          ['b', 2],\n        ]),\n      );\n      expect(replaceable.type).toBe('map');\n    });\n\n    test('init with other type should throw error', () => {\n      expect(() => {\n        // eslint-disable-next-line no-new\n        new Replaceable(new Date());\n      }).toThrow('Type date is not support in Replaceable!');\n    });\n  });\n\n  describe('get', () => {\n    test('get object item', () => {\n      const replaceable = new Replaceable({a: 1, b: 2});\n      expect(replaceable.get('b')).toBe(2);\n    });\n\n    test('get array item', () => {\n      const replaceable = new Replaceable([1, 2, 3]);\n      expect(replaceable.get(1)).toBe(2);\n    });\n\n    test('get Map item', () => {\n      const replaceable = new Replaceable(\n        new Map([\n          ['a', 1],\n          ['b', 2],\n        ]),\n      );\n      expect(replaceable.get('b')).toBe(2);\n    });\n  });\n\n  describe('set', () => {\n    test('set object item', () => {\n      const replaceable = new Replaceable({a: 1, b: 2});\n      replaceable.set('b', 3);\n      expect(replaceable.object).toEqual({a: 1, b: 3});\n    });\n\n    test('set array item', () => {\n      const replaceable = new Replaceable([1, 2, 3]);\n      replaceable.set(1, 3);\n      expect(replaceable.object).toEqual([1, 3, 3]);\n    });\n\n    test('set Map item', () => {\n      const replaceable = new Replaceable(\n        new Map([\n          ['a', 1],\n          ['b', 2],\n        ]),\n      );\n      replaceable.set('b', 3);\n      expect(replaceable.object).toEqual(\n        new Map([\n          ['a', 1],\n          ['b', 3],\n        ]),\n      );\n    });\n  });\n\n  describe('forEach', () => {\n    test('object forEach', () => {\n      const symbolKey = Symbol('jest');\n      const object = {a: 1, b: 2, [symbolKey]: 3};\n      const replaceable = new Replaceable(object);\n      const cb = jest.fn();\n      // eslint-disable-next-line unicorn/no-array-for-each\n      replaceable.forEach(cb);\n      expect(cb).toHaveBeenCalledTimes(3);\n      expect(cb.mock.calls[0]).toEqual([1, 'a', object]);\n      expect(cb.mock.calls[1]).toEqual([2, 'b', object]);\n      expect(cb.mock.calls[2]).toEqual([3, symbolKey, object]);\n    });\n\n    test('array forEach', () => {\n      const replaceable = new Replaceable([1, 2, 3]);\n      const cb = jest.fn();\n      // eslint-disable-next-line unicorn/no-array-for-each\n      replaceable.forEach(cb);\n      expect(cb).toHaveBeenCalledTimes(3);\n      expect(cb.mock.calls[0]).toEqual([1, 0, [1, 2, 3]]);\n      expect(cb.mock.calls[1]).toEqual([2, 1, [1, 2, 3]]);\n      expect(cb.mock.calls[2]).toEqual([3, 2, [1, 2, 3]]);\n    });\n\n    test('map forEach', () => {\n      const map = new Map([\n        ['a', 1],\n        ['b', 2],\n      ]);\n      const replaceable = new Replaceable(map);\n      const cb = jest.fn();\n      // eslint-disable-next-line unicorn/no-array-for-each\n      replaceable.forEach(cb);\n      expect(cb).toHaveBeenCalledTimes(2);\n      expect(cb.mock.calls[0]).toEqual([1, 'a', map]);\n      expect(cb.mock.calls[1]).toEqual([2, 'b', map]);\n    });\n\n    test('forEach should ignore nonenumerable property', () => {\n      const symbolKey = Symbol('jest');\n      const symbolKey2 = Symbol('awesome');\n      const object = {a: 1, [symbolKey]: 3};\n      Object.defineProperty(object, 'b', {\n        configurable: true,\n        enumerable: false,\n        value: 2,\n        writable: true,\n      });\n      Object.defineProperty(object, symbolKey2, {\n        configurable: true,\n        enumerable: false,\n        value: 4,\n        writable: true,\n      });\n      const replaceable = new Replaceable(object);\n      const cb = jest.fn();\n      // eslint-disable-next-line unicorn/no-array-for-each\n      replaceable.forEach(cb);\n      expect(cb).toHaveBeenCalledTimes(2);\n      expect(cb.mock.calls[0]).toEqual([1, 'a', object]);\n      expect(cb.mock.calls[1]).toEqual([3, symbolKey, object]);\n    });\n  });\n\n  describe('isReplaceable', () => {\n    test('should return true if two object types equal and support', () => {\n      expect(Replaceable.isReplaceable({a: 1}, {b: 2})).toBe(true);\n      expect(Replaceable.isReplaceable([], [1, 2, 3])).toBe(true);\n      expect(\n        Replaceable.isReplaceable(\n          new Map(),\n          new Map([\n            ['a', 1],\n            ['b', 2],\n          ]),\n        ),\n      ).toBe(true);\n    });\n\n    test('should return false if two object types not equal', () => {\n      expect(Replaceable.isReplaceable({a: 1}, [1, 2, 3])).toBe(false);\n    });\n\n    test('should return false if object types not support', () => {\n      expect(Replaceable.isReplaceable('foo', 'bar')).toBe(false);\n    });\n  });\n});"}
{"prompt":"Jasmine2Reporter,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {SpecResult} from '../jasmine/Spec';\nimport type {SuiteResult} from '../jasmine/Suite';\nimport JasmineReporter from '../reporter';\n\ndescribe('Jasmine2Reporter', () => {\n  let reporter: JasmineReporter;\n\n  beforeEach(() => {\n    // @ts-expect-error\n    reporter = new JasmineReporter({});\n  });\n\n  it('reports nested suites', () => {\n    const makeSpec = (name: string) =>\n      ({\n        description: 'description',\n        failedExpectations: [],\n        fullName: name,\n      }) as any as SpecResult;\n    reporter.suiteStarted({description: 'parent'} as SuiteResult);\n    reporter.suiteStarted({description: 'child'} as SuiteResult);\n    reporter.specDone(makeSpec('spec 1'));\n    // @ts-expect-error\n    reporter.suiteDone();\n    reporter.suiteStarted({description: 'child 2'} as SuiteResult);\n    reporter.specDone(makeSpec('spec 2'));\n    // @ts-expect-error\n    reporter.jasmineDone();\n\n    return reporter.getResults().then(runResults => {\n      const firstResult = runResults.testResults[0];\n      expect(firstResult.ancestorTitles[0]).toBe('parent');\n      expect(firstResult.ancestorTitles[1]).toBe('child');\n      const secondResult = runResults.testResults[1];\n      expect(secondResult.ancestorTitles[1]).toBe('child 2');\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* global requestAnimationFrame */\n\n'use strict';\n\ntest('requestAnimationFrame test', () => {\n  jest.useFakeTimers({\n    legacyFakeTimers: true,\n  });\n\n  let frameTimestamp = -1;\n  requestAnimationFrame(timestamp => {\n    frameTimestamp = timestamp;\n  });\n\n  jest.advanceTimersByTime(15);\n\n  expect(frameTimestamp).toBe(-1);\n\n  jest.advanceTimersByTime(1);\n\n  expect(frameTimestamp).toBeGreaterThan(15);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports = moduleName => require(moduleName);"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJasmine();\n\ntest('prints useful error for requires after test is done w/o `waitNextEventLoopTurnForUnhandledRejectionEvents`', () => {\n  const {stderr} = runJest('require-after-teardown');\n\n  const interestingLines = stderr.split('\\n').slice(9, 18).join('\\n');\n\n  expect(interestingLines).toMatchSnapshot();\n  expect(stderr.split('\\n')[19]).toMatch(\n    '(__tests__/lateRequire.test.js:11:20)',\n  );\n});\n\ntest('prints useful error for requires after test is done w/ `waitNextEventLoopTurnForUnhandledRejectionEvents`', () => {\n  const {stderr} = runJest('require-after-teardown', [\n    '--waitNextEventLoopTurnForUnhandledRejectionEvents',\n  ]);\n\n  const interestingLines = stderr.split('\\n').slice(5, 14).join('\\n');\n\n  expect(interestingLines).toMatchSnapshot();\n  expect(stderr.split('\\n')[16]).toMatch(\n    '(__tests__/lateRequire.test.js:11:20)',\n  );\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`prints useful error for requires after test is done w/ \\`waitNextEventLoopTurnForUnhandledRejectionEvents\\` 1`] = `\n\"    ReferenceError: You are trying to \\`import\\` a file outside of the scope of the test code.\n\n       9 | test('require after done', () => {\n      10 |   setTimeout(() => {\n    > 11 |     const double = require('../');\n         |                    ^\n      12 |\n      13 |     expect(double(5)).toBe(10);\n      14 |   }, 0);\"\n`;\n\nexports[`prints useful error for requires after test is done w/o \\`waitNextEventLoopTurnForUnhandledRejectionEvents\\` 1`] = `\n\"ReferenceError: You are trying to \\`import\\` a file after the Jest environment has been torn down. From __tests__/lateRequire.test.js.\n\n       9 | test('require after done', () => {\n      10 |   setTimeout(() => {\n    > 11 |     const double = require('../');\n         |                    ^\n      12 |\n      13 |     expect(double(5)).toBe(10);\n      14 |   }, 0);\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {skipSuiteOnJestCircus} from '@jest/test-utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJestCircus();\n\ntest.each`\n  jestArgs\n  ${[]}\n  ${['--waitNextEventLoopTurnForUnhandledRejectionEvents']}\n`('prints useful error for requires after test is done', ({jestArgs}) => {\n  const {stderr} = runJest('require-after-teardown', jestArgs);\n\n  const interestingLines = stderr.split('\\n').slice(9, 18).join('\\n');\n\n  expect(interestingLines).toMatchSnapshot();\n  expect(stderr.split('\\n')[19]).toMatch(\n    '(__tests__/lateRequire.test.js:11:20)',\n  );\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`prints useful error for requires after test is done 1`] = `\n\"ReferenceError: You are trying to \\`import\\` a file after the Jest environment has been torn down. From __tests__/lateRequire.test.js.\n\n       9 | test('require after done', () => {\n      10 |   setTimeout(() => {\n    > 11 |     const double = require('../');\n         |                    ^\n      12 |\n      13 |     expect(double(5)).toBe(10);\n      14 |   }, 0);\"\n`;\n\nexports[`prints useful error for requires after test is done 2`] = `\n\"ReferenceError: You are trying to \\`import\\` a file after the Jest environment has been torn down. From __tests__/lateRequire.test.js.\n\n       9 | test('require after done', () => {\n      10 |   setTimeout(() => {\n    > 11 |     const double = require('../');\n         |                    ^\n      12 |\n      13 |     expect(double(5)).toBe(10);\n      14 |   }, 0);\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('provides `require.main` set to test suite module', () => {\n  const {stderr, stdout} = runJest('require-main');\n  expect(stdout).not.toMatch('No tests found');\n  expect(stderr).toMatch(/PASS __tests__(\\/|\\\\+)loader\\.test\\.js/);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport runJest from '../runJest';\n\ntest('`require.main` not undefined after createRequire', () => {\n  const {stdout} = runJest('require-main-after-create-require');\n\n  expect(stdout).toBe(\n    path.join(\n      __dirname,\n      '../require-main-after-create-require/__tests__/parent.test.js',\n    ),\n  );\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('`require.main` on using `jest.isolateModules` should not be undefined', () => {\n  const {exitCode} = runJest('require-main-isolate-modules');\n\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest(\"`require.main` on using `--resetModules='true'` should not be undefined\", () => {\n  const {exitCode} = runJest('require-main-reset-modules', [\n    \"--resetModules='true'\",\n    'resetModulesFlag',\n  ]);\n  expect(exitCode).toBe(0);\n});\n\ntest('`require.main` on using `jest.resetModules()` should not be undefined', () => {\n  const {exitCode} = runJest('require-main-reset-modules', [\n    'resetModulesCall',\n  ]);\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {extractSummary, runYarnInstall} from '../Utils';\nimport runJest from '../runJest';\n\nconst dir = path.resolve(__dirname, '../require-missing-ext');\n\nbeforeEach(() => {\n  runYarnInstall(dir);\n});\n\ntest('shows a proper error from deep requires', () => {\n  const {stderr} = runJest(dir);\n  const {rest} = extractSummary(stderr);\n\n  expect(rest).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`shows a proper error from deep requires 1`] = `\n\"FAIL __tests__/test.js\n  ● Test suite failed to run\n\n    Cannot find module '../package' from 'node_modules/discord.js/src/index.js'\n\n    Require stack:\n      node_modules/discord.js/src/index.js\n      __tests__/test.js\n\n\n    However, Jest was able to find:\n    \t'../package.json'\n\n    You might want to include a file extension in your import, or update your 'moduleFileExtensions', which is currently ['js'].\n\n    See https://jestjs.io/docs/configuration#modulefileextensions-arraystring\n\n       8 | 'use strict';\n       9 |\n    > 10 | require('discord.js');\n         | ^\n      11 |\n      12 | test('dummy', () => {\n      13 |   expect(1).toBe(1);\n\n      at Resolver._throwModNotFoundError (../../packages/jest-resolve/build/index.js:935:11)\n      at Object.<anonymous> (node_modules/discord.js/src/index.js:21:12)\n      at Object.require (__tests__/test.js:10:1)\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nmodule.exports.parent = require('RegularModule').parent;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('v8 module', () => {\n  expect(() => require('v8')).not.toThrow();\n\n  expect(require('v8').getHeapStatistics().total_heap_size).toBeDefined();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ntest('works before resetAllMocks is called', () => {\n  jest.useFakeTimers();\n  const f = jest.fn();\n  setTimeout(f, 0);\n  jest.runAllTimers();\n  expect(f).toHaveBeenCalledTimes(1);\n});\n\ntest('works after resetAllMocks is called', () => {\n  jest.resetAllMocks();\n  jest.useFakeTimers();\n  const f = jest.fn();\n  setTimeout(f, 0);\n  jest.runAllTimers();\n  expect(f).toHaveBeenCalledTimes(1);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ntest('works when resetMocks is set in Jest config', () => {\n  const f = jest.fn();\n  setTimeout(f, 0);\n  jest.runAllTimers();\n  expect(f).toHaveBeenCalledTimes(1);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nglobalThis.testObject = new Proxy(\n  {},\n  {\n    get: function getter(target, key) {\n      return key;\n    },\n  },\n);\ntest('jest.resetModules should not error when _isMockFunction is defined but not boolean', () => {\n  jest.resetModules();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('jest.resetModules should not error when _isMockFunction is defined but not boolean', () => {\n  const result = runJest('reset-modules');\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nbeforeEach(() => {\n  jest.resetModules();\n});\n\nafterEach(() => {\n  jest.resetModules();\n});\n\ntest('require.main is set on requiring directly', () => {\n  const {getMain} = require('../direct.js');\n  expect(getMain()).toBeTruthy();\n});\n\ntest('require from main works on requiring directly', () => {\n  const {requireFromMain} = require('../direct.js');\n  expect(requireFromMain('../package.json')).toBeTruthy();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nbeforeEach(() => {\n  jest.resetModules();\n});\n\nafterEach(() => {\n  jest.resetModules();\n});\n\ntest('require.main is set on requiring indirectly', () => {\n  const {getMain} = require('../indirect.js');\n  expect(getMain()).toBeTruthy();\n});\n\ntest('require from main works on requiring indirectly', () => {\n  const {requireFromMain} = require('../indirect.js');\n  expect(requireFromMain('../package.json')).toBeTruthy();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ntest('require.main is set', () => {\n  const {getMain} = require('../direct.js');\n  expect(getMain()).toBeTruthy();\n});\n\ntest('require from main works', () => {\n  const {requireFromMain} = require('../direct.js');\n  expect(requireFromMain('../package.json')).toBeTruthy();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\ntest('require.main is set', () => {\n  const {getMain} = require('../indirect.js');\n  expect(getMain()).toBeTruthy();\n});\n\ntest('require from main works', () => {\n  const {requireFromMain} = require('../indirect.js');\n  expect(requireFromMain('../package.json')).toBeTruthy();\n});"}
{"prompt":"should resolve entry as index.js when package main is .,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\njest.mock('mock-module');\njest.mock('mock-module-alt');\njest.mock('mock-jsx-module');\njest.mock('mock-module-without-pkg');\n\nit('should resolve entry as index.js when package main is \".\"', () => {\n  const mockModule = require('mock-module');\n  expect(mockModule).toBe('test');\n});\n\nit('should resolve entry as index.js when package main is \"./\"', () => {\n  const mockModule = require('mock-module-alt');\n  expect(mockModule).toBe('test');\n});\n\nit('should resolve entry as index with other configured module file extension when package main is \".\"', () => {\n  const mockJsxModule = require('mock-jsx-module');\n  expect(mockJsxModule).toBe('test jsx');\n});\n\nit('should resolve entry as index without package.json', () => {\n  const mockModuleWithoutPkg = require('mock-module-without-pkg');\n  expect(mockModuleWithoutPkg).toBe('test mock-module-without-pkg');\n});"}
{"prompt":"We unmock Test5 they should already be, but to be sure.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst dedent = require('dedent');\n\nlet platform;\n\nfunction testRequire(filename) {\n  return () => (platform = require(filename));\n}\n\ntest('should explicitly resolve filename.<platform>.js', () => {\n  expect(testRequire('../test1.android.js')).not.toThrow();\n  expect(platform.extension).toBe('android.js');\n});\n\ntest('should explicitly resolve filename.native.js', () => {\n  expect(testRequire('../test1.native.js')).not.toThrow();\n  expect(platform.extension).toBe('native.js');\n});\n\ntest('should explicitly resolve filename.js', () => {\n  expect(testRequire('../test1.js')).not.toThrow();\n  expect(platform.extension).toBe('js');\n});\n\ntest('should explicitly resolve filename.json', () => {\n  expect(testRequire('../test1.json')).not.toThrow();\n  expect(platform.extension).toBe('json');\n});\n\ntest('should resolve filename.<platform>.js', () => {\n  expect(testRequire('../test1')).not.toThrow();\n  expect(platform.extension).toBe('android.js');\n});\n\ntest('should resolve filename.<platform>.js from haste package', () => {\n  expect(testRequire('custom-resolve/test1')).not.toThrow();\n  expect(platform.extension).toBe('android.js');\n});\n\ntest('should resolve filename.native.js', () => {\n  expect(testRequire('../test2')).not.toThrow();\n  expect(platform.extension).toBe('native.js');\n});\n\ntest('should resolve filename.native.js with moduleNameMapper', () => {\n  expect(testRequire('test2mapper')).not.toThrow();\n  expect(platform.extension).toBe('native.js');\n});\n\ntest('should resolve filename.js', () => {\n  expect(testRequire('../test3')).not.toThrow();\n  expect(platform.extension).toBe('js');\n});\n\ntest('should resolve filename.json', () => {\n  expect(testRequire('../test4')).not.toThrow();\n  expect(platform.extension).toBe('json');\n});\n\ntest('should preserve identity for symlinks', () => {\n  expect(require('../../../packages/jest-resolve')).toBe(\n    require('jest-resolve'),\n  );\n});\n\ntest('should require resolve haste files correctly', () => {\n  // We unmock Test5 (they should already be, but to be sure).\n  jest.unmock('Test5');\n\n  // Test5 is a standard module, that has a mock (but it is unmocked here).\n  expect(require.resolve('Test5')).toBe(require.resolve('../Test5'));\n\n  expect(require('Test5').key).toBe('real');\n\n  // Test6 only exits as a mock; so even when unmocked, we resolve to the mock.\n  expect(require.resolve('Test6')).toBe(require.resolve('../__mocks__/Test6'));\n\n  expect(require('Test6').key).toBe('mock');\n});\n\ntest('should require resolve haste mocks correctly', () => {\n  // Now we mock Test5 and Test6.\n  jest.mock('Test5');\n  jest.mock('Test6');\n\n  // The resolution still points to the real one, but requires the mock.\n  expect(require.resolve('Test5')).toBe(require.resolve('../Test5'));\n\n  expect(require('Test5').key).toBe('mock');\n\n  // And Test6 points to the mock, because Test6 does not exist as a module.\n  expect(require.resolve('Test6')).toBe(require.resolve('../__mocks__/Test6'));\n\n  expect(require('Test6').key).toBe('mock');\n});\n\ntest('should throw module not found error if the module has dependencies that cannot be found', () => {\n  expect(() => require('Test7')).toThrow(\n    expect.objectContaining({\n      code: 'MODULE_NOT_FOUND',\n      message: dedent`\n        Cannot find module 'nope' from 'requiresUnexistingModule.js'\n\n        Require stack:\n          requiresUnexistingModule.js\n          Test7.js\n          __tests__/resolve.test.js\\n\n      `,\n    }),\n  );\n});\n\ntest('should throw module not found error if the module cannot be found', () => {\n  expect(() => require('Test8')).toThrow(\n    expect.objectContaining({\n      code: 'MODULE_NOT_FOUND',\n      message: \"Cannot find module 'Test8' from '__tests__/resolve.test.js'\",\n    }),\n  );\n});"}
{"prompt":"Do not fully mock resolve because  is used by Jest. Doing it will crash","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as path from 'path';\nimport {fileURLToPath, pathToFileURL} from 'url';\nimport * as fs from 'graceful-fs';\nimport {sync as resolveSync} from 'resolve';\nimport {type IModuleMap, ModuleMap} from 'jest-haste-map';\nimport userResolver from '../__mocks__/userResolver';\nimport userResolverAsync from '../__mocks__/userResolverAsync';\nimport defaultResolver, {type PackageFilter} from '../defaultResolver';\nimport nodeModulesPaths from '../nodeModulesPaths';\nimport Resolver from '../resolver';\nimport type {ResolverConfig} from '../types';\n\njest.mock('../__mocks__/userResolver').mock('../__mocks__/userResolverAsync');\n\n// Do not fully mock `resolve` because it is used by Jest. Doing it will crash\n// in very strange ways. Instead, just spy on it and its `sync` method.\njest.mock('resolve', () => {\n  const originalModule =\n    jest.requireActual<typeof import('resolve')>('resolve');\n\n  const m = jest.fn<typeof import('resolve')>((...args) =>\n    originalModule(...args),\n  );\n  Object.assign(m, originalModule);\n  m.sync = jest.spyOn(originalModule, 'sync');\n\n  return m;\n});\n\nconst mockUserResolver = jest.mocked(userResolver);\nconst mockUserResolverAsync = jest.mocked(userResolverAsync);\nconst mockResolveSync = jest.mocked(resolveSync);\n\nbeforeEach(() => {\n  mockUserResolver.mockClear();\n  mockUserResolverAsync.async.mockClear();\n  mockResolveSync.mockClear();\n\n  Resolver.clearDefaultResolverCache();\n});\n\ndescribe('isCoreModule', () => {\n  it('returns false if `hasCoreModules` is false.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      hasCoreModules: false,\n    } as ResolverConfig);\n    const isCore = resolver.isCoreModule('assert');\n    expect(isCore).toBe(false);\n  });\n\n  it('returns true if `hasCoreModules` is true and `moduleName` is a core module.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const isCore = resolver.isCoreModule('assert');\n    expect(isCore).toBe(true);\n  });\n\n  it('returns false if `hasCoreModules` is true and `moduleName` is not a core module.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const isCore = resolver.isCoreModule('not-a-core-module');\n    expect(isCore).toBe(false);\n  });\n\n  it('returns false if `hasCoreModules` is true and `moduleNameMapper` alias a module same name with core module', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      moduleNameMapper: [\n        {\n          moduleName: '$1',\n          regex: /^constants$/,\n        },\n      ],\n    } as ResolverConfig);\n    const isCore = resolver.isCoreModule('constants');\n    expect(isCore).toBe(false);\n  });\n\n  it('returns true if using `node:` URLs and `moduleName` is a core module.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const isCore = resolver.isCoreModule('node:assert');\n    expect(isCore).toBe(true);\n  });\n\n  it('returns true if using `node:` URLs and `moduleName` is not a core module.', () => {\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const isCore = resolver.isCoreModule('node:not-a-core-module');\n    expect(isCore).toBe(true);\n  });\n});\n\ndescribe('findNodeModule', () => {\n  it('is possible to override the default resolver', () => {\n    const cwd = process.cwd();\n    const resolvedCwd = fs.realpathSync(cwd) || cwd;\n    const nodePaths = process.env.NODE_PATH\n      ? process.env.NODE_PATH.split(path.delimiter)\n          .filter(Boolean)\n          .map(p => path.resolve(resolvedCwd, p))\n      : null;\n\n    mockUserResolver.mockImplementation(() => 'module');\n\n    const newPath = Resolver.findNodeModule('test', {\n      basedir: '/',\n      conditions: ['conditions, woooo'],\n      extensions: ['js'],\n      moduleDirectory: ['node_modules'],\n      paths: ['/something'],\n      resolver: require.resolve('../__mocks__/userResolver'),\n    });\n\n    expect(newPath).toBe('module');\n    expect(mockUserResolver.mock.calls[0][0]).toBe('test');\n    expect(mockUserResolver.mock.calls[0][1]).toStrictEqual({\n      basedir: '/',\n      conditions: ['conditions, woooo'],\n      defaultResolver,\n      extensions: ['js'],\n      moduleDirectory: ['node_modules'],\n      paths: [...(nodePaths || []), '/something'],\n      rootDir: undefined,\n    });\n  });\n\n  it('wraps passed packageFilter to the resolve module when using the default resolver', () => {\n    const packageFilter = jest.fn<PackageFilter>();\n\n    // A resolver that delegates to defaultResolver with a packageFilter implementation\n    mockUserResolver.mockImplementation((request, opts) =>\n      opts.defaultResolver(request, {...opts, packageFilter}),\n    );\n\n    Resolver.findNodeModule('./test', {\n      basedir: path.resolve(__dirname, '../__mocks__/'),\n      resolver: require.resolve('../__mocks__/userResolver'),\n    });\n\n    expect(packageFilter).toHaveBeenCalledWith(\n      expect.objectContaining({name: '__mocks__'}),\n      expect.any(String),\n    );\n  });\n\n  it('supports file URLs', () => {\n    const path = pathToFileURL(__filename).href;\n    const newPath = Resolver.findNodeModule(path, {\n      basedir: '/',\n    });\n\n    expect(newPath).toBe(__filename);\n  });\n\n  describe('conditions', () => {\n    const conditionsRoot = path.resolve(__dirname, '../__mocks__/conditions');\n\n    test('resolves without exports, just main', () => {\n      const result = Resolver.findNodeModule('main', {\n        basedir: conditionsRoot,\n        conditions: ['require'],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/main/file.js'),\n      );\n    });\n\n    test('resolves with import', () => {\n      const result = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: ['import'],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/import.js'),\n      );\n    });\n\n    test('resolves with require', () => {\n      const result = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: ['require'],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/require.js'),\n      );\n    });\n\n    test('gets default when nothing is passed', () => {\n      const result = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/default.js'),\n      );\n    });\n\n    test('respects order in package.json, not conditions', () => {\n      const resultImport = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: ['import', 'require'],\n      });\n      const resultRequire = Resolver.findNodeModule('exports', {\n        basedir: conditionsRoot,\n        conditions: ['require', 'import'],\n      });\n\n      expect(resultImport).toEqual(resultRequire);\n    });\n\n    test('supports nested paths', () => {\n      const result = Resolver.findNodeModule('exports/nested', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(result).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/nestedDefault.js'),\n      );\n    });\n\n    test('supports nested paths with wildcard and no extension', () => {\n      const result = Resolver.findNodeModule('exports/directory/file', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(result).toEqual(\n        path.resolve(\n          conditionsRoot,\n          './node_modules/exports/some-other-directory/file.js',\n        ),\n      );\n    });\n\n    test('supports nested conditions', () => {\n      const resultRequire = Resolver.findNodeModule('exports/deeplyNested', {\n        basedir: conditionsRoot,\n        conditions: ['require'],\n      });\n      const resultDefault = Resolver.findNodeModule('exports/deeplyNested', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(resultRequire).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/nestedRequire.js'),\n      );\n\n      expect(resultDefault).toEqual(\n        path.resolve(conditionsRoot, './node_modules/exports/nestedDefault.js'),\n      );\n    });\n\n    test('supports separate directory path', () => {\n      const result = Resolver.findNodeModule('exports/directory/file.js', {\n        basedir: conditionsRoot,\n        conditions: [],\n      });\n\n      expect(result).toEqual(\n        path.resolve(\n          conditionsRoot,\n          './node_modules/exports/some-other-directory/file.js',\n        ),\n      );\n    });\n  });\n\n  describe('self-reference', () => {\n    const selfRefRoot = path.resolve(__dirname, '../__mocks__/self-ref');\n\n    test('supports self-reference', () => {\n      const result = Resolver.findNodeModule('foo', {\n        basedir: path.resolve(selfRefRoot, './foo/index.js'),\n        conditions: [],\n      });\n\n      expect(result).toEqual(path.resolve(selfRefRoot, './foo/file.js'));\n    });\n\n    test('supports nested self-reference', () => {\n      const result = Resolver.findNodeModule('foo', {\n        basedir: path.resolve(selfRefRoot, './foo/nested/index.js'),\n        conditions: [],\n      });\n\n      expect(result).toEqual(path.resolve(selfRefRoot, './foo/file.js'));\n    });\n\n    test('fails if own pkg.json with different name', () => {\n      const result = Resolver.findNodeModule('foo', {\n        basedir: path.resolve(\n          selfRefRoot,\n          './foo/nested-with-own-pkg/index.js',\n        ),\n        conditions: [],\n      });\n\n      expect(result).toBeNull();\n    });\n\n    test('fails if own pkg.json with no exports', () => {\n      const result = Resolver.findNodeModule('foo-no-exports', {\n        basedir: path.resolve(\n          selfRefRoot,\n          './foo/nested-with-no-exports/index.js',\n        ),\n        conditions: [],\n      });\n\n      expect(result).toBeNull();\n    });\n  });\n\n  describe('imports', () => {\n    const importsRoot = path.resolve(__dirname, '../__mocks__/imports');\n\n    test('supports internal reference', () => {\n      const result = Resolver.findNodeModule('#nested', {\n        basedir: path.resolve(importsRoot, './foo-import/index.cjs'),\n        conditions: ['require'],\n      });\n\n      expect(result).toEqual(\n        path.resolve(importsRoot, './foo-import/internal.cjs'),\n      );\n    });\n\n    test('supports external reference', () => {\n      const result = Resolver.findNodeModule('#nested', {\n        basedir: path.resolve(importsRoot, './foo-import/index.js'),\n        conditions: [],\n      });\n\n      expect(result).toEqual(\n        path.resolve(\n          importsRoot,\n          './foo-import/node_modules/external-foo/main.js',\n        ),\n      );\n    });\n\n    test('supports nested pattern', () => {\n      const result = Resolver.findNodeModule('#nested', {\n        basedir: path.resolve(importsRoot, './nested-import/index.cjs'),\n        conditions: ['node', 'require'],\n      });\n\n      expect(result).toEqual(\n        path.resolve(importsRoot, './nested-import/node.cjs'),\n      );\n    });\n\n    describe('supports array pattern', () => {\n      test('resolve to first found', () => {\n        const result = Resolver.findNodeModule('#array-import', {\n          basedir: path.resolve(importsRoot, './array-import/index.cjs'),\n          conditions: ['import'],\n        });\n\n        expect(result).toEqual(\n          path.resolve(importsRoot, './array-import/node.mjs'),\n        );\n      });\n\n      test('skip over not met nested condition', () => {\n        const result = Resolver.findNodeModule('#array-import', {\n          basedir: path.resolve(importsRoot, './array-import/index.cjs'),\n          conditions: ['browser'],\n        });\n\n        expect(result).toEqual(\n          path.resolve(importsRoot, './array-import/browser.cjs'),\n        );\n      });\n\n      test('match nested condition', () => {\n        const result = Resolver.findNodeModule('#array-import', {\n          basedir: path.resolve(importsRoot, './array-import/index.cjs'),\n          conditions: ['chrome', 'browser'],\n        });\n\n        expect(result).toEqual(\n          path.resolve(importsRoot, './array-import/chrome.cjs'),\n        );\n      });\n    });\n\n    test('fails for non-existent mapping', () => {\n      expect(() => {\n        Resolver.findNodeModule('#something-else', {\n          basedir: path.resolve(importsRoot, './foo-import/index.js'),\n          conditions: [],\n        });\n      }).toThrow('Missing \"#something-else\" specifier in \"foo-import\" package');\n    });\n  });\n});\n\ndescribe('findNodeModuleAsync', () => {\n  it('is possible to override the default resolver', async () => {\n    const cwd = process.cwd();\n    const resolvedCwd = fs.realpathSync(cwd) || cwd;\n    const nodePaths = process.env.NODE_PATH\n      ? process.env.NODE_PATH.split(path.delimiter)\n          .filter(Boolean)\n          .map(p => path.resolve(resolvedCwd, p))\n      : null;\n\n    mockUserResolverAsync.async.mockResolvedValue('module');\n\n    const newPath = await Resolver.findNodeModuleAsync('test', {\n      basedir: '/',\n      conditions: ['conditions, woooo'],\n      extensions: ['js'],\n      moduleDirectory: ['node_modules'],\n      paths: ['/something'],\n      resolver: require.resolve('../__mocks__/userResolverAsync'),\n    });\n\n    expect(newPath).toBe('module');\n    expect(mockUserResolverAsync.async.mock.calls[0][0]).toBe('test');\n    expect(mockUserResolverAsync.async.mock.calls[0][1]).toStrictEqual({\n      basedir: '/',\n      conditions: ['conditions, woooo'],\n      defaultResolver,\n      extensions: ['js'],\n      moduleDirectory: ['node_modules'],\n      paths: [...(nodePaths || []), '/something'],\n      rootDir: undefined,\n    });\n  });\n\n  it('passes packageFilter to the resolve module when using the default resolver', async () => {\n    const packageFilter = jest.fn<PackageFilter>();\n\n    // A resolver that delegates to defaultResolver with a packageFilter implementation\n    mockUserResolverAsync.async.mockImplementation((request, opts) =>\n      Promise.resolve(opts.defaultResolver(request, {...opts, packageFilter})),\n    );\n\n    await Resolver.findNodeModuleAsync('test', {\n      basedir: '/',\n      resolver: require.resolve('../__mocks__/userResolverAsync'),\n    });\n\n    expect(mockResolveSync).toHaveBeenCalledWith(\n      'test',\n      expect.objectContaining({\n        packageFilter,\n      }),\n    );\n  });\n\n  it('supports file URLs', async () => {\n    const path = pathToFileURL(__filename).href;\n    const newPath = await Resolver.findNodeModuleAsync(path, {\n      basedir: '/',\n    });\n\n    expect(newPath).toBe(__filename);\n  });\n});\n\ndescribe('resolveModule', () => {\n  let moduleMap: IModuleMap;\n  beforeEach(() => {\n    moduleMap = ModuleMap.create('/');\n  });\n\n  it('is possible to resolve node modules', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolved = resolver.resolveModule(\n      src,\n      './__mocks__/mockJsDependency',\n    );\n    expect(resolved).toBe(require.resolve('../__mocks__/mockJsDependency.js'));\n  });\n\n  it('is possible to resolve node modules with custom extensions', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js', '.jsx'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolvedJsx = resolver.resolveModule(\n      src,\n      './__mocks__/mockJsxDependency',\n    );\n    expect(resolvedJsx).toBe(\n      require.resolve('../__mocks__/mockJsxDependency.jsx'),\n    );\n  });\n\n  it('is possible to resolve node modules with custom extensions and platforms', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js', '.jsx'],\n      platforms: ['native'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolvedJsx = resolver.resolveModule(\n      src,\n      './__mocks__/mockJsxDependency',\n    );\n    expect(resolvedJsx).toBe(\n      require.resolve('../__mocks__/mockJsxDependency.native.jsx'),\n    );\n  });\n\n  it('is possible to resolve node modules by resolving their realpath', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = path.join(\n      path.resolve(__dirname, '../../src/__mocks__/bar/node_modules/'),\n      'foo/index.js',\n    );\n    const resolved = resolver.resolveModule(src, 'dep');\n    expect(resolved).toBe(\n      require.resolve('../../src/__mocks__/foo/node_modules/dep/index.js'),\n    );\n  });\n\n  it('is possible to specify custom resolve paths', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolved = resolver.resolveModule(src, 'mockJsDependency', {\n      paths: [\n        path.resolve(__dirname, '../../src/__mocks__'),\n        path.resolve(__dirname, '../../src/__tests__'),\n      ],\n    });\n    expect(resolved).toBe(require.resolve('../__mocks__/mockJsDependency.js'));\n  });\n\n  it('does not confuse directories with files', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const mocksDirectory = path.resolve(__dirname, '../__mocks__');\n    const fooSlashFoo = path.join(mocksDirectory, 'foo/foo.js');\n    const fooSlashIndex = path.join(mocksDirectory, 'foo/index.js');\n\n    const resolvedWithSlash = resolver.resolveModule(fooSlashFoo, './');\n    const resolvedWithDot = resolver.resolveModule(fooSlashFoo, '.');\n    expect(resolvedWithSlash).toBe(fooSlashIndex);\n    expect(resolvedWithSlash).toBe(resolvedWithDot);\n  });\n\n  it('custom resolver can resolve node modules', () => {\n    mockUserResolver.mockImplementation(() => 'module');\n\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n      resolver: require.resolve('../__mocks__/userResolver'),\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    resolver.resolveModule(src, 'fs');\n\n    expect(mockUserResolver).toHaveBeenCalled();\n    expect(mockUserResolver.mock.calls[0][0]).toBe('fs');\n  });\n\n  it('handles unmatched capture groups correctly', () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n      moduleNameMapper: [\n        {\n          moduleName: './__mocks__/foo$1',\n          regex: /^@Foo(\\/.*)?$/,\n        },\n      ],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    expect(resolver.resolveModule(src, '@Foo')).toBe(\n      require.resolve('../__mocks__/foo.js'),\n    );\n    expect(resolver.resolveModule(src, '@Foo/bar')).toBe(\n      require.resolve('../__mocks__/foo/bar/index.js'),\n    );\n  });\n});\n\ndescribe('resolveModuleAsync', () => {\n  let moduleMap: IModuleMap;\n  beforeEach(() => {\n    moduleMap = ModuleMap.create('/');\n  });\n\n  it('is possible to resolve node modules', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolved = await resolver.resolveModuleAsync(\n      src,\n      './__mocks__/mockJsDependency',\n    );\n    expect(resolved).toBe(require.resolve('../__mocks__/mockJsDependency.js'));\n  });\n\n  it('is possible to resolve node modules with custom extensions', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js', '.jsx'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolvedJsx = await resolver.resolveModuleAsync(\n      src,\n      './__mocks__/mockJsxDependency',\n    );\n    expect(resolvedJsx).toBe(\n      require.resolve('../__mocks__/mockJsxDependency.jsx'),\n    );\n  });\n\n  it('is possible to resolve node modules with custom extensions and platforms', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js', '.jsx'],\n      platforms: ['native'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolvedJsx = await resolver.resolveModuleAsync(\n      src,\n      './__mocks__/mockJsxDependency',\n    );\n    expect(resolvedJsx).toBe(\n      require.resolve('../__mocks__/mockJsxDependency.native.jsx'),\n    );\n  });\n\n  it('is possible to resolve node modules by resolving their realpath', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = path.join(\n      path.resolve(__dirname, '../../src/__mocks__/bar/node_modules/'),\n      'foo/index.js',\n    );\n    const resolved = await resolver.resolveModuleAsync(src, 'dep');\n    expect(resolved).toBe(\n      require.resolve('../../src/__mocks__/foo/node_modules/dep/index.js'),\n    );\n  });\n\n  it('is possible to specify custom resolve paths', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    const resolved = await resolver.resolveModuleAsync(\n      src,\n      'mockJsDependency',\n      {\n        paths: [\n          path.resolve(__dirname, '../../src/__tests__'),\n          path.resolve(__dirname, '../../src/__mocks__'),\n        ],\n      },\n    );\n    expect(resolved).toBe(require.resolve('../__mocks__/mockJsDependency.js'));\n  });\n\n  it('does not confuse directories with files', async () => {\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n    } as ResolverConfig);\n    const mocksDirectory = path.resolve(__dirname, '../__mocks__');\n    const fooSlashFoo = path.join(mocksDirectory, 'foo/foo.js');\n    const fooSlashIndex = path.join(mocksDirectory, 'foo/index.js');\n\n    const resolvedWithSlash = await resolver.resolveModuleAsync(\n      fooSlashFoo,\n      './',\n    );\n    const resolvedWithDot = await resolver.resolveModuleAsync(fooSlashFoo, '.');\n    expect(resolvedWithSlash).toBe(fooSlashIndex);\n    expect(resolvedWithSlash).toBe(resolvedWithDot);\n  });\n});\n\ndescribe('getMockModule', () => {\n  it('is possible to use custom resolver to resolve deps inside mock modules with moduleNameMapper', () => {\n    mockUserResolver.mockImplementation(() => 'module');\n\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n      moduleNameMapper: [\n        {\n          moduleName: '$1',\n          regex: /(.*)/,\n        },\n      ],\n      resolver: require.resolve('../__mocks__/userResolver'),\n    } as ResolverConfig);\n    const src = require.resolve('../');\n    resolver.getMockModule(src, 'dependentModule');\n\n    expect(mockUserResolver).toHaveBeenCalled();\n    expect(mockUserResolver.mock.calls[0][0]).toBe('dependentModule');\n    expect(mockUserResolver.mock.calls[0][1]).toHaveProperty(\n      'basedir',\n      path.dirname(src),\n    );\n  });\n});\n\ndescribe('getMockModuleAsync', () => {\n  it('is possible to use custom resolver to resolve deps inside mock modules with moduleNameMapper', async () => {\n    mockUserResolverAsync.async.mockResolvedValue('module');\n\n    const moduleMap = ModuleMap.create('/');\n    const resolver = new Resolver(moduleMap, {\n      extensions: ['.js'],\n      moduleNameMapper: [\n        {\n          moduleName: '$1',\n          regex: /(.*)/,\n        },\n      ],\n      resolver: require.resolve('../__mocks__/userResolverAsync'),\n    } as ResolverConfig);\n    const src = require.resolve('../');\n\n    await resolver.resolveModuleAsync(src, 'dependentModule', {\n      conditions: ['browser'],\n    });\n\n    expect(mockUserResolverAsync.async).toHaveBeenCalled();\n    expect(mockUserResolverAsync.async.mock.calls[0][0]).toBe(\n      'dependentModule',\n    );\n    expect(mockUserResolverAsync.async.mock.calls[0][1]).toHaveProperty(\n      'basedir',\n      path.dirname(src),\n    );\n    expect(mockUserResolverAsync.async.mock.calls[0][1]).toHaveProperty(\n      'conditions',\n      ['browser'],\n    );\n  });\n});\n\ndescribe('nodeModulesPaths', () => {\n  it('provides custom module paths after node_modules', () => {\n    const src = require.resolve('../');\n    const result = nodeModulesPaths(src, {paths: ['./customFolder']});\n    expect(result.at(-1)).toBe('./customFolder');\n  });\n\n  it('provides custom module multi paths after node_modules', () => {\n    const src = require.resolve('../');\n    const result = nodeModulesPaths(src, {\n      paths: ['./customFolder', './customFolder2', './customFolder3'],\n    });\n    expect(result.slice(-3)).toStrictEqual([\n      './customFolder',\n      './customFolder2',\n      './customFolder3',\n    ]);\n  });\n});\n\ndescribe('Resolver.getModulePaths() -> nodeModulesPaths()', () => {\n  const _path = path;\n  let moduleMap: IModuleMap;\n\n  beforeEach(() => {\n    jest.resetModules();\n\n    moduleMap = ModuleMap.create('/');\n\n    // Mocking realpath to function the old way, where it just looks at\n    // pathstrings instead of actually trying to access the physical directory.\n    // This test suite won't work otherwise, since we cannot make assumptions\n    // about the test environment when it comes to absolute paths.\n    jest.doMock('graceful-fs', () => ({\n      ...jest.requireActual<typeof import('graceful-fs')>('graceful-fs'),\n      realPathSync: {\n        native: (dirInput: string) => dirInput,\n      },\n    }));\n  });\n\n  afterAll(() => {\n    jest.resetModules();\n    jest.dontMock('path');\n  });\n\n  it('can resolve node modules relative to absolute paths in \"moduleDirectories\" on Windows platforms', () => {\n    jest.doMock('path', () => _path.win32);\n    const path = require('path');\n    const Resolver = require('../').default;\n\n    const cwd = 'D:\\\\temp\\\\project';\n    const src = 'C:\\\\path\\\\to\\\\node_modules';\n    const resolver = new Resolver(moduleMap, {\n      moduleDirectories: [src, 'node_modules'],\n    });\n    const dirs_expected = [\n      src,\n      `${cwd}\\\\node_modules`,\n      `${path.dirname(cwd)}\\\\node_modules`,\n      'D:\\\\node_modules',\n    ];\n    const dirs_actual = resolver.getModulePaths(cwd);\n    expect(dirs_actual).toEqual(expect.arrayContaining(dirs_expected));\n  });\n\n  it('can resolve node modules relative to absolute paths in \"moduleDirectories\" on Posix platforms', () => {\n    jest.doMock('path', () => _path.posix);\n    const path = require('path');\n    const Resolver = require('../').default;\n\n    const cwd = '/temp/project';\n    const src = '/path/to/node_modules';\n    const resolver = new Resolver(moduleMap, {\n      moduleDirectories: [src, 'node_modules'],\n    });\n    const dirs_expected = [\n      src,\n      `${cwd}/node_modules`,\n      `${path.dirname(cwd)}/node_modules`,\n      '/node_modules',\n    ];\n    const dirs_actual = resolver.getModulePaths(cwd);\n    expect(dirs_actual).toEqual(expect.arrayContaining(dirs_expected));\n  });\n});\n\ndescribe('Resolver.getGlobalPaths()', () => {\n  const _path = path;\n  let moduleMap: IModuleMap;\n  beforeEach(() => {\n    moduleMap = ModuleMap.create('/');\n  });\n\n  it('return global paths with npm package', () => {\n    jest.doMock('path', () => _path.posix);\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const globalPaths = resolver.getGlobalPaths('jest');\n    for (const globalPath of globalPaths)\n      expect(require.resolve.paths('jest')).toContain(globalPath);\n  });\n\n  it('return empty array with builtin module', () => {\n    jest.doMock('path', () => _path.posix);\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const globalPaths = resolver.getGlobalPaths('fs');\n    expect(globalPaths).toStrictEqual([]);\n  });\n\n  it('return global paths with absolute path', () => {\n    jest.doMock('path', () => _path.posix);\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const globalPaths = resolver.getGlobalPaths('/');\n    for (const globalPath of globalPaths)\n      expect(require.resolve.paths('/')).toContain(globalPath);\n  });\n\n  it('return empty array with relative path', () => {\n    jest.doMock('path', () => _path.posix);\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const globalPaths = resolver.getGlobalPaths('./');\n    expect(globalPaths).toStrictEqual([]);\n  });\n\n  it('return empty array without module name', () => {\n    jest.doMock('path', () => _path.posix);\n    const resolver = new Resolver(moduleMap, {} as ResolverConfig);\n    const globalPaths = resolver.getGlobalPaths();\n    expect(globalPaths).toStrictEqual([]);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport greeting from '../some-file';\n\ntest('async resolver resolves to correct file', () => {\n  expect(greeting).toBe('Hello from mapped file!!');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\ntest('runs test with native ESM', () => {\n  const {exitCode, stderr, stdout} = runJest('resolve-async', [], {\n    nodeOptions: '--experimental-vm-modules --no-warnings',\n  });\n\n  const {summary} = extractSummary(stderr);\n\n  expect(summary).toMatchSnapshot();\n  expect(stdout).toBe('');\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`runs test with native ESM 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst {fn} = require('fake-dep');\n\ntest('returns correct message', () => {\n  expect(fn()).toBe('hello from CJS');\n});"}
{"prompt":"run multiple times to ensure there are no caching errors","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {resolve} from 'path';\nimport runJest from '../runJest';\n\nconst dir = resolve(__dirname, '..', 'resolve-conditions');\n\ntest('resolves package exports correctly with custom resolver', () => {\n  // run multiple times to ensure there are no caching errors\n  for (let i = 0; i < 5; i++) {\n    const {exitCode} = runJest(dir, [], {\n      nodeOptions: '--experimental-vm-modules --no-warnings',\n    });\n    try {\n      expect(exitCode).toBe(0);\n    } catch (error) {\n      console.log(`Test failed on iteration ${i + 1}`);\n      throw error;\n    }\n  }\n});"}
{"prompt":".each[...JEST_CONFIG_EXT_ORDER]","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../../../../e2e/Utils';\nimport {JEST_CONFIG_EXT_ORDER} from '../constants';\nimport resolveConfigPath from '../resolveConfigPath';\n\nconst DIR = path.resolve(tmpdir(), 'resolve_config_path_test');\nconst ERROR_PATTERN = /Could not find a config file based on provided values/;\nconst NO_ROOT_DIR_ERROR_PATTERN = /Can't find a root directory/;\nconst MULTIPLE_CONFIGS_ERROR_PATTERN = /Multiple configurations found/;\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ndescribe.each([...JEST_CONFIG_EXT_ORDER])(\n  'Resolve config path %s',\n  extension => {\n    test(`file path with \"${extension}\"`, () => {\n      const relativeConfigPath = `a/b/c/my_config${extension}`;\n      const absoluteConfigPath = path.resolve(DIR, relativeConfigPath);\n\n      writeFiles(DIR, {[relativeConfigPath]: ''});\n\n      // absolute\n      expect(resolveConfigPath(absoluteConfigPath, DIR)).toBe(\n        absoluteConfigPath,\n      );\n      expect(() => resolveConfigPath('/does_not_exist', DIR)).toThrow(\n        NO_ROOT_DIR_ERROR_PATTERN,\n      );\n\n      // relative\n      expect(resolveConfigPath(relativeConfigPath, DIR)).toBe(\n        absoluteConfigPath,\n      );\n      expect(() => resolveConfigPath('does_not_exist', DIR)).toThrow(\n        NO_ROOT_DIR_ERROR_PATTERN,\n      );\n    });\n\n    test(`directory path with \"${extension}\"`, () => {\n      const relativePackageJsonPath = 'a/b/c/package.json';\n      const absolutePackageJsonPath = path.resolve(\n        DIR,\n        relativePackageJsonPath,\n      );\n      const relativeJestConfigPath = `a/b/c/jest.config${extension}`;\n      const absoluteJestConfigPath = path.resolve(DIR, relativeJestConfigPath);\n\n      // no configs yet. should throw\n      writeFiles(DIR, {[`a/b/c/some_random_file${extension}`]: ''});\n\n      expect(() =>\n        // absolute\n        resolveConfigPath(path.dirname(absoluteJestConfigPath), DIR),\n      ).toThrow(ERROR_PATTERN);\n\n      expect(() =>\n        // relative\n        resolveConfigPath(path.dirname(relativeJestConfigPath), DIR),\n      ).toThrow(ERROR_PATTERN);\n\n      writeFiles(DIR, {[relativePackageJsonPath]: ''});\n\n      // absolute\n      expect(\n        resolveConfigPath(path.dirname(absolutePackageJsonPath), DIR),\n      ).toBe(absolutePackageJsonPath);\n\n      // relative\n      expect(\n        resolveConfigPath(path.dirname(relativePackageJsonPath), DIR),\n      ).toBe(absolutePackageJsonPath);\n\n      // jest.config.js takes precedence\n      writeFiles(DIR, {[relativeJestConfigPath]: ''});\n\n      // absolute\n      expect(\n        resolveConfigPath(path.dirname(absolutePackageJsonPath), DIR),\n      ).toBe(absoluteJestConfigPath);\n\n      // relative\n      expect(\n        resolveConfigPath(path.dirname(relativePackageJsonPath), DIR),\n      ).toBe(absoluteJestConfigPath);\n\n      // jest.config.js and package.json with 'jest' cannot be used together\n      writeFiles(DIR, {[relativePackageJsonPath]: JSON.stringify({jest: {}})});\n\n      // absolute\n      expect(() =>\n        resolveConfigPath(path.dirname(absolutePackageJsonPath), DIR),\n      ).toThrow(MULTIPLE_CONFIGS_ERROR_PATTERN);\n\n      // relative\n      expect(() =>\n        resolveConfigPath(path.dirname(relativePackageJsonPath), DIR),\n      ).toThrow(MULTIPLE_CONFIGS_ERROR_PATTERN);\n\n      expect(() => {\n        resolveConfigPath(\n          path.join(path.dirname(relativePackageJsonPath), 'j/x/b/m/'),\n          DIR,\n        );\n      }).toThrow(NO_ROOT_DIR_ERROR_PATTERN);\n    });\n\n    test('file path from \"jest\" key', () => {\n      const anyFileName = `anyJestConfigfile${extension}`;\n      const relativePackageJsonPath = 'a/b/c/package.json';\n      const relativeAnyFilePath = `a/b/c/conf/${anyFileName}`;\n      const absolutePackageJsonPath = path.resolve(\n        DIR,\n        relativePackageJsonPath,\n      );\n      const absoluteAnyFilePath = path.resolve(DIR, relativeAnyFilePath);\n\n      writeFiles(DIR, {\n        'a/b/c/package.json': `{ \"jest\": \"conf/${anyFileName}\" }`,\n      });\n      writeFiles(DIR, {[relativeAnyFilePath]: ''});\n\n      const result = resolveConfigPath(\n        path.dirname(absolutePackageJsonPath),\n        DIR,\n      );\n\n      expect(result).toBe(absoluteAnyFilePath);\n    });\n\n    test('not a file path from \"jest\" key', () => {\n      const anyFileName = `anyJestConfigfile${extension}`;\n      const relativePackageJsonPath = 'a/b/c/package.json';\n      const relativeAnyFilePath = `a/b/c/conf/${anyFileName}`;\n      const absolutePackageJsonPath = path.resolve(\n        DIR,\n        relativePackageJsonPath,\n      );\n\n      writeFiles(DIR, {\n        'a/b/c/package.json': '{ \"jest\": {\"verbose\": true} }',\n      });\n      writeFiles(DIR, {[relativeAnyFilePath]: ''});\n\n      const result = resolveConfigPath(\n        path.dirname(absolutePackageJsonPath),\n        DIR,\n      );\n\n      expect(result).toBe(absolutePackageJsonPath);\n    });\n\n    test('not a valid file when \"jest\" key is a path', () => {\n      const anyFileName = `anyJestConfigfile${extension}`;\n      const relativePackageJsonPath = 'a/b/c/package.json';\n      const relativeAnyFilePath = `a/b/c/conf/${anyFileName}`;\n      const absolutePackageJsonPath = path.resolve(\n        DIR,\n        relativePackageJsonPath,\n      );\n\n      writeFiles(DIR, {\n        'a/b/c/package.json': '{ \"jest\": \"conf/nonExistentConfigfile.json\" }',\n      });\n      writeFiles(DIR, {[relativeAnyFilePath]: ''});\n\n      expect(() =>\n        resolveConfigPath(path.dirname(absolutePackageJsonPath), DIR),\n      ).toThrow(\n        /Jest expects the string configuration to point to a file, but .* not\\./,\n      );\n    });\n  },\n);\n\nconst pickPairsWithSameOrder = <T>(array: ReadonlyArray<T>) =>\n  array.flatMap((value1, idx, arr) =>\n    arr.slice(idx + 1).map(value2 => [value1, value2]),\n  );\n\ntest('pickPairsWithSameOrder', () => {\n  expect(pickPairsWithSameOrder([1, 2, 3])).toStrictEqual([\n    [1, 2],\n    [1, 3],\n    [2, 3],\n  ]);\n});\n\ndescribe.each(pickPairsWithSameOrder(JEST_CONFIG_EXT_ORDER))(\n  'Using multiple configs shows error',\n  (extension1, extension2) => {\n    test(`Using jest.config${extension1} and jest.config${extension2} shows error`, () => {\n      const relativeJestConfigPaths = [\n        `a/b/c/jest.config${extension1}`,\n        `a/b/c/jest.config${extension2}`,\n      ];\n\n      writeFiles(DIR, {\n        [relativeJestConfigPaths[0]]: '',\n        [relativeJestConfigPaths[1]]: '',\n      });\n\n      expect(() =>\n        resolveConfigPath(path.dirname(relativeJestConfigPaths[0]), DIR),\n      ).toThrow(MULTIPLE_CONFIGS_ERROR_PATTERN);\n    });\n  },\n);"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {fn} from 'fake-dep';\n\ntest('returns correct message', () => {\n  expect(fn()).toBe('hello from ESM');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {resolve} from 'path';\n\ntest('returns the resolve path for a relative path', () => {\n  expect(require.resolve.paths('./mod.js')).toEqual([resolve(__dirname)]);\n});\n\ntest('returns the resolve paths for a node_module', () => {\n  expect(require.resolve.paths('mod').slice(0, 2)).toEqual([\n    resolve(__dirname, 'node_modules'),\n    resolve(__dirname, '..', 'node_modules'),\n  ]);\n});\n\ntest('returns null for a native node module', () => {\n  expect(require.resolve.paths('fs')).toBeNull();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('require.resolve.paths', () => {\n  const {exitCode} = runJest('resolve-get-paths');\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('resolve node module', () => {\n  const result = runJest('resolve-node-module');\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {cleanup, extractSummary, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../resolve-no-extensions-no-js');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('show error message with matching files', () => {\n  const {exitCode, stderr} = runJest('resolve-no-extensions');\n  const {rest} = extractSummary(stderr);\n\n  expect(exitCode).toBe(1);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('show error message when no js moduleFileExtensions', () => {\n  writeFiles(DIR, {\n    'index.jsx': `\n      module.exports ={found: true};\n    `,\n    'package.json': `\n      {\n        \"jest\": {\n          \"moduleFileExtensions\": [\"jsx\"]\n        }\n      }\n    `,\n    'test.jsx': `\n      const m = require('../');\n\n      test('some test', () => {\n        expect(m.found).toBe(true);\n      });\n    `,\n  });\n\n  const {exitCode, stderr} = runJest('resolve-no-extensions-no-js');\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`show error message when no js moduleFileExtensions 1`] = `\n\"● Validation Error:\n\n  moduleFileExtensions must include 'js':\n  but instead received:\n    [\"jsx\"]\n  Please change your configuration to include 'js'.\n\n  Configuration Documentation:\n  https://jestjs.io/docs/configuration\n\"\n`;\n\nexports[`show error message with matching files 1`] = `\n\"FAIL __tests__/test.js\n  ● Test suite failed to run\n\n    Cannot find module './some-json-file' from 'index.js'\n\n    Require stack:\n      index.js\n      __tests__/test.js\n\n\n    However, Jest was able to find:\n    \t'./some-json-file.json'\n\n    You might want to include a file extension in your import, or update your 'moduleFileExtensions', which is currently ['js'].\n\n    See https://jestjs.io/docs/configuration#modulefileextensions-arraystring\n\n      6 |  */\n      7 |\n    > 8 | module.exports = require('./some-json-file');\n        |                  ^\n      9 |\n\n      at Resolver._throwModNotFoundError (../../packages/jest-resolve/build/index.js:935:11)\n      at Object.require (index.js:8:18)\n      at Object.require (__tests__/test.js:8:11)\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {resolve} from 'path';\n\ntest('finds a module relative to one of the given paths', () => {\n  expect(require.resolve('./mod.js', {paths: ['../dir']})).toBe(\n    resolve(__dirname, '..', 'dir', 'mod.js'),\n  );\n});\n\ntest('finds a module without a leading \"./\" relative to one of the given paths', () => {\n  expect(require.resolve('mod.js', {paths: ['../dir']})).toBe(\n    resolve(__dirname, '..', 'dir', 'mod.js'),\n  );\n});\n\ntest('finds a node_module above one of the given paths', () => {\n  expect(require.resolve('mod', {paths: ['../dir']})).toBe(\n    resolve(__dirname, '..', 'node_modules', 'mod', 'index.js'),\n  );\n});\n\ntest('finds a native node module when paths are given', () => {\n  expect(require.resolve('fs', {paths: ['../dir']})).toBe('fs');\n});\n\ntest('throws an error if the module cannot be found from given paths', () => {\n  expect(() => require.resolve('./mod.js', {paths: ['..']})).toThrow(\n    \"Cannot resolve module './mod.js' from paths ['..'] from \",\n  );\n});\n\ntest('throws module not found error if the module cannot be found from given paths', () => {\n  expect(() => require.resolve('./mod.js', {paths: ['..']})).toThrow(\n    expect.objectContaining({code: 'MODULE_NOT_FOUND'}),\n  );\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {resolve} from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst workdirNodeModules = resolve(\n  __dirname,\n  '..',\n  'resolve-with-paths',\n  'node_modules',\n);\n\nbeforeAll(() => {\n  writeFiles(resolve(workdirNodeModules, 'mod'), {\n    'index.js': 'module.exports = 42;',\n  });\n});\n\nafterAll(() => {\n  cleanup(workdirNodeModules);\n});\n\ntest('require.resolve with paths', () => {\n  const {exitCode} = runJest('resolve-with-paths');\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst resolved = require.resolve('./create_require_module', {\n  [Symbol.for('jest-resolve-outside-vm-option')]: true,\n});\nif (typeof resolved !== 'string') {\n  throw new TypeError(\n    'require.resolve not spec-compliant: must return a string',\n  );\n}\nmodule.exports = {\n  required: require(resolved),\n  resolved,\n};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports = require.resolve('testMapped/moduleInMapped');"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports = require.resolve('./resolve_self');"}
{"prompt":"Test in node_modules,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\ndescribe('Test in node_modules', () => {\n  test('gets run', () => {\n    console.log('I am running from within node_modules');\n    expect(true).toBe(true);\n  });\n});"}
{"prompt":"Retain All Files Integration,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ndescribe('Retain All Files Integration', () => {\n  test('valid test within node_modules', () => {\n    const {exitCode, stdout} = runJest('retain-all-files');\n    expect(exitCode).toBe(0);\n    expect(stdout).toContain('I am running from within node_modules');\n  });\n});"}
{"prompt":"retryTimes set,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\njest.retryTimes(3);\n\nit('retryTimes set', () => {\n  expect(true).toBeFalsy();\n});"}
{"prompt":".concurrentretryTimes set,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\njest.retryTimes(3);\n\nit.concurrent('retryTimes set', () => {\n  expect(true).toBeFalsy();\n});\n\nit.concurrent('truthy test', () => {\n  expect(true).toBeTruthy();\n});"}
{"prompt":"retryTimes set,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\njest.retryTimes(3, {logErrorsBeforeRetry: true, retryImmediately: true});\nlet i = 0;\nit('retryTimes set', () => {\n  i++;\n  if (i === 3) {\n    console.log('FIRST TRUTHY TEST');\n    expect(true).toBeTruthy();\n  } else {\n    expect(true).toBeFalsy();\n  }\n});\nit('truthy test', () => {\n  console.log('SECOND TRUTHY TEST');\n  expect(true).toBeTruthy();\n});"}
{"prompt":".concurrentretryable test 1,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\njest.retryTimes(3, {logErrorsBeforeRetry: true, retryImmediately: true});\nlet i1 = 0;\nit.concurrent('retryable test 1', () => {\n  i1++;\n  if (i1 === 3) {\n    console.log('SECOND TRUTHY TEST');\n    expect(true).toBeTruthy();\n  } else {\n    expect(true).toBeFalsy();\n  }\n});\n\nlet i2 = 0;\nit.concurrent('retryable test 2', () => {\n  i2++;\n  if (i2 === 3) {\n    console.log('THIRD TRUTHY TEST');\n    expect(true).toBeTruthy();\n  } else {\n    expect(true).toBeFalsy();\n  }\n});\nit.concurrent('truthy test', () => {\n  console.log('FIRST TRUTHY TEST');\n  expect(true).toBeTruthy();\n});"}
{"prompt":"returning values,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ndescribe('returning values', () => {\n  for (const val of [\n    1,\n    'string',\n    0.1,\n    null,\n    Number.NaN,\n    Number.POSITIVE_INFINITY,\n    true,\n    false,\n    [1],\n    {},\n    () => {},\n  ]) {\n    it(`throws if '${val}:${typeof val}' is returned`, () => val);\n  }\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports = require('./export_main');"}
{"prompt":"We only care about the static analysis, not about the runtime.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nrequire('ExclusivelyManualMock');\nrequire('ManuallyMocked');\nrequire('ModuleWithSideEffects');\nrequire('ModuleWithState');\nrequire('RegularModule');\n\n// We only care about the static analysis, not about the runtime.\nconst lazyRequire = () => {\n  require('image!not_really_a_module');\n  require('cat.png');\n  require('dog.png');\n};\n\nexports.jest = jest;\nexports.lazyRequire = lazyRequire;"}
{"prompt":"runJest,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {TestPathPatterns} from '@jest/pattern';\nimport runJest from '../runJest';\n\njest.mock('@jest/console');\n\nconst processErrWriteFn = process.stderr.write;\ndescribe('runJest', () => {\n  let stderrSpy;\n  beforeEach(async () => {\n    process.exit = jest.fn();\n    process.stderr.write = jest.fn();\n    process.stderr.write.mockReset();\n    stderrSpy = jest.spyOn(process.stderr, 'write');\n\n    await runJest({\n      changedFilesPromise: Promise.resolve({repos: {git: {size: 0}}}),\n      contexts: [],\n      globalConfig: {\n        rootDir: '',\n        testPathPatterns: new TestPathPatterns([]),\n        testSequencer: require.resolve('@jest/test-sequencer'),\n        watch: true,\n      },\n      onComplete: () => null,\n      outputStream: {},\n      startRun: {},\n      testWatcher: {isInterrupted: () => true},\n    });\n  });\n\n  afterEach(() => {\n    process.stderr.write = processErrWriteFn;\n  });\n\n  test('when watch is set then exit process', () => {\n    expect(process.exit).toHaveBeenCalledWith(1);\n  });\n\n  test('when watch is set then an error message is printed', () => {\n    expect(stderrSpy).toHaveBeenCalled();\n  });\n});"}
{"prompt":"setupFile,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ndescribe('setupFile', () => {\n  it('patches jasmine in setup file', () => {\n    expect(globalThis.describeDefined).toBe(true);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {resolve} from 'path';\nimport {run} from '../Utils';\n\nconst dir = resolve(__dirname, '..', 'run-programmatically');\n\ntest('run Jest programmatically cjs', () => {\n  const {stdout} = run('node cjs.js --version', dir);\n  expect(stdout).toMatch(/\\d{2}(?:\\.\\d{1,2}){2}\\S*-dev$/);\n});\n\ntest('run Jest programmatically esm', () => {\n  const {stdout} = run('node index.js --version', dir);\n  expect(stdout).toMatch(/\\d{2}(?:\\.\\d{1,2}){2}\\S*-dev$/);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {resolve} from 'path';\nimport stripAnsi = require('strip-ansi');\nimport {extractSummary, run} from '../Utils';\n\nconst dir = resolve(__dirname, '../run-programmatically-multiple-projects');\n\ntest('run programmatically with multiple projects', () => {\n  const {stderr, exitCode} = run('node run-jest.js', dir);\n  const {summary} = extractSummary(stripAnsi(stderr));\n  expect(exitCode).toBe(0);\n  expect(summary).toMatchSnapshot('summary');\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`run programmatically with multiple projects: summary 1`] = `\n\"Test Suites: 2 passed, 2 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites in 2 projects.\"\n`;"}
{"prompt":"Passing an exact path executes only the given test.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'run-tests-by-path-test');\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ntest('runs tests by exact path', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    '__tests__/t1.test.js': 'it(\"foo\", () => {})',\n    '__tests__/t2.test.js': 'it(\"bar\", () => {})',\n    'package.json': JSON.stringify({jest: {testEnvironment: 'node'}}),\n  });\n\n  // Passing an exact path executes only the given test.\n  const run1 = runJest(DIR, ['--runTestsByPath', '__tests__/t1.test.js']);\n  expect(run1.stderr).toMatch('PASS __tests__/t1.test.js');\n  expect(run1.stderr).not.toMatch('PASS __tests__/t2.test.js');\n\n  // When running with the flag and a pattern, no test is found.\n  const run2 = runJest(DIR, ['--runTestsByPath', '__tests__/t']);\n  expect(run2.stdout).toMatch(/no tests found/i);\n\n  // When ran without the flag and a pattern, both tests are found.\n  const run3 = runJest(DIR, ['__tests__/t']);\n  expect(run3.stderr).toMatch('PASS __tests__/t1.test.js');\n  expect(run3.stderr).toMatch('PASS __tests__/t2.test.js');\n});"}
{"prompt":"Runtime,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nlet createRuntime;\n\ndescribe('Runtime', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  describe('requireModule', () => {\n    it('installs source maps if available', async () => {\n      expect.assertions(1);\n\n      const runtime = await createRuntime(__filename);\n      const sum = runtime.requireModule(\n        runtime.__mockRootPath,\n        './sourcemaps/out/throwing-mapped-fn.js',\n      ).sum;\n\n      try {\n        sum();\n      } catch (error) {\n        if (process.platform === 'win32') {\n          expect(error.stack).toMatch(\n            /^Error: throwing fn\\s+at sum.+\\\\__tests__\\\\test_root\\\\sourcemaps\\\\(out\\\\)?throwing-mapped-fn.js:\\d+:\\d+/,\n          );\n        } else {\n          expect(error.stack).toMatch(\n            /^Error: throwing fn\\s+at sum.+\\/__tests__\\/test_root\\/sourcemaps\\/(out\\/)?throwing-mapped-fn.js:\\d+:\\d+/,\n          );\n        }\n      }\n    });\n  });\n});"}
{"prompt":"Runtime statics,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {makeProjectConfig} from '@jest/test-utils';\nimport HasteMap from 'jest-haste-map';\nimport Runtime from '../';\n\njest.mock('jest-haste-map');\n\ndescribe('Runtime statics', () => {\n  const projectConfig = makeProjectConfig({\n    cacheDirectory: '/tmp',\n    haste: {},\n    modulePathIgnorePatterns: ['/root/ignore-1', '/root/ignore-2'],\n    watchPathIgnorePatterns: ['/watch-root/ignore-1'],\n  });\n  const options = {};\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  test('Runtime.createHasteMap passes correct ignore files to HasteMap', async () => {\n    await Runtime.createHasteMap(projectConfig, options);\n    expect(HasteMap.create).toHaveBeenCalledWith(\n      expect.objectContaining({\n        ignorePattern: /\\/root\\/ignore-1|\\/root\\/ignore-2/,\n      }),\n    );\n  });\n\n  test('Runtime.createHasteMap passes correct ignore files to HasteMap in watch mode', async () => {\n    await Runtime.createHasteMap(projectConfig, {...options, watch: true});\n    expect(HasteMap.create).toHaveBeenCalledWith(\n      expect.objectContaining({\n        ignorePattern:\n          /\\/root\\/ignore-1|\\/root\\/ignore-2|\\/watch-root\\/ignore-1/,\n        watch: true,\n      }),\n    );\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nError.captureStackTrace = undefined;\n\ntest('some test', () => {\n  expect(1).toBe(2);\n});"}
{"prompt":"Runtime internal module registry,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\njest.mock('fs');\n\ndescribe('Runtime internal module registry', () => {\n  it('behaves correctly when requiring a module that is used by jest internals', () => {\n    const fs = require('fs');\n\n    // We require from this crazy path so that we can mimick Jest (and its\n    // transitive deps) being installed alongside a projects deps (e.g. with an\n    // NPM3 flat dep tree)\n    const jestUtil = require('jest-util');\n\n    // If FS is mocked correctly, this folder won't actually be created on the\n    // filesystem\n    jestUtil.createDirectory('./dont-create-this-folder');\n\n    expect(fs.__wasMkdirCalled()).toBe(true);\n  });\n});"}
{"prompt":"Runtime Internal Module Registry,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {json as runWithJson} from '../runJest';\n\ndescribe('Runtime Internal Module Registry', () => {\n  // Previously, if Jest required a module (e.g. requiring `mkdirp` from\n  // `jest-util`) and the project *using* Jest also required that module, Jest\n  // wouldn't re-require it and thus ignored any mocks that the module may have\n  // used.\n  //\n  // This test verifies that that behavior doesn't happen anymore, and correctly\n  // uses two module registries: an internal registry that's used specifically by\n  // Jest to require any internal modules used when setting up the test\n  // environment, and a \"normal\" module registry that's used by the actual test\n  // code (and can safely be cleared after every test)\n  it('correctly makes use of internal module registry when requiring modules', () => {\n    const {json} = runWithJson('runtime-internal-module-registry', []);\n\n    expect(json.numTotalTests).toBe(1);\n    expect(json.numPassedTests).toBe(1);\n  });\n});"}
{"prompt":"Runtime CLI,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {sync as spawnSync} from 'execa';\n\nconst JEST_RUNTIME = require.resolve('../../bin/jest-runtime-cli.js');\n\nconst timeout = 10_000;\n\nconst run = args =>\n  spawnSync(JEST_RUNTIME, args, {\n    cwd: process.cwd(),\n    env: process.env,\n    reject: false,\n    timeout: timeout - 500,\n  });\n\ndescribe('Runtime CLI', () => {\n  beforeAll(() => {\n    jest.retryTimes(3);\n    jest.setTimeout(timeout);\n  });\n\n  it('fails with no path', () => {\n    const expectedOutput =\n      'Please provide a path to a script. (See --help for details)';\n    expect(run([]).stdout).toBe(expectedOutput);\n  });\n\n  it('displays script output', () => {\n    const scriptPath = require.resolve('./test_root/logging.js');\n    expect(run([scriptPath, '--no-cache']).stdout).toMatch('Hello, world!');\n  });\n\n  it('always disables automocking', () => {\n    const scriptPath = require.resolve('./test_root/logging.js');\n    const output = run([\n      scriptPath,\n      '--no-cache',\n      `--config=${JSON.stringify({automock: true})}`,\n    ]);\n    expect(output.stdout).toMatch('Hello, world!');\n  });\n\n  it('throws script errors', () => {\n    const scriptPath = require.resolve('./test_root/throwing.js');\n    expect(run([scriptPath, '--no-cache']).stderr).toMatch('Error: throwing');\n  });\n});"}
{"prompt":"Runtime,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nlet createRuntime;\n\nconst moduleNameMapper = {\n  'module/name/(.*)': '<rootDir>/mapped_module_$1.js',\n};\n\ndescribe('Runtime', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  describe('createMockFromModule', () => {\n    it('does not cause side effects in the rest of the module system when generating a mock', async () => {\n      const runtime = await createRuntime(__filename);\n      const testRequire = runtime.requireModule.bind(\n        runtime,\n        runtime.__mockRootPath,\n      );\n\n      const module = testRequire('RegularModule');\n      const origModuleStateValue = module.getModuleStateValue();\n\n      expect(origModuleStateValue).toBe('default');\n\n      // Generate a mock for a module with side effects\n      const mock = module.jest.createMockFromModule('ModuleWithSideEffects');\n\n      // Make sure we get a mock.\n      expect(mock.fn()).toBeUndefined();\n      expect(module.getModuleStateValue()).toBe(origModuleStateValue);\n    });\n\n    it('resolves mapped modules correctly', async () => {\n      const runtime = await createRuntime(__filename, {moduleNameMapper});\n      const root = runtime.requireModule(runtime.__mockRootPath);\n      const mockModule = root.jest.createMockFromModule(\n        'module/name/createMockFromModule',\n      );\n\n      expect(mockModule.test.mock).toBeTruthy();\n    });\n  });\n\n  it('creates mock objects in the right environment', async () => {\n    const runtime = await createRuntime(__filename);\n    const testRequire = runtime.requireModule.bind(\n      runtime,\n      runtime.__mockRootPath,\n    );\n\n    const module = testRequire('RegularModule');\n    const mockModule = module.jest.createMockFromModule('RegularModule');\n    const testObjectPrototype = Object.getPrototypeOf(module.object);\n    const mockObjectPrototype = Object.getPrototypeOf(mockModule.object);\n    expect(mockObjectPrototype).toBe(testObjectPrototype);\n  });\n});"}
{"prompt":"Runtime,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nlet createRuntime;\n\ndescribe('Runtime', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  describe('requireModule', () => {\n    it('emulates a node stack trace during module load', async () => {\n      const runtime = await createRuntime(__filename);\n      let hasThrown = false;\n      try {\n        runtime.requireModule(runtime.__mockRootPath, './throwing.js');\n      } catch (error) {\n        hasThrown = true;\n        expect(error.stack).toMatch(/^Error: throwing\\s+at Object.<anonymous>/);\n      }\n      expect(hasThrown).toBe(true);\n    });\n\n    it('emulates a node stack trace during function execution', async () => {\n      const runtime = await createRuntime(__filename);\n      let hasThrown = false;\n      const sum = runtime.requireModule(\n        runtime.__mockRootPath,\n        './throwing_fn.js',\n      );\n\n      try {\n        sum();\n      } catch (error) {\n        hasThrown = true;\n        if (process.platform === 'win32') {\n          expect(error.stack).toMatch(\n            /^Error: throwing fn\\s+at sum.+\\\\__tests__\\\\test_root\\\\throwing_fn\\.js/,\n          );\n        } else {\n          expect(error.stack).toMatch(\n            /^Error: throwing fn\\s+at sum.+\\/__tests__\\/test_root\\/throwing_fn\\.js/,\n          );\n        }\n      }\n      expect(hasThrown).toBe(true);\n    });\n  });\n});"}
{"prompt":"Runtime,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nconst path = require('path');\n\nlet createRuntime;\n\ndescribe('Runtime', () => {\n  beforeEach(() => {\n    jest.resetModules();\n\n    createRuntime = require('createRuntime');\n  });\n\n  describe('internalModule', () => {\n    it('loads modules and applies transforms', async () => {\n      const runtime = await createRuntime(__filename, {\n        transform: {'\\\\.js$': './test_preprocessor'},\n      });\n      const modulePath = path.resolve(\n        path.dirname(runtime.__mockRootPath),\n        'internal-root.js',\n      );\n      expect(() => {\n        runtime.requireModule(modulePath);\n      }).toThrow(new Error('preprocessor must not run.'));\n    });\n    it('loads internal modules without applying transforms', async () => {\n      const runtime = await createRuntime(__filename, {\n        transform: {'\\\\.js$': './test_preprocessor'},\n      });\n      const modulePath = path.resolve(\n        path.dirname(runtime.__mockRootPath),\n        'internal-root.js',\n      );\n      const exports = runtime.requireInternalModule(modulePath);\n      expect(exports()).toBe('internal-module-data');\n    });\n\n    it('loads JSON modules and applies transforms', async () => {\n      const runtime = await createRuntime(__filename, {\n        transform: {'\\\\.json$': './test_json_preprocessor'},\n      });\n      const modulePath = path.resolve(\n        path.dirname(runtime.__mockRootPath),\n        'internal-root.json',\n      );\n      const exports = runtime.requireModule(modulePath);\n      expect(exports).toEqual({foo: 'foo'});\n    });\n    it('loads internal JSON modules without applying transforms', async () => {\n      const runtime = await createRuntime(__filename, {\n        transform: {'\\\\.json$': './test_json_preprocessor'},\n      });\n      const modulePath = path.resolve(\n        path.dirname(runtime.__mockRootPath),\n        'internal-root.json',\n      );\n      const exports = runtime.requireInternalModule(modulePath);\n      expect(exports).toEqual({foo: 'bar'});\n    });\n\n    const OPTIMIZED_MODULE_EXAMPLE = 'chalk';\n    it('loads modules normally even if on the optimization list', () =>\n      createRuntime(__filename).then(runtime => {\n        const modulePath = path.resolve(\n          path.dirname(runtime.__mockRootPath),\n          'require-by-name.js',\n        );\n        const requireByName = runtime.requireModule(modulePath);\n        expect(requireByName(OPTIMIZED_MODULE_EXAMPLE)).not.toBe(\n          require(OPTIMIZED_MODULE_EXAMPLE),\n        );\n      }));\n    it('loads internal modules from outside if on the optimization list', () =>\n      createRuntime(__filename).then(runtime => {\n        const modulePath = path.resolve(\n          path.dirname(runtime.__mockRootPath),\n          'require-by-name.js',\n        );\n        const requireByName = runtime.requireInternalModule(modulePath);\n        expect(requireByName(OPTIMIZED_MODULE_EXAMPLE)).toBe(\n          require(OPTIMIZED_MODULE_EXAMPLE),\n        );\n      }));\n  });\n});"}
{"prompt":"Runtime,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nlet createRuntime;\n\ndescribe('Runtime', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  describe('jest.fn', () => {\n    it('creates mock functions', async () => {\n      const runtime = await createRuntime(__filename);\n      const root = runtime.requireModule(runtime.__mockRootPath);\n      const mock = root.jest.fn();\n      expect(mock._isMockFunction).toBe(true);\n      mock();\n      expect(mock).toHaveBeenCalled();\n    });\n\n    it('creates mock functions with mock implementations', async () => {\n      const runtime = await createRuntime(__filename);\n      const root = runtime.requireModule(runtime.__mockRootPath);\n      const mock = root.jest.fn(string => `${string} implementation`);\n      expect(mock._isMockFunction).toBe(true);\n      const value = mock('mock');\n      expect(value).toBe('mock implementation');\n      expect(mock).toHaveBeenCalled();\n    });\n  });\n\n  describe('jest.isMockFunction', () => {\n    it('recognizes a mocked function', async () => {\n      const runtime = await createRuntime(__filename);\n      const root = runtime.requireModule(runtime.__mockRootPath);\n      const mock = root.jest.fn();\n      expect(root.jest.isMockFunction(() => {})).toBe(false);\n      expect(root.jest.isMockFunction(mock)).toBe(true);\n    });\n  });\n\n  describe('jest.clearAllMocks', () => {\n    it('clears all mocks', async () => {\n      const runtime = await createRuntime(__filename);\n      const root = runtime.requireModule(runtime.__mockRootPath);\n\n      const mock1 = root.jest.fn();\n      mock1();\n\n      const mock2 = root.jest.fn();\n      mock2();\n\n      expect(mock1).toHaveBeenCalled();\n      expect(mock2).toHaveBeenCalled();\n\n      runtime.clearAllMocks();\n\n      expect(mock1).not.toHaveBeenCalled();\n      expect(mock2).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('jest.isEnvironmentTornDown()', () => {\n    it('should be set to true when the environment is torn down', async () => {\n      const runtime = await createRuntime(__filename);\n      const root = runtime.requireModule(runtime.__mockRootPath);\n      expect(root.jest.isEnvironmentTornDown()).toBe(false);\n      runtime.teardown();\n      expect(root.jest.isEnvironmentTornDown()).toBe(true);\n    });\n  });\n\n  describe('jest.isolateModules', () => {\n    it('isolates the modules', async () => {\n      const runtime = await createRuntime(__filename);\n      const root = runtime.requireModule(runtime.__mockRootPath);\n      root.jest.isolateModules(() => {\n        const exports = runtime.requireModuleOrMock(\n          runtime.__mockRootPath,\n          'ModuleWithState',\n        );\n        expect(exports.getState()).toBe(1);\n        exports.increment();\n        expect(exports.getState()).toBe(2);\n      });\n\n      root.jest.isolateModules(() => {\n        const exports = runtime.requireModuleOrMock(\n          runtime.__mockRootPath,\n          'ModuleWithState',\n        );\n        expect(exports.getState()).toBe(1);\n        exports.increment();\n        expect(exports.getState()).toBe(2);\n      });\n    });\n  });\n\n  describe('jest.isolateModulesAsync', () => {\n    it('isolates the modules', async () => {\n      const runtime = await createRuntime(__filename);\n      const root = runtime.requireModule(runtime.__mockRootPath);\n      await root.jest.isolateModulesAsync(async () => {\n        const exports = runtime.requireModuleOrMock(\n          runtime.__mockRootPath,\n          'ModuleWithState',\n        );\n        expect(exports.getState()).toBe(1);\n        exports.increment();\n        expect(exports.getState()).toBe(2);\n      });\n\n      await root.jest.isolateModulesAsync(async () => {\n        const exports = runtime.requireModuleOrMock(\n          runtime.__mockRootPath,\n          'ModuleWithState',\n        );\n        expect(exports.getState()).toBe(1);\n        exports.increment();\n        expect(exports.getState()).toBe(2);\n      });\n    });\n  });\n});"}
{"prompt":"Runtime,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nlet createRuntime;\nlet obj;\n\ndescribe('Runtime', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n\n    obj = {\n      property: 1,\n    };\n  });\n\n  describe('jest.replaceProperty', () => {\n    it('should work', async () => {\n      const runtime = await createRuntime(__filename);\n      const root = runtime.requireModule(runtime.__mockRootPath);\n      const mocked = root.jest.replaceProperty(obj, 'property', 2);\n      expect(obj.property).toBe(2);\n\n      mocked.replaceValue(3);\n      expect(obj.property).toBe(3);\n\n      mocked.restore();\n      expect(obj.property).toBe(1);\n    });\n  });\n});"}
{"prompt":"Runtime,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nlet createRuntime;\n\ndescribe('Runtime', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  describe('jest.spyOn', () => {\n    it('calls the original function', async () => {\n      const runtime = await createRuntime(__filename);\n      const root = runtime.requireModule(runtime.__mockRootPath);\n\n      let isOriginalCalled = false;\n      const obj = {\n        method: () => {\n          isOriginalCalled = true;\n        },\n      };\n\n      const spy = root.jest.spyOn(obj, 'method');\n\n      obj.method();\n\n      expect(isOriginalCalled).toBe(true);\n      expect(spy).toHaveBeenCalled();\n    });\n  });\n\n  describe('jest.spyOnProperty', () => {\n    it('calls the original function', async () => {\n      const runtime = await createRuntime(__filename);\n      const root = runtime.requireModule(runtime.__mockRootPath);\n\n      let isOriginalCalled = false;\n      const obj = {\n        get method() {\n          return () => (isOriginalCalled = true);\n        },\n      };\n\n      const spy = root.jest.spyOn(obj, 'method', 'get');\n\n      obj.method();\n\n      expect(isOriginalCalled).toBe(true);\n      expect(spy).toHaveBeenCalled();\n    });\n  });\n});"}
{"prompt":"Runtime,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nconst path = require('path');\n\nlet createRuntime;\n\nconst rootJsPath = path.join('.', path.sep, 'root');\n\ndescribe('Runtime', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  describe('jest.mock', () => {\n    it('uses explicitly set mocks instead of automocking', async () => {\n      const runtime = await createRuntime(__filename);\n      const mockReference = {isMock: true};\n      const root = runtime.requireModule(runtime.__mockRootPath, rootJsPath);\n      // Erase module registry because root.js requires most other modules.\n      root.jest.resetModules();\n\n      root.jest.mock('RegularModule', () => mockReference);\n      root.jest.mock('ManuallyMocked', () => mockReference);\n      root.jest.mock('nested1/nested2/nested3');\n\n      expect(\n        runtime.requireModuleOrMock(runtime.__mockRootPath, 'RegularModule'),\n      ).toEqual(mockReference);\n\n      expect(\n        runtime.requireModuleOrMock(runtime.__mockRootPath, 'ManuallyMocked'),\n      ).toEqual(mockReference);\n\n      expect(\n        runtime.requireModuleOrMock(\n          runtime.__mockRootPath,\n          'nested1/nested2/nested3',\n        ),\n      ).toEqual(mockReference);\n    });\n\n    it('sets virtual mock for non-existing module required from same directory', async () => {\n      const runtime = await createRuntime(__filename);\n      const mockReference = {isVirtualMock: true};\n      const virtual = true;\n      const root = runtime.requireModule(runtime.__mockRootPath, rootJsPath);\n      // Erase module registry because root.js requires most other modules.\n      root.jest.resetModules();\n\n      root.jest.mock('NotInstalledModule', () => mockReference, {virtual});\n      root.jest.mock('../ManuallyMocked', () => mockReference, {virtual});\n      root.jest.mock('/AbsolutePath/Mock', () => mockReference, {virtual});\n\n      expect(\n        runtime.requireModuleOrMock(\n          runtime.__mockRootPath,\n          'NotInstalledModule',\n        ),\n      ).toEqual(mockReference);\n\n      expect(\n        runtime.requireModuleOrMock(\n          runtime.__mockRootPath,\n          '../ManuallyMocked',\n        ),\n      ).toEqual(mockReference);\n\n      expect(\n        runtime.requireModuleOrMock(\n          runtime.__mockRootPath,\n          '/AbsolutePath/Mock',\n        ),\n      ).toEqual(mockReference);\n    });\n\n    it('sets virtual mock for non-existing module required from different directory', async () => {\n      const runtime = await createRuntime(__filename);\n      const mockReference = {isVirtualMock: true};\n      const virtual = true;\n      const root = runtime.requireModule(runtime.__mockRootPath, rootJsPath);\n      // Erase module registry because root.js requires most other modules.\n      root.jest.resetModules();\n\n      root.jest.mock('NotInstalledModule', () => mockReference, {virtual});\n      root.jest.mock('../ManuallyMocked', () => mockReference, {virtual});\n      root.jest.mock('/AbsolutePath/Mock', () => mockReference, {virtual});\n\n      expect(\n        runtime.requireModuleOrMock(\n          runtime.__mockSubdirPath,\n          'NotInstalledModule',\n        ),\n      ).toEqual(mockReference);\n\n      expect(\n        runtime.requireModuleOrMock(\n          runtime.__mockSubdirPath,\n          '../../../ManuallyMocked',\n        ),\n      ).toEqual(mockReference);\n\n      expect(\n        runtime.requireModuleOrMock(\n          runtime.__mockSubdirPath,\n          '/AbsolutePath/Mock',\n        ),\n      ).toEqual(mockReference);\n    });\n  });\n\n  describe('jest.setMock', () => {\n    it('uses explicitly set mocks instead of automocking', async () => {\n      const runtime = await createRuntime(__filename);\n      const mockReference = {isMock: true};\n      const root = runtime.requireModule(runtime.__mockRootPath, rootJsPath);\n      // Erase module registry because root.js requires most other modules.\n      root.jest.resetModules();\n\n      root.jest.setMock('RegularModule', mockReference);\n      root.jest.setMock('ManuallyMocked', mockReference);\n\n      expect(\n        runtime.requireModuleOrMock(runtime.__mockRootPath, 'RegularModule'),\n      ).toBe(mockReference);\n\n      expect(\n        runtime.requireModuleOrMock(runtime.__mockRootPath, 'ManuallyMocked'),\n      ).toBe(mockReference);\n    });\n  });\n\n  describe('jest.onGenerateMock', () => {\n    it('calls single callback and returns transformed value', async () => {\n      const runtime = await createRuntime(__filename);\n      const mockReference = {isMock: true};\n      const root = runtime.requireModule(runtime.__mockRootPath, rootJsPath);\n      // Erase module registry because root.js requires most other modules.\n      root.jest.resetModules();\n\n      const onGenerateMock = jest.fn((moduleName, moduleMock) => mockReference);\n\n      root.jest.onGenerateMock(onGenerateMock);\n      root.jest.mock('RegularModule');\n      root.jest.mock('ManuallyMocked');\n\n      expect(\n        runtime.requireModuleOrMock(runtime.__mockRootPath, 'RegularModule'),\n      ).toEqual(mockReference);\n      expect(onGenerateMock).toHaveBeenCalledWith(\n        'RegularModule',\n        expect.anything(),\n      );\n\n      onGenerateMock.mockReset();\n\n      expect(\n        runtime.requireModuleOrMock(runtime.__mockRootPath, 'ManuallyMocked'),\n      ).not.toEqual(mockReference);\n      expect(onGenerateMock).not.toHaveBeenCalled();\n    });\n\n    it('calls multiple callback and returns transformed value', async () => {\n      const runtime = await createRuntime(__filename);\n      const root = runtime.requireModule(runtime.__mockRootPath, rootJsPath);\n      // Erase module registry because root.js requires most other modules.\n      root.jest.resetModules();\n\n      const onGenerateMock1 = jest.fn((moduleName, moduleMock) => ({\n        isMock: true,\n        value: 1,\n      }));\n\n      const onGenerateMock2 = jest.fn((moduleName, moduleMock) => ({\n        ...moduleMock,\n        value: moduleMock.value + 1,\n      }));\n\n      const onGenerateMock3 = jest.fn((moduleName, moduleMock) => ({\n        ...moduleMock,\n        value: moduleMock.value ** 2,\n      }));\n\n      root.jest.onGenerateMock(onGenerateMock1);\n      root.jest.onGenerateMock(onGenerateMock2);\n      root.jest.onGenerateMock(onGenerateMock3);\n      root.jest.mock('RegularModule');\n      root.jest.mock('ManuallyMocked');\n\n      expect(\n        runtime.requireModuleOrMock(runtime.__mockRootPath, 'RegularModule'),\n      ).toEqual({\n        isMock: true,\n        value: 4,\n      });\n      expect(onGenerateMock1).toHaveBeenCalledWith(\n        'RegularModule',\n        expect.anything(),\n      );\n      expect(onGenerateMock2).toHaveBeenCalledWith('RegularModule', {\n        isMock: true,\n        value: 1,\n      });\n      expect(onGenerateMock3).toHaveBeenCalledWith('RegularModule', {\n        isMock: true,\n        value: 2,\n      });\n    });\n  });\n});"}
{"prompt":"Runtime,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nconst path = require('path');\n\nconst moduleDirectories = ['module_dir'];\n\nlet createRuntime;\nlet rootDir;\n\ndescribe('Runtime', () => {\n  beforeEach(() => {\n    rootDir = path.resolve(path.dirname(__filename), 'test_root');\n    createRuntime = require('createRuntime');\n  });\n\n  it('uses configured moduleDirectories', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleDirectories,\n    });\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      'module_dir_module',\n    );\n    expect(exports).toBeDefined();\n  });\n\n  it('resolves packages', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleDirectories,\n    });\n    const exports = runtime.requireModule(runtime.__mockRootPath, 'my-module');\n    expect(exports.isNodeModule).toBe(true);\n  });\n\n  it('finds closest module from moduleDirectories', async () => {\n    const runtime = await createRuntime(__filename, {moduleDirectories});\n    const exports = runtime.requireModule(\n      path.join(rootDir, 'subdir2', 'my_module.js'),\n      'module_dir_module',\n    );\n    expect(exports.modulePath).toBe('subdir2/module_dir/module_dir_module.js');\n  });\n\n  it('only checks the configured directories', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleDirectories,\n    });\n    expect(() => {\n      runtime.requireModule(runtime.__mockRootPath, 'not-a-haste-package');\n    }).toThrow(\n      new Error(\"Cannot find module 'not-a-haste-package' from 'root.js'\"),\n    );\n  });\n});"}
{"prompt":"Runtime,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nconst path = require('path');\n\nconst cwd = process.cwd();\n\nlet createLocalRuntime;\n\ndescribe('Runtime', () => {\n  beforeEach(() => {\n    jest.resetModules();\n\n    createLocalRuntime = (nodePath, config) => {\n      process.env.NODE_PATH = nodePath;\n      const createRuntime = require('createRuntime');\n      return createRuntime(__filename, config);\n    };\n  });\n\n  it('uses NODE_PATH to find modules', async () => {\n    const nodePath = `${__dirname}/NODE_PATH_dir`;\n    const runtime = await createLocalRuntime(nodePath);\n    const exports = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'regular_module_in_node_path',\n    );\n    expect(exports).toBeDefined();\n  });\n\n  it('uses modulePaths to find modules', async () => {\n    const nodePath = `${__dirname}/NODE_PATH_dir`;\n    const runtime = await createLocalRuntime(null, {modulePaths: [nodePath]});\n    const exports = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'regular_module_in_node_path',\n    );\n    expect(exports).toBeDefined();\n  });\n\n  it('finds modules in NODE_PATH containing multiple paths', async () => {\n    const nodePath = `${cwd}/some/other/path${path.delimiter}${__dirname}/NODE_PATH_dir`;\n    const runtime = await createLocalRuntime(nodePath);\n    const exports = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'regular_module_in_node_path',\n    );\n    expect(exports).toBeDefined();\n  });\n\n  it('does not find modules if NODE_PATH is relative', async () => {\n    const nodePath = `${cwd.slice(\n      path.sep.length,\n    )}src/Runtime/__tests__/NODE_PATH_dir`;\n    const runtime = await createLocalRuntime(nodePath);\n    expect(() => {\n      runtime.requireModuleOrMock(\n        runtime.__mockRootPath,\n        'regular_module_in_node_path',\n      );\n    }).toThrow(\n      new Error(\n        \"Cannot find module 'regular_module_in_node_path' from 'root.js'\",\n      ),\n    );\n  });\n});"}
{"prompt":"Runtime requireActual,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nlet createRuntime;\n\ndescribe('Runtime requireActual', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  it('requires node module when manual mock exists', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireActual(\n      runtime.__mockRootPath,\n      'mocked-node-module',\n    );\n    expect(exports.isManualMockModule).toBe(false);\n  });\n\n  test('requireActual with moduleNameMapper', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper: {\n        '^testMapped/(.*)': '<rootDir>/mapped_dir/$1',\n      },\n    });\n    const exports = runtime.requireActual(\n      runtime.__mockRootPath,\n      'testMapped/moduleInMapped',\n    );\n    expect(exports).toBe('in_mapped');\n  });\n});"}
{"prompt":"Runtime require.cache,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nlet createRuntime;\n\ndescribe('Runtime require.cache', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  it('require.cache returns loaded module list as native Nodejs require does', async () => {\n    const runtime = await createRuntime(__filename);\n    const regularModule = runtime.requireModule(\n      runtime.__mockRootPath,\n      'RegularModule',\n    ).module;\n    const id = regularModule.id;\n    const cache = regularModule.require.cache;\n\n    expect(cache[id]).toBe(regularModule);\n    expect(id in cache).toBeTruthy();\n    expect(Object.keys(cache).includes(id)).toBeTruthy();\n    expect(Object.getOwnPropertyNames(cache).includes(id)).toBeTruthy();\n  });\n\n  it('require.cache is tolerant readonly', async () => {\n    const runtime = await createRuntime(__filename);\n    const regularModule = runtime.requireModule(\n      runtime.__mockRootPath,\n      'RegularModule',\n    ).module;\n\n    delete regularModule.require.cache[regularModule.id];\n    expect(regularModule.require.cache[regularModule.id]).toBe(regularModule);\n\n    regularModule.require.cache[regularModule.id] = 'something';\n    expect(regularModule.require.cache[regularModule.id]).toBe(regularModule);\n  });\n});"}
{"prompt":"Runtime,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nlet createRuntime;\nconst consoleWarn = console.warn;\n\ndescribe('Runtime', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  afterEach(() => {\n    console.warn = consoleWarn;\n  });\n\n  describe('requireMock', () => {\n    it('uses manual mocks before attempting to automock', async () => {\n      const runtime = await createRuntime(__filename);\n      const exports = runtime.requireMock(\n        runtime.__mockRootPath,\n        'ManuallyMocked',\n      );\n      expect(exports.isManualMockModule).toBe(true);\n    });\n\n    it('can resolve modules that are only referenced from mocks', async () => {\n      const runtime = await createRuntime(__filename);\n      const exports = runtime.requireMock(\n        runtime.__mockRootPath,\n        'ManuallyMocked',\n      );\n      expect(exports.onlyRequiredFromMockModuleValue).toBe(\n        'banana banana banana',\n      );\n    });\n\n    it('stores and re-uses manual mock exports', async () => {\n      const runtime = await createRuntime(__filename);\n      let exports = runtime.requireMock(\n        runtime.__mockRootPath,\n        'ManuallyMocked',\n      );\n      exports.setModuleStateValue('test value');\n      exports = runtime.requireMock(runtime.__mockRootPath, 'ManuallyMocked');\n      expect(exports.getModuleStateValue()).toBe('test value');\n    });\n\n    it('automocks haste modules without a manual mock', async () => {\n      const runtime = await createRuntime(__filename);\n      const exports = runtime.requireMock(\n        runtime.__mockRootPath,\n        'RegularModule',\n      );\n      expect(exports.getModuleStateValue._isMockFunction).toBe(true);\n    });\n\n    it('automocks relative-path modules without a file extension', async () => {\n      const runtime = await createRuntime(__filename);\n      const exports = runtime.requireMock(\n        __filename,\n        './test_root/RegularModule',\n      );\n      expect(exports.getModuleStateValue._isMockFunction).toBe(true);\n    });\n\n    it('automocks relative-path modules with a file extension', async () => {\n      const runtime = await createRuntime(__filename);\n      const exports = runtime.requireMock(\n        __filename,\n        './test_root/RegularModule.js',\n      );\n      expect(exports.getModuleStateValue._isMockFunction).toBe(true);\n    });\n\n    it('just falls back when loading a native module', async () => {\n      const runtime = await createRuntime(__filename);\n      let error;\n      // Okay so this is a really WAT way to test this, but we\n      // are going to require an empty .node file which should\n      // throw an error letting us know that the file is too\n      // short. If it does not (it gives another error) then we\n      // are not correctly falling back to 'native' require.\n      try {\n        runtime.requireMock(__filename, './test_root/NativeModule.node');\n      } catch (thrownError) {\n        error = thrownError;\n      } finally {\n        expect(error.message).toMatch(\n          /NativeModule.node: file too short|NativeModule.node, 0x0001|not a valid Win\\d+ application/,\n        );\n      }\n    });\n\n    it('stores and re-uses automocked haste exports', async () => {\n      const runtime = await createRuntime(__filename);\n      let exports = runtime.requireMock(\n        runtime.__mockRootPath,\n        'RegularModule',\n      );\n      exports.externalMutation = 'test value';\n      exports = runtime.requireMock(runtime.__mockRootPath, 'RegularModule');\n      expect(exports.externalMutation).toBe('test value');\n    });\n\n    it('stores and re-uses automocked relative-path modules', async () => {\n      const runtime = await createRuntime(__filename);\n      let exports = runtime.requireMock(\n        __filename,\n        './test_root/RegularModule',\n      );\n      exports.externalMutation = 'test value';\n      exports = runtime.requireMock(__filename, './test_root/RegularModule');\n      expect(exports.externalMutation).toBe('test value');\n    });\n\n    it('multiple node core modules returns correct module', async () => {\n      const runtime = await createRuntime(__filename);\n      runtime.requireMock(runtime.__mockRootPath, 'fs');\n      expect(\n        runtime.requireMock(runtime.__mockRootPath, 'events').EventEmitter,\n      ).toBeDefined();\n    });\n\n    it('throws on non-existent haste modules', async () => {\n      const runtime = await createRuntime(__filename);\n      expect(() => {\n        runtime.requireMock(runtime.__mockRootPath, 'DoesntExist');\n      }).toThrow(\"Cannot find module 'DoesntExist' from 'root.js'\");\n    });\n\n    it('uses manual mocks when using a custom resolver', async () => {\n      const runtime = await createRuntime(__filename, {\n        // using the default resolver as a custom resolver\n        resolver: require.resolve('./defaultResolver.js'),\n      });\n      const exports = runtime.requireMock(\n        runtime.__mockRootPath,\n        './ManuallyMocked',\n      );\n\n      expect(exports.isManualMockModule).toBe(true);\n    });\n\n    it('provides `require.main` in mock', async () => {\n      const runtime = await createRuntime(__filename);\n      runtime.setMock(__filename, 'export_main', () => module, {\n        virtual: true,\n      });\n      const mainModule = runtime.requireMock(__filename, 'export_main');\n      expect(mainModule).toBe(module);\n    });\n  });\n});"}
{"prompt":"Runtime requireModule,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nimport {builtinModules, createRequire} from 'module';\nimport * as path from 'path';\nimport {pathToFileURL} from 'url';\nimport slash from 'slash';\n\nlet createRuntime;\n\ndescribe('Runtime requireModule', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  it('finds haste modules', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      'RegularModule',\n    );\n    expect(exports.isRealModule).toBe(true);\n  });\n\n  it('provides `module` to modules', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      'RegularModule',\n    );\n    expect(Object.keys(exports.module)).toEqual([\n      'children',\n      'exports',\n      'filename',\n      'id',\n      'isPreloading',\n      'loaded',\n      'path',\n      'parent',\n      'paths',\n      'main',\n    ]);\n  });\n\n  it('provides `module.parent` to modules', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      'RequireRegularModule',\n    );\n    expect(Object.keys(exports.parent)).toEqual([\n      'children',\n      'exports',\n      'filename',\n      'id',\n      'isPreloading',\n      'loaded',\n      'path',\n      'parent',\n      'paths',\n      'main',\n    ]);\n  });\n\n  it('`module.parent` should be undefined for entrypoints', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      'RegularModule',\n    );\n    expect(exports.parent).toBeNull();\n  });\n\n  it('resolve module.parent.require correctly', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      'inner_parent_module',\n    );\n    expect(exports.outputString).toBe('This should happen');\n  });\n\n  it('resolve module.parent.filename correctly', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      'inner_parent_module',\n    );\n\n    expect(slash(exports.parentFileName.replace(__dirname, ''))).toBe(\n      '/test_root/inner_parent_module.js',\n    );\n  });\n\n  it('provides `module.loaded` to modules', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      'RegularModule',\n    );\n\n    // `exports.loaded` is set while the module is loaded, so should be `false`\n    expect(exports.loaded).toBe(false);\n    // After the module is loaded we can query `module.loaded` again, at which point it should be `true`\n    expect(exports.isLoaded()).toBe(true);\n  });\n\n  it('provides `module.filename` to modules', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      'RegularModule',\n    );\n    expect(\n      exports.filename.endsWith(`test_root${path.sep}RegularModule.js`),\n    ).toBe(true);\n  });\n\n  it('provides `module.paths` to modules', async () => {\n    const altModuleDir = 'bower_components';\n    const moduleDirectories = ['node_modules', altModuleDir];\n\n    const runtime = await createRuntime(__filename, {moduleDirectories});\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      'RegularModule',\n    );\n    expect(exports.paths.length).toBeGreaterThan(0);\n    const root = path.parse(process.cwd()).root;\n    const globalPath = path.join(root, 'node_modules');\n    const rootIndex = exports.paths.indexOf(globalPath);\n    for (const [index, path] of exports.paths.entries()) {\n      if (index <= rootIndex) {\n        expect(moduleDirectories.some(dir => path.endsWith(dir))).toBe(true);\n      }\n    }\n  });\n\n  it('provides `require.main` to modules', async () => {\n    const runtime = await createRuntime(__filename);\n    runtime._mainModule = module;\n    for (const modulePath of [\n      './test_root/modules_with_main/export_main.js',\n      './test_root/modules_with_main/re_export_main.js',\n    ]) {\n      const mainModule = runtime.requireModule(__filename, modulePath);\n      expect(mainModule).toBe(module);\n    }\n  });\n\n  it('throws on non-existent haste modules', async () => {\n    const runtime = await createRuntime(__filename);\n    expect(() => {\n      runtime.requireModule(runtime.__mockRootPath, 'DoesntExist');\n    }).toThrow(new Error(\"Cannot find module 'DoesntExist' from 'root.js'\"));\n  });\n\n  it('finds relative-path modules without file extension', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      './RegularModule',\n    );\n    expect(exports.isRealModule).toBe(true);\n  });\n\n  it('finds relative-path modules with file extension', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      './RegularModule.js',\n    );\n    expect(exports.isRealModule).toBe(true);\n  });\n\n  it('throws on non-existent relative-path modules', async () => {\n    const runtime = await createRuntime(__filename);\n    expect(() => {\n      runtime.requireModule(runtime.__mockRootPath, './DoesntExist');\n    }).toThrow(new Error(\"Cannot find module './DoesntExist' from 'root.js'\"));\n  });\n\n  it('finds node core built-in modules', async () => {\n    const runtime = await createRuntime(__filename);\n    expect(() => {\n      runtime.requireModule(runtime.__mockRootPath, 'fs');\n    }).not.toThrow();\n  });\n\n  it('finds node core built-in modules with node:prefix', async () => {\n    const runtime = await createRuntime(__filename);\n\n    expect(runtime.requireModule(runtime.__mockRootPath, 'fs')).toBe(\n      runtime.requireModule(runtime.__mockRootPath, 'node:fs'),\n    );\n    expect(runtime.requireModule(runtime.__mockRootPath, 'module')).toBe(\n      runtime.requireModule(runtime.__mockRootPath, 'node:module'),\n    );\n  });\n\n  it('finds and loads JSON files without file extension', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(runtime.__mockRootPath, './JSONFile');\n    expect(exports.isJSONModule).toBe(true);\n  });\n\n  it('finds and loads JSON files with file extension', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      './JSONFile.json',\n    );\n    expect(exports.isJSONModule).toBe(true);\n  });\n\n  it('requires a JSON file twice successfully', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports1 = runtime.requireModule(\n      runtime.__mockRootPath,\n      './JSONFile.json',\n    );\n    const exports2 = runtime.requireModule(\n      runtime.__mockRootPath,\n      './JSONFile.json',\n    );\n    expect(exports1.isJSONModule).toBe(true);\n    expect(exports2.isJSONModule).toBe(true);\n    expect(exports1).toBe(exports2);\n  });\n\n  it(\"provides manual mock when real module doesn't exist\", async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      'ExclusivelyManualMock',\n    );\n    expect(exports.isExclusivelyManualMockModule).toBe(true);\n  });\n\n  it(\"doesn't override real modules with manual mocks when explicitly unmocked\", async () => {\n    const runtime = await createRuntime(__filename, {\n      automock: true,\n    });\n    const root = runtime.requireModule(runtime.__mockRootPath, './root.js');\n    root.jest.resetModules();\n    root.jest.unmock('ManuallyMocked');\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      'ManuallyMocked',\n    );\n    expect(exports.isManualMockModule).toBe(false);\n  });\n\n  it('resolves haste packages properly', async () => {\n    const runtime = await createRuntime(__filename);\n    const hastePackage = runtime.requireModule(\n      runtime.__mockRootPath,\n      'haste-package/core/module',\n    );\n    expect(hastePackage.isHastePackage).toBe(true);\n  });\n\n  it('resolves platform extensions based on the default platform', async () => {\n    await Promise.all([\n      createRuntime(__filename).then(runtime => {\n        const exports = runtime.requireModule(\n          runtime.__mockRootPath,\n          'Platform',\n        );\n\n        expect(exports.platform).toBe('default');\n      }),\n      createRuntime(__filename, {\n        haste: {\n          defaultPlatform: 'ios',\n          platforms: ['ios', 'android'],\n        },\n      }).then(runtime => {\n        const exports = runtime.requireModule(\n          runtime.__mockRootPath,\n          'Platform',\n        );\n\n        expect(exports.platform).toBe('ios');\n      }),\n      createRuntime(__filename, {\n        haste: {\n          platforms: ['ios', 'android'],\n        },\n      }).then(runtime => {\n        const exports = runtime.requireModule(\n          runtime.__mockRootPath,\n          'Platform',\n        );\n\n        expect(exports.platform).toBe('default');\n      }),\n      createRuntime(__filename, {\n        haste: {\n          defaultPlatform: 'android',\n          platforms: ['ios', 'android'],\n        },\n      }).then(runtime => {\n        const exports = runtime.requireModule(\n          runtime.__mockRootPath,\n          'Platform',\n        );\n\n        expect(exports.platform).toBe('android');\n      }),\n      createRuntime(__filename, {\n        haste: {\n          defaultPlatform: 'windows',\n          platforms: ['ios', 'android', 'native', 'windows'],\n        },\n      }).then(runtime => {\n        const exports = runtime.requireModule(\n          runtime.__mockRootPath,\n          'Platform',\n        );\n\n        // We prefer `native` over the default module if the default one\n        // cannot be found.\n        expect(exports.platform).toBe('native');\n      }),\n    ]);\n  });\n\n  it('finds modules encoded in UTF-8 *with BOM*', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      './utf8_with_bom.js',\n    );\n    expect(exports).toBe('isModuleEncodedInUTF8WithBOM');\n  });\n\n  it('finds and loads JSON files encoded in UTF-8 *with BOM*', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(\n      runtime.__mockRootPath,\n      './utf8_with_bom.json',\n    );\n    expect(exports.isJSONModuleEncodedInUTF8WithBOM).toBe(true);\n  });\n\n  it('should export a constructable Module class', async () => {\n    const runtime = await createRuntime(__filename);\n    const Module = runtime.requireModule(runtime.__mockRootPath, 'module');\n\n    expect(() => new Module()).not.toThrow();\n  });\n\n  it('caches Module correctly', async () => {\n    const runtime = await createRuntime(__filename);\n    const Module1 = runtime.requireModule(runtime.__mockRootPath, 'module');\n    const Module2 = runtime.requireModule(runtime.__mockRootPath, 'module');\n\n    expect(Module1).toBe(Module2);\n  });\n\n  it('does not cache modules that throw during evaluation', async () => {\n    const runtime = await createRuntime(__filename);\n    expect(() =>\n      runtime.requireModule(runtime.__mockRootPath, 'throwing'),\n    ).toThrow('throwing');\n    expect(() =>\n      runtime.requireModule(runtime.__mockRootPath, 'throwing'),\n    ).toThrow('throwing');\n  });\n\n  it('overrides module.createRequire', async () => {\n    const runtime = await createRuntime(__filename);\n    const exports = runtime.requireModule(runtime.__mockRootPath, 'module');\n\n    expect(exports.createRequire).not.toBe(createRequire);\n\n    // createRequire with string\n    {\n      const customRequire = exports.createRequire(runtime.__mockRootPath);\n      expect(customRequire('./create_require_module').foo).toBe('foo');\n    }\n\n    // createRequire with URL object\n    {\n      const customRequire = exports.createRequire(\n        pathToFileURL(runtime.__mockRootPath),\n      );\n      expect(customRequire('./create_require_module').foo).toBe('foo');\n    }\n\n    // createRequire with file URL string\n    {\n      const customRequire = exports.createRequire(\n        pathToFileURL(runtime.__mockRootPath).toString(),\n      );\n      expect(customRequire('./create_require_module').foo).toBe('foo');\n    }\n\n    // createRequire with absolute module path\n    {\n      const customRequire = exports.createRequire(runtime.__mockRootPath);\n      expect(customRequire('./create_require_module').foo).toBe('foo');\n    }\n\n    expect(exports.syncBuiltinESMExports).not.toThrow();\n    expect(exports.builtinModules).toEqual(builtinModules);\n  });\n});"}
{"prompt":"Runtime requireModule with no extension,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nlet createRuntime;\n\ndescribe('Runtime requireModule with no extension', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  it('throws error pointing out file with extension', async () => {\n    const runtime = await createRuntime(__filename);\n\n    expect(() =>\n      runtime.requireModuleOrMock(\n        runtime.__mockRootPath,\n        'RegularModuleWithWrongExt',\n      ),\n    ).toThrowErrorMatchingSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Runtime requireModule with no extension throws error pointing out file with extension 1`] = `\n\"Cannot find module 'RegularModuleWithWrongExt' from 'root.js'\n\nHowever, Jest was able to find:\n\t'./RegularModuleWithWrongExt.txt'\n\nYou might want to include a file extension in your import, or update your 'moduleFileExtensions', which is currently ['js', 'jsx', 'ts', 'tsx', 'json', 'node'].\n\nSee https://jestjs.io/docs/configuration#modulefileextensions-arraystring\"\n`;"}
{"prompt":"mocks modules by default when using automocking, async  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nconst moduleNameMapper = {\n  '\\\\.css$': '<rootDir>/__mocks__/ManuallyMocked',\n  '^[./a-zA-Z0-9$_-]+.png$': 'RelativeImageStub',\n  '^image![a-zA-Z0-9$_-]+$': 'global_image_stub',\n  mappedToDirectory: '<rootDir>/MyDirectoryModule',\n  mappedToModule: '<rootDir>/TestModuleNameMapperResolution',\n  mappedToPath: '<rootDir>/global_image_stub.js',\n  'module/name/(.*)': '<rootDir>/mapped_module_$1.js',\n};\n\nlet createRuntime;\n\nbeforeEach(() => {\n  createRuntime = require('createRuntime');\n});\n\nit('mocks modules by default when using automocking', async () => {\n  const runtime = await createRuntime(__filename, {\n    automock: true,\n    moduleNameMapper,\n  });\n  const exports = runtime.requireModuleOrMock(\n    runtime.__mockRootPath,\n    'RegularModule',\n  );\n  expect(exports.setModuleStateValue._isMockFunction).toBe(true);\n});\n\nit(\"doesn't mock modules when explicitly unmocked when using automocking\", async () => {\n  const runtime = await createRuntime(__filename, {\n    automock: true,\n    moduleNameMapper,\n  });\n  const root = runtime.requireModule(runtime.__mockRootPath);\n  root.jest.unmock('RegularModule');\n  const exports = runtime.requireModuleOrMock(\n    runtime.__mockRootPath,\n    'RegularModule',\n  );\n  expect(exports.isRealModule).toBe(true);\n});\n\nit(\"doesn't mock modules when explicitly unmocked via a different name\", async () => {\n  const runtime = await createRuntime(__filename, {\n    automock: true,\n    moduleNameMapper,\n  });\n  const root = runtime.requireModule(runtime.__mockRootPath);\n  root.jest.unmock('./RegularModule');\n  const exports = runtime.requireModuleOrMock(\n    runtime.__mockRootPath,\n    'RegularModule',\n  );\n  expect(exports.isRealModule).toBe(true);\n});\n\nit(\"doesn't mock modules when disableAutomock() has been called\", async () => {\n  const runtime = await createRuntime(__filename, {moduleNameMapper});\n  const root = runtime.requireModule(runtime.__mockRootPath);\n  root.jest.disableAutomock();\n  const exports = runtime.requireModuleOrMock(\n    runtime.__mockRootPath,\n    'RegularModule',\n  );\n  expect(exports.isRealModule).toBe(true);\n});\n\nit('uses manual mock when automocking on and mock is available', async () => {\n  const runtime = await createRuntime(__filename, {\n    automock: true,\n    moduleNameMapper,\n  });\n  const exports = runtime.requireModuleOrMock(\n    runtime.__mockRootPath,\n    'ManuallyMocked',\n  );\n  expect(exports.isManualMockModule).toBe(true);\n});\n\nit('does not use manual mock when automocking is off and a real module is available', async () => {\n  const runtime = await createRuntime(__filename, {moduleNameMapper});\n  const root = runtime.requireModule(runtime.__mockRootPath);\n  root.jest.disableAutomock();\n  const exports = runtime.requireModuleOrMock(\n    runtime.__mockRootPath,\n    'ManuallyMocked',\n  );\n  expect(exports.isManualMockModule).toBe(false);\n});\n\nit('resolves mapped module names and unmocks them by default', async () => {\n  const runtime = await createRuntime(__filename, {\n    moduleFileExtensions: ['js', 'jsx'],\n    moduleNameMapper,\n  });\n  let exports = runtime.requireModuleOrMock(\n    runtime.__mockRootPath,\n    'image!not_really_a_module',\n  );\n  expect(exports.isGlobalImageStub).toBe(true);\n  exports = runtime.requireModuleOrMock(runtime.__mockRootPath, 'mappedToPath');\n  expect(exports.isGlobalImageStub).toBe(true);\n\n  exports = runtime.requireModuleOrMock(\n    runtime.__mockRootPath,\n    'mappedToModule',\n  );\n  expect(exports.moduleNameMapperResolutionWorks).toBe(true);\n\n  exports = runtime.requireModuleOrMock(\n    runtime.__mockRootPath,\n    'mappedToDirectory',\n  );\n  expect(exports.isIndex).toBe(true);\n\n  exports = runtime.requireModuleOrMock(runtime.__mockRootPath, 'cat.png');\n  expect(exports.isRelativeImageStub).toBe(true);\n\n  exports = runtime.requireModuleOrMock(\n    runtime.__mockRootPath,\n    '../photos/dog.png',\n  );\n  expect(exports.isRelativeImageStub).toBe(true);\n\n  exports = runtime.requireModuleOrMock(\n    runtime.__mockRootPath,\n    'module/name/test',\n  );\n  expect(exports).toBe('mapped_module');\n\n  exports = runtime.requireModuleOrMock(\n    runtime.__mockRootPath,\n    'subdir1/style.css',\n  );\n  expect(exports.isManualMockModule).toBe(true);\n});\n\nit('automocking is disabled by default', async () => {\n  const runtime = await createRuntime(__filename, {\n    moduleNameMapper,\n  });\n  const exports = runtime.requireModuleOrMock(\n    runtime.__mockRootPath,\n    'RegularModule',\n  );\n  expect(exports.setModuleStateValue._isMockFunction).toBeUndefined();\n});\n\nit('unmocks modules in config.unmockedModulePathPatterns for tests with automock enabled when automock is false', async () => {\n  const runtime = await createRuntime(__filename, {\n    automock: false,\n    moduleNameMapper,\n    unmockedModulePathPatterns: ['npm3-main-dep'],\n  });\n  const root = runtime.requireModule(runtime.__mockRootPath);\n  root.jest.enableAutomock();\n  const nodeModule = runtime.requireModuleOrMock(\n    runtime.__mockRootPath,\n    'npm3-main-dep',\n  );\n  const moduleData = nodeModule();\n  expect(moduleData.isUnmocked()).toBe(true);\n});\n\nit('unmocks virtual mocks after they have been mocked previously', async () => {\n  const runtime = await createRuntime(__filename);\n  const root = runtime.requireModule(runtime.__mockRootPath);\n\n  const mockImpl = {foo: 'bar'};\n  root.jest.mock('my-virtual-module', () => mockImpl, {virtual: true});\n\n  expect(\n    runtime.requireModuleOrMock(runtime.__mockRootPath, 'my-virtual-module'),\n  ).toEqual(mockImpl);\n\n  root.jest.unmock('my-virtual-module');\n\n  expect(() => {\n    runtime.requireModuleOrMock(runtime.__mockRootPath, 'my-virtual-module');\n  }).toThrow(\n    new Error(\"Cannot find module 'my-virtual-module' from 'root.js'\"),\n  );\n});\n\ndescribe('resetModules', () => {\n  it('resets all the modules', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper,\n    });\n    let exports = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'ModuleWithState',\n    );\n    expect(exports.getState()).toBe(1);\n    exports.increment();\n    expect(exports.getState()).toBe(2);\n    runtime.resetModules();\n    exports = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'ModuleWithState',\n    );\n    expect(exports.getState()).toBe(1);\n  });\n});\n\ndescribe('isolateModules', () => {\n  it('keeps its registry isolated from global one', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper,\n    });\n    let exports;\n    exports = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'ModuleWithState',\n    );\n    exports.increment();\n    expect(exports.getState()).toBe(2);\n\n    runtime.isolateModules(() => {\n      exports = runtime.requireModuleOrMock(\n        runtime.__mockRootPath,\n        'ModuleWithState',\n      );\n      expect(exports.getState()).toBe(1);\n    });\n\n    exports = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'ModuleWithState',\n    );\n    expect(exports.getState()).toBe(2);\n  });\n\n  it('resets all modules after the block', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper,\n    });\n    let exports;\n    runtime.isolateModules(() => {\n      exports = runtime.requireModuleOrMock(\n        runtime.__mockRootPath,\n        'ModuleWithState',\n      );\n      expect(exports.getState()).toBe(1);\n      exports.increment();\n      expect(exports.getState()).toBe(2);\n    });\n\n    exports = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'ModuleWithState',\n    );\n    expect(exports.getState()).toBe(1);\n  });\n\n  it('resets module after failing', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper,\n    });\n    expect(() =>\n      runtime.isolateModules(() => {\n        throw new Error('Error from isolated module');\n      }),\n    ).toThrow('Error from isolated module');\n\n    runtime.isolateModules(() => {\n      expect(true).toBe(true);\n    });\n  });\n\n  it('cannot nest isolateModules blocks', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper,\n    });\n    expect(() => {\n      runtime.isolateModules(() => {\n        runtime.isolateModules(() => {});\n      });\n    }).toThrow(\n      'isolateModules cannot be nested inside another isolateModules or isolateModulesAsync.',\n    );\n  });\n\n  it('can call resetModules within a isolateModules block', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper,\n    });\n    let exports;\n    runtime.isolateModules(() => {\n      exports = runtime.requireModuleOrMock(\n        runtime.__mockRootPath,\n        'ModuleWithState',\n      );\n      expect(exports.getState()).toBe(1);\n\n      exports.increment();\n      runtime.resetModules();\n\n      exports = runtime.requireModuleOrMock(\n        runtime.__mockRootPath,\n        'ModuleWithState',\n      );\n      expect(exports.getState()).toBe(1);\n    });\n\n    exports = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'ModuleWithState',\n    );\n    expect(exports.getState()).toBe(1);\n  });\n\n  describe('can use isolateModules from a beforeEach block', () => {\n    let exports;\n    beforeEach(() => {\n      jest.isolateModules(() => {\n        exports = require('./test_root/ModuleWithState');\n        exports.set(1); // Ensure idempotency with the isolateModulesAsync test\n      });\n    });\n\n    it('can use the required module from beforeEach and re-require it', () => {\n      expect(exports.getState()).toBe(1);\n      exports.increment();\n      expect(exports.getState()).toBe(2);\n\n      exports = require('./test_root/ModuleWithState');\n      expect(exports.getState()).toBe(1);\n      exports.increment();\n      expect(exports.getState()).toBe(2);\n    });\n  });\n});\n\ndescribe('isolateModulesAsync', () => {\n  it('keeps its registry isolated from global one', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper,\n    });\n    let exports;\n    exports = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'ModuleWithState',\n    );\n    exports.increment();\n    expect(exports.getState()).toBe(2);\n\n    await runtime.isolateModulesAsync(async () => {\n      exports = runtime.requireModuleOrMock(\n        runtime.__mockRootPath,\n        'ModuleWithState',\n      );\n      expect(exports.getState()).toBe(1);\n    });\n\n    exports = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'ModuleWithState',\n    );\n    expect(exports.getState()).toBe(2);\n  });\n\n  it('resets all modules after the block', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper,\n    });\n    let exports;\n    await runtime.isolateModulesAsync(async () => {\n      exports = runtime.requireModuleOrMock(\n        runtime.__mockRootPath,\n        'ModuleWithState',\n      );\n      expect(exports.getState()).toBe(1);\n      exports.increment();\n      expect(exports.getState()).toBe(2);\n    });\n\n    exports = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'ModuleWithState',\n    );\n    expect(exports.getState()).toBe(1);\n  });\n\n  it('resets module after failing', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper,\n    });\n    await expect(\n      runtime.isolateModulesAsync(async () => {\n        throw new Error('Error from isolated module');\n      }),\n    ).rejects.toThrow('Error from isolated module');\n\n    await runtime.isolateModulesAsync(async () => {\n      expect(true).toBe(true);\n    });\n  });\n\n  it('cannot nest isolateModulesAsync blocks', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper,\n    });\n    await expect(async () => {\n      await runtime.isolateModulesAsync(async () => {\n        await runtime.isolateModulesAsync(() => Promise.resolve());\n      });\n    }).rejects.toThrow(\n      'isolateModulesAsync cannot be nested inside another isolateModulesAsync or isolateModules.',\n    );\n  });\n\n  it('can call resetModules within a isolateModules block', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper,\n    });\n    let exports;\n    await runtime.isolateModulesAsync(async () => {\n      exports = runtime.requireModuleOrMock(\n        runtime.__mockRootPath,\n        'ModuleWithState',\n      );\n      expect(exports.getState()).toBe(1);\n\n      exports.increment();\n      runtime.resetModules();\n\n      exports = runtime.requireModuleOrMock(\n        runtime.__mockRootPath,\n        'ModuleWithState',\n      );\n      expect(exports.getState()).toBe(1);\n    });\n\n    exports = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'ModuleWithState',\n    );\n    expect(exports.getState()).toBe(1);\n  });\n\n  describe('can use isolateModulesAsync from a beforeEach block', () => {\n    let exports;\n    beforeEach(async () => {\n      await jest.isolateModulesAsync(async () => {\n        exports = require('./test_root/ModuleWithState');\n        exports.set(1); // Ensure idempotency with the isolateModules test\n      });\n    });\n\n    it('can use the required module from beforeEach and re-require it', () => {\n      expect(exports.getState()).toBe(1);\n      exports.increment();\n      expect(exports.getState()).toBe(2);\n\n      exports = require('./test_root/ModuleWithState');\n      expect(exports.getState()).toBe(2);\n      exports.increment();\n      expect(exports.getState()).toBe(3);\n    });\n  });\n});"}
{"prompt":"transitive dependencies,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nlet createRuntime;\n\nconst moduleNameMapper = {\n  '^[./a-zA-Z0-9$_-]+.png$': 'RelativeImageStub',\n  '^image![a-zA-Z0-9$_-]+$': 'global_image_stub',\n  '^testMapped/(.*)': '<rootDir>/mapped_dir/$1',\n  mappedToDirectory: '<rootDir>/MyDirectoryModule',\n  mappedToPath: '<rootDir>/global_image_stub.js',\n  'module/name/(.*)': '<rootDir>/mapped_module_$1.js',\n};\n\nbeforeEach(() => {\n  jest.resetModules();\n\n  createRuntime = require('createRuntime');\n});\n\ndescribe('transitive dependencies', () => {\n  const expectUnmocked = nodeModule => {\n    const moduleData = nodeModule();\n    expect(moduleData.isUnmocked()).toBe(true);\n    expect(moduleData.transitiveNPM3Dep).toBe('npm3-transitive-dep');\n    expect(moduleData.internalImplementation()).toBe('internal-module-code');\n  };\n\n  it('mocks a manually mocked and mapped module', async () => {\n    const runtime = await createRuntime(__filename, {\n      automock: false,\n      moduleNameMapper,\n    });\n    runtime.setMock(\n      __filename,\n      './test_root/mapped_dir/moduleInMapped',\n      () => 'mocked_in_mapped',\n    );\n\n    const parentDep = runtime.requireModule(\n      runtime.__mockRootPath,\n      './dep_on_mapped_module.js',\n    );\n    expect(parentDep).toEqual({result: 'mocked_in_mapped'});\n  });\n\n  it('unmocks transitive dependencies in node_modules by default', async () => {\n    const runtime = await createRuntime(__filename, {\n      automock: true,\n      moduleNameMapper,\n      unmockedModulePathPatterns: ['npm3-main-dep'],\n    });\n    const root = runtime.requireModule(runtime.__mockRootPath, './root.js');\n    expectUnmocked(\n      runtime.requireModuleOrMock(runtime.__mockRootPath, 'npm3-main-dep'),\n    );\n\n    // Test twice to make sure Runtime caching works properly\n    root.jest.resetModules();\n    expectUnmocked(\n      runtime.requireModuleOrMock(runtime.__mockRootPath, 'npm3-main-dep'),\n    );\n\n    // Directly requiring the transitive dependency will mock it\n    const transitiveDep = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'npm3-transitive-dep',\n    );\n    expect(transitiveDep()).toBeUndefined();\n  });\n\n  it('unmocks transitive dependencies in node_modules when using unmock', async () => {\n    const runtime = await createRuntime(__filename, {\n      automock: true,\n      moduleNameMapper,\n    });\n    const root = runtime.requireModule(runtime.__mockRootPath);\n    root.jest.unmock('npm3-main-dep');\n    expectUnmocked(\n      runtime.requireModuleOrMock(runtime.__mockRootPath, 'npm3-main-dep'),\n    );\n\n    // Test twice to make sure Runtime caching works properly\n    root.jest.resetModules();\n    expectUnmocked(\n      runtime.requireModuleOrMock(runtime.__mockRootPath, 'npm3-main-dep'),\n    );\n\n    // Directly requiring the transitive dependency will mock it\n    const transitiveDep = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'npm3-transitive-dep',\n    );\n    expect(transitiveDep()).toBeUndefined();\n  });\n\n  it('unmocks transitive dependencies in node_modules by default when using both patterns and unmock', async () => {\n    const runtime = await createRuntime(__filename, {\n      automock: true,\n      moduleNameMapper,\n      unmockedModulePathPatterns: ['banana-module'],\n    });\n    const root = runtime.requireModule(runtime.__mockRootPath);\n    root.jest.unmock('npm3-main-dep');\n    expectUnmocked(\n      runtime.requireModuleOrMock(runtime.__mockRootPath, 'npm3-main-dep'),\n    );\n\n    // Test twice to make sure Runtime caching works properly\n    root.jest.resetModules();\n    expectUnmocked(\n      runtime.requireModuleOrMock(runtime.__mockRootPath, 'npm3-main-dep'),\n    );\n\n    // Directly requiring the transitive dependency will mock it\n    const transitiveDep = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'npm3-transitive-dep',\n    );\n    expect(transitiveDep()).toBeUndefined();\n  });\n\n  it('mocks deep dependencies when using unmock', async () => {\n    const runtime = await createRuntime(__filename, {\n      automock: true,\n      moduleNameMapper,\n    });\n    const root = runtime.requireModule(runtime.__mockRootPath, './root.js');\n    root.jest.unmock('FooContainer.react');\n\n    const FooContainer = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'FooContainer.react',\n    );\n\n    expect(new FooContainer().render().indexOf('5')).toBe(-1);\n  });\n\n  it('does not mock deep dependencies when using deepUnmock', async () => {\n    const runtime = await createRuntime(__filename, {moduleNameMapper});\n    const root = runtime.requireModule(runtime.__mockRootPath, './root.js');\n    root.jest.deepUnmock('FooContainer.react');\n\n    const FooContainer = runtime.requireModuleOrMock(\n      runtime.__mockRootPath,\n      'FooContainer.react',\n    );\n\n    expect(new FooContainer().render().indexOf('5')).not.toBe(-1);\n  });\n});"}
{"prompt":"Runtime require.resolve,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as os from 'os';\nimport * as path from 'path';\nimport {promises as fs} from 'graceful-fs';\nimport type {Config} from '@jest/types';\nimport type Runtime from '..';\nimport {createOutsideJestVmPath} from '../helpers';\n\nlet createRuntime: (\n  path: string,\n  config?: Config.InitialOptions,\n) => Promise<Runtime & {__mockRootPath: string}>;\n\nconst getTmpDir = async () =>\n  fs.mkdtemp(path.join(os.tmpdir(), 'jest-resolve-test-'));\n\ndescribe('Runtime require.resolve', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  it('resolves a module path', async () => {\n    const runtime = await createRuntime(__filename);\n    const resolved = runtime.requireModule(\n      runtime.__mockRootPath,\n      './resolve_self.js',\n    );\n    expect(resolved).toEqual(require.resolve('./test_root/resolve_self.js'));\n  });\n\n  it('resolves an absolute module path', async () => {\n    const absoluteFilePath = path.join(await getTmpDir(), 'test.js');\n    await fs.writeFile(\n      absoluteFilePath,\n      'module.exports = require.resolve(__filename);',\n      'utf8',\n    );\n\n    const runtime = await createRuntime(__filename);\n    const resolved = runtime.requireModule(\n      runtime.__mockRootPath,\n      absoluteFilePath,\n    );\n\n    expect(resolved).toEqual(require.resolve(absoluteFilePath));\n  });\n\n  it('required modules can resolve absolute module paths with no paths entries passed', async () => {\n    const tmpdir = await getTmpDir();\n    const entrypoint = path.join(tmpdir, 'test.js');\n    const target = path.join(tmpdir, 'target.js');\n\n    // we want to test the require.resolve implementation within a\n    // runtime-required module, so we need to create a module that then resolves\n    // an absolute path, so we need two files: the entrypoint, and an absolute\n    // target to require.\n    await fs.writeFile(\n      entrypoint,\n      `module.exports = require.resolve(${JSON.stringify(\n        target,\n      )}, {paths: []});`,\n      'utf8',\n    );\n\n    await fs.writeFile(target, 'module.exports = {}', 'utf8');\n\n    const runtime = await createRuntime(__filename);\n    const resolved = runtime.requireModule(runtime.__mockRootPath, entrypoint);\n    expect(resolved).toEqual(require.resolve(target, {paths: []}));\n  });\n\n  it('resolves a module path with moduleNameMapper', async () => {\n    const runtime = await createRuntime(__filename, {\n      moduleNameMapper: {\n        '^testMapped/(.*)': '<rootDir>/mapped_dir/$1',\n      },\n    });\n    const resolved = runtime.requireModule(\n      runtime.__mockRootPath,\n      './resolve_mapped.js',\n    );\n    expect(resolved).toEqual(\n      require.resolve('./test_root/mapped_dir/moduleInMapped.js'),\n    );\n  });\n\n  describe('with the jest-resolve-outside-vm-option', () => {\n    it('forwards to the real Node require in an internal context', async () => {\n      const runtime = await createRuntime(__filename);\n      const module = runtime.requireInternalModule(\n        runtime.__mockRootPath,\n        './resolve_and_require_outside.js',\n      );\n      expect(module.required).toBe(\n        require('./test_root/create_require_module'),\n      );\n    });\n\n    it('ignores the option in an external context', async () => {\n      const runtime = await createRuntime(__filename);\n      const module = runtime.requireModule(\n        runtime.__mockRootPath,\n        './resolve_and_require_outside.js',\n      );\n      expect(module.required.foo).toBe('foo');\n      expect(module.required).not.toBe(\n        require('./test_root/create_require_module'),\n      );\n    });\n\n    // make sure we also check isInternal during require, not just during resolve\n    it('does not understand a self-constructed outsideJestVmPath in an external context', async () => {\n      const runtime = await createRuntime(__filename);\n      expect(() =>\n        runtime.requireModule(\n          runtime.__mockRootPath,\n          createOutsideJestVmPath(\n            require.resolve('./test_root/create_require_module.js'),\n          ),\n        ),\n      ).toThrow(/cannot find.+create_require_module/i);\n    });\n  });\n});"}
{"prompt":"Runtime,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nlet createRuntime;\n\ndescribe('Runtime', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  describe('resetModules', () => {\n    it('does not throw when accessing _isMockFunction on an unsafe global', async () => {\n      const runtime = await createRuntime(__filename);\n      runtime._environment.global.UNSAFE_GLOBAL = new Proxy(\n        {},\n        {\n          get(target, p, receiver) {\n            if (p === '_isMockFunction') throw new Error('Unsafe global!');\n          },\n        },\n      );\n      expect(() => runtime.resetModules()).not.toThrow();\n    });\n  });\n});"}
{"prompt":"Runtime,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet createRuntime;\n\ndescribe('Runtime', () => {\n  beforeEach(() => {\n    createRuntime = require('createRuntime');\n  });\n\n  describe('wrapCodeInModuleWrapper', () => {\n    it('generates the correct args for the module wrapper', async () => {\n      const runtime = await createRuntime(__filename);\n\n      expect(\n        runtime.wrapCodeInModuleWrapper('module.exports = \"Hello!\"'),\n      ).toMatchSnapshot();\n    });\n\n    it('injects \"extra globals\"', async () => {\n      const runtime = await createRuntime(__filename, {\n        sandboxInjectedGlobals: ['Math'],\n      });\n\n      expect(\n        runtime.wrapCodeInModuleWrapper('module.exports = \"Hello!\"'),\n      ).toMatchSnapshot();\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Runtime wrapCodeInModuleWrapper generates the correct args for the module wrapper 1`] = `\n\"({\"Object.<anonymous>\":function(module,exports,require,__dirname,__filename,jest){module.exports = \"Hello!\"\n}});\"\n`;\n\nexports[`Runtime wrapCodeInModuleWrapper injects \"extra globals\" 1`] = `\n\"({\"Object.<anonymous>\":function(module,exports,require,__dirname,__filename,jest,Math){module.exports = \"Hello!\"\n}});\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('mts extension', () => {\n  expect(1).toBe(1);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('cts extension', () => {\n  expect(1).toBe(1);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, createEmptyPackage, writeFiles} from '../Utils';\nimport {json as runJest} from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'extra-globals');\n\nbeforeEach(() => {\n  cleanup(DIR);\n  createEmptyPackage(DIR, {jest: {sandboxInjectedGlobals: ['Math']}});\n});\n\nafterAll(() => cleanup(DIR));\n\ntest('works with injected globals', () => {\n  writeFiles(DIR, {\n    'test.js': `\n       test('Math works when injected', () => {\n         expect(Math.floor(1.5)).toBe(1);\n       });\n  `,\n  });\n\n  const {exitCode} = runJest(DIR);\n\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nrequire('@myorg/pkg');"}
{"prompt":"Bad preprocessor","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport type {Config} from '@jest/types';\nimport type {\n  AsyncTransformer,\n  FixedRawSourceMap,\n  Options,\n  ReducedTransformOptions,\n  ShouldInstrumentOptions,\n  SyncTransformer,\n  TransformedSource,\n  Transformer,\n  TransformerFactory,\n} from '../types';\n\njest\n  .mock('graceful-fs', () => ({\n    ...jest.requireActual<typeof import('graceful-fs')>('graceful-fs'),\n    /* eslint-disable sort-keys */\n    readFileSync: jest.fn((path: string, options: string) => {\n      mockInvariant(typeof path === 'string');\n\n      expect(options).toBe('utf8');\n      if (mockFs[path]) {\n        return mockFs[path];\n      }\n\n      throw new Error(`Cannot read path '${path}'.`);\n    }),\n    writeFileSync: jest.fn<typeof import('fs').writeFileSync>(\n      (path, data, options) => {\n        mockInvariant(typeof path === 'string');\n        mockInvariant(typeof data === 'string');\n        expect(options).toBe('utf8');\n        mockFs[path] = data;\n      },\n    ),\n\n    unlinkSync: jest.fn<typeof import('fs').unlinkSync>(),\n    statSync: jest.fn<typeof import('fs').statSync>(path => ({\n      isFile() {\n        mockInvariant(typeof path === 'string');\n        return !!mockFs[path];\n      },\n      mtime: {getTime: () => 42, toString: () => '42'},\n    })),\n\n    existsSync: jest.fn<typeof import('fs').existsSync>(path => {\n      mockInvariant(typeof path === 'string');\n\n      return !!mockFs[path];\n    }),\n    /* eslint-enable */\n  }))\n  .mock('jest-haste-map', () => ({\n    getStatic() {\n      return {\n        getCacheFilePath: (cacheDir: string, baseDir: string) =>\n          cacheDir + baseDir,\n      };\n    },\n  }))\n  .mock('jest-util', () => ({\n    ...jest.requireActual<typeof import('jest-util')>('jest-util'),\n    createDirectory: jest.fn(),\n  }))\n  .mock('path', () => jest.requireActual<typeof import('path')>('path').posix);\n\njest.mock(\n  'test_preprocessor',\n  () => {\n    const transformer: Transformer = {\n      getCacheKey: jest.fn(() => 'ab'),\n      process: (content, filename, config) => ({\n        code: (require('dedent') as typeof import('dedent').default)`\n          const TRANSFORMED = {\n            filename: '${filename}',\n            script: '${content}',\n            config: '${JSON.stringify(config)}',\n          };\n        `,\n      }),\n    };\n\n    return transformer;\n  },\n  {virtual: true},\n);\n\njest.mock(\n  'test_async_preprocessor',\n  () => {\n    const transformer: AsyncTransformer = {\n      getCacheKeyAsync: jest.fn(() => Promise.resolve('ab')),\n      processAsync: (content, filename, config) =>\n        Promise.resolve({\n          code: (require('dedent') as typeof import('dedent').default)`\n          const TRANSFORMED = {\n            filename: '${filename}',\n            script: '${content}',\n            config: '${JSON.stringify(config)}',\n          };\n        `,\n        }),\n    };\n\n    return transformer;\n  },\n  {virtual: true},\n);\n\njest.mock(\n  'configureable-preprocessor',\n  () => ({\n    createTransformer: jest.fn(() => ({\n      process: jest.fn().mockReturnValue({code: 'processedCode'}),\n    })),\n  }),\n  {virtual: true},\n);\n\njest.mock(\n  'cache_fs_preprocessor',\n  () => {\n    const syncTransformer: SyncTransformer = {\n      getCacheKey: jest.fn(() => 'ab'),\n      process: jest.fn(() => ({code: 'processedCode'})),\n    };\n    return syncTransformer;\n  },\n  {virtual: true},\n);\n\njest.mock(\n  'cache_fs_async_preprocessor',\n  () => {\n    const asyncTransformer: AsyncTransformer = {\n      getCacheKeyAsync: jest.fn(() => Promise.resolve('ab')),\n      processAsync: jest.fn(() => Promise.resolve({code: 'processedCode'})),\n    };\n    return asyncTransformer;\n  },\n  {virtual: true},\n);\n\njest.mock(\n  'preprocessor-with-sourcemaps',\n  () => ({\n    getCacheKey: jest.fn(() => 'ab'),\n    process: jest.fn(),\n  }),\n  {virtual: true},\n);\n\njest.mock(\n  'async-preprocessor-with-sourcemaps',\n  () => ({\n    getCacheKeyAsync: jest.fn(() => 'ab'),\n    processAsync: jest.fn(),\n  }),\n  {virtual: true},\n);\n\njest.mock(\n  'css-preprocessor',\n  () => {\n    const transformer: Transformer = {\n      getCacheKey: jest.fn(() => 'cd'),\n      process: (content, filename) => ({\n        code: (require('dedent') as typeof import('dedent').default)`\n          module.exports = {\n            filename: ${filename},\n            rawFirstLine: ${content.split('\\n')[0]},\n          };\n        `,\n      }),\n    };\n\n    return transformer;\n  },\n  {virtual: true},\n);\n\njest.mock('passthrough-preprocessor', () => ({process: jest.fn()}), {\n  virtual: true,\n});\n\n// Bad preprocessor\njest.mock('skipped-required-props-preprocessor', () => ({}), {virtual: true});\n\n// Bad preprocessor\njest.mock(\n  'skipped-required-props-preprocessor-only-sync',\n  () => ({process: () => ({code: ''})}),\n  {virtual: true},\n);\n\n// Bad preprocessor\njest.mock(\n  'skipped-required-props-preprocessor-only-async',\n  () => ({processAsync: () => Promise.resolve({code: ''})}),\n  {virtual: true},\n);\n\n// Bad preprocessor\njest.mock(\n  'skipped-required-create-transformer-props-preprocessor',\n  () => ({\n    createTransformer() {\n      return {};\n    },\n  }),\n  {virtual: true},\n);\n\njest.mock(\n  'skipped-process-method-preprocessor',\n  () => ({\n    createTransformer() {\n      return {process: jest.fn().mockReturnValue({code: 'code'})};\n    },\n  }),\n  {virtual: true},\n);\n\njest.mock(\n  'async-factory',\n  () => ({\n    createTransformer() {\n      return Promise.resolve({\n        process: jest.fn().mockReturnValue({code: 'code'}),\n      });\n    },\n  }),\n  {virtual: true},\n);\n\njest.mock(\n  'factory-for-async-preprocessor',\n  () => {\n    const transformer: AsyncTransformer = {\n      processAsync: jest.fn(() => Promise.resolve({code: 'code'})),\n    };\n    return {\n      createTransformer() {\n        return transformer;\n      },\n    };\n  },\n  {virtual: true},\n);\n\nconst getCachePath = (\n  mockFs: Record<string, string>,\n  config: Config.ProjectConfig,\n) => {\n  for (const path in mockFs) {\n    if (path.startsWith(config.cacheDirectory)) {\n      return path;\n    }\n  }\n  return null;\n};\n\nlet createScriptTransformer: typeof import('../ScriptTransformer').createScriptTransformer;\nlet config: Config.ProjectConfig;\nlet fs: typeof import('fs');\nlet mockFs: Record<string, string>;\nlet object: <T>(input: T) => T;\nlet writeFileAtomic: typeof import('write-file-atomic');\n\njest.mock('write-file-atomic', () => ({\n  sync: jest.fn<typeof import('write-file-atomic').sync>((filePath, data) => {\n    mockInvariant(typeof data === 'string');\n    mockFs[filePath] = data;\n  }),\n}));\n\ndescribe('ScriptTransformer', () => {\n  const reset = () => {\n    jest.resetModules();\n\n    object = data =>\n      Object.assign(Object.create(null) as Record<string, unknown>, data);\n\n    mockFs = object({\n      '/fruits/avocado.js': ['module.exports = \"avocado\";'].join('\\n'),\n      '/fruits/banana.js': ['module.exports = \"banana\";'].join('\\n'),\n      '/fruits/banana:colon.js': ['module.exports = \"bananaColon\";'].join('\\n'),\n      '/fruits/grapefruit.js': [\n        'module.exports = function () { return \"grapefruit\"; }',\n      ].join('\\n'),\n      '/fruits/kiwi.js': ['module.exports = () => \"kiwi\";'].join('\\n'),\n      '/fruits/mango.js': ['module.exports = () => \"mango\";'].join('\\n'),\n      '/fruits/package.json': ['{\"name\": \"fruits\"}'].join('\\n'),\n      '/node_modules/react.js': ['module.exports = \"react\";'].join('\\n'),\n      '/styles/App.css': ['root {', '  font-family: Helvetica;', '}'].join(\n        '\\n',\n      ),\n    });\n\n    fs = require('graceful-fs') as typeof import('fs');\n\n    writeFileAtomic =\n      require('write-file-atomic') as typeof import('write-file-atomic');\n\n    config = makeProjectConfig({\n      cache: true,\n      cacheDirectory: '/cache/',\n      id: 'test',\n      rootDir: '/',\n      transformIgnorePatterns: ['/node_modules/'],\n    });\n\n    createScriptTransformer = (\n      require('../ScriptTransformer') as typeof import('../ScriptTransformer')\n    ).createScriptTransformer;\n  };\n\n  beforeEach(reset);\n  afterEach(() => {\n    jest.unmock('../shouldInstrument');\n  });\n\n  it('transforms a file properly', async () => {\n    const scriptTransformer = await createScriptTransformer(config);\n    const transformedBananaWithCoverage = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n\n    expect(transformedBananaWithCoverage.code).toMatchSnapshot();\n\n    // no-cache case\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n\n    // in-memory cache\n    const transformedBananaWithCoverageAgain = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(transformedBananaWithCoverageAgain).toBe(\n      transformedBananaWithCoverage,\n    );\n\n    const transformedKiwiWithCoverage = scriptTransformer.transform(\n      '/fruits/kiwi.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(transformedKiwiWithCoverage.code).toMatchSnapshot();\n\n    expect(transformedBananaWithCoverage.code).not.toEqual(\n      transformedKiwiWithCoverage.code,\n    );\n    expect(transformedBananaWithCoverage.code).not.toMatch(/instrumented kiwi/);\n\n    // If we disable coverage, we get a different result.\n    const transformedKiwiWithoutCoverage = scriptTransformer.transform(\n      '/fruits/kiwi.js',\n      getCoverageOptions({collectCoverage: false}),\n    );\n\n    expect(transformedKiwiWithoutCoverage.code).not.toEqual(\n      transformedKiwiWithCoverage.code,\n    );\n  });\n\n  it('transforms a file async properly', async () => {\n    const scriptTransformer = await createScriptTransformer(config);\n    const transformedBananaWithCoverage =\n      await scriptTransformer.transformAsync(\n        '/fruits/banana.js',\n        getCoverageOptions({collectCoverage: true}),\n      );\n\n    expect(transformedBananaWithCoverage.code).toMatchSnapshot();\n\n    // no-cache case\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n\n    // in-memory cache\n    const transformedBananaWithCoverageAgain =\n      await scriptTransformer.transformAsync(\n        '/fruits/banana.js',\n        getCoverageOptions({collectCoverage: true}),\n      );\n    expect(transformedBananaWithCoverageAgain).toBe(\n      transformedBananaWithCoverage,\n    );\n\n    const transformedKiwiWithCoverage = await scriptTransformer.transformAsync(\n      '/fruits/kiwi.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(transformedKiwiWithCoverage.code).toMatchSnapshot();\n\n    expect(transformedBananaWithCoverage.code).not.toEqual(\n      transformedKiwiWithCoverage.code,\n    );\n    expect(transformedBananaWithCoverage.code).not.toMatch(/instrumented kiwi/);\n\n    // If we disable coverage, we get a different result.\n    const transformedKiwiWithoutCoverage =\n      await scriptTransformer.transformAsync(\n        '/fruits/kiwi.js',\n        getCoverageOptions({collectCoverage: false}),\n      );\n\n    expect(transformedKiwiWithoutCoverage.code).not.toEqual(\n      transformedKiwiWithCoverage.code,\n    );\n  });\n\n  it(\"throws an error if `process` doesn't return an object containing `code` key with processed string\", async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'passthrough-preprocessor', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const incorrectReturnValues = [\n      [undefined, '/fruits/banana.js'],\n      ['code', '/fruits/banana.js'],\n      [{a: 'a'}, '/fruits/kiwi.js'],\n      [[], '/fruits/grapefruit.js'],\n    ];\n\n    for (const [returnValue, filePath] of incorrectReturnValues) {\n      mockInvariant(typeof filePath === 'string');\n      jest\n        .mocked(\n          (require('passthrough-preprocessor') as SyncTransformer).process,\n        )\n        .mockReturnValue(returnValue);\n      expect(() =>\n        scriptTransformer.transform(filePath, getCoverageOptions()),\n      ).toThrowErrorMatchingSnapshot();\n    }\n\n    const correctReturnValues = [[{code: 'code'}, '/fruits/kiwi.js']];\n\n    for (const [returnValue, filePath] of correctReturnValues) {\n      mockInvariant(typeof filePath === 'string');\n      jest\n        .mocked(\n          (require('passthrough-preprocessor') as SyncTransformer).process,\n        )\n        .mockReturnValue(returnValue);\n      expect(() =>\n        scriptTransformer.transform(filePath, getCoverageOptions()),\n      ).not.toThrow();\n    }\n  });\n\n  it(\"throws an error if `processAsync` doesn't return a promise of object containing `code` key with processed string\", async () => {\n    const incorrectReturnValues: Array<[unknown, string]> = [\n      [undefined, '/fruits/banana.js'],\n      ['code', '/fruits/avocado.js'],\n      [{a: 'a'}, '/fruits/kiwi.js'],\n      [[], '/fruits/grapefruit.js'],\n    ];\n\n    const correctReturnValues: Array<[TransformedSource, string]> = [\n      [{code: 'code'}, '/fruits/mango.js'],\n    ];\n\n    const buildPromise = async ([returnValue, filePath]: [\n      TransformedSource,\n      string,\n    ]): Promise<any> => {\n      const processorName = `passthrough-preprocessor${filePath.replaceAll(\n        /\\.|\\//g,\n        '-',\n      )}`;\n\n      jest.doMock(\n        processorName,\n        () => ({\n          processAsync: jest.fn(),\n        }),\n        {virtual: true},\n      );\n      const transformer = require(processorName) as AsyncTransformer;\n      jest.mocked(transformer.processAsync).mockResolvedValue(returnValue);\n\n      config = {\n        ...config,\n        transform: [...incorrectReturnValues, ...correctReturnValues].map(\n          ([_, filePath]) => [filePath, processorName, {}],\n        ),\n      };\n\n      const scriptTransformer = await createScriptTransformer(config);\n\n      return scriptTransformer.transformAsync(filePath, getCoverageOptions());\n    };\n\n    const promisesToReject = incorrectReturnValues\n      .map(buildPromise)\n      .map(promise => expect(promise).rejects.toThrowErrorMatchingSnapshot());\n\n    const promisesToResolve = correctReturnValues\n      .map(buildPromise)\n      .map(promise => expect(promise).resolves.toHaveProperty('code'));\n\n    await Promise.all([...promisesToReject, ...promisesToResolve]);\n  });\n\n  it('throws an error if neither `process` nor `processAsync` is defined', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'skipped-required-props-preprocessor', {}]],\n    };\n    await expect(() =>\n      createScriptTransformer(config),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it(\"(in sync mode) throws an error if `process` isn't defined\", async () => {\n    config = {\n      ...config,\n      transform: [\n        ['\\\\.js$', 'skipped-required-props-preprocessor-only-async', {}],\n      ],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n    expect(() =>\n      scriptTransformer.transformSource(\n        'sample.js',\n        '',\n        getTransformOptions(false),\n      ),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  it('(in async mode) handles only sync `process`', async () => {\n    config = {\n      ...config,\n      transform: [\n        ['\\\\.js$', 'skipped-required-props-preprocessor-only-sync', {}],\n      ],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n    expect(\n      await scriptTransformer.transformSourceAsync(\n        'sample.js',\n        '',\n        getTransformOptions(false),\n      ),\n    ).toBeDefined();\n  });\n\n  it('handle async createTransformer', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'async-factory', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n    expect(\n      await scriptTransformer.transformSourceAsync(\n        'sample.js',\n        '',\n        getTransformOptions(false),\n      ),\n    ).toBeDefined();\n  });\n\n  it('throws an error if createTransformer returns object without `process` method', async () => {\n    config = {\n      ...config,\n      transform: [\n        [\n          '\\\\.js$',\n          'skipped-required-create-transformer-props-preprocessor',\n          {},\n        ],\n      ],\n    };\n    await expect(() =>\n      createScriptTransformer(config),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it(\"shouldn't throw error without process method. But with correct createTransformer method\", async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'skipped-process-method-preprocessor', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n    expect(() =>\n      scriptTransformer.transformSource(\n        'sample.js',\n        '',\n        getTransformOptions(false),\n      ),\n    ).not.toThrow();\n  });\n\n  it(\"in async mode, shouldn't throw if createTransformer returns an preprocessor with `process` or `processAsync`\", async () => {\n    config = {\n      ...config,\n      transform: [\n        ['async-sample.js', 'factory-for-async-preprocessor', {}],\n        ['sync-sample.js', 'skipped-process-method-preprocessor', {}],\n      ],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n    await Promise.all([\n      expect(\n        scriptTransformer.transformSourceAsync(\n          'async-sample.js',\n          '',\n          getTransformOptions(false),\n        ),\n      ).resolves.toBeDefined(),\n      expect(\n        scriptTransformer.transformSourceAsync(\n          'sync-sample.js',\n          '',\n          getTransformOptions(false),\n        ),\n      ).resolves.toBeDefined(),\n    ]);\n  });\n\n  it('uses the supplied preprocessor', async () => {\n    config = {...config, transform: [['\\\\.js$', 'test_preprocessor', {}]]};\n    const scriptTransformer = await createScriptTransformer(config);\n    const res1 = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(\n      (require('test_preprocessor') as SyncTransformer).getCacheKey,\n    ).toHaveBeenCalled();\n\n    expect(res1.code).toMatchSnapshot();\n\n    const res2 = scriptTransformer.transform(\n      '/node_modules/react.js',\n      getCoverageOptions(),\n    );\n    // ignores preprocessor\n    expect(res2.code).toMatchSnapshot();\n  });\n\n  it('in async mode, uses the supplied preprocessor', async () => {\n    config = {...config, transform: [['\\\\.js$', 'test_preprocessor', {}]]};\n    const scriptTransformer = await createScriptTransformer(config);\n    const res1 = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(\n      (require('test_preprocessor') as SyncTransformer).getCacheKey,\n    ).toHaveBeenCalled();\n\n    expect(res1.code).toMatchSnapshot();\n\n    const res2 = await scriptTransformer.transformAsync(\n      '/node_modules/react.js',\n      getCoverageOptions(),\n    );\n    // ignores preprocessor\n    expect(res2.code).toMatchSnapshot();\n  });\n\n  it('in async mode, uses the supplied async preprocessor', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'test_async_preprocessor', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n    const res1 = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(\n      (require('test_async_preprocessor') as AsyncTransformer).getCacheKeyAsync,\n    ).toHaveBeenCalled();\n\n    expect(res1.code).toMatchSnapshot();\n\n    const res2 = await scriptTransformer.transformAsync(\n      '/node_modules/react.js',\n      getCoverageOptions(),\n    );\n    // ignores preprocessor\n    expect(res2.code).toMatchSnapshot();\n  });\n\n  it('uses multiple preprocessors', async () => {\n    config = {\n      ...config,\n      transform: [\n        ['\\\\.js$', 'test_preprocessor', {}],\n        ['\\\\.css$', 'css-preprocessor', {}],\n      ],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const res1 = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    const res2 = scriptTransformer.transform(\n      '/styles/App.css',\n      getCoverageOptions(),\n    );\n\n    expect(\n      (require('test_preprocessor') as SyncTransformer).getCacheKey,\n    ).toHaveBeenCalled();\n    expect(\n      (require('css-preprocessor') as SyncTransformer).getCacheKey,\n    ).toHaveBeenCalled();\n    expect(res1.code).toMatchSnapshot();\n    expect(res2.code).toMatchSnapshot();\n\n    const res3 = scriptTransformer.transform(\n      '/node_modules/react.js',\n      getCoverageOptions(),\n    );\n    // ignores preprocessor\n    expect(res3.code).toMatchSnapshot();\n  });\n\n  it('uses mixture of sync/async preprocessors', async () => {\n    config = {\n      ...config,\n      transform: [\n        ['\\\\.js$', 'test_async_preprocessor', {}],\n        ['\\\\.css$', 'css-preprocessor', {}],\n      ],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const res1 = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    const res2 = await scriptTransformer.transformAsync(\n      '/styles/App.css',\n      getCoverageOptions(),\n    );\n\n    expect(\n      (require('test_async_preprocessor') as AsyncTransformer).getCacheKeyAsync,\n    ).toHaveBeenCalled();\n    expect(\n      (require('css-preprocessor') as SyncTransformer).getCacheKey,\n    ).toHaveBeenCalled();\n    expect(res1.code).toMatchSnapshot();\n    expect(res2.code).toMatchSnapshot();\n\n    const res3 = await scriptTransformer.transformAsync(\n      '/node_modules/react.js',\n      getCoverageOptions(),\n    );\n    // ignores preprocessor\n    expect(res3.code).toMatchSnapshot();\n  });\n\n  it('writes source map if preprocessor supplies it', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const map = {\n      mappings: ';AAAA',\n      version: 3,\n    };\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map,\n      });\n\n    const result = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    const mapStr = JSON.stringify(map);\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      mapStr,\n      {\n        encoding: 'utf8',\n        fsync: false,\n      },\n    );\n  });\n\n  it('in async mode, writes source map if preprocessor supplies it', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const map = {\n      mappings: ';AAAA',\n      version: 3,\n    };\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    const mapStr = JSON.stringify(map);\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      mapStr,\n      {\n        encoding: 'utf8',\n        fsync: false,\n      },\n    );\n  });\n\n  it('in async mode, writes source map if async preprocessor supplies it', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'async-preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const map = {\n      mappings: ';AAAA',\n      version: 3,\n    };\n\n    jest\n      .mocked(\n        (require('async-preprocessor-with-sourcemaps') as AsyncTransformer)\n          .processAsync,\n      )\n      .mockResolvedValue({\n        code: 'content',\n        map,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    const mapStr = JSON.stringify(map);\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      mapStr,\n      {\n        encoding: 'utf8',\n        fsync: false,\n      },\n    );\n  });\n\n  it('writes source map if preprocessor inlines it', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const sourceMap = JSON.stringify({\n      mappings: 'AAAA,IAAM,CAAC,GAAW,CAAC,CAAC',\n      version: 3,\n    });\n\n    const content =\n      'var x = 1;\\n' +\n      `//# sourceMappingURL=data:application/json;base64,${Buffer.from(\n        sourceMap,\n      ).toString('base64')}`;\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: content,\n      });\n\n    const result = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      sourceMap,\n      {encoding: 'utf8', fsync: false},\n    );\n  });\n\n  it('in async mode, writes source map if preprocessor inlines it', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const sourceMap = JSON.stringify({\n      mappings: 'AAAA,IAAM,CAAC,GAAW,CAAC,CAAC',\n      version: 3,\n    });\n\n    const content =\n      'var x = 1;\\n' +\n      `//# sourceMappingURL=data:application/json;base64,${Buffer.from(\n        sourceMap,\n      ).toString('base64')}`;\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: content,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      sourceMap,\n      {encoding: 'utf8', fsync: false},\n    );\n  });\n\n  it('writes source map if async preprocessor inlines it', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'async-preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const sourceMap = JSON.stringify({\n      mappings: 'AAAA,IAAM,CAAC,GAAW,CAAC,CAAC',\n      version: 3,\n    });\n\n    const content =\n      'var x = 1;\\n' +\n      `//# sourceMappingURL=data:application/json;base64,${Buffer.from(\n        sourceMap,\n      ).toString('base64')}`;\n\n    jest\n      .mocked(\n        (require('async-preprocessor-with-sourcemaps') as AsyncTransformer)\n          .processAsync,\n      )\n      .mockResolvedValue({code: content});\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      sourceMap,\n      {encoding: 'utf8', fsync: false},\n    );\n  });\n\n  it('warns of unparseable inlined source maps from the preprocessor', async () => {\n    const warn = console.warn;\n    console.warn = jest.fn();\n\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const sourceMap = JSON.stringify({\n      mappings: 'AAAA,IAAM,CAAC,GAAW,CAAC,CAAC',\n      version: 3,\n    });\n\n    // Cut off the inlined map prematurely with slice so the JSON ends abruptly\n    const content =\n      'var x = 1;\\n' +\n      `//# sourceMappingURL=data:application/json;base64,${Buffer.from(\n        sourceMap,\n      )\n        .toString('base64')\n        .slice(0, 16)}`;\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: content,\n      });\n\n    const result = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toBeNull();\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(1);\n\n    expect(console.warn).toHaveBeenCalledTimes(1);\n    expect(jest.mocked(console.warn).mock.calls[0][0]).toMatchSnapshot();\n    console.warn = warn;\n  });\n\n  it('in async mode, warns of unparseable inlined source maps from the preprocessor', async () => {\n    const warn = console.warn;\n    console.warn = jest.fn();\n\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const sourceMap = JSON.stringify({\n      mappings: 'AAAA,IAAM,CAAC,GAAW,CAAC,CAAC',\n      version: 3,\n    });\n\n    // Cut off the inlined map prematurely with slice so the JSON ends abruptly\n    const content =\n      'var x = 1;\\n' +\n      `//# sourceMappingURL=data:application/json;base64,${Buffer.from(\n        sourceMap,\n      )\n        .toString('base64')\n        .slice(0, 16)}`;\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: content,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toBeNull();\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(1);\n\n    expect(console.warn).toHaveBeenCalledTimes(1);\n    expect(jest.mocked(console.warn).mock.calls[0][0]).toMatchSnapshot();\n    console.warn = warn;\n  });\n\n  it('warns of unparseable inlined source maps from the async preprocessor', async () => {\n    const warn = console.warn;\n    console.warn = jest.fn();\n\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'async-preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const sourceMap = JSON.stringify({\n      mappings: 'AAAA,IAAM,CAAC,GAAW,CAAC,CAAC',\n      version: 3,\n    });\n\n    // Cut off the inlined map prematurely with slice so the JSON ends abruptly\n    const content =\n      'var x = 1;\\n' +\n      `//# sourceMappingURL=data:application/json;base64,${Buffer.from(\n        sourceMap,\n      )\n        .toString('base64')\n        .slice(0, 16)}`;\n\n    jest\n      .mocked(\n        (require('async-preprocessor-with-sourcemaps') as AsyncTransformer)\n          .processAsync,\n      )\n      .mockResolvedValue({code: content});\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toBeNull();\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(1);\n\n    expect(console.warn).toHaveBeenCalledTimes(1);\n    expect(jest.mocked(console.warn).mock.calls[0][0]).toMatchSnapshot();\n    console.warn = warn;\n  });\n\n  // this duplicates with 'writes source map if preprocessor supplies it'\n  it('writes source maps if given by the transformer', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    const map = {\n      mappings: ';AAAA',\n      version: 3,\n    };\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map,\n      });\n\n    const result = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      JSON.stringify(map),\n      {\n        encoding: 'utf8',\n        fsync: false,\n      },\n    );\n  });\n\n  it('does not write source map if not given by the transformer', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map: null,\n      });\n\n    const result = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toBeFalsy();\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(1);\n  });\n\n  it('in async mode, does not write source map if not given by the transformer', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map: null,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toBeFalsy();\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(1);\n  });\n\n  it('does not write source map if not given by the async preprocessor', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'async-preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    jest\n      .mocked(\n        (require('async-preprocessor-with-sourcemaps') as AsyncTransformer)\n          .processAsync,\n      )\n      .mockResolvedValue({\n        code: 'content',\n        map: null,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toBeFalsy();\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(1);\n  });\n\n  it('should write a source map for the instrumented file when transformed', async () => {\n    const transformerConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(transformerConfig);\n\n    const map = {\n      mappings: ';AAAA',\n      version: 3,\n    };\n\n    // A map from the original source to the instrumented output\n    /* eslint-disable sort-keys */\n    const instrumentedCodeMap: FixedRawSourceMap = {\n      version: 3,\n      names: ['cov_25u22311x4', 'actualCoverage', 's', 'content'],\n      sources: ['banana.js'],\n      sourcesContent: ['content'],\n      mappings:\n        ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeY;IAAAA,cAAA,YAAAA,CAAA;MAAA,OAAAC,cAAA;IAAA;EAAA;EAAA,OAAAA,cAAA;AAAA;AAAAD,cAAA;AAAAA,cAAA,GAAAE,CAAA;AAfZC,OAAO',\n      ignoreList: [],\n    };\n    /* eslint-enable */\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map,\n      });\n\n    const result = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      JSON.stringify(instrumentedCodeMap),\n      expect.anything(),\n    );\n\n    // Inline source map allows debugging of original source when running instrumented code\n    expect(result.code).toContain('//# sourceMappingURL');\n  });\n\n  it('in async mode, should write a source map for the instrumented file when transformed', async () => {\n    const transformerConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(transformerConfig);\n\n    const map = {\n      mappings: ';AAAA',\n      version: 3,\n    };\n\n    // A map from the original source to the instrumented output\n    /* eslint-disable sort-keys */\n    const instrumentedCodeMap = {\n      version: 3,\n      names: ['cov_25u22311x4', 'actualCoverage', 's', 'content'],\n      sources: ['banana.js'],\n      sourcesContent: ['content'],\n      mappings:\n        ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeY;IAAAA,cAAA,YAAAA,CAAA;MAAA,OAAAC,cAAA;IAAA;EAAA;EAAA,OAAAA,cAAA;AAAA;AAAAD,cAAA;AAAAA,cAAA,GAAAE,CAAA;AAfZC,OAAO',\n      ignoreList: [],\n    };\n    /* eslint-enable */\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      JSON.stringify(instrumentedCodeMap),\n      expect.anything(),\n    );\n\n    // Inline source map allows debugging of original source when running instrumented code\n    expect(result.code).toContain('//# sourceMappingURL');\n  });\n\n  it('should write a source map for the instrumented file when async transformed', async () => {\n    const transformerConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'async-preprocessor-with-sourcemaps', {}]],\n    };\n    const scriptTransformer = await createScriptTransformer(transformerConfig);\n\n    const map = {\n      mappings: ';AAAA',\n      version: 3,\n    };\n\n    // A map from the original source to the instrumented output\n    /* eslint-disable sort-keys */\n    const instrumentedCodeMap = {\n      version: 3,\n      names: ['cov_25u22311x4', 'actualCoverage', 's', 'content'],\n      sources: ['banana.js'],\n      sourcesContent: ['content'],\n      mappings:\n        ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeY;IAAAA,cAAA,YAAAA,CAAA;MAAA,OAAAC,cAAA;IAAA;EAAA;EAAA,OAAAA,cAAA;AAAA;AAAAD,cAAA;AAAAA,cAAA,GAAAE,CAAA;AAfZC,OAAO',\n      ignoreList: [],\n    };\n    /* eslint-enable */\n\n    jest\n      .mocked(\n        (require('async-preprocessor-with-sourcemaps') as AsyncTransformer)\n          .processAsync,\n      )\n      .mockResolvedValue({\n        code: 'content',\n        map,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      JSON.stringify(instrumentedCodeMap),\n      expect.anything(),\n    );\n\n    // Inline source map allows debugging of original source when running instrumented code\n    expect(result.code).toContain('//# sourceMappingURL');\n  });\n\n  it('should write a source map for the instrumented file when not transformed', async () => {\n    const scriptTransformer = await createScriptTransformer(config);\n\n    // A map from the original source to the instrumented output\n    /* eslint-disable sort-keys */\n    const instrumentedCodeMap = {\n      version: 3,\n      names: ['cov_25u22311x4', 'actualCoverage', 's', 'module', 'exports'],\n      sources: ['banana.js'],\n      sourcesContent: ['module.exports = \"banana\";'],\n      mappings:\n        ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeY;IAAAA,cAAA,YAAAA,CAAA;MAAA,OAAAC,cAAA;IAAA;EAAA;EAAA,OAAAA,cAAA;AAAA;AAAAD,cAAA;AAAAA,cAAA,GAAAE,CAAA;AAfZC,MAAM,CAACC,OAAO,GAAG,QAAQ',\n      ignoreList: [],\n    };\n    /* eslint-enable */\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map: null,\n      });\n\n    const result = scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      JSON.stringify(instrumentedCodeMap),\n      expect.anything(),\n    );\n\n    // Inline source map allows debugging of original source when running instrumented code\n    expect(result.code).toContain('//# sourceMappingURL');\n  });\n\n  it('in async mode, should write a source map for the instrumented file when not transformed', async () => {\n    const scriptTransformer = await createScriptTransformer(config);\n\n    // A map from the original source to the instrumented output\n    /* eslint-disable sort-keys */\n    const instrumentedCodeMap = {\n      version: 3,\n      names: ['cov_25u22311x4', 'actualCoverage', 's', 'module', 'exports'],\n      sources: ['banana.js'],\n      sourcesContent: ['module.exports = \"banana\";'],\n      mappings:\n        ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeY;IAAAA,cAAA,YAAAA,CAAA;MAAA,OAAAC,cAAA;IAAA;EAAA;EAAA,OAAAA,cAAA;AAAA;AAAAD,cAAA;AAAAA,cAAA,GAAAE,CAAA;AAfZC,MAAM,CAACC,OAAO,GAAG,QAAQ',\n      ignoreList: [],\n    };\n    /* eslint-enable */\n\n    jest\n      .mocked(\n        (require('preprocessor-with-sourcemaps') as SyncTransformer).process,\n      )\n      .mockReturnValue({\n        code: 'content',\n        map: null,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      JSON.stringify(instrumentedCodeMap),\n      expect.anything(),\n    );\n\n    // Inline source map allows debugging of original source when running instrumented code\n    expect(result.code).toContain('//# sourceMappingURL');\n  });\n\n  it('should write a source map for the instrumented file when not transformed by async preprocessor', async () => {\n    const scriptTransformer = await createScriptTransformer(config);\n\n    // A map from the original source to the instrumented output\n    /* eslint-disable sort-keys */\n    const instrumentedCodeMap = {\n      version: 3,\n      names: ['cov_25u22311x4', 'actualCoverage', 's', 'module', 'exports'],\n      sources: ['banana.js'],\n      sourcesContent: ['module.exports = \"banana\";'],\n      mappings:\n        ';;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAeY;IAAAA,cAAA,YAAAA,CAAA;MAAA,OAAAC,cAAA;IAAA;EAAA;EAAA,OAAAA,cAAA;AAAA;AAAAD,cAAA;AAAAA,cAAA,GAAAE,CAAA;AAfZC,MAAM,CAACC,OAAO,GAAG,QAAQ',\n      ignoreList: [],\n    };\n    /* eslint-enable */\n\n    jest\n      .mocked(\n        (require('async-preprocessor-with-sourcemaps') as AsyncTransformer)\n          .processAsync,\n      )\n      .mockResolvedValue({\n        code: 'content',\n        map: null,\n      });\n\n    const result = await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n    expect(result.sourceMapPath).toEqual(expect.any(String));\n    expect(writeFileAtomic.sync).toHaveBeenCalledTimes(2);\n    expect(writeFileAtomic.sync).toHaveBeenCalledWith(\n      result.sourceMapPath,\n      JSON.stringify(instrumentedCodeMap),\n      expect.anything(),\n    );\n\n    // Inline source map allows debugging of original source when running instrumented code\n    expect(result.code).toContain('//# sourceMappingURL');\n  });\n\n  it('passes expected transform options to getCacheKey', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {configKey: 'configValue'}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    scriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n\n    const {getCacheKey} = require('test_preprocessor') as SyncTransformer;\n    expect(getCacheKey).toMatchSnapshot();\n  });\n\n  it('in async mode, passes expected transform options to getCacheKey', async () => {\n    config = {\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {configKey: 'configValue'}]],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n\n    const {getCacheKey} = require('test_preprocessor') as SyncTransformer;\n    expect(getCacheKey).toMatchSnapshot();\n  });\n\n  it('passes expected transform options to getCacheKeyAsync', async () => {\n    config = {\n      ...config,\n      transform: [\n        ['\\\\.js$', 'test_async_preprocessor', {configKey: 'configValue'}],\n      ],\n    };\n    const scriptTransformer = await createScriptTransformer(config);\n\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions({collectCoverage: true}),\n    );\n\n    const {getCacheKeyAsync} =\n      require('test_async_preprocessor') as AsyncTransformer;\n    expect(getCacheKeyAsync).toMatchSnapshot();\n  });\n\n  it('creates transformer with config', async () => {\n    const transformerConfig = {};\n    config = Object.assign(config, {\n      transform: [['\\\\.js$', 'configureable-preprocessor', transformerConfig]],\n    });\n    const scriptTransformer = await createScriptTransformer(config);\n\n    scriptTransformer.transform('/fruits/banana.js', getCoverageOptions());\n    expect(\n      (\n        require('configureable-preprocessor') as TransformerFactory<SyncTransformer>\n      ).createTransformer,\n    ).toHaveBeenCalledWith(transformerConfig);\n  });\n\n  it('passes correct config to a preprocessor used multiple times', async () => {\n    const transformerConfig1 = {};\n    const transformerConfig2 = {};\n\n    config = Object.assign(config, {\n      transform: [\n        // same preprocessor\n        [\n          // *only* /fruits/banana.js\n          '/fruits/banana\\\\.js$',\n          'configureable-preprocessor',\n          transformerConfig1,\n        ],\n        [\n          // *not* /fruits/banana.js\n          '/fruits/(?!banana)\\\\w+\\\\.js$',\n          'configureable-preprocessor',\n          transformerConfig2,\n        ],\n      ],\n    });\n\n    const scriptTransformer = await createScriptTransformer(config);\n\n    scriptTransformer.transform('/fruits/banana.js', getCoverageOptions());\n    expect(\n      (\n        require('configureable-preprocessor') as TransformerFactory<SyncTransformer>\n      ).createTransformer,\n    ).toHaveBeenLastCalledWith(transformerConfig1);\n\n    scriptTransformer.transform('/fruits/kiwi.js', getCoverageOptions());\n    expect(\n      (\n        require('configureable-preprocessor') as TransformerFactory<SyncTransformer>\n      ).createTransformer,\n    ).toHaveBeenLastCalledWith(transformerConfig2);\n  });\n\n  it('reads values from the cache', async () => {\n    const transformConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    };\n    let scriptTransformer = await createScriptTransformer(transformConfig);\n    scriptTransformer.transform('/fruits/banana.js', getCoverageOptions());\n\n    const cachePath = getCachePath(mockFs, config);\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n    expect(jest.mocked(writeFileAtomic.sync).mock.calls[0][0]).toBe(cachePath);\n\n    // Cache the state in `mockFsCopy`\n    const mockFsCopy = mockFs;\n    jest.resetModules();\n    reset();\n\n    // Restore the cached fs\n    mockFs = mockFsCopy;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    scriptTransformer.transform('/fruits/banana.js', getCoverageOptions());\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n    expect(fs.readFileSync).toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).not.toHaveBeenCalled();\n\n    // Don't read from the cache when `config.cache` is false.\n    jest.resetModules();\n    reset();\n    mockFs = mockFsCopy;\n    transformConfig.cache = false;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    scriptTransformer.transform('/fruits/banana.js', getCoverageOptions());\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n    expect(fs.readFileSync).not.toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n  });\n\n  it('in async mode, reads values from the cache', async () => {\n    const transformConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    };\n    let scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    const cachePath = getCachePath(mockFs, config);\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n    expect(jest.mocked(writeFileAtomic.sync).mock.calls[0][0]).toBe(cachePath);\n\n    // Cache the state in `mockFsCopy`\n    const mockFsCopy = mockFs;\n    jest.resetModules();\n    reset();\n\n    // Restore the cached fs\n    mockFs = mockFsCopy;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n    expect(fs.readFileSync).toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).not.toHaveBeenCalled();\n\n    // Don't read from the cache when `config.cache` is false.\n    jest.resetModules();\n    reset();\n    mockFs = mockFsCopy;\n    transformConfig.cache = false;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n    expect(fs.readFileSync).not.toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n  });\n\n  it('reads values from the cache when using async preprocessor', async () => {\n    const transformConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'test_async_preprocessor', {}]],\n    };\n    let scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    const cachePath = getCachePath(mockFs, config);\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n    expect(jest.mocked(writeFileAtomic.sync).mock.calls[0][0]).toBe(cachePath);\n\n    // Cache the state in `mockFsCopy`\n    const mockFsCopy = mockFs;\n    jest.resetModules();\n    reset();\n\n    // Restore the cached fs\n    mockFs = mockFsCopy;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n    expect(fs.readFileSync).toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).not.toHaveBeenCalled();\n\n    // Don't read from the cache when `config.cache` is false.\n    jest.resetModules();\n    reset();\n    mockFs = mockFsCopy;\n    transformConfig.cache = false;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n    expect(fs.readFileSync).not.toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n  });\n\n  it('reads values from the cache when the file contains colons', async () => {\n    const transformConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    };\n    let scriptTransformer = await createScriptTransformer(transformConfig);\n    scriptTransformer.transform(\n      '/fruits/banana:colon.js',\n      getCoverageOptions(),\n    );\n\n    const cachePath = getCachePath(mockFs, config);\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n    expect(jest.mocked(writeFileAtomic.sync).mock.calls[0][0]).toBe(cachePath);\n\n    // Cache the state in `mockFsCopy`\n    const mockFsCopy = mockFs;\n    jest.resetModules();\n    reset();\n\n    // Restore the cached fs\n    mockFs = mockFsCopy;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    scriptTransformer.transform(\n      '/fruits/banana:colon.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith(\n      '/fruits/banana:colon.js',\n      'utf8',\n    );\n    expect(fs.readFileSync).toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).not.toHaveBeenCalled();\n  });\n\n  it('in async mode, reads values from the cache when the file contains colons', async () => {\n    const transformConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    };\n    let scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana:colon.js',\n      getCoverageOptions(),\n    );\n\n    const cachePath = getCachePath(mockFs, config);\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n    expect(jest.mocked(writeFileAtomic.sync).mock.calls[0][0]).toBe(cachePath);\n\n    // Cache the state in `mockFsCopy`\n    const mockFsCopy = mockFs;\n    jest.resetModules();\n    reset();\n\n    // Restore the cached fs\n    mockFs = mockFsCopy;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana:colon.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith(\n      '/fruits/banana:colon.js',\n      'utf8',\n    );\n    expect(fs.readFileSync).toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).not.toHaveBeenCalled();\n  });\n\n  it('with async preprocessor, reads values from the cache when the file contains colons', async () => {\n    const transformConfig: Config.ProjectConfig = {\n      ...config,\n      transform: [['\\\\.js$', 'test_async_preprocessor', {}]],\n    };\n    let scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana:colon.js',\n      getCoverageOptions(),\n    );\n\n    const cachePath = getCachePath(mockFs, config);\n    expect(writeFileAtomic.sync).toHaveBeenCalled();\n    expect(jest.mocked(writeFileAtomic.sync).mock.calls[0][0]).toBe(cachePath);\n\n    // Cache the state in `mockFsCopy`\n    const mockFsCopy = mockFs;\n    jest.resetModules();\n    reset();\n\n    // Restore the cached fs\n    mockFs = mockFsCopy;\n    scriptTransformer = await createScriptTransformer(transformConfig);\n    await scriptTransformer.transformAsync(\n      '/fruits/banana:colon.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith(\n      '/fruits/banana:colon.js',\n      'utf8',\n    );\n    expect(fs.readFileSync).toHaveBeenCalledWith(cachePath, 'utf8');\n    expect(writeFileAtomic.sync).not.toHaveBeenCalled();\n  });\n\n  it('should reuse the value from in-memory cache which is set by custom transformer', async () => {\n    const cacheFS = new Map<string, string>();\n    const testPreprocessor =\n      require('cache_fs_preprocessor') as SyncTransformer;\n    const scriptTransformer = await createScriptTransformer(\n      {\n        ...config,\n        transform: [['\\\\.js$', 'cache_fs_preprocessor', {}]],\n      },\n      cacheFS,\n    );\n    const fileName1 = '/fruits/banana.js';\n    const fileName2 = '/fruits/kiwi.js';\n\n    scriptTransformer.transform(fileName1, getCoverageOptions());\n\n    cacheFS.set(fileName2, 'foo');\n\n    scriptTransformer.transform(fileName2, getCoverageOptions());\n\n    mockInvariant(testPreprocessor.getCacheKey != null);\n\n    expect(\n      jest.mocked(testPreprocessor.getCacheKey).mock.calls[0][2].cacheFS,\n    ).toBeDefined();\n    expect(\n      jest.mocked(testPreprocessor.process).mock.calls[0][2].cacheFS,\n    ).toBeDefined();\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith(fileName1, 'utf8');\n  });\n\n  it('in async mode, should reuse the value from in-memory cache which is set by custom preprocessor', async () => {\n    const cacheFS = new Map<string, string>();\n    const testPreprocessor =\n      require('cache_fs_preprocessor') as SyncTransformer;\n    const scriptTransformer = await createScriptTransformer(\n      {\n        ...config,\n        transform: [['\\\\.js$', 'cache_fs_preprocessor', {}]],\n      },\n      cacheFS,\n    );\n    const fileName1 = '/fruits/banana.js';\n    const fileName2 = '/fruits/kiwi.js';\n\n    await scriptTransformer.transformAsync(fileName1, getCoverageOptions());\n\n    cacheFS.set(fileName2, 'foo');\n\n    await scriptTransformer.transformAsync(fileName2, getCoverageOptions());\n\n    mockInvariant(testPreprocessor.getCacheKey != null);\n\n    expect(\n      jest.mocked(testPreprocessor.getCacheKey).mock.calls[0][2].cacheFS,\n    ).toBeDefined();\n    expect(\n      jest.mocked(testPreprocessor.process).mock.calls[0][2].cacheFS,\n    ).toBeDefined();\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith(fileName1, 'utf8');\n  });\n\n  it('should reuse the value from in-memory cache which is set by custom async preprocessor', async () => {\n    const cacheFS = new Map<string, string>();\n    const testPreprocessor =\n      require('cache_fs_async_preprocessor') as AsyncTransformer;\n    const scriptTransformer = await createScriptTransformer(\n      {\n        ...config,\n        transform: [['\\\\.js$', 'cache_fs_async_preprocessor', {}]],\n      },\n      cacheFS,\n    );\n    const fileName1 = '/fruits/banana.js';\n    const fileName2 = '/fruits/kiwi.js';\n\n    await scriptTransformer.transformAsync(fileName1, getCoverageOptions());\n\n    cacheFS.set(fileName2, 'foo');\n\n    await scriptTransformer.transformAsync(fileName2, getCoverageOptions());\n\n    mockInvariant(testPreprocessor.getCacheKeyAsync != null);\n\n    expect(\n      jest.mocked(testPreprocessor.getCacheKeyAsync).mock.calls[0][2].cacheFS,\n    ).toBeDefined();\n    expect(\n      jest.mocked(testPreprocessor.processAsync).mock.calls[0][2].cacheFS,\n    ).toBeDefined();\n    expect(fs.readFileSync).toHaveBeenCalledTimes(1);\n    expect(fs.readFileSync).toHaveBeenCalledWith(fileName1, 'utf8');\n  });\n\n  it('does not reuse the in-memory cache between different projects', async () => {\n    const scriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    });\n\n    scriptTransformer.transform('/fruits/banana.js', getCoverageOptions());\n\n    const anotherScriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'css-preprocessor', {}]],\n    });\n\n    anotherScriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n  });\n\n  it('async mode does not reuse the in-memory cache between different projects', async () => {\n    const scriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    });\n\n    await scriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    const anotherScriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'css-preprocessor', {}]],\n    });\n\n    await anotherScriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(2);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n  });\n\n  it('regardless of sync/async, does not reuse the in-memory cache between different projects', async () => {\n    const scriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    });\n\n    scriptTransformer.transform('/fruits/banana.js', getCoverageOptions());\n\n    const anotherScriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'css-preprocessor', {}]],\n    });\n\n    await anotherScriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    const yetAnotherScriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    });\n    yetAnotherScriptTransformer.transform(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    const fruityScriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'test_async_preprocessor', {}]],\n    });\n    await fruityScriptTransformer.transformAsync(\n      '/fruits/banana.js',\n      getCoverageOptions(),\n    );\n\n    expect(fs.readFileSync).toHaveBeenCalledTimes(4);\n    expect(fs.readFileSync).toHaveBeenCalledWith('/fruits/banana.js', 'utf8');\n  });\n\n  it('preload transformer when using `createScriptTransformer`', async () => {\n    const scriptTransformer = await createScriptTransformer({\n      ...config,\n      transform: [['\\\\.js$', 'test_preprocessor', {}]],\n    });\n\n    // @ts-expect-error - private property\n    expect([...scriptTransformer._transformCache.entries()]).toEqual([\n      ['\\\\.js$test_preprocessor', expect.any(Object)],\n    ]);\n  });\n});\n\nfunction getTransformOptions(instrument: boolean): ReducedTransformOptions {\n  return {\n    instrument,\n    supportsDynamicImport: false,\n    supportsExportNamespaceFrom: false,\n    supportsStaticESM: false,\n    supportsTopLevelAwait: false,\n  };\n}\n\nfunction getCoverageOptions(\n  overrides: Partial<ShouldInstrumentOptions> = {},\n): Options {\n  const globalConfig = makeGlobalConfig(overrides);\n\n  return {\n    collectCoverage: globalConfig.collectCoverage,\n    collectCoverageFrom: globalConfig.collectCoverageFrom,\n    coverageProvider: globalConfig.coverageProvider,\n    supportsDynamicImport: false,\n    supportsExportNamespaceFrom: false,\n    supportsStaticESM: false,\n    supportsTopLevelAwait: false,\n  };\n}\n\nfunction mockInvariant(subject: boolean): asserts subject {\n  if (subject == null) {\n    throw new Error('Went boom');\n  }\n}"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`ScriptTransformer (in sync mode) throws an error if \\`process\\` isn't defined 1`] = `\n\"<red><bold>● Invalid synchronous transformer module:</intensity></color>\n<red>  \"skipped-required-props-preprocessor-only-async\" specified in the \"transform\" object of Jest configuration</color>\n<red>  must export a \\`process\\` function.</color>\n<red>  <bold>Code Transformation Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/code-transformation</color>\n<red></color>\"\n`;\n\nexports[`ScriptTransformer in async mode, passes expected transform options to getCacheKey 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [\n      \"module.exports = \"banana\";\",\n      \"/fruits/banana.js\",\n      Object {\n        \"cacheFS\": Map {\n          \"/fruits/banana.js\" => \"module.exports = \"banana\";\",\n        },\n        \"collectCoverage\": true,\n        \"collectCoverageFrom\": Array [],\n        \"config\": Object {\n          \"automock\": false,\n          \"cache\": true,\n          \"cacheDirectory\": \"/cache/\",\n          \"clearMocks\": false,\n          \"collectCoverageFrom\": Array [\n            \"src\",\n            \"!public\",\n          ],\n          \"coverageDirectory\": \"coverage\",\n          \"coveragePathIgnorePatterns\": Array [],\n          \"coverageReporters\": Array [],\n          \"cwd\": \"/test_root_dir/\",\n          \"detectLeaks\": false,\n          \"detectOpenHandles\": false,\n          \"displayName\": undefined,\n          \"errorOnDeprecated\": false,\n          \"extensionsToTreatAsEsm\": Array [],\n          \"fakeTimers\": Object {\n            \"enableGlobally\": false,\n          },\n          \"filter\": undefined,\n          \"forceCoverageMatch\": Array [],\n          \"globalSetup\": undefined,\n          \"globalTeardown\": undefined,\n          \"globals\": Object {},\n          \"haste\": Object {},\n          \"id\": \"test\",\n          \"injectGlobals\": true,\n          \"moduleDirectories\": Array [],\n          \"moduleFileExtensions\": Array [\n            \"js\",\n          ],\n          \"moduleNameMapper\": Array [],\n          \"modulePathIgnorePatterns\": Array [],\n          \"modulePaths\": Array [],\n          \"openHandlesTimeout\": 1000,\n          \"prettierPath\": \"prettier\",\n          \"reporters\": Array [\n            \"default\",\n            \"custom-reporter-1\",\n            Array [\n              \"custom-reporter-2\",\n              Object {\n                \"configValue\": true,\n              },\n            ],\n          ],\n          \"resetMocks\": false,\n          \"resetModules\": false,\n          \"resolver\": undefined,\n          \"restoreMocks\": false,\n          \"rootDir\": \"/\",\n          \"roots\": Array [],\n          \"runner\": \"jest-runner\",\n          \"runtime\": \"/test_module_loader_path\",\n          \"sandboxInjectedGlobals\": Array [],\n          \"setupFiles\": Array [],\n          \"setupFilesAfterEnv\": Array [],\n          \"skipFilter\": false,\n          \"skipNodeResolution\": false,\n          \"slowTestThreshold\": 5,\n          \"snapshotFormat\": Object {},\n          \"snapshotResolver\": undefined,\n          \"snapshotSerializers\": Array [],\n          \"testEnvironment\": \"node\",\n          \"testEnvironmentOptions\": Object {},\n          \"testLocationInResults\": false,\n          \"testMatch\": Array [],\n          \"testPathIgnorePatterns\": Array [],\n          \"testRegex\": Array [\n            \"\\\\.test\\\\.js$\",\n          ],\n          \"testRunner\": \"jest-circus/runner\",\n          \"testTimeout\": 5000,\n          \"transform\": Array [\n            Array [\n              \"\\\\.js$\",\n              \"test_preprocessor\",\n              Object {\n                \"configKey\": \"configValue\",\n              },\n            ],\n          ],\n          \"transformIgnorePatterns\": Array [\n            \"/node_modules/\",\n          ],\n          \"unmockedModulePathPatterns\": undefined,\n          \"waitNextEventLoopTurnForUnhandledRejectionEvents\": false,\n          \"watchPathIgnorePatterns\": Array [],\n        },\n        \"configString\": \"{\"automock\":false,\"cache\":true,\"cacheDirectory\":\"/cache/\",\"clearMocks\":false,\"collectCoverageFrom\":[\"src\",\"!public\"],\"coverageDirectory\":\"coverage\",\"coveragePathIgnorePatterns\":[],\"coverageReporters\":[],\"cwd\":\"/test_root_dir/\",\"detectLeaks\":false,\"detectOpenHandles\":false,\"errorOnDeprecated\":false,\"extensionsToTreatAsEsm\":[],\"fakeTimers\":{\"enableGlobally\":false},\"forceCoverageMatch\":[],\"globals\":{},\"haste\":{},\"id\":\"test\",\"injectGlobals\":true,\"moduleDirectories\":[],\"moduleFileExtensions\":[\"js\"],\"moduleNameMapper\":[],\"modulePathIgnorePatterns\":[],\"modulePaths\":[],\"openHandlesTimeout\":1000,\"prettierPath\":\"prettier\",\"reporters\":[\"default\",\"custom-reporter-1\",[\"custom-reporter-2\",{\"configValue\":true}]],\"resetMocks\":false,\"resetModules\":false,\"restoreMocks\":false,\"rootDir\":\"/\",\"roots\":[],\"runner\":\"jest-runner\",\"runtime\":\"/test_module_loader_path\",\"sandboxInjectedGlobals\":[],\"setupFiles\":[],\"setupFilesAfterEnv\":[],\"skipFilter\":false,\"skipNodeResolution\":false,\"slowTestThreshold\":5,\"snapshotFormat\":{},\"snapshotSerializers\":[],\"testEnvironment\":\"node\",\"testEnvironmentOptions\":{},\"testLocationInResults\":false,\"testMatch\":[],\"testPathIgnorePatterns\":[],\"testRegex\":[\"\\\\\\\\.test\\\\\\\\.js$\"],\"testRunner\":\"jest-circus/runner\",\"testTimeout\":5000,\"transform\":[[\"\\\\\\\\.js$\",\"test_preprocessor\",{\"configKey\":\"configValue\"}]],\"transformIgnorePatterns\":[\"/node_modules/\"],\"waitNextEventLoopTurnForUnhandledRejectionEvents\":false,\"watchPathIgnorePatterns\":[]}\",\n        \"coverageProvider\": \"babel\",\n        \"instrument\": true,\n        \"supportsDynamicImport\": false,\n        \"supportsExportNamespaceFrom\": false,\n        \"supportsStaticESM\": false,\n        \"supportsTopLevelAwait\": false,\n        \"transformerConfig\": Object {\n          \"configKey\": \"configValue\",\n        },\n      },\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": \"ab\",\n    },\n  ],\n}\n`;\n\nexports[`ScriptTransformer in async mode, uses the supplied async preprocessor 1`] = `\n\"const TRANSFORMED = {\n  filename: '/fruits/banana.js',\n  script: 'module.exports = \"banana\";',\n  config: '{\"collectCoverage\":false,\"collectCoverageFrom\":[],\"coverageProvider\":\"babel\",\"supportsDynamicImport\":false,\"supportsExportNamespaceFrom\":false,\"supportsStaticESM\":false,\"supportsTopLevelAwait\":false,\"instrument\":false,\"cacheFS\":{},\"config\":{\"automock\":false,\"cache\":true,\"cacheDirectory\":\"/cache/\",\"clearMocks\":false,\"collectCoverageFrom\":[\"src\",\"!public\"],\"coverageDirectory\":\"coverage\",\"coveragePathIgnorePatterns\":[],\"coverageReporters\":[],\"cwd\":\"/test_root_dir/\",\"detectLeaks\":false,\"detectOpenHandles\":false,\"errorOnDeprecated\":false,\"extensionsToTreatAsEsm\":[],\"fakeTimers\":{\"enableGlobally\":false},\"forceCoverageMatch\":[],\"globals\":{},\"haste\":{},\"id\":\"test\",\"injectGlobals\":true,\"moduleDirectories\":[],\"moduleFileExtensions\":[\"js\"],\"moduleNameMapper\":[],\"modulePathIgnorePatterns\":[],\"modulePaths\":[],\"openHandlesTimeout\":1000,\"prettierPath\":\"prettier\",\"reporters\":[\"default\",\"custom-reporter-1\",[\"custom-reporter-2\",{\"configValue\":true}]],\"resetMocks\":false,\"resetModules\":false,\"restoreMocks\":false,\"rootDir\":\"/\",\"roots\":[],\"runner\":\"jest-runner\",\"runtime\":\"/test_module_loader_path\",\"sandboxInjectedGlobals\":[],\"setupFiles\":[],\"setupFilesAfterEnv\":[],\"skipFilter\":false,\"skipNodeResolution\":false,\"slowTestThreshold\":5,\"snapshotFormat\":{},\"snapshotSerializers\":[],\"testEnvironment\":\"node\",\"testEnvironmentOptions\":{},\"testLocationInResults\":false,\"testMatch\":[],\"testPathIgnorePatterns\":[],\"testRegex\":[\"\\\\\\\\.test\\\\\\\\.js$\"],\"testRunner\":\"jest-circus/runner\",\"testTimeout\":5000,\"transform\":[[\"\\\\\\\\.js$\",\"test_async_preprocessor\",{}]],\"transformIgnorePatterns\":[\"/node_modules/\"],\"waitNextEventLoopTurnForUnhandledRejectionEvents\":false,\"watchPathIgnorePatterns\":[]},\"configString\":\"{\\\\\"automock\\\\\":false,\\\\\"cache\\\\\":true,\\\\\"cacheDirectory\\\\\":\\\\\"/cache/\\\\\",\\\\\"clearMocks\\\\\":false,\\\\\"collectCoverageFrom\\\\\":[\\\\\"src\\\\\",\\\\\"!public\\\\\"],\\\\\"coverageDirectory\\\\\":\\\\\"coverage\\\\\",\\\\\"coveragePathIgnorePatterns\\\\\":[],\\\\\"coverageReporters\\\\\":[],\\\\\"cwd\\\\\":\\\\\"/test_root_dir/\\\\\",\\\\\"detectLeaks\\\\\":false,\\\\\"detectOpenHandles\\\\\":false,\\\\\"errorOnDeprecated\\\\\":false,\\\\\"extensionsToTreatAsEsm\\\\\":[],\\\\\"fakeTimers\\\\\":{\\\\\"enableGlobally\\\\\":false},\\\\\"forceCoverageMatch\\\\\":[],\\\\\"globals\\\\\":{},\\\\\"haste\\\\\":{},\\\\\"id\\\\\":\\\\\"test\\\\\",\\\\\"injectGlobals\\\\\":true,\\\\\"moduleDirectories\\\\\":[],\\\\\"moduleFileExtensions\\\\\":[\\\\\"js\\\\\"],\\\\\"moduleNameMapper\\\\\":[],\\\\\"modulePathIgnorePatterns\\\\\":[],\\\\\"modulePaths\\\\\":[],\\\\\"openHandlesTimeout\\\\\":1000,\\\\\"prettierPath\\\\\":\\\\\"prettier\\\\\",\\\\\"reporters\\\\\":[\\\\\"default\\\\\",\\\\\"custom-reporter-1\\\\\",[\\\\\"custom-reporter-2\\\\\",{\\\\\"configValue\\\\\":true}]],\\\\\"resetMocks\\\\\":false,\\\\\"resetModules\\\\\":false,\\\\\"restoreMocks\\\\\":false,\\\\\"rootDir\\\\\":\\\\\"/\\\\\",\\\\\"roots\\\\\":[],\\\\\"runner\\\\\":\\\\\"jest-runner\\\\\",\\\\\"runtime\\\\\":\\\\\"/test_module_loader_path\\\\\",\\\\\"sandboxInjectedGlobals\\\\\":[],\\\\\"setupFiles\\\\\":[],\\\\\"setupFilesAfterEnv\\\\\":[],\\\\\"skipFilter\\\\\":false,\\\\\"skipNodeResolution\\\\\":false,\\\\\"slowTestThreshold\\\\\":5,\\\\\"snapshotFormat\\\\\":{},\\\\\"snapshotSerializers\\\\\":[],\\\\\"testEnvironment\\\\\":\\\\\"node\\\\\",\\\\\"testEnvironmentOptions\\\\\":{},\\\\\"testLocationInResults\\\\\":false,\\\\\"testMatch\\\\\":[],\\\\\"testPathIgnorePatterns\\\\\":[],\\\\\"testRegex\\\\\":[\\\\\"\\\\\\\\\\\\\\\\.test\\\\\\\\\\\\\\\\.js$\\\\\"],\\\\\"testRunner\\\\\":\\\\\"jest-circus/runner\\\\\",\\\\\"testTimeout\\\\\":5000,\\\\\"transform\\\\\":[[\\\\\"\\\\\\\\\\\\\\\\.js$\\\\\",\\\\\"test_async_preprocessor\\\\\",{}]],\\\\\"transformIgnorePatterns\\\\\":[\\\\\"/node_modules/\\\\\"],\\\\\"waitNextEventLoopTurnForUnhandledRejectionEvents\\\\\":false,\\\\\"watchPathIgnorePatterns\\\\\":[]}\",\"transformerConfig\":{}}',\n};\"\n`;\n\nexports[`ScriptTransformer in async mode, uses the supplied async preprocessor 2`] = `\"module.exports = \"react\";\"`;\n\nexports[`ScriptTransformer in async mode, uses the supplied preprocessor 1`] = `\n\"const TRANSFORMED = {\n  filename: '/fruits/banana.js',\n  script: 'module.exports = \"banana\";',\n  config: '{\"collectCoverage\":false,\"collectCoverageFrom\":[],\"coverageProvider\":\"babel\",\"supportsDynamicImport\":false,\"supportsExportNamespaceFrom\":false,\"supportsStaticESM\":false,\"supportsTopLevelAwait\":false,\"instrument\":false,\"cacheFS\":{},\"config\":{\"automock\":false,\"cache\":true,\"cacheDirectory\":\"/cache/\",\"clearMocks\":false,\"collectCoverageFrom\":[\"src\",\"!public\"],\"coverageDirectory\":\"coverage\",\"coveragePathIgnorePatterns\":[],\"coverageReporters\":[],\"cwd\":\"/test_root_dir/\",\"detectLeaks\":false,\"detectOpenHandles\":false,\"errorOnDeprecated\":false,\"extensionsToTreatAsEsm\":[],\"fakeTimers\":{\"enableGlobally\":false},\"forceCoverageMatch\":[],\"globals\":{},\"haste\":{},\"id\":\"test\",\"injectGlobals\":true,\"moduleDirectories\":[],\"moduleFileExtensions\":[\"js\"],\"moduleNameMapper\":[],\"modulePathIgnorePatterns\":[],\"modulePaths\":[],\"openHandlesTimeout\":1000,\"prettierPath\":\"prettier\",\"reporters\":[\"default\",\"custom-reporter-1\",[\"custom-reporter-2\",{\"configValue\":true}]],\"resetMocks\":false,\"resetModules\":false,\"restoreMocks\":false,\"rootDir\":\"/\",\"roots\":[],\"runner\":\"jest-runner\",\"runtime\":\"/test_module_loader_path\",\"sandboxInjectedGlobals\":[],\"setupFiles\":[],\"setupFilesAfterEnv\":[],\"skipFilter\":false,\"skipNodeResolution\":false,\"slowTestThreshold\":5,\"snapshotFormat\":{},\"snapshotSerializers\":[],\"testEnvironment\":\"node\",\"testEnvironmentOptions\":{},\"testLocationInResults\":false,\"testMatch\":[],\"testPathIgnorePatterns\":[],\"testRegex\":[\"\\\\\\\\.test\\\\\\\\.js$\"],\"testRunner\":\"jest-circus/runner\",\"testTimeout\":5000,\"transform\":[[\"\\\\\\\\.js$\",\"test_preprocessor\",{}]],\"transformIgnorePatterns\":[\"/node_modules/\"],\"waitNextEventLoopTurnForUnhandledRejectionEvents\":false,\"watchPathIgnorePatterns\":[]},\"configString\":\"{\\\\\"automock\\\\\":false,\\\\\"cache\\\\\":true,\\\\\"cacheDirectory\\\\\":\\\\\"/cache/\\\\\",\\\\\"clearMocks\\\\\":false,\\\\\"collectCoverageFrom\\\\\":[\\\\\"src\\\\\",\\\\\"!public\\\\\"],\\\\\"coverageDirectory\\\\\":\\\\\"coverage\\\\\",\\\\\"coveragePathIgnorePatterns\\\\\":[],\\\\\"coverageReporters\\\\\":[],\\\\\"cwd\\\\\":\\\\\"/test_root_dir/\\\\\",\\\\\"detectLeaks\\\\\":false,\\\\\"detectOpenHandles\\\\\":false,\\\\\"errorOnDeprecated\\\\\":false,\\\\\"extensionsToTreatAsEsm\\\\\":[],\\\\\"fakeTimers\\\\\":{\\\\\"enableGlobally\\\\\":false},\\\\\"forceCoverageMatch\\\\\":[],\\\\\"globals\\\\\":{},\\\\\"haste\\\\\":{},\\\\\"id\\\\\":\\\\\"test\\\\\",\\\\\"injectGlobals\\\\\":true,\\\\\"moduleDirectories\\\\\":[],\\\\\"moduleFileExtensions\\\\\":[\\\\\"js\\\\\"],\\\\\"moduleNameMapper\\\\\":[],\\\\\"modulePathIgnorePatterns\\\\\":[],\\\\\"modulePaths\\\\\":[],\\\\\"openHandlesTimeout\\\\\":1000,\\\\\"prettierPath\\\\\":\\\\\"prettier\\\\\",\\\\\"reporters\\\\\":[\\\\\"default\\\\\",\\\\\"custom-reporter-1\\\\\",[\\\\\"custom-reporter-2\\\\\",{\\\\\"configValue\\\\\":true}]],\\\\\"resetMocks\\\\\":false,\\\\\"resetModules\\\\\":false,\\\\\"restoreMocks\\\\\":false,\\\\\"rootDir\\\\\":\\\\\"/\\\\\",\\\\\"roots\\\\\":[],\\\\\"runner\\\\\":\\\\\"jest-runner\\\\\",\\\\\"runtime\\\\\":\\\\\"/test_module_loader_path\\\\\",\\\\\"sandboxInjectedGlobals\\\\\":[],\\\\\"setupFiles\\\\\":[],\\\\\"setupFilesAfterEnv\\\\\":[],\\\\\"skipFilter\\\\\":false,\\\\\"skipNodeResolution\\\\\":false,\\\\\"slowTestThreshold\\\\\":5,\\\\\"snapshotFormat\\\\\":{},\\\\\"snapshotSerializers\\\\\":[],\\\\\"testEnvironment\\\\\":\\\\\"node\\\\\",\\\\\"testEnvironmentOptions\\\\\":{},\\\\\"testLocationInResults\\\\\":false,\\\\\"testMatch\\\\\":[],\\\\\"testPathIgnorePatterns\\\\\":[],\\\\\"testRegex\\\\\":[\\\\\"\\\\\\\\\\\\\\\\.test\\\\\\\\\\\\\\\\.js$\\\\\"],\\\\\"testRunner\\\\\":\\\\\"jest-circus/runner\\\\\",\\\\\"testTimeout\\\\\":5000,\\\\\"transform\\\\\":[[\\\\\"\\\\\\\\\\\\\\\\.js$\\\\\",\\\\\"test_preprocessor\\\\\",{}]],\\\\\"transformIgnorePatterns\\\\\":[\\\\\"/node_modules/\\\\\"],\\\\\"waitNextEventLoopTurnForUnhandledRejectionEvents\\\\\":false,\\\\\"watchPathIgnorePatterns\\\\\":[]}\",\"transformerConfig\":{}}',\n};\"\n`;\n\nexports[`ScriptTransformer in async mode, uses the supplied preprocessor 2`] = `\"module.exports = \"react\";\"`;\n\nexports[`ScriptTransformer in async mode, warns of unparseable inlined source maps from the preprocessor 1`] = `\n\"<yellow><bold>● Invalid source map:</intensity></color>\n<yellow>  The source map for \"/fruits/banana.js\" returned by \"preprocessor-with-sourcemaps\" is invalid.</color>\n<yellow>  Proceeding without source mapping for that file.</color>\"\n`;\n\nexports[`ScriptTransformer passes expected transform options to getCacheKey 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [\n      \"module.exports = \"banana\";\",\n      \"/fruits/banana.js\",\n      Object {\n        \"cacheFS\": Map {\n          \"/fruits/banana.js\" => \"module.exports = \"banana\";\",\n        },\n        \"collectCoverage\": true,\n        \"collectCoverageFrom\": Array [],\n        \"config\": Object {\n          \"automock\": false,\n          \"cache\": true,\n          \"cacheDirectory\": \"/cache/\",\n          \"clearMocks\": false,\n          \"collectCoverageFrom\": Array [\n            \"src\",\n            \"!public\",\n          ],\n          \"coverageDirectory\": \"coverage\",\n          \"coveragePathIgnorePatterns\": Array [],\n          \"coverageReporters\": Array [],\n          \"cwd\": \"/test_root_dir/\",\n          \"detectLeaks\": false,\n          \"detectOpenHandles\": false,\n          \"displayName\": undefined,\n          \"errorOnDeprecated\": false,\n          \"extensionsToTreatAsEsm\": Array [],\n          \"fakeTimers\": Object {\n            \"enableGlobally\": false,\n          },\n          \"filter\": undefined,\n          \"forceCoverageMatch\": Array [],\n          \"globalSetup\": undefined,\n          \"globalTeardown\": undefined,\n          \"globals\": Object {},\n          \"haste\": Object {},\n          \"id\": \"test\",\n          \"injectGlobals\": true,\n          \"moduleDirectories\": Array [],\n          \"moduleFileExtensions\": Array [\n            \"js\",\n          ],\n          \"moduleNameMapper\": Array [],\n          \"modulePathIgnorePatterns\": Array [],\n          \"modulePaths\": Array [],\n          \"openHandlesTimeout\": 1000,\n          \"prettierPath\": \"prettier\",\n          \"reporters\": Array [\n            \"default\",\n            \"custom-reporter-1\",\n            Array [\n              \"custom-reporter-2\",\n              Object {\n                \"configValue\": true,\n              },\n            ],\n          ],\n          \"resetMocks\": false,\n          \"resetModules\": false,\n          \"resolver\": undefined,\n          \"restoreMocks\": false,\n          \"rootDir\": \"/\",\n          \"roots\": Array [],\n          \"runner\": \"jest-runner\",\n          \"runtime\": \"/test_module_loader_path\",\n          \"sandboxInjectedGlobals\": Array [],\n          \"setupFiles\": Array [],\n          \"setupFilesAfterEnv\": Array [],\n          \"skipFilter\": false,\n          \"skipNodeResolution\": false,\n          \"slowTestThreshold\": 5,\n          \"snapshotFormat\": Object {},\n          \"snapshotResolver\": undefined,\n          \"snapshotSerializers\": Array [],\n          \"testEnvironment\": \"node\",\n          \"testEnvironmentOptions\": Object {},\n          \"testLocationInResults\": false,\n          \"testMatch\": Array [],\n          \"testPathIgnorePatterns\": Array [],\n          \"testRegex\": Array [\n            \"\\\\.test\\\\.js$\",\n          ],\n          \"testRunner\": \"jest-circus/runner\",\n          \"testTimeout\": 5000,\n          \"transform\": Array [\n            Array [\n              \"\\\\.js$\",\n              \"test_preprocessor\",\n              Object {\n                \"configKey\": \"configValue\",\n              },\n            ],\n          ],\n          \"transformIgnorePatterns\": Array [\n            \"/node_modules/\",\n          ],\n          \"unmockedModulePathPatterns\": undefined,\n          \"waitNextEventLoopTurnForUnhandledRejectionEvents\": false,\n          \"watchPathIgnorePatterns\": Array [],\n        },\n        \"configString\": \"{\"automock\":false,\"cache\":true,\"cacheDirectory\":\"/cache/\",\"clearMocks\":false,\"collectCoverageFrom\":[\"src\",\"!public\"],\"coverageDirectory\":\"coverage\",\"coveragePathIgnorePatterns\":[],\"coverageReporters\":[],\"cwd\":\"/test_root_dir/\",\"detectLeaks\":false,\"detectOpenHandles\":false,\"errorOnDeprecated\":false,\"extensionsToTreatAsEsm\":[],\"fakeTimers\":{\"enableGlobally\":false},\"forceCoverageMatch\":[],\"globals\":{},\"haste\":{},\"id\":\"test\",\"injectGlobals\":true,\"moduleDirectories\":[],\"moduleFileExtensions\":[\"js\"],\"moduleNameMapper\":[],\"modulePathIgnorePatterns\":[],\"modulePaths\":[],\"openHandlesTimeout\":1000,\"prettierPath\":\"prettier\",\"reporters\":[\"default\",\"custom-reporter-1\",[\"custom-reporter-2\",{\"configValue\":true}]],\"resetMocks\":false,\"resetModules\":false,\"restoreMocks\":false,\"rootDir\":\"/\",\"roots\":[],\"runner\":\"jest-runner\",\"runtime\":\"/test_module_loader_path\",\"sandboxInjectedGlobals\":[],\"setupFiles\":[],\"setupFilesAfterEnv\":[],\"skipFilter\":false,\"skipNodeResolution\":false,\"slowTestThreshold\":5,\"snapshotFormat\":{},\"snapshotSerializers\":[],\"testEnvironment\":\"node\",\"testEnvironmentOptions\":{},\"testLocationInResults\":false,\"testMatch\":[],\"testPathIgnorePatterns\":[],\"testRegex\":[\"\\\\\\\\.test\\\\\\\\.js$\"],\"testRunner\":\"jest-circus/runner\",\"testTimeout\":5000,\"transform\":[[\"\\\\\\\\.js$\",\"test_preprocessor\",{\"configKey\":\"configValue\"}]],\"transformIgnorePatterns\":[\"/node_modules/\"],\"waitNextEventLoopTurnForUnhandledRejectionEvents\":false,\"watchPathIgnorePatterns\":[]}\",\n        \"coverageProvider\": \"babel\",\n        \"instrument\": true,\n        \"supportsDynamicImport\": false,\n        \"supportsExportNamespaceFrom\": false,\n        \"supportsStaticESM\": false,\n        \"supportsTopLevelAwait\": false,\n        \"transformerConfig\": Object {\n          \"configKey\": \"configValue\",\n        },\n      },\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": \"ab\",\n    },\n  ],\n}\n`;\n\nexports[`ScriptTransformer passes expected transform options to getCacheKeyAsync 1`] = `\n[MockFunction] {\n  \"calls\": Array [\n    Array [\n      \"module.exports = \"banana\";\",\n      \"/fruits/banana.js\",\n      Object {\n        \"cacheFS\": Map {\n          \"/fruits/banana.js\" => \"module.exports = \"banana\";\",\n        },\n        \"collectCoverage\": true,\n        \"collectCoverageFrom\": Array [],\n        \"config\": Object {\n          \"automock\": false,\n          \"cache\": true,\n          \"cacheDirectory\": \"/cache/\",\n          \"clearMocks\": false,\n          \"collectCoverageFrom\": Array [\n            \"src\",\n            \"!public\",\n          ],\n          \"coverageDirectory\": \"coverage\",\n          \"coveragePathIgnorePatterns\": Array [],\n          \"coverageReporters\": Array [],\n          \"cwd\": \"/test_root_dir/\",\n          \"detectLeaks\": false,\n          \"detectOpenHandles\": false,\n          \"displayName\": undefined,\n          \"errorOnDeprecated\": false,\n          \"extensionsToTreatAsEsm\": Array [],\n          \"fakeTimers\": Object {\n            \"enableGlobally\": false,\n          },\n          \"filter\": undefined,\n          \"forceCoverageMatch\": Array [],\n          \"globalSetup\": undefined,\n          \"globalTeardown\": undefined,\n          \"globals\": Object {},\n          \"haste\": Object {},\n          \"id\": \"test\",\n          \"injectGlobals\": true,\n          \"moduleDirectories\": Array [],\n          \"moduleFileExtensions\": Array [\n            \"js\",\n          ],\n          \"moduleNameMapper\": Array [],\n          \"modulePathIgnorePatterns\": Array [],\n          \"modulePaths\": Array [],\n          \"openHandlesTimeout\": 1000,\n          \"prettierPath\": \"prettier\",\n          \"reporters\": Array [\n            \"default\",\n            \"custom-reporter-1\",\n            Array [\n              \"custom-reporter-2\",\n              Object {\n                \"configValue\": true,\n              },\n            ],\n          ],\n          \"resetMocks\": false,\n          \"resetModules\": false,\n          \"resolver\": undefined,\n          \"restoreMocks\": false,\n          \"rootDir\": \"/\",\n          \"roots\": Array [],\n          \"runner\": \"jest-runner\",\n          \"runtime\": \"/test_module_loader_path\",\n          \"sandboxInjectedGlobals\": Array [],\n          \"setupFiles\": Array [],\n          \"setupFilesAfterEnv\": Array [],\n          \"skipFilter\": false,\n          \"skipNodeResolution\": false,\n          \"slowTestThreshold\": 5,\n          \"snapshotFormat\": Object {},\n          \"snapshotResolver\": undefined,\n          \"snapshotSerializers\": Array [],\n          \"testEnvironment\": \"node\",\n          \"testEnvironmentOptions\": Object {},\n          \"testLocationInResults\": false,\n          \"testMatch\": Array [],\n          \"testPathIgnorePatterns\": Array [],\n          \"testRegex\": Array [\n            \"\\\\.test\\\\.js$\",\n          ],\n          \"testRunner\": \"jest-circus/runner\",\n          \"testTimeout\": 5000,\n          \"transform\": Array [\n            Array [\n              \"\\\\.js$\",\n              \"test_async_preprocessor\",\n              Object {\n                \"configKey\": \"configValue\",\n              },\n            ],\n          ],\n          \"transformIgnorePatterns\": Array [\n            \"/node_modules/\",\n          ],\n          \"unmockedModulePathPatterns\": undefined,\n          \"waitNextEventLoopTurnForUnhandledRejectionEvents\": false,\n          \"watchPathIgnorePatterns\": Array [],\n        },\n        \"configString\": \"{\"automock\":false,\"cache\":true,\"cacheDirectory\":\"/cache/\",\"clearMocks\":false,\"collectCoverageFrom\":[\"src\",\"!public\"],\"coverageDirectory\":\"coverage\",\"coveragePathIgnorePatterns\":[],\"coverageReporters\":[],\"cwd\":\"/test_root_dir/\",\"detectLeaks\":false,\"detectOpenHandles\":false,\"errorOnDeprecated\":false,\"extensionsToTreatAsEsm\":[],\"fakeTimers\":{\"enableGlobally\":false},\"forceCoverageMatch\":[],\"globals\":{},\"haste\":{},\"id\":\"test\",\"injectGlobals\":true,\"moduleDirectories\":[],\"moduleFileExtensions\":[\"js\"],\"moduleNameMapper\":[],\"modulePathIgnorePatterns\":[],\"modulePaths\":[],\"openHandlesTimeout\":1000,\"prettierPath\":\"prettier\",\"reporters\":[\"default\",\"custom-reporter-1\",[\"custom-reporter-2\",{\"configValue\":true}]],\"resetMocks\":false,\"resetModules\":false,\"restoreMocks\":false,\"rootDir\":\"/\",\"roots\":[],\"runner\":\"jest-runner\",\"runtime\":\"/test_module_loader_path\",\"sandboxInjectedGlobals\":[],\"setupFiles\":[],\"setupFilesAfterEnv\":[],\"skipFilter\":false,\"skipNodeResolution\":false,\"slowTestThreshold\":5,\"snapshotFormat\":{},\"snapshotSerializers\":[],\"testEnvironment\":\"node\",\"testEnvironmentOptions\":{},\"testLocationInResults\":false,\"testMatch\":[],\"testPathIgnorePatterns\":[],\"testRegex\":[\"\\\\\\\\.test\\\\\\\\.js$\"],\"testRunner\":\"jest-circus/runner\",\"testTimeout\":5000,\"transform\":[[\"\\\\\\\\.js$\",\"test_async_preprocessor\",{\"configKey\":\"configValue\"}]],\"transformIgnorePatterns\":[\"/node_modules/\"],\"waitNextEventLoopTurnForUnhandledRejectionEvents\":false,\"watchPathIgnorePatterns\":[]}\",\n        \"coverageProvider\": \"babel\",\n        \"instrument\": true,\n        \"supportsDynamicImport\": false,\n        \"supportsExportNamespaceFrom\": false,\n        \"supportsStaticESM\": false,\n        \"supportsTopLevelAwait\": false,\n        \"transformerConfig\": Object {\n          \"configKey\": \"configValue\",\n        },\n      },\n    ],\n  ],\n  \"results\": Array [\n    Object {\n      \"type\": \"return\",\n      \"value\": Promise {},\n    },\n  ],\n}\n`;\n\nexports[`ScriptTransformer throws an error if \\`process\\` doesn't return an object containing \\`code\\` key with processed string 1`] = `\n\"<red><bold>● Invalid return value:</intensity></color>\n<red>  \\`process()\\` or/and \\`processAsync()\\` method of code transformer found at </color>\n<red>  \"passthrough-preprocessor\" </color>\n<red>  should return an object or a Promise resolving to an object. The object </color>\n<red>  must have \\`code\\` property with a string of processed code.</color>\n<red>  <bold>This error may be caused by a breaking change in Jest 28:</intensity></color>\n<red>  https://jest-archive-august-2023.netlify.app/docs/28.x/upgrading-to-jest28#transformer</color>\n<red>  <bold>Code Transformation Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/code-transformation</color>\n<red></color>\"\n`;\n\nexports[`ScriptTransformer throws an error if \\`process\\` doesn't return an object containing \\`code\\` key with processed string 2`] = `\n\"<red><bold>● Invalid return value:</intensity></color>\n<red>  \\`process()\\` or/and \\`processAsync()\\` method of code transformer found at </color>\n<red>  \"passthrough-preprocessor\" </color>\n<red>  should return an object or a Promise resolving to an object. The object </color>\n<red>  must have \\`code\\` property with a string of processed code.</color>\n<red>  <bold>This error may be caused by a breaking change in Jest 28:</intensity></color>\n<red>  https://jest-archive-august-2023.netlify.app/docs/28.x/upgrading-to-jest28#transformer</color>\n<red>  <bold>Code Transformation Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/code-transformation</color>\n<red></color>\"\n`;\n\nexports[`ScriptTransformer throws an error if \\`process\\` doesn't return an object containing \\`code\\` key with processed string 3`] = `\n\"<red><bold>● Invalid return value:</intensity></color>\n<red>  \\`process()\\` or/and \\`processAsync()\\` method of code transformer found at </color>\n<red>  \"passthrough-preprocessor\" </color>\n<red>  should return an object or a Promise resolving to an object. The object </color>\n<red>  must have \\`code\\` property with a string of processed code.</color>\n<red>  <bold>This error may be caused by a breaking change in Jest 28:</intensity></color>\n<red>  https://jest-archive-august-2023.netlify.app/docs/28.x/upgrading-to-jest28#transformer</color>\n<red>  <bold>Code Transformation Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/code-transformation</color>\n<red></color>\"\n`;\n\nexports[`ScriptTransformer throws an error if \\`process\\` doesn't return an object containing \\`code\\` key with processed string 4`] = `\n\"<red><bold>● Invalid return value:</intensity></color>\n<red>  \\`process()\\` or/and \\`processAsync()\\` method of code transformer found at </color>\n<red>  \"passthrough-preprocessor\" </color>\n<red>  should return an object or a Promise resolving to an object. The object </color>\n<red>  must have \\`code\\` property with a string of processed code.</color>\n<red>  <bold>This error may be caused by a breaking change in Jest 28:</intensity></color>\n<red>  https://jest-archive-august-2023.netlify.app/docs/28.x/upgrading-to-jest28#transformer</color>\n<red>  <bold>Code Transformation Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/code-transformation</color>\n<red></color>\"\n`;\n\nexports[`ScriptTransformer throws an error if \\`processAsync\\` doesn't return a promise of object containing \\`code\\` key with processed string 1`] = `\n\"<red><bold>● Invalid return value:</intensity></color>\n<red>  \\`process()\\` or/and \\`processAsync()\\` method of code transformer found at </color>\n<red>  \"passthrough-preprocessor-fruits-banana-js\" </color>\n<red>  should return an object or a Promise resolving to an object. The object </color>\n<red>  must have \\`code\\` property with a string of processed code.</color>\n<red>  <bold>This error may be caused by a breaking change in Jest 28:</intensity></color>\n<red>  https://jest-archive-august-2023.netlify.app/docs/28.x/upgrading-to-jest28#transformer</color>\n<red>  <bold>Code Transformation Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/code-transformation</color>\n<red></color>\"\n`;\n\nexports[`ScriptTransformer throws an error if \\`processAsync\\` doesn't return a promise of object containing \\`code\\` key with processed string 2`] = `\n\"<red><bold>● Invalid return value:</intensity></color>\n<red>  \\`process()\\` or/and \\`processAsync()\\` method of code transformer found at </color>\n<red>  \"passthrough-preprocessor-fruits-avocado-js\" </color>\n<red>  should return an object or a Promise resolving to an object. The object </color>\n<red>  must have \\`code\\` property with a string of processed code.</color>\n<red>  <bold>This error may be caused by a breaking change in Jest 28:</intensity></color>\n<red>  https://jest-archive-august-2023.netlify.app/docs/28.x/upgrading-to-jest28#transformer</color>\n<red>  <bold>Code Transformation Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/code-transformation</color>\n<red></color>\"\n`;\n\nexports[`ScriptTransformer throws an error if \\`processAsync\\` doesn't return a promise of object containing \\`code\\` key with processed string 3`] = `\n\"<red><bold>● Invalid return value:</intensity></color>\n<red>  \\`process()\\` or/and \\`processAsync()\\` method of code transformer found at </color>\n<red>  \"passthrough-preprocessor-fruits-kiwi-js\" </color>\n<red>  should return an object or a Promise resolving to an object. The object </color>\n<red>  must have \\`code\\` property with a string of processed code.</color>\n<red>  <bold>This error may be caused by a breaking change in Jest 28:</intensity></color>\n<red>  https://jest-archive-august-2023.netlify.app/docs/28.x/upgrading-to-jest28#transformer</color>\n<red>  <bold>Code Transformation Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/code-transformation</color>\n<red></color>\"\n`;\n\nexports[`ScriptTransformer throws an error if \\`processAsync\\` doesn't return a promise of object containing \\`code\\` key with processed string 4`] = `\n\"<red><bold>● Invalid return value:</intensity></color>\n<red>  \\`process()\\` or/and \\`processAsync()\\` method of code transformer found at </color>\n<red>  \"passthrough-preprocessor-fruits-grapefruit-js\" </color>\n<red>  should return an object or a Promise resolving to an object. The object </color>\n<red>  must have \\`code\\` property with a string of processed code.</color>\n<red>  <bold>This error may be caused by a breaking change in Jest 28:</intensity></color>\n<red>  https://jest-archive-august-2023.netlify.app/docs/28.x/upgrading-to-jest28#transformer</color>\n<red>  <bold>Code Transformation Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/code-transformation</color>\n<red></color>\"\n`;\n\nexports[`ScriptTransformer throws an error if createTransformer returns object without \\`process\\` method 1`] = `\n\"<red><bold>● Invalid transformer module:</intensity></color>\n<red>  \"skipped-required-create-transformer-props-preprocessor\" specified in the \"transform\" object of Jest configuration</color>\n<red>  must export a \\`process\\` or \\`processAsync\\` or \\`createTransformer\\` function.</color>\n<red>  <bold>Code Transformation Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/code-transformation</color>\n<red></color>\"\n`;\n\nexports[`ScriptTransformer throws an error if neither \\`process\\` nor \\`processAsync\\` is defined 1`] = `\n\"<red><bold>● Invalid transformer module:</intensity></color>\n<red>  \"skipped-required-props-preprocessor\" specified in the \"transform\" object of Jest configuration</color>\n<red>  must export a \\`process\\` or \\`processAsync\\` or \\`createTransformer\\` function.</color>\n<red>  <bold>Code Transformation Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/code-transformation</color>\n<red></color>\"\n`;\n\nexports[`ScriptTransformer transforms a file async properly 1`] = `\n\"/* istanbul ignore next */\nfunction cov_25u22311x4() {\n  var path = \"/fruits/banana.js\";\n  var hash = \"3f8e915bed83285455a8a16aa04dc0cf5242d755\";\n  var global = new Function(\"return this\")();\n  var gcv = \"__coverage__\";\n  var coverageData = {\n    path: \"/fruits/banana.js\",\n    statementMap: {\n      \"0\": {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 26\n        }\n      }\n    },\n    fnMap: {},\n    branchMap: {},\n    s: {\n      \"0\": 0\n    },\n    f: {},\n    b: {},\n    inputSourceMap: null,\n    _coverageSchema: \"1a1c01bbd47fc00a2c39e90264f33305004495a9\",\n    hash: \"3f8e915bed83285455a8a16aa04dc0cf5242d755\"\n  };\n  var coverage = global[gcv] || (global[gcv] = {});\n  if (!coverage[path] || coverage[path].hash !== hash) {\n    coverage[path] = coverageData;\n  }\n  var actualCoverage = coverage[path];\n  {\n    // @ts-ignore\n    cov_25u22311x4 = function () {\n      return actualCoverage;\n    };\n  }\n  return actualCoverage;\n}\ncov_25u22311x4();\ncov_25u22311x4().s[0]++;\nmodule.exports = \"banana\";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjb3ZfMjV1MjIzMTF4NCIsImFjdHVhbENvdmVyYWdlIiwicyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlcyI6WyJiYW5hbmEuanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImJhbmFuYVwiOyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWVZO0lBQUFBLGNBQUEsWUFBQUEsQ0FBQTtNQUFBLE9BQUFDLGNBQUE7SUFBQTtFQUFBO0VBQUEsT0FBQUEsY0FBQTtBQUFBO0FBQUFELGNBQUE7QUFBQUEsY0FBQSxHQUFBRSxDQUFBO0FBZlpDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHLFFBQVEiLCJpZ25vcmVMaXN0IjpbXX0=\"\n`;\n\nexports[`ScriptTransformer transforms a file async properly 2`] = `\n\"/* istanbul ignore next */\nfunction cov_23yvu8etmu() {\n  var path = \"/fruits/kiwi.js\";\n  var hash = \"8b5afd38d79008f13ebc229b89ef82b12ee9447a\";\n  var global = new Function(\"return this\")();\n  var gcv = \"__coverage__\";\n  var coverageData = {\n    path: \"/fruits/kiwi.js\",\n    statementMap: {\n      \"0\": {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 30\n        }\n      },\n      \"1\": {\n        start: {\n          line: 1,\n          column: 23\n        },\n        end: {\n          line: 1,\n          column: 29\n        }\n      }\n    },\n    fnMap: {\n      \"0\": {\n        name: \"(anonymous_0)\",\n        decl: {\n          start: {\n            line: 1,\n            column: 17\n          },\n          end: {\n            line: 1,\n            column: 18\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 23\n          },\n          end: {\n            line: 1,\n            column: 29\n          }\n        },\n        line: 1\n      }\n    },\n    branchMap: {},\n    s: {\n      \"0\": 0,\n      \"1\": 0\n    },\n    f: {\n      \"0\": 0\n    },\n    b: {},\n    inputSourceMap: null,\n    _coverageSchema: \"1a1c01bbd47fc00a2c39e90264f33305004495a9\",\n    hash: \"8b5afd38d79008f13ebc229b89ef82b12ee9447a\"\n  };\n  var coverage = global[gcv] || (global[gcv] = {});\n  if (!coverage[path] || coverage[path].hash !== hash) {\n    coverage[path] = coverageData;\n  }\n  var actualCoverage = coverage[path];\n  {\n    // @ts-ignore\n    cov_23yvu8etmu = function () {\n      return actualCoverage;\n    };\n  }\n  return actualCoverage;\n}\ncov_23yvu8etmu();\ncov_23yvu8etmu().s[0]++;\nmodule.exports = () => {\n  /* istanbul ignore next */\n  cov_23yvu8etmu().f[0]++;\n  cov_23yvu8etmu().s[1]++;\n  return \"kiwi\";\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjb3ZfMjN5dnU4ZXRtdSIsImFjdHVhbENvdmVyYWdlIiwicyIsIm1vZHVsZSIsImV4cG9ydHMiLCJmIl0sInNvdXJjZXMiOlsia2l3aS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9ICgpID0+IFwia2l3aVwiOyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBZVk7SUFBQUEsY0FBQSxZQUFBQSxDQUFBO01BQUEsT0FBQUMsY0FBQTtJQUFBO0VBQUE7RUFBQSxPQUFBQSxjQUFBO0FBQUE7QUFBQUQsY0FBQTtBQUFBQSxjQUFBLEdBQUFFLENBQUE7QUFmWkMsTUFBTSxDQUFDQyxPQUFPLEdBQUcsTUFBTTtFQUFBO0VBQUFKLGNBQUEsR0FBQUssQ0FBQTtFQUFBTCxjQUFBLEdBQUFFLENBQUE7RUFBQSxhQUFNO0FBQUQsQ0FBQyIsImlnbm9yZUxpc3QiOltdfQ==\"\n`;\n\nexports[`ScriptTransformer transforms a file properly 1`] = `\n\"/* istanbul ignore next */\nfunction cov_25u22311x4() {\n  var path = \"/fruits/banana.js\";\n  var hash = \"3f8e915bed83285455a8a16aa04dc0cf5242d755\";\n  var global = new Function(\"return this\")();\n  var gcv = \"__coverage__\";\n  var coverageData = {\n    path: \"/fruits/banana.js\",\n    statementMap: {\n      \"0\": {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 26\n        }\n      }\n    },\n    fnMap: {},\n    branchMap: {},\n    s: {\n      \"0\": 0\n    },\n    f: {},\n    b: {},\n    inputSourceMap: null,\n    _coverageSchema: \"1a1c01bbd47fc00a2c39e90264f33305004495a9\",\n    hash: \"3f8e915bed83285455a8a16aa04dc0cf5242d755\"\n  };\n  var coverage = global[gcv] || (global[gcv] = {});\n  if (!coverage[path] || coverage[path].hash !== hash) {\n    coverage[path] = coverageData;\n  }\n  var actualCoverage = coverage[path];\n  {\n    // @ts-ignore\n    cov_25u22311x4 = function () {\n      return actualCoverage;\n    };\n  }\n  return actualCoverage;\n}\ncov_25u22311x4();\ncov_25u22311x4().s[0]++;\nmodule.exports = \"banana\";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjb3ZfMjV1MjIzMTF4NCIsImFjdHVhbENvdmVyYWdlIiwicyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlcyI6WyJiYW5hbmEuanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcImJhbmFuYVwiOyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWVZO0lBQUFBLGNBQUEsWUFBQUEsQ0FBQTtNQUFBLE9BQUFDLGNBQUE7SUFBQTtFQUFBO0VBQUEsT0FBQUEsY0FBQTtBQUFBO0FBQUFELGNBQUE7QUFBQUEsY0FBQSxHQUFBRSxDQUFBO0FBZlpDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHLFFBQVEiLCJpZ25vcmVMaXN0IjpbXX0=\"\n`;\n\nexports[`ScriptTransformer transforms a file properly 2`] = `\n\"/* istanbul ignore next */\nfunction cov_23yvu8etmu() {\n  var path = \"/fruits/kiwi.js\";\n  var hash = \"8b5afd38d79008f13ebc229b89ef82b12ee9447a\";\n  var global = new Function(\"return this\")();\n  var gcv = \"__coverage__\";\n  var coverageData = {\n    path: \"/fruits/kiwi.js\",\n    statementMap: {\n      \"0\": {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 30\n        }\n      },\n      \"1\": {\n        start: {\n          line: 1,\n          column: 23\n        },\n        end: {\n          line: 1,\n          column: 29\n        }\n      }\n    },\n    fnMap: {\n      \"0\": {\n        name: \"(anonymous_0)\",\n        decl: {\n          start: {\n            line: 1,\n            column: 17\n          },\n          end: {\n            line: 1,\n            column: 18\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 23\n          },\n          end: {\n            line: 1,\n            column: 29\n          }\n        },\n        line: 1\n      }\n    },\n    branchMap: {},\n    s: {\n      \"0\": 0,\n      \"1\": 0\n    },\n    f: {\n      \"0\": 0\n    },\n    b: {},\n    inputSourceMap: null,\n    _coverageSchema: \"1a1c01bbd47fc00a2c39e90264f33305004495a9\",\n    hash: \"8b5afd38d79008f13ebc229b89ef82b12ee9447a\"\n  };\n  var coverage = global[gcv] || (global[gcv] = {});\n  if (!coverage[path] || coverage[path].hash !== hash) {\n    coverage[path] = coverageData;\n  }\n  var actualCoverage = coverage[path];\n  {\n    // @ts-ignore\n    cov_23yvu8etmu = function () {\n      return actualCoverage;\n    };\n  }\n  return actualCoverage;\n}\ncov_23yvu8etmu();\ncov_23yvu8etmu().s[0]++;\nmodule.exports = () => {\n  /* istanbul ignore next */\n  cov_23yvu8etmu().f[0]++;\n  cov_23yvu8etmu().s[1]++;\n  return \"kiwi\";\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJjb3ZfMjN5dnU4ZXRtdSIsImFjdHVhbENvdmVyYWdlIiwicyIsIm1vZHVsZSIsImV4cG9ydHMiLCJmIl0sInNvdXJjZXMiOlsia2l3aS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9ICgpID0+IFwia2l3aVwiOyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBZVk7SUFBQUEsY0FBQSxZQUFBQSxDQUFBO01BQUEsT0FBQUMsY0FBQTtJQUFBO0VBQUE7RUFBQSxPQUFBQSxjQUFBO0FBQUE7QUFBQUQsY0FBQTtBQUFBQSxjQUFBLEdBQUFFLENBQUE7QUFmWkMsTUFBTSxDQUFDQyxPQUFPLEdBQUcsTUFBTTtFQUFBO0VBQUFKLGNBQUEsR0FBQUssQ0FBQTtFQUFBTCxjQUFBLEdBQUFFLENBQUE7RUFBQSxhQUFNO0FBQUQsQ0FBQyIsImlnbm9yZUxpc3QiOltdfQ==\"\n`;\n\nexports[`ScriptTransformer uses mixture of sync/async preprocessors 1`] = `\n\"const TRANSFORMED = {\n  filename: '/fruits/banana.js',\n  script: 'module.exports = \"banana\";',\n  config: '{\"collectCoverage\":false,\"collectCoverageFrom\":[],\"coverageProvider\":\"babel\",\"supportsDynamicImport\":false,\"supportsExportNamespaceFrom\":false,\"supportsStaticESM\":false,\"supportsTopLevelAwait\":false,\"instrument\":false,\"cacheFS\":{},\"config\":{\"automock\":false,\"cache\":true,\"cacheDirectory\":\"/cache/\",\"clearMocks\":false,\"collectCoverageFrom\":[\"src\",\"!public\"],\"coverageDirectory\":\"coverage\",\"coveragePathIgnorePatterns\":[],\"coverageReporters\":[],\"cwd\":\"/test_root_dir/\",\"detectLeaks\":false,\"detectOpenHandles\":false,\"errorOnDeprecated\":false,\"extensionsToTreatAsEsm\":[],\"fakeTimers\":{\"enableGlobally\":false},\"forceCoverageMatch\":[],\"globals\":{},\"haste\":{},\"id\":\"test\",\"injectGlobals\":true,\"moduleDirectories\":[],\"moduleFileExtensions\":[\"js\"],\"moduleNameMapper\":[],\"modulePathIgnorePatterns\":[],\"modulePaths\":[],\"openHandlesTimeout\":1000,\"prettierPath\":\"prettier\",\"reporters\":[\"default\",\"custom-reporter-1\",[\"custom-reporter-2\",{\"configValue\":true}]],\"resetMocks\":false,\"resetModules\":false,\"restoreMocks\":false,\"rootDir\":\"/\",\"roots\":[],\"runner\":\"jest-runner\",\"runtime\":\"/test_module_loader_path\",\"sandboxInjectedGlobals\":[],\"setupFiles\":[],\"setupFilesAfterEnv\":[],\"skipFilter\":false,\"skipNodeResolution\":false,\"slowTestThreshold\":5,\"snapshotFormat\":{},\"snapshotSerializers\":[],\"testEnvironment\":\"node\",\"testEnvironmentOptions\":{},\"testLocationInResults\":false,\"testMatch\":[],\"testPathIgnorePatterns\":[],\"testRegex\":[\"\\\\\\\\.test\\\\\\\\.js$\"],\"testRunner\":\"jest-circus/runner\",\"testTimeout\":5000,\"transform\":[[\"\\\\\\\\.js$\",\"test_async_preprocessor\",{}],[\"\\\\\\\\.css$\",\"css-preprocessor\",{}]],\"transformIgnorePatterns\":[\"/node_modules/\"],\"waitNextEventLoopTurnForUnhandledRejectionEvents\":false,\"watchPathIgnorePatterns\":[]},\"configString\":\"{\\\\\"automock\\\\\":false,\\\\\"cache\\\\\":true,\\\\\"cacheDirectory\\\\\":\\\\\"/cache/\\\\\",\\\\\"clearMocks\\\\\":false,\\\\\"collectCoverageFrom\\\\\":[\\\\\"src\\\\\",\\\\\"!public\\\\\"],\\\\\"coverageDirectory\\\\\":\\\\\"coverage\\\\\",\\\\\"coveragePathIgnorePatterns\\\\\":[],\\\\\"coverageReporters\\\\\":[],\\\\\"cwd\\\\\":\\\\\"/test_root_dir/\\\\\",\\\\\"detectLeaks\\\\\":false,\\\\\"detectOpenHandles\\\\\":false,\\\\\"errorOnDeprecated\\\\\":false,\\\\\"extensionsToTreatAsEsm\\\\\":[],\\\\\"fakeTimers\\\\\":{\\\\\"enableGlobally\\\\\":false},\\\\\"forceCoverageMatch\\\\\":[],\\\\\"globals\\\\\":{},\\\\\"haste\\\\\":{},\\\\\"id\\\\\":\\\\\"test\\\\\",\\\\\"injectGlobals\\\\\":true,\\\\\"moduleDirectories\\\\\":[],\\\\\"moduleFileExtensions\\\\\":[\\\\\"js\\\\\"],\\\\\"moduleNameMapper\\\\\":[],\\\\\"modulePathIgnorePatterns\\\\\":[],\\\\\"modulePaths\\\\\":[],\\\\\"openHandlesTimeout\\\\\":1000,\\\\\"prettierPath\\\\\":\\\\\"prettier\\\\\",\\\\\"reporters\\\\\":[\\\\\"default\\\\\",\\\\\"custom-reporter-1\\\\\",[\\\\\"custom-reporter-2\\\\\",{\\\\\"configValue\\\\\":true}]],\\\\\"resetMocks\\\\\":false,\\\\\"resetModules\\\\\":false,\\\\\"restoreMocks\\\\\":false,\\\\\"rootDir\\\\\":\\\\\"/\\\\\",\\\\\"roots\\\\\":[],\\\\\"runner\\\\\":\\\\\"jest-runner\\\\\",\\\\\"runtime\\\\\":\\\\\"/test_module_loader_path\\\\\",\\\\\"sandboxInjectedGlobals\\\\\":[],\\\\\"setupFiles\\\\\":[],\\\\\"setupFilesAfterEnv\\\\\":[],\\\\\"skipFilter\\\\\":false,\\\\\"skipNodeResolution\\\\\":false,\\\\\"slowTestThreshold\\\\\":5,\\\\\"snapshotFormat\\\\\":{},\\\\\"snapshotSerializers\\\\\":[],\\\\\"testEnvironment\\\\\":\\\\\"node\\\\\",\\\\\"testEnvironmentOptions\\\\\":{},\\\\\"testLocationInResults\\\\\":false,\\\\\"testMatch\\\\\":[],\\\\\"testPathIgnorePatterns\\\\\":[],\\\\\"testRegex\\\\\":[\\\\\"\\\\\\\\\\\\\\\\.test\\\\\\\\\\\\\\\\.js$\\\\\"],\\\\\"testRunner\\\\\":\\\\\"jest-circus/runner\\\\\",\\\\\"testTimeout\\\\\":5000,\\\\\"transform\\\\\":[[\\\\\"\\\\\\\\\\\\\\\\.js$\\\\\",\\\\\"test_async_preprocessor\\\\\",{}],[\\\\\"\\\\\\\\\\\\\\\\.css$\\\\\",\\\\\"css-preprocessor\\\\\",{}]],\\\\\"transformIgnorePatterns\\\\\":[\\\\\"/node_modules/\\\\\"],\\\\\"waitNextEventLoopTurnForUnhandledRejectionEvents\\\\\":false,\\\\\"watchPathIgnorePatterns\\\\\":[]}\",\"transformerConfig\":{}}',\n};\"\n`;\n\nexports[`ScriptTransformer uses mixture of sync/async preprocessors 2`] = `\n\"module.exports = {\n  filename: /styles/App.css,\n  rawFirstLine: root {,\n};\"\n`;\n\nexports[`ScriptTransformer uses mixture of sync/async preprocessors 3`] = `\"module.exports = \"react\";\"`;\n\nexports[`ScriptTransformer uses multiple preprocessors 1`] = `\n\"const TRANSFORMED = {\n  filename: '/fruits/banana.js',\n  script: 'module.exports = \"banana\";',\n  config: '{\"collectCoverage\":false,\"collectCoverageFrom\":[],\"coverageProvider\":\"babel\",\"supportsDynamicImport\":false,\"supportsExportNamespaceFrom\":false,\"supportsStaticESM\":false,\"supportsTopLevelAwait\":false,\"instrument\":false,\"cacheFS\":{},\"config\":{\"automock\":false,\"cache\":true,\"cacheDirectory\":\"/cache/\",\"clearMocks\":false,\"collectCoverageFrom\":[\"src\",\"!public\"],\"coverageDirectory\":\"coverage\",\"coveragePathIgnorePatterns\":[],\"coverageReporters\":[],\"cwd\":\"/test_root_dir/\",\"detectLeaks\":false,\"detectOpenHandles\":false,\"errorOnDeprecated\":false,\"extensionsToTreatAsEsm\":[],\"fakeTimers\":{\"enableGlobally\":false},\"forceCoverageMatch\":[],\"globals\":{},\"haste\":{},\"id\":\"test\",\"injectGlobals\":true,\"moduleDirectories\":[],\"moduleFileExtensions\":[\"js\"],\"moduleNameMapper\":[],\"modulePathIgnorePatterns\":[],\"modulePaths\":[],\"openHandlesTimeout\":1000,\"prettierPath\":\"prettier\",\"reporters\":[\"default\",\"custom-reporter-1\",[\"custom-reporter-2\",{\"configValue\":true}]],\"resetMocks\":false,\"resetModules\":false,\"restoreMocks\":false,\"rootDir\":\"/\",\"roots\":[],\"runner\":\"jest-runner\",\"runtime\":\"/test_module_loader_path\",\"sandboxInjectedGlobals\":[],\"setupFiles\":[],\"setupFilesAfterEnv\":[],\"skipFilter\":false,\"skipNodeResolution\":false,\"slowTestThreshold\":5,\"snapshotFormat\":{},\"snapshotSerializers\":[],\"testEnvironment\":\"node\",\"testEnvironmentOptions\":{},\"testLocationInResults\":false,\"testMatch\":[],\"testPathIgnorePatterns\":[],\"testRegex\":[\"\\\\\\\\.test\\\\\\\\.js$\"],\"testRunner\":\"jest-circus/runner\",\"testTimeout\":5000,\"transform\":[[\"\\\\\\\\.js$\",\"test_preprocessor\",{}],[\"\\\\\\\\.css$\",\"css-preprocessor\",{}]],\"transformIgnorePatterns\":[\"/node_modules/\"],\"waitNextEventLoopTurnForUnhandledRejectionEvents\":false,\"watchPathIgnorePatterns\":[]},\"configString\":\"{\\\\\"automock\\\\\":false,\\\\\"cache\\\\\":true,\\\\\"cacheDirectory\\\\\":\\\\\"/cache/\\\\\",\\\\\"clearMocks\\\\\":false,\\\\\"collectCoverageFrom\\\\\":[\\\\\"src\\\\\",\\\\\"!public\\\\\"],\\\\\"coverageDirectory\\\\\":\\\\\"coverage\\\\\",\\\\\"coveragePathIgnorePatterns\\\\\":[],\\\\\"coverageReporters\\\\\":[],\\\\\"cwd\\\\\":\\\\\"/test_root_dir/\\\\\",\\\\\"detectLeaks\\\\\":false,\\\\\"detectOpenHandles\\\\\":false,\\\\\"errorOnDeprecated\\\\\":false,\\\\\"extensionsToTreatAsEsm\\\\\":[],\\\\\"fakeTimers\\\\\":{\\\\\"enableGlobally\\\\\":false},\\\\\"forceCoverageMatch\\\\\":[],\\\\\"globals\\\\\":{},\\\\\"haste\\\\\":{},\\\\\"id\\\\\":\\\\\"test\\\\\",\\\\\"injectGlobals\\\\\":true,\\\\\"moduleDirectories\\\\\":[],\\\\\"moduleFileExtensions\\\\\":[\\\\\"js\\\\\"],\\\\\"moduleNameMapper\\\\\":[],\\\\\"modulePathIgnorePatterns\\\\\":[],\\\\\"modulePaths\\\\\":[],\\\\\"openHandlesTimeout\\\\\":1000,\\\\\"prettierPath\\\\\":\\\\\"prettier\\\\\",\\\\\"reporters\\\\\":[\\\\\"default\\\\\",\\\\\"custom-reporter-1\\\\\",[\\\\\"custom-reporter-2\\\\\",{\\\\\"configValue\\\\\":true}]],\\\\\"resetMocks\\\\\":false,\\\\\"resetModules\\\\\":false,\\\\\"restoreMocks\\\\\":false,\\\\\"rootDir\\\\\":\\\\\"/\\\\\",\\\\\"roots\\\\\":[],\\\\\"runner\\\\\":\\\\\"jest-runner\\\\\",\\\\\"runtime\\\\\":\\\\\"/test_module_loader_path\\\\\",\\\\\"sandboxInjectedGlobals\\\\\":[],\\\\\"setupFiles\\\\\":[],\\\\\"setupFilesAfterEnv\\\\\":[],\\\\\"skipFilter\\\\\":false,\\\\\"skipNodeResolution\\\\\":false,\\\\\"slowTestThreshold\\\\\":5,\\\\\"snapshotFormat\\\\\":{},\\\\\"snapshotSerializers\\\\\":[],\\\\\"testEnvironment\\\\\":\\\\\"node\\\\\",\\\\\"testEnvironmentOptions\\\\\":{},\\\\\"testLocationInResults\\\\\":false,\\\\\"testMatch\\\\\":[],\\\\\"testPathIgnorePatterns\\\\\":[],\\\\\"testRegex\\\\\":[\\\\\"\\\\\\\\\\\\\\\\.test\\\\\\\\\\\\\\\\.js$\\\\\"],\\\\\"testRunner\\\\\":\\\\\"jest-circus/runner\\\\\",\\\\\"testTimeout\\\\\":5000,\\\\\"transform\\\\\":[[\\\\\"\\\\\\\\\\\\\\\\.js$\\\\\",\\\\\"test_preprocessor\\\\\",{}],[\\\\\"\\\\\\\\\\\\\\\\.css$\\\\\",\\\\\"css-preprocessor\\\\\",{}]],\\\\\"transformIgnorePatterns\\\\\":[\\\\\"/node_modules/\\\\\"],\\\\\"waitNextEventLoopTurnForUnhandledRejectionEvents\\\\\":false,\\\\\"watchPathIgnorePatterns\\\\\":[]}\",\"transformerConfig\":{}}',\n};\"\n`;\n\nexports[`ScriptTransformer uses multiple preprocessors 2`] = `\n\"module.exports = {\n  filename: /styles/App.css,\n  rawFirstLine: root {,\n};\"\n`;\n\nexports[`ScriptTransformer uses multiple preprocessors 3`] = `\"module.exports = \"react\";\"`;\n\nexports[`ScriptTransformer uses the supplied preprocessor 1`] = `\n\"const TRANSFORMED = {\n  filename: '/fruits/banana.js',\n  script: 'module.exports = \"banana\";',\n  config: '{\"collectCoverage\":false,\"collectCoverageFrom\":[],\"coverageProvider\":\"babel\",\"supportsDynamicImport\":false,\"supportsExportNamespaceFrom\":false,\"supportsStaticESM\":false,\"supportsTopLevelAwait\":false,\"instrument\":false,\"cacheFS\":{},\"config\":{\"automock\":false,\"cache\":true,\"cacheDirectory\":\"/cache/\",\"clearMocks\":false,\"collectCoverageFrom\":[\"src\",\"!public\"],\"coverageDirectory\":\"coverage\",\"coveragePathIgnorePatterns\":[],\"coverageReporters\":[],\"cwd\":\"/test_root_dir/\",\"detectLeaks\":false,\"detectOpenHandles\":false,\"errorOnDeprecated\":false,\"extensionsToTreatAsEsm\":[],\"fakeTimers\":{\"enableGlobally\":false},\"forceCoverageMatch\":[],\"globals\":{},\"haste\":{},\"id\":\"test\",\"injectGlobals\":true,\"moduleDirectories\":[],\"moduleFileExtensions\":[\"js\"],\"moduleNameMapper\":[],\"modulePathIgnorePatterns\":[],\"modulePaths\":[],\"openHandlesTimeout\":1000,\"prettierPath\":\"prettier\",\"reporters\":[\"default\",\"custom-reporter-1\",[\"custom-reporter-2\",{\"configValue\":true}]],\"resetMocks\":false,\"resetModules\":false,\"restoreMocks\":false,\"rootDir\":\"/\",\"roots\":[],\"runner\":\"jest-runner\",\"runtime\":\"/test_module_loader_path\",\"sandboxInjectedGlobals\":[],\"setupFiles\":[],\"setupFilesAfterEnv\":[],\"skipFilter\":false,\"skipNodeResolution\":false,\"slowTestThreshold\":5,\"snapshotFormat\":{},\"snapshotSerializers\":[],\"testEnvironment\":\"node\",\"testEnvironmentOptions\":{},\"testLocationInResults\":false,\"testMatch\":[],\"testPathIgnorePatterns\":[],\"testRegex\":[\"\\\\\\\\.test\\\\\\\\.js$\"],\"testRunner\":\"jest-circus/runner\",\"testTimeout\":5000,\"transform\":[[\"\\\\\\\\.js$\",\"test_preprocessor\",{}]],\"transformIgnorePatterns\":[\"/node_modules/\"],\"waitNextEventLoopTurnForUnhandledRejectionEvents\":false,\"watchPathIgnorePatterns\":[]},\"configString\":\"{\\\\\"automock\\\\\":false,\\\\\"cache\\\\\":true,\\\\\"cacheDirectory\\\\\":\\\\\"/cache/\\\\\",\\\\\"clearMocks\\\\\":false,\\\\\"collectCoverageFrom\\\\\":[\\\\\"src\\\\\",\\\\\"!public\\\\\"],\\\\\"coverageDirectory\\\\\":\\\\\"coverage\\\\\",\\\\\"coveragePathIgnorePatterns\\\\\":[],\\\\\"coverageReporters\\\\\":[],\\\\\"cwd\\\\\":\\\\\"/test_root_dir/\\\\\",\\\\\"detectLeaks\\\\\":false,\\\\\"detectOpenHandles\\\\\":false,\\\\\"errorOnDeprecated\\\\\":false,\\\\\"extensionsToTreatAsEsm\\\\\":[],\\\\\"fakeTimers\\\\\":{\\\\\"enableGlobally\\\\\":false},\\\\\"forceCoverageMatch\\\\\":[],\\\\\"globals\\\\\":{},\\\\\"haste\\\\\":{},\\\\\"id\\\\\":\\\\\"test\\\\\",\\\\\"injectGlobals\\\\\":true,\\\\\"moduleDirectories\\\\\":[],\\\\\"moduleFileExtensions\\\\\":[\\\\\"js\\\\\"],\\\\\"moduleNameMapper\\\\\":[],\\\\\"modulePathIgnorePatterns\\\\\":[],\\\\\"modulePaths\\\\\":[],\\\\\"openHandlesTimeout\\\\\":1000,\\\\\"prettierPath\\\\\":\\\\\"prettier\\\\\",\\\\\"reporters\\\\\":[\\\\\"default\\\\\",\\\\\"custom-reporter-1\\\\\",[\\\\\"custom-reporter-2\\\\\",{\\\\\"configValue\\\\\":true}]],\\\\\"resetMocks\\\\\":false,\\\\\"resetModules\\\\\":false,\\\\\"restoreMocks\\\\\":false,\\\\\"rootDir\\\\\":\\\\\"/\\\\\",\\\\\"roots\\\\\":[],\\\\\"runner\\\\\":\\\\\"jest-runner\\\\\",\\\\\"runtime\\\\\":\\\\\"/test_module_loader_path\\\\\",\\\\\"sandboxInjectedGlobals\\\\\":[],\\\\\"setupFiles\\\\\":[],\\\\\"setupFilesAfterEnv\\\\\":[],\\\\\"skipFilter\\\\\":false,\\\\\"skipNodeResolution\\\\\":false,\\\\\"slowTestThreshold\\\\\":5,\\\\\"snapshotFormat\\\\\":{},\\\\\"snapshotSerializers\\\\\":[],\\\\\"testEnvironment\\\\\":\\\\\"node\\\\\",\\\\\"testEnvironmentOptions\\\\\":{},\\\\\"testLocationInResults\\\\\":false,\\\\\"testMatch\\\\\":[],\\\\\"testPathIgnorePatterns\\\\\":[],\\\\\"testRegex\\\\\":[\\\\\"\\\\\\\\\\\\\\\\.test\\\\\\\\\\\\\\\\.js$\\\\\"],\\\\\"testRunner\\\\\":\\\\\"jest-circus/runner\\\\\",\\\\\"testTimeout\\\\\":5000,\\\\\"transform\\\\\":[[\\\\\"\\\\\\\\\\\\\\\\.js$\\\\\",\\\\\"test_preprocessor\\\\\",{}]],\\\\\"transformIgnorePatterns\\\\\":[\\\\\"/node_modules/\\\\\"],\\\\\"waitNextEventLoopTurnForUnhandledRejectionEvents\\\\\":false,\\\\\"watchPathIgnorePatterns\\\\\":[]}\",\"transformerConfig\":{}}',\n};\"\n`;\n\nexports[`ScriptTransformer uses the supplied preprocessor 2`] = `\"module.exports = \"react\";\"`;\n\nexports[`ScriptTransformer warns of unparseable inlined source maps from the async preprocessor 1`] = `\n\"<yellow><bold>● Invalid source map:</intensity></color>\n<yellow>  The source map for \"/fruits/banana.js\" returned by \"async-preprocessor-with-sourcemaps\" is invalid.</color>\n<yellow>  Proceeding without source mapping for that file.</color>\"\n`;\n\nexports[`ScriptTransformer warns of unparseable inlined source maps from the preprocessor 1`] = `\n\"<yellow><bold>● Invalid source map:</intensity></color>\n<yellow>  The source map for \"/fruits/banana.js\" returned by \"preprocessor-with-sourcemaps\" is invalid.</color>\n<yellow>  Proceeding without source mapping for that file.</color>\"\n`;"}
{"prompt":"When offset is -1,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport scroll from '../scroll';\n\nit('When offset is -1', () => {\n  expect(scroll(25, {max: 10, offset: -1})).toEqual({\n    end: 10,\n    index: -1,\n    start: 0,\n  });\n});\n\nit('When offset is in the first set of items', () => {\n  expect(scroll(25, {max: 10, offset: 4})).toEqual({\n    end: 10,\n    index: 4,\n    start: 0,\n  });\n\n  expect(scroll(25, {max: 10, offset: 6})).toEqual({\n    end: 10,\n    index: 6,\n    start: 0,\n  });\n});\n\nit('When offset is in the middle of the list', () => {\n  expect(scroll(25, {max: 10, offset: 7})).toEqual({\n    end: 11,\n    index: 6,\n    start: 1,\n  });\n\n  expect(scroll(25, {max: 10, offset: 14})).toEqual({\n    end: 18,\n    index: 6,\n    start: 8,\n  });\n});\n\nit('When offset is at the end of the list', () => {\n  expect(scroll(25, {max: 10, offset: 23})).toEqual({\n    end: 25,\n    index: 8,\n    start: 15,\n  });\n\n  expect(scroll(25, {max: 10, offset: 25})).toEqual({\n    end: 25,\n    index: 10,\n    start: 15,\n  });\n\n  expect(scroll(25, {max: 10, offset: 35})).toEqual({\n    end: 25,\n    index: 10,\n    start: 15,\n  });\n});\n\nit('When offset is at the end and size is smaller than max', () => {\n  expect(scroll(8, {max: 10, offset: 6})).toEqual({\n    end: 8,\n    index: 6,\n    start: 0,\n  });\n\n  expect(scroll(5, {max: 6, offset: 4})).toEqual({\n    end: 5,\n    index: 4,\n    start: 0,\n  });\n});"}
{"prompt":"SearchSource,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as path from 'path';\nimport {TestPathPatterns} from '@jest/pattern';\nimport type {Test} from '@jest/test-result';\nimport type {Config} from '@jest/types';\nimport {normalize} from 'jest-config';\nimport Runtime from 'jest-runtime';\nimport SearchSource from '../SearchSource';\nimport type {Filter} from '../types';\n\njest.setTimeout(15_000);\n\njest.mock('graceful-fs', () => {\n  const realFs = jest.requireActual<typeof import('fs')>('fs');\n\n  const mockedFs: typeof import('fs') = {\n    ...realFs,\n    statSync: path => {\n      if (path === '/foo/bar/prefix') {\n        return {isDirectory: () => true};\n      }\n\n      return realFs.statSync(path);\n    },\n  };\n\n  return mockedFs;\n});\n\nconst rootDir = path.resolve(__dirname, 'test_root');\nconst testRegex = `${path.sep}__testtests__${path.sep}`;\nconst testMatch = ['**/__testtests__/**/*'];\nconst maxWorkers = 1;\n\nconst toPaths = (tests: Array<Test>) => tests.map(({path}) => path);\n\nconst initSearchSource = async (\n  initialOptions: Config.InitialOptions,\n  options: {\n    contextFiles?: Array<string>;\n  } = {},\n) => {\n  const {options: config} = await normalize(initialOptions, {} as Config.Argv);\n  const context = await Runtime.createContext(config, {\n    maxWorkers,\n    watchman: false,\n  });\n  if (options.contextFiles) {\n    jest\n      .spyOn(context.hasteFS, 'getAllFiles')\n      .mockReturnValue(options.contextFiles);\n  }\n  return {config, searchSource: new SearchSource(context)};\n};\n\ndescribe('SearchSource', () => {\n  const id = 'SearchSource';\n  let searchSource: SearchSource;\n\n  describe('isTestFilePath', () => {\n    beforeEach(async () => {\n      ({searchSource} = await initSearchSource({\n        id,\n        rootDir: '.',\n        roots: [],\n      }));\n    });\n\n    // micromatch doesn't support '..' through the globstar ('**') to avoid\n    // infinite recursion.\n    it('supports ../ paths and unix separators via testRegex', async () => {\n      if (process.platform === 'win32') {\n        return;\n      }\n      const {searchSource} = await initSearchSource({\n        id,\n        rootDir: '.',\n        roots: [],\n        testMatch: undefined,\n        testRegex: '(/__tests__/.*|(\\\\.|/)(test|spec))\\\\.jsx?$',\n      });\n\n      const path = '/path/to/__tests__/foo/bar/baz/../../../test.js';\n      expect(searchSource.isTestFilePath(path)).toBe(true);\n    });\n\n    it('supports unix separators', () => {\n      if (process.platform !== 'win32') {\n        const path = '/path/to/__tests__/test.js';\n        expect(searchSource.isTestFilePath(path)).toBe(true);\n      }\n    });\n\n    it('supports win32 separators', () => {\n      if (process.platform === 'win32') {\n        const path = '\\\\path\\\\to\\\\__tests__\\\\test.js';\n        expect(searchSource.isTestFilePath(path)).toBe(true);\n      }\n    });\n  });\n\n  describe('getTestPaths', () => {\n    const getTestPaths = async (\n      initialOptions: Config.InitialOptions,\n      filter?: Filter,\n    ) => {\n      const {searchSource, config} = await initSearchSource(initialOptions);\n      const allConfig = {\n        ...config,\n        ...initialOptions,\n        testPathPatterns: new TestPathPatterns([]),\n      };\n      const {tests: paths} = await searchSource.getTestPaths(\n        allConfig,\n        allConfig,\n        null,\n        filter,\n      );\n      return paths.map(({path: p}) => path.relative(rootDir, p)).sort();\n    };\n\n    it('finds tests matching a pattern via testRegex', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx', 'txt'],\n        rootDir,\n        testMatch: undefined,\n        testRegex: 'not-really-a-test',\n      });\n      expect(paths).toEqual([\n        path.normalize('.hiddenFolder/not-really-a-test.txt'),\n        path.normalize('__testtests__/not-really-a-test.txt'),\n      ]);\n    });\n\n    it('finds tests matching a pattern via testMatch', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx', 'txt'],\n        rootDir,\n        testMatch: ['**/not-really-a-test.txt', '!**/do-not-match-me.txt'],\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('.hiddenFolder/not-really-a-test.txt'),\n        path.normalize('__testtests__/not-really-a-test.txt'),\n      ]);\n    });\n\n    it('finds tests matching a JS regex pattern', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch: undefined,\n        testRegex: 'test.jsx?',\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('finds tests matching a JS glob pattern', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch: ['**/test.js?(x)'],\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('finds tests matching a JS with overriding glob patterns', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch: [\n          '**/*.js?(x)',\n          '!**/test.js?(x)',\n          '**/test.js',\n          '!**/test.js',\n        ],\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('module.jsx'),\n        path.normalize('noTests.js'),\n      ]);\n    });\n\n    it('finds tests with default file extensions using testRegex', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir,\n        testMatch: undefined,\n        testRegex,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('finds tests with default file extensions using testMatch', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir,\n        testMatch,\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('finds tests with parentheses in their rootDir when using testMatch', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir: path.resolve(__dirname, 'test_root_with_(parentheses)'),\n        testMatch: ['<rootDir>**/__testtests__/**/*'],\n        testRegex: undefined,\n      });\n      expect(paths).toEqual([\n        expect.stringContaining(path.normalize('__testtests__/test.js')),\n      ]);\n    });\n\n    it('finds tests with similar but custom file extensions', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('finds tests with totally custom foobar file extensions', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'foobar'],\n        rootDir,\n        testMatch,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.foobar'),\n        path.normalize('__testtests__/test.js'),\n      ]);\n    });\n\n    it('finds tests with many kinds of file extensions', async () => {\n      const paths = await getTestPaths({\n        id,\n        moduleFileExtensions: ['js', 'jsx'],\n        rootDir,\n        testMatch,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('finds tests using a regex only', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir,\n        testMatch: undefined,\n        testRegex,\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('finds tests using a glob only', async () => {\n      const paths = await getTestPaths({\n        id,\n        rootDir,\n        testMatch,\n        testRegex: '',\n      });\n      expect(paths).toEqual([\n        path.normalize('__testtests__/test.js'),\n        path.normalize('__testtests__/test.jsx'),\n      ]);\n    });\n\n    it('filter tests based on an optional filter method', async () => {\n      const filterFunction = (testPaths: Array<string>) =>\n        Promise.resolve({\n          filtered: testPaths.filter(testPath => testPath.includes('test.jsx')),\n        });\n      const paths = await getTestPaths(\n        {\n          id,\n          rootDir,\n        },\n        filterFunction,\n      );\n\n      expect(paths).toHaveLength(1);\n      expect(paths[0]).toStrictEqual(path.normalize('__testtests__/test.jsx'));\n    });\n  });\n\n  describe('filterPathsWin32', () => {\n    beforeEach(async () => {\n      ({searchSource} = await initSearchSource(\n        {\n          id,\n          rootDir: '.',\n          roots: [],\n        },\n        {\n          contextFiles: [\n            path.resolve('packages/lib/my-lib.ts'),\n            path.resolve('packages/@core/my-app.ts'),\n            path.resolve('packages/+cli/my-cli.ts'),\n            path.resolve('packages/.hidden/my-app-hidden.ts'),\n            path.resolve('packages/programs (x86)/my-program.ts'),\n          ],\n        },\n      ));\n    });\n\n    it('should allow a simple match', async () => {\n      const result = searchSource.filterPathsWin32(['packages/lib/my-lib.ts']);\n      expect(result).toEqual([path.resolve('packages/lib/my-lib.ts')]);\n    });\n    it('should allow to match a file inside a hidden directory', async () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/.hidden/my-app-hidden.ts',\n      ]);\n      expect(result).toEqual([\n        path.resolve('packages/.hidden/my-app-hidden.ts'),\n      ]);\n    });\n    it('should allow to match a file inside a directory prefixed with a \"@\"', async () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/@core/my-app.ts',\n      ]);\n      expect(result).toEqual([path.resolve('packages/@core/my-app.ts')]);\n    });\n    it('should allow to match a file inside a directory prefixed with a \"+\"', async () => {\n      const result = searchSource.filterPathsWin32(['packages/+cli/my-cli.ts']);\n      expect(result).toEqual([path.resolve('packages/+cli/my-cli.ts')]);\n    });\n    it('should allow an @(pattern)', () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/@(@core)/my-app.ts',\n      ]);\n      expect(result).toEqual([path.resolve('packages/@core/my-app.ts')]);\n    });\n    it('should allow a +(pattern)', () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/+(@core)/my-app.ts',\n      ]);\n      expect(result).toEqual([path.resolve('packages/@core/my-app.ts')]);\n    });\n    it('should allow for (pattern) in file path', () => {\n      const result = searchSource.filterPathsWin32([\n        'packages/programs (x86)/my-program.ts',\n      ]);\n      expect(result).toEqual([\n        path.resolve('packages/programs (x86)/my-program.ts'),\n      ]);\n    });\n    it('should allow no results found', () => {\n      const result = searchSource.filterPathsWin32(['not/exists']);\n      expect(result).toHaveLength(0);\n    });\n  });\n\n  describe('findRelatedTests', () => {\n    const rootDir = path.join(\n      __dirname,\n      '..',\n      '..',\n      '..',\n      'jest-runtime',\n      'src',\n      '__tests__',\n      'test_root',\n    );\n    const rootPath = path.join(rootDir, 'root.js');\n\n    beforeEach(async () => {\n      ({searchSource} = await initSearchSource({\n        haste: {\n          hasteImplModulePath: path.join(\n            __dirname,\n            '..',\n            '..',\n            '..',\n            'jest-haste-map',\n            'src',\n            '__tests__',\n            'haste_impl.js',\n          ),\n        },\n        id: 'SearchSource-findRelatedTests-tests',\n        rootDir,\n      }));\n    });\n\n    it('makes sure a file is related to itself', async () => {\n      const data = await searchSource.findRelatedTests(\n        new Set([rootPath]),\n        false,\n      );\n      expect(toPaths(data.tests)).toEqual([rootPath]);\n    });\n\n    it('finds tests that depend directly on the path', async () => {\n      const filePath = path.join(rootDir, 'RegularModule.js');\n      const file2Path = path.join(rootDir, 'RequireRegularModule.js');\n      const parentDep = path.join(rootDir, 'ModuleWithSideEffects.js');\n      const data = await searchSource.findRelatedTests(\n        new Set([filePath]),\n        false,\n      );\n      expect(toPaths(data.tests).sort()).toEqual([\n        parentDep,\n        filePath,\n        file2Path,\n        rootPath,\n      ]);\n    });\n\n    it('excludes untested files from coverage', async () => {\n      const unrelatedFile = path.join(rootDir, 'JSONFile.json');\n      const regular = path.join(rootDir, 'RegularModule.js');\n      const requireRegular = path.join(rootDir, 'RequireRegularMode.js');\n\n      const data = await searchSource.findRelatedTests(\n        new Set([regular, requireRegular, unrelatedFile]),\n        true,\n      );\n      expect([...(data.collectCoverageFrom || [])]).toEqual([\n        'RegularModule.js',\n      ]);\n    });\n  });\n\n  describe('findRelatedTestsFromPattern', () => {\n    beforeEach(async () => {\n      ({searchSource} = await initSearchSource({\n        id,\n        moduleFileExtensions: ['js', 'jsx', 'foobar'],\n        rootDir,\n        testMatch,\n      }));\n    });\n\n    it('returns empty search result for empty input', async () => {\n      const input: Array<string> = [];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(data.tests).toEqual([]);\n    });\n\n    it('returns empty search result for invalid input', async () => {\n      const input = ['non-existend.js'];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(data.tests).toEqual([]);\n    });\n\n    it('returns empty search result if no related tests were found', async () => {\n      const input = ['no_tests.js'];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(data.tests).toEqual([]);\n    });\n\n    it('finds tests for a single file', async () => {\n      const input = ['packages/jest-core/src/__tests__/test_root/module.jsx'];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(toPaths(data.tests).sort()).toEqual([\n        path.join(rootDir, '__testtests__', 'test.js'),\n        path.join(rootDir, '__testtests__', 'test.jsx'),\n      ]);\n    });\n\n    it('finds tests for multiple files', async () => {\n      const input = [\n        'packages/jest-core/src/__tests__/test_root/module.jsx',\n        'packages/jest-core/src/__tests__/test_root/module.foobar',\n      ];\n      const data = await searchSource.findRelatedTestsFromPattern(input, false);\n      expect(toPaths(data.tests).sort()).toEqual([\n        path.join(rootDir, '__testtests__', 'test.foobar'),\n        path.join(rootDir, '__testtests__', 'test.js'),\n        path.join(rootDir, '__testtests__', 'test.jsx'),\n      ]);\n    });\n\n    it('does not mistake roots folders with prefix names', async () => {\n      if (process.platform === 'win32') {\n        return;\n      }\n      ({searchSource} = await initSearchSource({\n        id,\n        rootDir: '.',\n        roots: ['/foo/bar/prefix'],\n      }));\n\n      const input = ['/foo/bar/prefix-suffix/__tests__/my-test.test.js'];\n      const data = searchSource.findTestsByPaths(input);\n      expect(data.tests).toEqual([]);\n    });\n  });\n\n  describe('findRelatedSourcesFromTestsInChangedFiles', () => {\n    const rootDir = path.resolve(\n      __dirname,\n      '../../../jest-runtime/src/__tests__/test_root',\n    );\n\n    beforeEach(async () => {\n      ({searchSource} = await initSearchSource({\n        haste: {\n          hasteImplModulePath: path.resolve(\n            __dirname,\n            '../../../jest-haste-map/src/__tests__/haste_impl.js',\n          ),\n        },\n        id: 'SearchSource-findRelatedSourcesFromTestsInChangedFiles-tests',\n        rootDir,\n      }));\n    });\n\n    it('return empty set if no SCM', async () => {\n      const requireRegularModule = path.join(\n        rootDir,\n        'RequireRegularModule.js',\n      );\n      const sources =\n        await searchSource.findRelatedSourcesFromTestsInChangedFiles({\n          changedFiles: new Set([requireRegularModule]),\n          repos: {\n            git: new Set(),\n            hg: new Set(),\n          },\n        });\n      expect(sources).toEqual([]);\n    });\n\n    it('return sources required by tests', async () => {\n      const regularModule = path.join(rootDir, 'RegularModule.js');\n      const requireRegularModule = path.join(\n        rootDir,\n        'RequireRegularModule.js',\n      );\n      const sources =\n        await searchSource.findRelatedSourcesFromTestsInChangedFiles({\n          changedFiles: new Set([requireRegularModule]),\n          repos: {\n            git: new Set('/path/to/git'),\n            hg: new Set(),\n          },\n        });\n      expect(sources).toEqual([regularModule]);\n    });\n  });\n});"}
{"prompt":"should run when second-project appears in selectProjects,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit('should run when second-project appears in selectProjects', () => {\n  expect(true).toBe(true);\n});"}
{"prompt":"snapshot,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\ndescribe('snapshot', () => {\n  it('works with plain objects and the title has `escape` characters', () => {\n    const test = {\n      a: 1,\n      b: '2',\n      c: 'three`',\n      d: 'vier',\n    };\n    expect(test).toMatchSnapshot();\n  });\n});"}
{"prompt":"Given a config with two named projects, first-project and second-project,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {resolve} from 'path';\nimport run, {\n  type RunJestJsonResult,\n  type RunJestResult,\n  json as runWithJson,\n} from '../runJest';\n\ndescribe('Given a config with two named projects, first-project and second-project', () => {\n  const dir = resolve(__dirname, '..', 'select-projects');\n\n  describe('when Jest is started with `--selectProjects first-project`', () => {\n    let result: RunJestJsonResult;\n    beforeAll(() => {\n      result = runWithJson('select-projects', [\n        '--selectProjects',\n        'first-project',\n      ]);\n    });\n    it('runs the tests in the first project only', () => {\n      expect(result.json).toHaveProperty('success', true);\n      expect(result.json).toHaveProperty('numTotalTests', 1);\n      expect(result.json.testResults.map(({name}) => name)).toEqual([\n        resolve(dir, '__tests__/first-project.test.js'),\n      ]);\n    });\n    it('prints that only first-project will run', () => {\n      expect(result.stderr).toMatch(/^Running one project: first-project/);\n    });\n  });\n\n  describe('when Jest is started with `--selectProjects second-project`', () => {\n    let result: RunJestJsonResult;\n    beforeAll(() => {\n      result = runWithJson('select-projects', [\n        '--selectProjects',\n        'second-project',\n      ]);\n    });\n    it('runs the tests in the second project only', () => {\n      expect(result.json).toHaveProperty('success', true);\n      expect(result.json).toHaveProperty('numTotalTests', 1);\n      expect(result.json.testResults.map(({name}) => name)).toEqual([\n        resolve(dir, '__tests__/second-project.test.js'),\n      ]);\n    });\n    it('prints that only second-project will run', () => {\n      expect(result.stderr).toMatch(/^Running one project: second-project/);\n    });\n  });\n\n  describe('when Jest is started with `--selectProjects first-project second-project`', () => {\n    let result: RunJestJsonResult;\n    beforeAll(() => {\n      result = runWithJson('select-projects', [\n        '--selectProjects',\n        'first-project',\n        'second-project',\n      ]);\n    });\n    it('runs the tests in the first and second projects', () => {\n      expect(result.json).toHaveProperty('success', true);\n      expect(result.json).toHaveProperty('numTotalTests', 2);\n      expect(result.json.testResults.map(({name}) => name).sort()).toEqual([\n        resolve(dir, '__tests__/first-project.test.js'),\n        resolve(dir, '__tests__/second-project.test.js'),\n      ]);\n    });\n    it('prints that both first-project and second-project will run', () => {\n      expect(result.stderr).toMatch(\n        /^Running 2 projects:\\n- first-project\\n- second-project/,\n      );\n    });\n  });\n\n  describe('when Jest is started without providing `--selectProjects`', () => {\n    let result: RunJestJsonResult;\n    beforeAll(() => {\n      result = runWithJson('select-projects', []);\n    });\n    it('runs the tests in the first and second projects', () => {\n      expect(result.json).toHaveProperty('success', true);\n      expect(result.json).toHaveProperty('numTotalTests', 2);\n      expect(result.json.testResults.map(({name}) => name).sort()).toEqual([\n        resolve(dir, '__tests__/first-project.test.js'),\n        resolve(dir, '__tests__/second-project.test.js'),\n      ]);\n    });\n    it('does not print which projects are run', () => {\n      expect(result.stderr).not.toMatch(/^Running/);\n    });\n  });\n\n  describe('when Jest is started with `--selectProjects third-project`', () => {\n    let result: RunJestResult;\n    beforeAll(() => {\n      result = run('select-projects', ['--selectProjects', 'third-project']);\n    });\n    it('fails', () => {\n      expect(result).toHaveProperty('failed', true);\n    });\n    it('prints that no project was found', () => {\n      expect(result.stdout).toMatch(\n        /^You provided values for --selectProjects but no projects were found matching the selection/,\n      );\n    });\n  });\n\n  describe('when Jest is started with `--ignoreProjects first-project', () => {\n    let result: RunJestJsonResult;\n    beforeAll(() => {\n      result = runWithJson('select-projects', [\n        '--ignoreProjects',\n        'first-project',\n      ]);\n    });\n    it('runs the tests in the second project only', () => {\n      expect(result.json).toHaveProperty('success', true);\n      expect(result.json).toHaveProperty('numTotalTests', 1);\n      expect(result.json.testResults.map(({name}) => name)).toEqual([\n        resolve(dir, '__tests__/second-project.test.js'),\n      ]);\n    });\n    it('prints that only second-project will run', () => {\n      expect(result.stderr).toMatch(/^Running one project: second-project/);\n    });\n  });\n\n  describe('when Jest is started with `--ignoreProjects second-project', () => {\n    let result: RunJestJsonResult;\n    beforeAll(() => {\n      result = runWithJson('select-projects', [\n        '--ignoreProjects',\n        'second-project',\n      ]);\n    });\n    it('runs the tests in the first project only', () => {\n      expect(result.json).toHaveProperty('success', true);\n      expect(result.json).toHaveProperty('numTotalTests', 1);\n      expect(result.json.testResults.map(({name}) => name)).toEqual([\n        resolve(dir, '__tests__/first-project.test.js'),\n      ]);\n    });\n    it('prints that only first-project will run', () => {\n      expect(result.stderr).toMatch(/^Running one project: first-project/);\n    });\n  });\n\n  describe('when Jest is started with `--ignoreProjects third-project`', () => {\n    let result: RunJestJsonResult;\n    beforeAll(() => {\n      result = runWithJson('select-projects', [\n        '--ignoreProjects',\n        'third-project',\n      ]);\n    });\n    it('runs the tests in the first and second projects', () => {\n      expect(result.json).toHaveProperty('success', true);\n      expect(result.json).toHaveProperty('numTotalTests', 2);\n      expect(result.json.testResults.map(({name}) => name).sort()).toEqual([\n        resolve(dir, '__tests__/first-project.test.js'),\n        resolve(dir, '__tests__/second-project.test.js'),\n      ]);\n    });\n    it('prints that both first-project and second-project will run', () => {\n      expect(result.stderr).toMatch(\n        /^Running 2 projects:\\n- first-project\\n- second-project/,\n      );\n    });\n  });\n\n  describe('when Jest is started with `--ignoreProjects first-project second-project`', () => {\n    let result: RunJestResult;\n    beforeAll(() => {\n      result = run('select-projects', [\n        '--ignoreProjects',\n        'first-project',\n        'second-project',\n      ]);\n    });\n    it('fails', () => {\n      expect(result).toHaveProperty('failed', true);\n    });\n    it.skip('prints that no project was found', () => {\n      expect(result.stdout).toMatch(\n        /^You provided values for --ignoreProjects, but no projects were found matching the selection/,\n      );\n    });\n  });\n\n  describe('when Jest is started with `--selectProjects first-project second-project --ignoreProjects first-project` ', () => {\n    let result: RunJestJsonResult;\n    beforeAll(() => {\n      result = runWithJson('select-projects', [\n        '--selectProjects',\n        'first-project',\n        'second-project',\n        '--ignoreProjects',\n        'first-project',\n      ]);\n    });\n    it('runs the tests in the second project only', () => {\n      expect(result.json).toHaveProperty('success', true);\n      expect(result.json).toHaveProperty('numTotalTests', 1);\n      expect(result.json.testResults.map(({name}) => name)).toEqual([\n        resolve(dir, '__tests__/second-project.test.js'),\n      ]);\n    });\n    it('prints that only second-project will run', () => {\n      expect(result.stderr).toMatch(/^Running one project: second-project/);\n    });\n  });\n\n  describe('when Jest is started with `--selectProjects first-project --ignoreProjects first-project` ', () => {\n    let result: RunJestResult;\n    beforeAll(() => {\n      result = run('select-projects', [\n        '--selectProjects',\n        'first-project',\n        '--ignoreProjects',\n        'first-project',\n      ]);\n    });\n    it('fails', () => {\n      expect(result).toHaveProperty('failed', true);\n    });\n    it.skip('prints that no project was found', () => {\n      expect(result.stdout).toMatch(\n        /^You provided values for --selectProjects and --ignoreProjects, but no projects were found matching the selection./,\n      );\n    });\n  });\n});\n\ndescribe('Given a config with two projects, first-project and an unnamed project', () => {\n  const dir = resolve(__dirname, '..', 'select-projects-missing-name');\n\n  describe('when Jest is started with `--selectProjects first-project`', () => {\n    let result: RunJestJsonResult;\n    beforeAll(() => {\n      result = runWithJson('select-projects-missing-name', [\n        '--selectProjects',\n        'first-project',\n      ]);\n    });\n    it('runs the tests in the first project only', () => {\n      expect(result.json.success).toBe(true);\n      expect(result.json.numTotalTests).toBe(1);\n      expect(result.json.testResults.map(({name}) => name)).toEqual([\n        resolve(dir, '__tests__/first-project.test.js'),\n      ]);\n    });\n    it('prints that a project does not have a name', () => {\n      expect(result.stderr).toMatch(\n        /^You provided values for --selectProjects but a project does not have a name/,\n      );\n    });\n    it('prints that only first-project will run', () => {\n      const stderrThirdLine = result.stderr.split('\\n')[2];\n      expect(stderrThirdLine).toMatch(/^Running one project: first-project/);\n    });\n  });\n\n  describe('when Jest is started without providing `--selectProjects`', () => {\n    let result: RunJestJsonResult;\n    beforeAll(() => {\n      result = runWithJson('select-projects-missing-name', []);\n    });\n    it('runs the tests in the first and second projects', () => {\n      expect(result.json.success).toBe(true);\n      expect(result.json.numTotalTests).toBe(2);\n      expect(result.json.testResults.map(({name}) => name).sort()).toEqual([\n        resolve(dir, '__tests__/first-project.test.js'),\n        resolve(dir, '__tests__/second-project.test.js'),\n      ]);\n    });\n    it('does not print that a project has no name', () => {\n      expect(result.stderr).not.toMatch(\n        /^You provided values for --selectProjects but a project does not have a name/,\n      );\n    });\n  });\n\n  describe('when Jest is started with `--selectProjects third-project`', () => {\n    let result: RunJestResult;\n    beforeAll(() => {\n      result = run('select-projects-missing-name', [\n        '--selectProjects',\n        'third-project',\n      ]);\n    });\n    it('fails', () => {\n      expect(result).toHaveProperty('failed', true);\n    });\n    it('prints that a project does not have a name', () => {\n      expect(result.stdout).toMatch(\n        /^You provided values for --selectProjects but a project does not have a name/,\n      );\n    });\n    it('prints that no project was found', () => {\n      const stdoutThirdLine = result.stdout.split('\\n')[2];\n      expect(stdoutThirdLine).toMatch(\n        /^You provided values for --selectProjects but no projects were found matching the selection/,\n      );\n    });\n  });\n\n  describe('when Jest is started with `--ignoreProjects first-project`', () => {\n    let result: RunJestJsonResult;\n    beforeAll(() => {\n      result = runWithJson('select-projects-missing-name', [\n        '--ignoreProjects',\n        'first-project',\n      ]);\n    });\n    it('runs the tests in the second project only', () => {\n      expect(result.json.success).toBe(true);\n      expect(result.json.numTotalTests).toBe(1);\n      expect(result.json.testResults.map(({name}) => name)).toEqual([\n        resolve(dir, '__tests__/second-project.test.js'),\n      ]);\n    });\n    it('prints that a project does not have a name', () => {\n      expect(result.stderr).toMatch(\n        /^You provided values for --ignoreProjects but a project does not have a name/,\n      );\n    });\n    it('prints that only second-project will run', () => {\n      const stderrThirdLine = result.stderr.split('\\n')[2];\n      expect(stderrThirdLine).toMatch(\n        /^Running one project: <unnamed project>/,\n      );\n    });\n  });\n});"}
{"prompt":"process.ex is documented to only stop the current thread rather than","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nconst {isMainThread} = require('worker_threads');\n\nasync function selfKill() {\n  if (!isMainThread) {\n    // process.exit is documented to only stop the current thread rather than\n    // the entire process in a worker_threads environment.\n    process.exit();\n  }\n\n  process.kill(process.pid);\n}\n\nmodule.exports = {\n  selfKill,\n};"}
{"prompt":"populate an object wh all basic JavaScript datatypes","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport serializeToJSON from '../serializeToJSON';\n\n// populate an object with all basic JavaScript datatypes\nconst object = {\n  chillness: 100,\n  flaws: null,\n  hopOut: {\n    atThe: 'after party',\n    when: new Date('2000-07-14'),\n  },\n  i: ['pull up'],\n  location: undefined,\n  ok: true,\n  species: 'capybara',\n  weight: 9.5,\n};\n\nit('serializes regular objects like JSON.stringify', () => {\n  expect(serializeToJSON(object)).toEqual(JSON.stringify(object));\n});\n\nit('serializes errors', () => {\n  const objectWithError = {\n    ...object,\n    error: new Error('too cool'),\n  };\n  const withError = serializeToJSON(objectWithError);\n  const withoutError = JSON.stringify(objectWithError);\n\n  expect(withoutError).not.toEqual(withError);\n\n  expect(withError).toContain('\"message\":\"too cool\"');\n  expect(withError).toContain('\"name\":\"Error\"');\n  expect(withError).toContain('\"stack\":\"Error:');\n\n  expect(JSON.parse(withError)).toMatchObject({\n    error: {\n      message: 'too cool',\n      name: 'Error',\n    },\n  });\n});"}
{"prompt":"server,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('server', () => {\n  it('should work', () => {});\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {Config} from '@jest/types';\nimport setFromArgv from '../setFromArgv';\n\ntest('maps special values to valid options', () => {\n  const options = {} as Config.InitialOptions;\n  const argv = {\n    coverage: true,\n    env: 'node',\n    json: true,\n    watchAll: true,\n  } as Config.Argv;\n\n  expect(setFromArgv(options, argv)).toMatchObject({\n    collectCoverage: true,\n    testEnvironment: 'node',\n    useStderr: true,\n    watch: false,\n    watchAll: true,\n  });\n});\n\ntest('maps regular values to themselves', () => {\n  const options = {} as Config.InitialOptions;\n  const argv = {\n    collectCoverageFrom: '**/*.{js,jsx}',\n    coverageDirectory: 'covDir',\n    watchman: true,\n  } as Config.Argv;\n\n  expect(setFromArgv(options, argv)).toMatchObject({\n    collectCoverageFrom: '**/*.{js,jsx}',\n    coverageDirectory: 'covDir',\n    watchman: true,\n  });\n});\n\ntest('works with string objects', () => {\n  const options = {} as Config.InitialOptions;\n  const argv = {\n    moduleNameMapper:\n      '{\"types/(.*)\": \"<rootDir>/src/types/$1\", \"types2/(.*)\": [\"<rootDir>/src/types2/$1\", \"<rootDir>/src/types3/$1\"]}',\n    testEnvironmentOptions: '{\"userAgent\": \"Agent/007\"}',\n    transform: '{\"*.js\": \"<rootDir>/transformer\"}',\n  } as Config.Argv;\n  expect(setFromArgv(options, argv)).toMatchObject({\n    moduleNameMapper: {\n      'types/(.*)': '<rootDir>/src/types/$1',\n      'types2/(.*)': ['<rootDir>/src/types2/$1', '<rootDir>/src/types3/$1'],\n    },\n    testEnvironmentOptions: {\n      userAgent: 'Agent/007',\n    },\n    transform: {\n      '*.js': '<rootDir>/transformer',\n    },\n  });\n});\n\ntest('explicit flags override those from --config', () => {\n  const options = {} as Config.InitialOptions;\n  const argv = {\n    config: '{\"watch\": false}',\n    watch: true,\n  } as Config.Argv;\n  expect(setFromArgv(options, argv)).toMatchObject({watch: true});\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ntest('setImmediate test', () => {\n  expect(true).toBe(true);\n\n  setImmediate(() => {\n    throw new Error('Scheduled Error');\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport prettyFormat from '..';\nimport type {OptionsReceived, Plugins} from '../types';\n\ndeclare module 'expect' {\n  interface Matchers<R> {\n    toPrettyPrintTo(expected: unknown, options?: OptionsReceived): R;\n  }\n}\n\nconst setPrettyPrint = (plugins: Plugins) => {\n  expect.extend({\n    toPrettyPrintTo(\n      received: unknown,\n      expected: unknown,\n      options?: OptionsReceived,\n    ) {\n      const prettyFormatted = prettyFormat(received, {plugins, ...options});\n      const pass = prettyFormatted === expected;\n\n      return {\n        actual: prettyFormatted,\n        message: pass\n          ? () =>\n              `${this.utils.matcherHint('.not.toBe')}\\n\\n` +\n              'Expected value to not be:\\n' +\n              `  ${this.utils.printExpected(expected)}\\n` +\n              'Received:\\n' +\n              `  ${this.utils.printReceived(prettyFormatted)}`\n          : () => {\n              const diffString = this.utils.diff(expected, prettyFormatted, {\n                expand: this.expand,\n              });\n              return (\n                `${this.utils.matcherHint('.toBe')}\\n\\n` +\n                'Expected value to be:\\n' +\n                `  ${this.utils.printExpected(expected)}\\n` +\n                'Received:\\n' +\n                `  ${this.utils.printReceived(prettyFormatted)}${\n                  diffString == null ? '' : `\\n\\nDifference:\\n\\n${diffString}`\n                }`\n              );\n            },\n        pass,\n      };\n    },\n  });\n};\n\nexport default setPrettyPrint;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst fetchedData = require('../fetched-data');\n\ntest('fetches mock data', () => {\n  expect(fetchedData.RESPONSE).toBe('mock-fetched-data');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\n\nconst DIR = path.join(os.tmpdir(), 'jest-global-setup');\n\ntest('should exist setup file', () => {\n  const files = fs.readdirSync(DIR);\n  expect(files).toHaveLength(1);\n  const setup = fs.readFileSync(path.join(DIR, files[0]), 'utf8');\n  expect(setup).toBe('setup');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\n\nconst DIR = path.join(os.tmpdir(), 'jest-global-setup');\n\ntest('should exist setup file', () => {\n  const files = fs.readdirSync(DIR);\n  expect(files).toHaveLength(1);\n  const setup = fs.readFileSync(path.join(DIR, files[0]), 'utf8');\n  expect(setup).toBe('setup');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\n\nconst DIR = path.join(os.tmpdir(), 'jest-global-setup');\n\ntest('should exist setup file', () => {\n  const files = fs.readdirSync(DIR);\n  expect(files).toHaveLength(1);\n  const setup = fs.readFileSync(path.join(DIR, files[0]), 'utf8');\n  expect(setup).toBe('setup');\n});"}
{"prompt":"setupFilesAfterEnv,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ndescribe('setupFilesAfterEnv', () => {\n  it('has waited for async function', () => {\n    expect(globalThis.afterEnvAsyncFunctionFinished).toBe(true);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('invokes async function exported from `setupFiles` module', () => {\n  const result = runJest('setup-files');\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"setupFilesAfterEnv,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {writeFiles} from '../Utils';\nimport {json as runWithJson} from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../setup-files-after-env-config');\n\nconst pkgJsonOutputFilePath = path.join(\n  process.cwd(),\n  'e2e/setup-files-after-env-config/package.json',\n);\n\nafterAll(() => {\n  fs.unlinkSync(pkgJsonOutputFilePath);\n});\n\ndescribe('setupFilesAfterEnv', () => {\n  it('requires multiple setup files before each file in the suite', () => {\n    const pkgJson = {\n      jest: {\n        setupFilesAfterEnv: ['./setup1.js', './setup2.js'],\n      },\n    };\n\n    writeFiles(DIR, {\n      'package.json': JSON.stringify(pkgJson, null, 2),\n    });\n\n    const result = runWithJson('setup-files-after-env-config', [\n      'test1.test.js',\n      'test2.test.js',\n    ]);\n\n    expect(result.json.numTotalTests).toBe(2);\n    expect(result.json.numPassedTests).toBe(2);\n    expect(result.json.testResults).toHaveLength(2);\n    expect(result.exitCode).toBe(0);\n  });\n\n  it('requires setup files *after* the test runners are required', () => {\n    const pkgJson = {\n      jest: {\n        setupFilesAfterEnv: ['./setupHooksIntoRunner.js'],\n      },\n    };\n\n    writeFiles(DIR, {\n      'package.json': JSON.stringify(pkgJson, null, 2),\n    });\n\n    const result = runWithJson('setup-files-after-env-config', [\n      'runnerPatch.test.js',\n    ]);\n\n    expect(result.json.numTotalTests).toBe(1);\n    expect(result.json.numPassedTests).toBe(1);\n    expect(result.json.testResults).toHaveLength(1);\n    expect(result.exitCode).toBe(0);\n  });\n\n  it('awaits async function returned from the setup file (jest-circus)', () => {\n    const pkgJson = {\n      jest: {\n        setupFilesAfterEnv: ['./setupAsyncFunction.js'],\n        testRunner: 'jest-circus',\n      },\n    };\n\n    writeFiles(DIR, {\n      'package.json': JSON.stringify(pkgJson, null, 2),\n    });\n\n    const result = runWithJson('setup-files-after-env-config', [\n      'setupAsyncFunction.test.js',\n    ]);\n\n    expect(result.json.numTotalTests).toBe(1);\n    expect(result.json.numPassedTests).toBe(1);\n    expect(result.json.testResults).toHaveLength(1);\n    expect(result.exitCode).toBe(0);\n  });\n\n  it('awaits async function returned from the setup file (jest-jasmine2)', () => {\n    const pkgJson = {\n      jest: {\n        setupFilesAfterEnv: ['./setupAsyncFunction.js'],\n        testRunner: 'jest-jasmine2',\n      },\n    };\n\n    writeFiles(DIR, {\n      'package.json': JSON.stringify(pkgJson, null, 2),\n    });\n\n    const result = runWithJson('setup-files-after-env-config', [\n      'setupAsyncFunction.test.js',\n    ]);\n\n    expect(result.json.numTotalTests).toBe(1);\n    expect(result.json.numPassedTests).toBe(1);\n    expect(result.json.testResults).toHaveLength(1);\n    expect(result.exitCode).toBe(0);\n  });\n});"}
{"prompt":"project only has 3 files","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as path from 'path';\nimport runJest from '../runJest';\n\ntest('--shard=1/1', () => {\n  const result = runJest('shard', ['--shard=1/1', '--listTests']);\n\n  const paths = result.stdout\n    .split('\\n')\n    .filter(Boolean)\n    .map(file => path.basename(file))\n    .sort();\n\n  expect(paths).toEqual(['1.test.js', '2.test.js', '3.test.js']);\n});\n\ntest('--shard=1/2', () => {\n  const result = runJest('shard', ['--shard=1/2', '--listTests']);\n\n  const paths = result.stdout\n    .split('\\n')\n    .filter(Boolean)\n    .map(file => path.basename(file))\n    .sort();\n\n  expect(paths).toEqual(['1.test.js', '3.test.js']);\n});\n\ntest('--shard=2/2', () => {\n  const result = runJest('shard', ['--shard=2/2', '--listTests']);\n\n  const paths = result.stdout\n    .split('\\n')\n    .filter(Boolean)\n    .map(file => path.basename(file));\n\n  expect(paths).toEqual(['2.test.js']);\n});\n\ntest('--shard=4/4', () => {\n  const result = runJest('shard', ['--shard=4/4', '--listTests']);\n\n  const paths = result.stdout\n    .split('\\n')\n    .filter(Boolean)\n    .map(file => path.basename(file));\n\n  // project only has 3 files\n  // shards > 3 are empty\n  expect(paths).toEqual([]);\n});\n\ntest('--shard=1/2 custom non-sharding test sequencer', () => {\n  const result = runJest('shard', [\n    '--shard=1/2',\n    '--listTests',\n    '--testSequencer=./no-sharding-test-sequencer.js',\n  ]);\n\n  expect(result).toMatchObject({\n    failed: true,\n    stderr: expect.stringMatching(\n      /Shard (.*) requested, but test sequencer (.*) in (.*) has no shard method./,\n    ),\n  });\n});\n\ntest('--shard=1/2 custom sharding test sequencer', () => {\n  const result = runJest('shard', [\n    '--shard=1/2',\n    '--listTests',\n    '--testSequencer=./sharding-test-sequencer.js',\n  ]);\n\n  const paths = result.stdout\n    .split('\\n')\n    .filter(Boolean)\n    .map(file => path.basename(file));\n\n  expect(paths).toEqual(['3.test.js']);\n});"}
{"prompt":"settings for anything arbrary","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {fc} from '@fast-check/jest';\n\n// settings for anything arbitrary\nexport const anythingSettings = {\n  key: fc.oneof(fc.string(), fc.constantFrom('k1', 'k2', 'k3')),\n  maxDepth: 2, // Limit object depth (default: 2)\n  maxKeys: 5, // Limit number of keys per object (default: 5)\n  withBoxedValues: true,\n  // Issue #7975 have to be fixed before enabling the generation of Map\n  withMap: false,\n  // Issue #7975 have to be fixed before enabling the generation of Set\n  withSet: false,\n};\n\n// assertion settings\nexport const assertSettings = {}; // eg.: {numRuns: 10000}"}
{"prompt":"shouldInstrument,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport type {Config} from '@jest/types';\nimport shouldInstrument from '../shouldInstrument';\nimport type {Options} from '../types';\n\ndescribe('shouldInstrument', () => {\n  const defaultFilename = 'source_file.test.js';\n  const defaultOptions: Options = {\n    ...makeGlobalConfig({\n      collectCoverage: true,\n    }),\n    changedFiles: undefined,\n  };\n  const defaultConfig = makeProjectConfig({rootDir: '/'});\n  describe('should return true', () => {\n    const testShouldInstrument = (\n      filename = defaultFilename,\n      options: Partial<Options>,\n      config: Partial<Config.ProjectConfig>,\n      loadedFilenames?: Array<string>,\n    ) => {\n      const result = shouldInstrument(\n        filename,\n        {...defaultOptions, ...options},\n        {...defaultConfig, ...config},\n        loadedFilenames,\n      );\n      expect(result).toBe(true);\n    };\n\n    it('when testRegex is provided and file is not a test file', () => {\n      testShouldInstrument('source_file.js', defaultOptions, {\n        testRegex: ['.*\\\\.(test)\\\\.(js)$'],\n      });\n    });\n\n    it('when more than one testRegex is provided and filename is not a test file', () => {\n      testShouldInstrument('source_file.js', defaultOptions, {\n        testRegex: ['.*\\\\_(test)\\\\.(js)$', '.*\\\\.(test)\\\\.(js)$', 'never'],\n      });\n    });\n\n    it('when testMatch is provided and file is not a test file', () => {\n      testShouldInstrument('source_file.js', defaultOptions, {\n        testMatch: ['**/?(*.)(test).js', '!**/dont/**/*.js'],\n      });\n    });\n\n    it('when testPathIgnorePatterns is provided and file is not a test file', () => {\n      testShouldInstrument('src/test.js', defaultOptions, {\n        testPathIgnorePatterns: ['src/'],\n      });\n    });\n\n    it('when more than one testPathIgnorePatterns is provided and filename is not a test file', () => {\n      testShouldInstrument('src/test.js', defaultOptions, {\n        testPathIgnorePatterns: ['test/', 'src/'],\n      });\n    });\n\n    it('when testRegex and testPathIgnorePatterns are provided and file is not a test file', () => {\n      testShouldInstrument('src/source_file.js', defaultOptions, {\n        testPathIgnorePatterns: ['test/'],\n        testRegex: ['.*\\\\.(test)\\\\.(js)$'],\n      });\n    });\n\n    it('when testMatch and testPathIgnorePatterns are provided and file is not a test file', () => {\n      testShouldInstrument('src/source_file.js', defaultOptions, {\n        testMatch: ['**/?(*.)(test).js', '!**/dont/**/*.js'],\n        testPathIgnorePatterns: ['test/'],\n      });\n    });\n\n    it('should return true when filename matches collectCoverageFrom', () => {\n      testShouldInstrument(\n        'do/collect/coverage.js',\n        {\n          collectCoverageFrom: ['!**/dont/**/*.js', '**/do/**/*.js'],\n        },\n        defaultConfig,\n      );\n    });\n\n    it('should return true if the file is not in coveragePathIgnorePatterns', () => {\n      testShouldInstrument('do/collect/coverage.js', defaultOptions, {\n        coveragePathIgnorePatterns: ['dont'],\n      });\n    });\n\n    it('should return true if file is a testfile but forceCoverageMatch is set', () => {\n      testShouldInstrument('do/collect/sum.coverage.test.js', defaultOptions, {\n        forceCoverageMatch: ['**/*.(coverage).(test).js'],\n        testRegex: ['.*\\\\.(test)\\\\.(js)$'],\n      });\n    });\n\n    it('when file is in loadedFilenames list', () => {\n      testShouldInstrument(\n        'do/collect/coverage.js',\n        defaultOptions,\n        defaultConfig,\n        ['do/collect/coverage.js'],\n      );\n    });\n\n    it('when file is in not loadedFilenames list, but matches collectCoverageFrom', () => {\n      testShouldInstrument(\n        'do/collect/coverage.js',\n        {collectCoverageFrom: ['!**/dont/**/*.js', '**/do/**/*.js']},\n        defaultConfig,\n        ['dont/collect/coverage.js'],\n      );\n    });\n\n    it('when file is a .json module, but matches forceCoverageMatch', () => {\n      testShouldInstrument('do/collect/coverage.json', defaultOptions, {\n        forceCoverageMatch: ['**/do/**/*.json'],\n      });\n    });\n  });\n\n  describe('should return false', () => {\n    const testShouldInstrument = (\n      filename = defaultFilename,\n      options: Partial<Options>,\n      config: Partial<Config.ProjectConfig>,\n      loadedFilenames?: Array<string>,\n    ) => {\n      const result = shouldInstrument(\n        filename,\n        {...defaultOptions, ...options},\n        {...defaultConfig, ...config},\n        loadedFilenames,\n      );\n      expect(result).toBe(false);\n    };\n\n    it('if collectCoverage is falsy', () => {\n      testShouldInstrument(\n        'source_file.js',\n        {\n          collectCoverage: false,\n        },\n        defaultConfig,\n      );\n    });\n\n    it('when testRegex is provided and filename is a test file', () => {\n      testShouldInstrument(defaultFilename, defaultOptions, {\n        testRegex: ['.*\\\\.(test)\\\\.(js)$'],\n      });\n    });\n\n    it('when more than one testRegex is provided and filename matches one of the patterns', () => {\n      testShouldInstrument(defaultFilename, defaultOptions, {\n        testRegex: ['.*\\\\_(test)\\\\.(js)$', '.*\\\\.(test)\\\\.(js)$', 'never'],\n      });\n    });\n\n    it('when testMatch is provided and file is a test file', () => {\n      testShouldInstrument(defaultFilename, defaultOptions, {\n        testMatch: ['**/?(*.)(test).js'],\n      });\n    });\n\n    it('when testRegex and testPathIgnorePatterns are provided and filename is a test file', () => {\n      testShouldInstrument(`test/${defaultFilename}`, defaultOptions, {\n        testPathIgnorePatterns: ['src/'],\n        testRegex: ['.*\\\\.(test)\\\\.(js)$'],\n      });\n    });\n\n    it('when testMatch and testPathIgnorePatterns are provided and file is a test file', () => {\n      testShouldInstrument(`test/${defaultFilename}`, defaultOptions, {\n        testMatch: ['**/?(*.)(test).js'],\n        testPathIgnorePatterns: ['src/'],\n      });\n    });\n\n    it('when filename does not match collectCoverageFrom', () => {\n      testShouldInstrument(\n        'dont/collect/coverage.js',\n        {\n          collectCoverageFrom: ['!**/dont/**/*.js', '**/do/**/*.js'],\n        },\n        defaultConfig,\n      );\n    });\n\n    it('if the file is in coveragePathIgnorePatterns', () => {\n      testShouldInstrument('dont/collect/coverage.js', defaultOptions, {\n        coveragePathIgnorePatterns: ['dont'],\n      });\n    });\n\n    it('if file is in mock patterns', () => {\n      const filename =\n        process.platform === 'win32'\n          ? 'dont\\\\__mocks__\\\\collect\\\\coverage.js'\n          : 'dont/__mocks__/collect/coverage.js';\n\n      testShouldInstrument(filename, defaultOptions, defaultConfig);\n    });\n\n    it('if file is a globalSetup file', () => {\n      testShouldInstrument('globalSetup.js', defaultOptions, {\n        globalSetup: 'globalSetup.js',\n      });\n    });\n\n    it('if file is globalTeardown file', () => {\n      testShouldInstrument('globalTeardown.js', defaultOptions, {\n        globalTeardown: 'globalTeardown.js',\n      });\n    });\n\n    it('if file is in setupFiles', () => {\n      testShouldInstrument('setupTest.js', defaultOptions, {\n        setupFiles: ['setupTest.js'],\n      });\n    });\n\n    it('if file is in setupFilesAfterEnv', () => {\n      testShouldInstrument('setupTest.js', defaultOptions, {\n        setupFilesAfterEnv: ['setupTest.js'],\n      });\n    });\n\n    it('when file is not in loadedFilenames list', () => {\n      testShouldInstrument(\n        'dont/collect/coverage.js',\n        defaultOptions,\n        defaultConfig,\n        ['do/collect/coverage.js'],\n      );\n    });\n\n    it('when file is in not loadedFilenames list and does not match collectCoverageFrom', () => {\n      testShouldInstrument(\n        'dont/collect/coverage.js',\n        {collectCoverageFrom: ['!**/dont/**/*.js', '**/do/**/*.js']},\n        defaultConfig,\n        ['do/collect/coverage.js'],\n      );\n    });\n\n    it('when file is a .json module', () => {\n      testShouldInstrument(\n        'dont/collect/coverage.json',\n        defaultOptions,\n        defaultConfig,\n      );\n    });\n  });\n});"}
{"prompt":"Make the snapshot flag stable on CI.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'show-config-test');\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ntest('--showConfig outputs config info and exits', () => {\n  writeFiles(DIR, {\n    '__tests__/test.test.js': \"test('test', () => {});\",\n    'package.json': JSON.stringify({jest: {environment: 'node'}}),\n  });\n\n  let {stdout} = runJest(DIR, [\n    '--showConfig',\n    '--no-cache',\n    // Make the snapshot flag stable on CI.\n    '--ci',\n  ]);\n\n  stdout = stdout\n    .replaceAll('\\\\\\\\node_modules\\\\\\\\', 'node_modules')\n    .replaceAll(/\\\\\\\\\\.pnp\\\\\\\\\\.\\[\\^[/\\\\]+]\\+\\$/g, '<<REPLACED_PNP_PATH>>')\n    .replaceAll(/\\\\\\\\(?:([^.]+?)|$)/g, '/$1')\n    .replaceAll(/\"cacheDirectory\": \"(.+)\"/g, '\"cacheDirectory\": \"/tmp/jest\"')\n    .replaceAll(/\"id\": \"(.+)\"/g, '\"id\": \"[md5 hash]\"')\n    .replaceAll(/\"version\": \"(.+)\"/g, '\"version\": \"[version]\"')\n    .replaceAll(/\"maxWorkers\": (\\d+)/g, '\"maxWorkers\": \"[maxWorkers]\"')\n    .replaceAll(/\"\\S*show-config-test/gm, '\"<<REPLACED_ROOT_DIR>>')\n    .replaceAll(/\"\\S*\\/jest\\/packages/gm, '\"<<REPLACED_JEST_PACKAGES_DIR>>')\n    .replaceAll(/\"seed\": (-?\\d+)/g, '\"seed\": <<RANDOM_SEED>>');\n\n  expect(stdout).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`--showConfig outputs config info and exits 1`] = `\n\"{\n  \"configs\": [\n    {\n      \"automock\": false,\n      \"cache\": false,\n      \"cacheDirectory\": \"/tmp/jest\",\n      \"clearMocks\": false,\n      \"collectCoverageFrom\": [],\n      \"coverageDirectory\": \"<<REPLACED_ROOT_DIR>>/coverage\",\n      \"coveragePathIgnorePatterns\": [\n        \"/node_modules/\"\n      ],\n      \"coverageReporters\": [\n        \"json\",\n        \"text\",\n        \"lcov\",\n        \"clover\"\n      ],\n      \"cwd\": \"<<REPLACED_ROOT_DIR>>\",\n      \"detectLeaks\": false,\n      \"detectOpenHandles\": false,\n      \"errorOnDeprecated\": false,\n      \"extensionsToTreatAsEsm\": [],\n      \"fakeTimers\": {\n        \"enableGlobally\": false\n      },\n      \"forceCoverageMatch\": [],\n      \"globals\": {},\n      \"haste\": {\n        \"computeSha1\": false,\n        \"enableSymlinks\": false,\n        \"forceNodeFilesystemAPI\": true,\n        \"throwOnModuleCollision\": false\n      },\n      \"id\": \"[md5 hash]\",\n      \"injectGlobals\": true,\n      \"moduleDirectories\": [\n        \"node_modules\"\n      ],\n      \"moduleFileExtensions\": [\n        \"js\",\n        \"mjs\",\n        \"cjs\",\n        \"jsx\",\n        \"ts\",\n        \"mts\",\n        \"cts\",\n        \"tsx\",\n        \"json\",\n        \"node\"\n      ],\n      \"moduleNameMapper\": [],\n      \"modulePathIgnorePatterns\": [],\n      \"openHandlesTimeout\": 1000,\n      \"prettierPath\": \"prettier\",\n      \"resetMocks\": false,\n      \"resetModules\": false,\n      \"restoreMocks\": false,\n      \"rootDir\": \"<<REPLACED_ROOT_DIR>>\",\n      \"roots\": [\n        \"<<REPLACED_ROOT_DIR>>\"\n      ],\n      \"runner\": \"<<REPLACED_JEST_PACKAGES_DIR>>/jest-runner/build/index.js\",\n      \"sandboxInjectedGlobals\": [],\n      \"setupFiles\": [],\n      \"setupFilesAfterEnv\": [],\n      \"skipFilter\": false,\n      \"slowTestThreshold\": 5,\n      \"snapshotFormat\": {\n        \"escapeString\": false,\n        \"printBasicPrototype\": false\n      },\n      \"snapshotSerializers\": [],\n      \"testEnvironment\": \"<<REPLACED_JEST_PACKAGES_DIR>>/jest-environment-node/build/index.js\",\n      \"testEnvironmentOptions\": {},\n      \"testLocationInResults\": false,\n      \"testMatch\": [\n        \"**/__tests__/**/*.?([mc])[jt]s?(x)\",\n        \"**/?(*.)+(spec|test).?([mc])[jt]s?(x)\"\n      ],\n      \"testPathIgnorePatterns\": [\n        \"/node_modules/\"\n      ],\n      \"testRegex\": [],\n      \"testRunner\": \"<<REPLACED_JEST_PACKAGES_DIR>>/jest-circus/build/runner.js\",\n      \"transform\": [\n        [\n          \"\\\\\\\\.[jt]sx?$\",\n          \"<<REPLACED_JEST_PACKAGES_DIR>>/babel-jest/build/index.js\",\n          {}\n        ]\n      ],\n      \"transformIgnorePatterns\": [\n        \"/node_modules/\",\n        \"<<REPLACED_PNP_PATH>>\"\n      ],\n      \"waitNextEventLoopTurnForUnhandledRejectionEvents\": false,\n      \"watchPathIgnorePatterns\": []\n    }\n  ],\n  \"globalConfig\": {\n    \"bail\": 0,\n    \"changedFilesWithAncestor\": false,\n    \"ci\": true,\n    \"collectCoverage\": false,\n    \"collectCoverageFrom\": [],\n    \"coverageDirectory\": \"<<REPLACED_ROOT_DIR>>/coverage\",\n    \"coverageProvider\": \"babel\",\n    \"coverageReporters\": [\n      \"json\",\n      \"text\",\n      \"lcov\",\n      \"clover\"\n    ],\n    \"detectLeaks\": false,\n    \"detectOpenHandles\": false,\n    \"errorOnDeprecated\": false,\n    \"expand\": false,\n    \"findRelatedTests\": false,\n    \"forceExit\": false,\n    \"json\": false,\n    \"lastCommit\": false,\n    \"listTests\": false,\n    \"logHeapUsage\": false,\n    \"maxConcurrency\": 5,\n    \"maxWorkers\": \"[maxWorkers]\",\n    \"noStackTrace\": false,\n    \"nonFlagArgs\": [],\n    \"notify\": false,\n    \"notifyMode\": \"failure-change\",\n    \"onlyChanged\": false,\n    \"onlyFailures\": false,\n    \"openHandlesTimeout\": 1000,\n    \"passWithNoTests\": false,\n    \"projects\": [],\n    \"rootDir\": \"<<REPLACED_ROOT_DIR>>\",\n    \"runInBand\": false,\n    \"runTestsByPath\": false,\n    \"seed\": <<RANDOM_SEED>>,\n    \"skipFilter\": false,\n    \"snapshotFormat\": {\n      \"escapeString\": false,\n      \"printBasicPrototype\": false\n    },\n    \"testFailureExitCode\": 1,\n    \"testPathPatterns\": [],\n    \"testSequencer\": \"<<REPLACED_JEST_PACKAGES_DIR>>/jest-test-sequencer/build/index.js\",\n    \"updateSnapshot\": \"none\",\n    \"useStderr\": false,\n    \"waitNextEventLoopTurnForUnhandledRejectionEvents\": false,\n    \"watch\": false,\n    \"watchAll\": false,\n    \"watchman\": true,\n    \"workerThreads\": false\n  },\n  \"version\": \"[version]\"\n}\"\n`;"}
{"prompt":".each[showSeed, randomize]Option %s, option => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {extractSummary, replaceSeed} from '../Utils';\nimport runJest from '../runJest';\n\nconst dir = path.resolve(__dirname, '../jest-object');\n\nconst randomSeedValueRegExp = /Seed:\\s+<<REPLACED>>/;\nconst seedValueRegExp = /Seed:\\s+1234/;\n\ndescribe.each(['showSeed', 'randomize'])('Option %s', option => {\n  test(`--${option} changes report to output seed`, () => {\n    const {stderr} = runJest(dir, [`--${option}`, '--no-cache']);\n\n    const {summary} = extractSummary(stderr);\n\n    expect(replaceSeed(summary)).toMatch(randomSeedValueRegExp);\n  });\n\n  test(`if --${option} is not present the report will not show the seed`, () => {\n    const {stderr} = runJest(dir, ['--seed', '1234']);\n\n    const {summary} = extractSummary(stderr);\n\n    expect(replaceSeed(summary)).not.toMatch(randomSeedValueRegExp);\n  });\n\n  test(`if ${option} is present in the config the report will show the seed`, () => {\n    const {stderr} = runJest(dir, [\n      '--seed',\n      '1234',\n      '--config',\n      `${option}-config.json`,\n    ]);\n\n    const {summary} = extractSummary(stderr);\n\n    expect(summary).toMatch(seedValueRegExp);\n  });\n\n  test(`--seed --${option} will show the seed in the report`, () => {\n    const {stderr} = runJest(dir, [`--${option}`, '--seed', '1234']);\n\n    const {summary} = extractSummary(stderr);\n\n    expect(summary).toMatch(seedValueRegExp);\n  });\n});"}
{"prompt":"rngBuilder,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport shuffleArray, {rngBuilder} from '../shuffleArray';\n\ndescribe('rngBuilder', () => {\n  // Breaking these orders would be a breaking change\n  // Some people will be using seeds relying on a particular order\n  test.each([1, 2, 4, 8, 16])('creates a randomizer given seed %s', seed => {\n    const rng = rngBuilder(seed);\n    const results = Array.from({length: 10}).map(() => rng.next(0, 10));\n    expect(results).toMatchSnapshot();\n  });\n});\n\ndescribe('shuffleArray', () => {\n  test('empty array is shuffled', () => {\n    const shuffled = shuffleArray([], rngBuilder(seed));\n    expect(shuffled).toEqual([]);\n  });\n\n  // Breaking these orders would be a breaking change\n  // Some people will be using seeds relying on a particular order\n  const seed = 321;\n  test.each([[['a']], [['a', 'b']], [['a', 'b', 'c']], [['a', 'b', 'c', 'd']]])(\n    'shuffles list %p',\n    l => {\n      expect(shuffleArray(l, rngBuilder(seed))).toMatchSnapshot();\n    },\n  );\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`rngBuilder creates a randomizer given seed 1 1`] = `\nArray [\n  0,\n  2,\n  4,\n  0,\n  2,\n  8,\n  5,\n  9,\n  9,\n  5,\n]\n`;\n\nexports[`rngBuilder creates a randomizer given seed 2 1`] = `\nArray [\n  10,\n  1,\n  0,\n  7,\n  4,\n  4,\n  5,\n  0,\n  10,\n  3,\n]\n`;\n\nexports[`rngBuilder creates a randomizer given seed 4 1`] = `\nArray [\n  8,\n  10,\n  3,\n  2,\n  5,\n  2,\n  3,\n  4,\n  8,\n  5,\n]\n`;\n\nexports[`rngBuilder creates a randomizer given seed 8 1`] = `\nArray [\n  4,\n  6,\n  0,\n  5,\n  10,\n  0,\n  3,\n  9,\n  5,\n  6,\n]\n`;\n\nexports[`rngBuilder creates a randomizer given seed 16 1`] = `\nArray [\n  7,\n  9,\n  3,\n  2,\n  8,\n  1,\n  6,\n  1,\n  10,\n  1,\n]\n`;\n\nexports[`shuffleArray shuffles list [\"a\", \"b\", \"c\", \"d\"] 1`] = `\nArray [\n  \"c\",\n  \"b\",\n  \"a\",\n  \"d\",\n]\n`;\n\nexports[`shuffleArray shuffles list [\"a\", \"b\", \"c\"] 1`] = `\nArray [\n  \"b\",\n  \"a\",\n  \"c\",\n]\n`;\n\nexports[`shuffleArray shuffles list [\"a\", \"b\"] 1`] = `\nArray [\n  \"a\",\n  \"b\",\n]\n`;\n\nexports[`shuffleArray shuffles list [\"a\"] 1`] = `\nArray [\n  \"a\",\n]\n`;"}
{"prompt":"@sinonjs/fake-timers integration,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {makeProjectConfig} from '@jest/test-utils';\nimport FakeTimers from '../modernFakeTimers';\n\njest.spyOn(Date, 'now').mockImplementation(() => 123_456);\n\nconst mockInstall = jest.fn();\n\nconst mockWithGlobal = {\n  install: mockInstall,\n  timers: {\n    Date: jest.fn(),\n    cancelAnimationFrame: jest.fn(),\n    clearImmediate: jest.fn(),\n    clearInterval: jest.fn(),\n    clearTimeout: jest.fn(),\n    hrtime: jest.fn(),\n    nextTick: jest.fn(),\n    performance: jest.fn(),\n    queueMicrotask: jest.fn(),\n    requestAnimationFrame: jest.fn(),\n    setImmediate: jest.fn(),\n    setInterval: jest.fn(),\n    setTimeout: jest.fn(),\n  },\n};\n\njest.mock('@sinonjs/fake-timers', () => {\n  return {\n    withGlobal: jest.fn(() => mockWithGlobal),\n  };\n});\n\nafterEach(() => {\n  jest.clearAllMocks();\n});\n\ndescribe('`@sinonjs/fake-timers` integration', () => {\n  test('uses default global config, when `useFakeTimers()` is called without options', () => {\n    const timers = new FakeTimers({\n      config: makeProjectConfig(),\n      global: globalThis,\n    });\n\n    timers.useFakeTimers();\n\n    expect(mockInstall).toHaveBeenCalledWith({\n      advanceTimeDelta: undefined,\n      loopLimit: 100_000,\n      now: 123_456,\n      shouldAdvanceTime: false,\n      shouldClearNativeTimers: true,\n      toFake: [\n        'Date',\n        'cancelAnimationFrame',\n        'clearImmediate',\n        'clearInterval',\n        'clearTimeout',\n        'hrtime',\n        'nextTick',\n        'performance',\n        'queueMicrotask',\n        'requestAnimationFrame',\n        'setImmediate',\n        'setInterval',\n        'setTimeout',\n      ],\n    });\n  });\n\n  test('uses custom global config, when `useFakeTimers()` is called without options', () => {\n    const timers = new FakeTimers({\n      config: makeProjectConfig({\n        fakeTimers: {\n          advanceTimers: true,\n          doNotFake: ['Date', 'nextTick'],\n          now: 0,\n          timerLimit: 100,\n        },\n      }),\n      global: globalThis,\n    });\n\n    timers.useFakeTimers();\n\n    expect(mockInstall).toHaveBeenCalledWith({\n      advanceTimeDelta: undefined,\n      loopLimit: 100,\n      now: 0,\n      shouldAdvanceTime: true,\n      shouldClearNativeTimers: true,\n      toFake: [\n        'cancelAnimationFrame',\n        'clearImmediate',\n        'clearInterval',\n        'clearTimeout',\n        'hrtime',\n        'performance',\n        'queueMicrotask',\n        'requestAnimationFrame',\n        'setImmediate',\n        'setInterval',\n        'setTimeout',\n      ],\n    });\n  });\n\n  test('overrides default global config, when `useFakeTimers()` is called with options,', () => {\n    const timers = new FakeTimers({\n      config: makeProjectConfig(),\n      global: globalThis,\n    });\n\n    timers.useFakeTimers({\n      advanceTimers: 40,\n      doNotFake: ['Date', 'queueMicrotask'],\n      now: new Date('1995-12-17'),\n      timerLimit: 2000,\n    });\n\n    expect(mockInstall).toHaveBeenCalledWith({\n      advanceTimeDelta: 40,\n      loopLimit: 2000,\n      now: new Date('1995-12-17'),\n      shouldAdvanceTime: true,\n      shouldClearNativeTimers: true,\n      toFake: [\n        'cancelAnimationFrame',\n        'clearImmediate',\n        'clearInterval',\n        'clearTimeout',\n        'hrtime',\n        'nextTick',\n        'performance',\n        'requestAnimationFrame',\n        'setImmediate',\n        'setInterval',\n        'setTimeout',\n      ],\n    });\n  });\n\n  test('overrides custom global config, when `useFakeTimers()` is called with options,', () => {\n    const timers = new FakeTimers({\n      config: makeProjectConfig({\n        fakeTimers: {\n          advanceTimers: 20,\n          doNotFake: ['Date', 'nextTick'],\n          now: 0,\n          timerLimit: 1000,\n        },\n      }),\n      global: globalThis,\n    });\n\n    timers.useFakeTimers({\n      advanceTimers: false,\n      doNotFake: ['hrtime'],\n      now: 123_456,\n    });\n\n    expect(mockInstall).toHaveBeenCalledWith({\n      advanceTimeDelta: undefined,\n      loopLimit: 1000,\n      now: 123_456,\n      shouldAdvanceTime: false,\n      shouldClearNativeTimers: true,\n      toFake: [\n        'Date',\n        'cancelAnimationFrame',\n        'clearImmediate',\n        'clearInterval',\n        'clearTimeout',\n        'nextTick',\n        'performance',\n        'queueMicrotask',\n        'requestAnimationFrame',\n        'setImmediate',\n        'setInterval',\n        'setTimeout',\n      ],\n    });\n  });\n});"}
{"prompt":"Custom Reporters,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\ndescribe('Custom Reporters', () => {\n  it.skip('sample', () => {});\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {json as runWithJson} from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../before-all-skipped');\n\ntest('correctly skip `beforeAll`s in skipped tests', () => {\n  const {json} = runWithJson(DIR);\n  expect(json.numTotalTests).toBe(8);\n  expect(json.numPassedTests).toBe(4);\n  expect(json.numPendingTests).toBe(4);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJasmine();\n\ntest('Snapshots get correct names in concurrent tests', () => {\n  const result = runJest('snapshot-concurrent', ['--ci']);\n  expect(result.exitCode).toBe(0);\n});"}
{"prompt":"Snapshot serializers,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ndescribe('Snapshot serializers', () => {\n  it('renders snapshot', () => {\n    const result = runJest('snapshot-unknown', ['-w=1']);\n    const stderr = result.stderr;\n\n    expect(stderr).toMatch('2 snapshot files obsolete');\n    expect(stderr).toMatch('__tests__/__snapshots__/fails.test.js.snap');\n    expect(stderr).toMatch('__tests__/__snapshots__/fails2.test.js.snap');\n    expect(result.exitCode).toBe(1);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('snapshots are written to custom location', () => {\n  expect('foobar').toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`snapshots not updated 1`] = `\"1\"`;\n\nexports[`snapshots not updated 2`] = `\"1\"`;"}
{"prompt":"eslint-disable-next-line no-eval","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {extractSummary} from '../Utils';\nimport runJest, {json as runWithJson} from '../runJest';\n\nconst emptyTest = 'describe(\"\", () => {it(\"\", () => {})})';\nconst snapshotDir = path.resolve(\n  __dirname,\n  '../snapshot/__tests__/__snapshots__',\n);\nconst snapshotFile = path.resolve(snapshotDir, 'snapshot.test.js.snap');\nconst secondSnapshotFile = path.resolve(\n  snapshotDir,\n  'secondSnapshot.test.js.snap',\n);\nconst snapshotOfCopy = path.resolve(snapshotDir, 'snapshot.test_copy.js.snap');\nconst originalTestPath = path.resolve(\n  __dirname,\n  '../snapshot/__tests__/snapshot.test.js',\n);\nconst originalTestContent = fs.readFileSync(originalTestPath, 'utf8');\nconst copyOfTestPath = originalTestPath.replace(/\\.js$/, '_copy.js');\n\nconst snapshotEscapeDir = path.resolve(\n  __dirname,\n  '../snapshot-escape/__tests__/',\n);\nconst snapshotEscapeTestFile = path.resolve(\n  snapshotEscapeDir,\n  'snapshot.test.js',\n);\nconst snapshotEscapeSnapshotDir = path.resolve(\n  snapshotEscapeDir,\n  '__snapshots__',\n);\nconst snapshotEscapeFile = path.resolve(\n  snapshotEscapeSnapshotDir,\n  'snapshot.test.js.snap',\n);\nconst snapshotEscapeRegexFile = path.resolve(\n  snapshotEscapeSnapshotDir,\n  'snapshotEscapeRegex.js.snap',\n);\nconst snapshotEscapeSubstitutionFile = path.resolve(\n  snapshotEscapeSnapshotDir,\n  'snapshotEscapeSubstitution.test.js.snap',\n);\n\nconst initialTestData = fs.readFileSync(snapshotEscapeTestFile, 'utf8');\n\nconst fileExists = (filePath: string) => {\n  try {\n    return fs.statSync(filePath).isFile();\n  } catch {}\n  return false;\n};\nconst getSnapshotOfCopy = () => {\n  const exports = Object.create(null);\n  // eslint-disable-next-line no-eval\n  eval(fs.readFileSync(snapshotOfCopy, 'utf8'));\n  return exports;\n};\n\ndescribe('Snapshot', () => {\n  const cleanup = () => {\n    for (const file of [\n      snapshotFile,\n      secondSnapshotFile,\n      snapshotOfCopy,\n      copyOfTestPath,\n      snapshotEscapeFile,\n      snapshotEscapeRegexFile,\n      snapshotEscapeSubstitutionFile,\n    ]) {\n      if (fileExists(file)) {\n        fs.unlinkSync(file);\n      }\n    }\n    if (fileExists(snapshotDir)) {\n      fs.rmdirSync(snapshotDir);\n    }\n    if (fileExists(snapshotEscapeSnapshotDir)) {\n      fs.rmdirSync(snapshotEscapeSnapshotDir);\n    }\n\n    fs.writeFileSync(snapshotEscapeTestFile, initialTestData, 'utf8');\n  };\n\n  beforeEach(cleanup);\n  afterAll(cleanup);\n\n  it('stores new snapshots on the first run', () => {\n    const {exitCode, json, stderr} = runWithJson('snapshot', [\n      '-w=1',\n      '--ci=false',\n    ]);\n\n    expect(json.numTotalTests).toBe(5);\n    expect(json.numPassedTests).toBe(5);\n    expect(json.numFailedTests).toBe(0);\n    expect(json.numPendingTests).toBe(0);\n    expect(exitCode).toBe(0);\n\n    const content = require(snapshotFile);\n    expect(\n      content['snapshot is not influenced by previous counter 1'],\n    ).toBeDefined();\n\n    expect(stderr).toMatch('5 snapshots written from 2 test suites');\n    expect(extractSummary(stderr).summary).toMatchSnapshot();\n  });\n\n  it('works with escaped characters', () => {\n    // Write the first snapshot\n    let result = runJest('snapshot-escape', [\n      '-w=1',\n      '--ci=false',\n      'snapshot.test.js',\n    ]);\n    let stderr = result.stderr;\n\n    expect(stderr).toMatch('1 snapshot written');\n    expect(result.exitCode).toBe(0);\n    expect(extractSummary(stderr).summary).toMatchSnapshot();\n\n    // Write the second snapshot\n    const testData =\n      \"test('escape strings two', () => expect('two: \\\\'\\\"').\" +\n      'toMatchSnapshot());';\n    const newTestData = initialTestData + testData;\n    fs.writeFileSync(snapshotEscapeTestFile, newTestData, 'utf8');\n\n    result = runJest('snapshot-escape', [\n      '-w=1',\n      '--ci=false',\n      '--updateSnapshot',\n      'snapshot.test.js',\n    ]);\n    stderr = result.stderr;\n\n    expect(stderr).toMatch('1 snapshot written');\n    expect(extractSummary(stderr).summary).toMatchSnapshot();\n    expect(result.exitCode).toBe(0);\n\n    // Now let's check again if everything still passes.\n    // If this test doesn't pass, some snapshot data was not properly escaped.\n    result = runJest('snapshot-escape', [\n      '-w=1',\n      '--ci=false',\n      'snapshot.test.js',\n    ]);\n    stderr = result.stderr;\n\n    expect(stderr).not.toMatch('Snapshot Summary');\n    expect(extractSummary(stderr).summary).toMatchSnapshot();\n    expect(result.exitCode).toBe(0);\n  });\n\n  it('works with escaped regex', () => {\n    // Write the first snapshot\n    let result = runJest('snapshot-escape', [\n      '-w=1',\n      '--ci=false',\n      'snapshotEscapeRegex.js',\n    ]);\n    let stderr = result.stderr;\n\n    expect(stderr).toMatch('2 snapshots written from 1 test suite.');\n    expect(result.exitCode).toBe(0);\n    expect(extractSummary(stderr).summary).toMatchSnapshot();\n\n    result = runJest('snapshot-escape', [\n      '-w=1',\n      '--ci=false',\n      'snapshotEscapeRegex.js',\n    ]);\n    stderr = result.stderr;\n\n    // Make sure we aren't writing a snapshot this time which would\n    // indicate that the snapshot couldn't be loaded properly.\n    expect(stderr).not.toMatch('Snapshot Summary');\n    expect(extractSummary(stderr).summary).toMatchSnapshot();\n    expect(result.exitCode).toBe(0);\n  });\n\n  it('works with template literal substitutions', () => {\n    // Write the first snapshot\n    let result = runJest('snapshot-escape', [\n      '-w=1',\n      '--ci=false',\n      'snapshotEscapeSubstitution.test.js',\n    ]);\n    let stderr = result.stderr;\n\n    expect(stderr).toMatch('1 snapshot written');\n    expect(result.exitCode).toBe(0);\n    expect(extractSummary(stderr).summary).toMatchSnapshot();\n\n    result = runJest('snapshot-escape', [\n      '-w=1',\n      '--ci=false',\n      'snapshotEscapeSubstitution.test.js',\n    ]);\n    stderr = result.stderr;\n\n    // Make sure we aren't writing a snapshot this time which would\n    // indicate that the snapshot couldn't be loaded properly.\n    expect(stderr).not.toMatch('1 snapshot written');\n    expect(extractSummary(stderr).summary).toMatchSnapshot();\n    expect(result.exitCode).toBe(0);\n  });\n\n  describe('Validation', () => {\n    beforeEach(() => {\n      fs.writeFileSync(copyOfTestPath, originalTestContent);\n    });\n\n    it('does not save snapshots in CI mode by default', () => {\n      const result = runWithJson('snapshot', ['-w=1', '--ci=true']);\n\n      expect(result.json.success).toBe(false);\n      expect(result.json.numTotalTests).toBe(9);\n      expect(result.json.snapshot.added).toBe(0);\n      expect(result.json.snapshot.total).toBe(9);\n      const {rest, summary} = extractSummary(result.stderr);\n\n      expect(rest).toMatch('New snapshot was not written');\n      expect(summary).toMatchSnapshot();\n    });\n\n    it('works on subsequent runs without `-u`', () => {\n      const firstRun = runWithJson('snapshot', ['-w=1', '--ci=false']);\n\n      const content = require(snapshotOfCopy);\n      expect(content).toBeDefined();\n      const secondRun = runWithJson('snapshot', []);\n\n      expect(firstRun.json.numTotalTests).toBe(9);\n      expect(secondRun.json.numTotalTests).toBe(9);\n      expect(secondRun.json.success).toBe(true);\n\n      expect(firstRun.stderr).toMatch('9 snapshots written from 3 test suites');\n      expect(secondRun.stderr).toMatch('9 passed, 9 total');\n      expect(extractSummary(firstRun.stderr).summary).toMatchSnapshot();\n      expect(extractSummary(secondRun.stderr).summary).toMatchSnapshot();\n    });\n\n    it('deletes the snapshot if the test suite has been removed', () => {\n      const firstRun = runWithJson('snapshot', ['-w=1', '--ci=false']);\n      fs.unlinkSync(copyOfTestPath);\n\n      const content = require(snapshotOfCopy);\n      expect(content).toBeDefined();\n      const secondRun = runWithJson('snapshot', ['-w=1', '--ci=false', '-u']);\n\n      expect(firstRun.json.numTotalTests).toBe(9);\n      expect(secondRun.json.numTotalTests).toBe(5);\n      expect(fileExists(snapshotOfCopy)).toBe(false);\n\n      expect(firstRun.stderr).toMatch('9 snapshots written from 3 test suites');\n      expect(secondRun.stderr).toMatch(\n        '1 snapshot file removed from 1 test suite',\n      );\n      expect(extractSummary(firstRun.stderr).summary).toMatchSnapshot();\n      expect(extractSummary(secondRun.stderr).summary).toMatchSnapshot();\n    });\n\n    it('deletes a snapshot when a test does removes all the snapshots', () => {\n      const firstRun = runWithJson('snapshot', ['-w=1', '--ci=false']);\n\n      fs.writeFileSync(copyOfTestPath, emptyTest);\n      const secondRun = runWithJson('snapshot', ['-w=1', '--ci=false', '-u']);\n      fs.unlinkSync(copyOfTestPath);\n\n      expect(firstRun.json.numTotalTests).toBe(9);\n      expect(secondRun.json.numTotalTests).toBe(6);\n\n      expect(fileExists(snapshotOfCopy)).toBe(false);\n      expect(firstRun.stderr).toMatch('9 snapshots written from 3 test suites');\n      expect(secondRun.stderr).toMatch(\n        '1 snapshot file removed from 1 test suite',\n      );\n      expect(extractSummary(firstRun.stderr).summary).toMatchSnapshot();\n      expect(extractSummary(secondRun.stderr).summary).toMatchSnapshot();\n    });\n\n    it('updates the snapshot when a test removes some snapshots', () => {\n      const firstRun = runWithJson('snapshot', ['-w=1', '--ci=false']);\n      fs.unlinkSync(copyOfTestPath);\n      const beforeRemovingSnapshot = getSnapshotOfCopy();\n\n      fs.writeFileSync(\n        copyOfTestPath,\n        originalTestContent.replace(\n          '.toMatchSnapshot()',\n          '.not.toBe(undefined)',\n        ),\n      );\n      const secondRun = runWithJson('snapshot', ['-w=1', '--ci=false', '-u']);\n      fs.unlinkSync(copyOfTestPath);\n\n      expect(firstRun.json.numTotalTests).toBe(9);\n      expect(secondRun.json.numTotalTests).toBe(9);\n      expect(fileExists(snapshotOfCopy)).toBe(true);\n      const afterRemovingSnapshot = getSnapshotOfCopy();\n\n      expect(Object.keys(beforeRemovingSnapshot).length - 1).toBe(\n        Object.keys(afterRemovingSnapshot).length,\n      );\n      const keyToCheck =\n        'snapshot works with plain objects and the ' +\n        'title has `escape` characters 2';\n      expect(beforeRemovingSnapshot[keyToCheck]).toBeDefined();\n      expect(afterRemovingSnapshot[keyToCheck]).toBeUndefined();\n\n      expect(extractSummary(firstRun.stderr).summary).toMatchSnapshot();\n      expect(firstRun.stderr).toMatch('9 snapshots written from 3 test suites');\n\n      expect(extractSummary(secondRun.stderr).summary).toMatchSnapshot();\n      expect(secondRun.stderr).toMatch('1 snapshot updated from 1 test suite');\n      expect(secondRun.stderr).toMatch('1 snapshot removed from 1 test suite');\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Snapshot Validation deletes a snapshot when a test does removes all the snapshots 1`] = `\n\"Test Suites: 3 passed, 3 total\nTests:       9 passed, 9 total\nSnapshots:   9 written, 9 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`Snapshot Validation deletes a snapshot when a test does removes all the snapshots 2`] = `\n\"Test Suites: 3 passed, 3 total\nTests:       6 passed, 6 total\nSnapshots:   1 file removed, 5 passed, 5 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`Snapshot Validation deletes the snapshot if the test suite has been removed 1`] = `\n\"Test Suites: 3 passed, 3 total\nTests:       9 passed, 9 total\nSnapshots:   9 written, 9 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`Snapshot Validation deletes the snapshot if the test suite has been removed 2`] = `\n\"Test Suites: 2 passed, 2 total\nTests:       5 passed, 5 total\nSnapshots:   1 file removed, 5 passed, 5 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`Snapshot Validation does not save snapshots in CI mode by default 1`] = `\n\"Test Suites: 3 failed, 3 total\nTests:       7 failed, 2 passed, 9 total\nSnapshots:   9 failed, 9 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`Snapshot Validation updates the snapshot when a test removes some snapshots 1`] = `\n\"Test Suites: 3 passed, 3 total\nTests:       9 passed, 9 total\nSnapshots:   9 written, 9 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`Snapshot Validation updates the snapshot when a test removes some snapshots 2`] = `\n\"Test Suites: 3 passed, 3 total\nTests:       9 passed, 9 total\nSnapshots:   1 removed, 1 updated, 7 passed, 8 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`Snapshot Validation works on subsequent runs without \\`-u\\` 1`] = `\n\"Test Suites: 3 passed, 3 total\nTests:       9 passed, 9 total\nSnapshots:   9 written, 9 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`Snapshot Validation works on subsequent runs without \\`-u\\` 2`] = `\n\"Test Suites: 3 passed, 3 total\nTests:       9 passed, 9 total\nSnapshots:   9 passed, 9 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`Snapshot stores new snapshots on the first run 1`] = `\n\"Test Suites: 2 passed, 2 total\nTests:       5 passed, 5 total\nSnapshots:   5 written, 5 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`Snapshot works with escaped characters 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   1 written, 1 total\nTime:        <<REPLACED>>\nRan all test suites matching snapshot.test.js.\"\n`;\n\nexports[`Snapshot works with escaped characters 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   1 written, 1 passed, 2 total\nTime:        <<REPLACED>>\nRan all test suites matching snapshot.test.js.\"\n`;\n\nexports[`Snapshot works with escaped characters 3`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   2 passed, 2 total\nTime:        <<REPLACED>>\nRan all test suites matching snapshot.test.js.\"\n`;\n\nexports[`Snapshot works with escaped regex 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   2 written, 2 total\nTime:        <<REPLACED>>\nRan all test suites matching snapshotEscapeRegex.js.\"\n`;\n\nexports[`Snapshot works with escaped regex 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   2 passed, 2 total\nTime:        <<REPLACED>>\nRan all test suites matching snapshotEscapeRegex.js.\"\n`;\n\nexports[`Snapshot works with template literal substitutions 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   1 written, 1 total\nTime:        <<REPLACED>>\nRan all test suites matching snapshotEscapeSubstitution.test.js.\"\n`;\n\nexports[`Snapshot works with template literal substitutions 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   1 passed, 1 total\nTime:        <<REPLACED>>\nRan all test suites matching snapshotEscapeSubstitution.test.js.\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst regex = /\\dd \\s+ \\w \\\\\\[ \\. blahzz.* [x-z]+/;\n\ntest('escape regex', () => expect(regex).toMatchSnapshot());\n\ntest('escape regex nested in object', () => {\n  const objectContainingRegex = {regex};\n  expect(objectContainingRegex).toMatchSnapshot();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('escape substitution', () => expect('${banana}').toMatchSnapshot());"}
{"prompt":"SnapshotInteractiveMode,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport chalk from 'chalk';\nimport {KEYS} from 'jest-watcher';\nimport SnapshotInteractiveMode from '../SnapshotInteractiveMode';\n\njest.doMock('chalk', () =>\n  Object.assign(new chalk.Instance({level: 0}), {\n    stripColor: str => str,\n  }),\n);\n\ndescribe('SnapshotInteractiveMode', () => {\n  let pipe;\n  let instance;\n  let mockCallback;\n  beforeEach(() => {\n    pipe = {write: jest.fn()};\n    instance = new SnapshotInteractiveMode(pipe);\n    mockCallback = jest.fn(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n  });\n\n  test('is inactive at construction', () => {\n    expect(instance.isActive()).toBeFalsy();\n  });\n\n  test('call to run process the first file', () => {\n    const assertions = [\n      {fullName: 'test one', path: 'first.js'},\n      {fullName: 'test two', path: 'second.js'},\n    ];\n    instance.run(assertions, mockCallback);\n    expect(instance.isActive()).toBeTruthy();\n    expect(mockCallback).toHaveBeenCalledWith(assertions[0], false);\n  });\n\n  test('call to abort', () => {\n    const assertions = [\n      {fullName: 'test one', path: 'first.js'},\n      {fullName: 'test two', path: 'second.js'},\n    ];\n    instance.run(assertions, mockCallback);\n    expect(instance.isActive()).toBeTruthy();\n    instance.abort();\n    expect(instance.isActive()).toBeFalsy();\n    expect(instance.getSkippedNum()).toBe(0);\n    expect(mockCallback).toHaveBeenCalledWith(null, false);\n  });\n\n  test('call to reset', () => {\n    const assertions = [\n      {fullName: 'test one', path: 'first.js'},\n      {fullName: 'test two', path: 'second.js'},\n    ];\n    instance.run(assertions, mockCallback);\n    expect(instance.isActive()).toBeTruthy();\n    instance.restart();\n    expect(instance.isActive()).toBeTruthy();\n    expect(instance.getSkippedNum()).toBe(0);\n    expect(mockCallback).toHaveBeenCalledWith(assertions[0], false);\n  });\n\n  test('press Q or ESC triggers an abort', () => {\n    instance.abort = jest.fn();\n    instance.put('q');\n    instance.put(KEYS.ESCAPE);\n    expect(instance.abort).toHaveBeenCalledTimes(2);\n  });\n\n  test('press ENTER trigger a run', () => {\n    const assertions = [{fullName: 'test one', path: 'first.js'}];\n    instance.run(assertions, mockCallback);\n    instance.put(KEYS.ENTER);\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n    expect(mockCallback).toHaveBeenCalledWith(assertions[0], false);\n  });\n\n  test('skip 1 test, then restart', () => {\n    const assertions = [{fullName: 'test one', path: 'first.js'}];\n\n    instance.run(assertions, mockCallback);\n    expect(mockCallback).toHaveBeenNthCalledWith(1, assertions[0], false);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('s');\n    expect(mockCallback).toHaveBeenCalledTimes(1);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('r');\n    expect(instance.getSkippedNum()).toBe(0);\n    expect(mockCallback).toHaveBeenNthCalledWith(2, assertions[0], false);\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n  });\n\n  test('skip 1 test, then quit', () => {\n    const assertions = [{fullName: 'test one', path: 'first.js'}];\n\n    instance.run(assertions, mockCallback);\n    expect(mockCallback).toHaveBeenNthCalledWith(1, assertions[0], false);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('s');\n    expect(mockCallback).toHaveBeenCalledTimes(1);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('q');\n    expect(instance.getSkippedNum()).toBe(0);\n    expect(mockCallback).toHaveBeenNthCalledWith(2, null, false);\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n  });\n\n  test('update 1 test, then finish and return', () => {\n    const mockCallback = jest.fn();\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: false}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n\n    const assertions = [{fullName: 'test one', path: 'first.js'}];\n\n    instance.run(assertions, mockCallback);\n    expect(mockCallback).toHaveBeenNthCalledWith(1, assertions[0], false);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('u');\n    expect(mockCallback).toHaveBeenNthCalledWith(2, assertions[0], true);\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n\n    instance.put(KEYS.ENTER);\n    expect(instance.isActive()).toBe(false);\n    expect(mockCallback).toHaveBeenNthCalledWith(3, null, false);\n  });\n\n  test('skip 2 tests, then finish and restart', () => {\n    const assertions = [\n      {fullName: 'test one', path: 'first.js'},\n      {fullName: 'test two', path: 'first.js'},\n    ];\n    instance.run(assertions, mockCallback);\n    expect(mockCallback).toHaveBeenNthCalledWith(1, assertions[0], false);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('s');\n    expect(mockCallback).toHaveBeenNthCalledWith(2, assertions[1], false);\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('s');\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('r');\n    expect(instance.getSkippedNum()).toBe(0);\n    expect(mockCallback).toHaveBeenNthCalledWith(3, assertions[0], false);\n    expect(mockCallback).toHaveBeenCalledTimes(3);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n  });\n\n  test('update 2 tests, then finish and return', () => {\n    const mockCallback = jest.fn();\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: false}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: false}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n\n    const assertions = [\n      {fullName: 'test one', path: 'first.js'},\n      {fullName: 'test two', path: 'first.js'},\n    ];\n\n    instance.run(assertions, mockCallback);\n    expect(mockCallback).toHaveBeenNthCalledWith(1, assertions[0], false);\n    expect(mockCallback).toHaveBeenCalledTimes(1);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('u');\n    expect(mockCallback).toHaveBeenNthCalledWith(2, assertions[0], true);\n    expect(mockCallback).toHaveBeenNthCalledWith(3, assertions[1], false);\n    expect(mockCallback).toHaveBeenCalledTimes(3);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('u');\n    expect(mockCallback).toHaveBeenNthCalledWith(4, assertions[1], true);\n    expect(mockCallback).toHaveBeenCalledTimes(4);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put(KEYS.ENTER);\n    expect(instance.isActive()).toBe(false);\n    expect(mockCallback).toHaveBeenNthCalledWith(5, null, false);\n    expect(mockCallback).toHaveBeenCalledTimes(5);\n  });\n\n  test('update 1 test, skip 1 test, then finish and restart', () => {\n    const mockCallback = jest.fn();\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: false}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n\n    const assertions = [\n      {fullName: 'test one', path: 'first.js'},\n      {fullName: 'test two', path: 'first.js'},\n    ];\n\n    instance.run(assertions, mockCallback);\n    expect(mockCallback).toHaveBeenNthCalledWith(1, assertions[0], false);\n    expect(mockCallback).toHaveBeenCalledTimes(1);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('u');\n    expect(mockCallback).toHaveBeenNthCalledWith(2, assertions[0], true);\n    expect(mockCallback).toHaveBeenNthCalledWith(3, assertions[1], false);\n    expect(mockCallback).toHaveBeenCalledTimes(3);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('s');\n    expect(mockCallback).toHaveBeenCalledTimes(3);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('r');\n    expect(instance.getSkippedNum()).toBe(0);\n    expect(mockCallback).toHaveBeenNthCalledWith(4, assertions[1], false);\n    expect(mockCallback).toHaveBeenCalledTimes(4);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n  });\n\n  test('skip 1 test, update 1 test, then finish and restart', () => {\n    const mockCallback = jest.fn();\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: false}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n    mockCallback.mockImplementationOnce(() => {\n      instance.updateWithResults({snapshot: {failure: true}});\n    });\n\n    const assertions = [\n      {fullName: 'test one', path: 'first.js'},\n      {fullName: 'test two', path: 'first.js'},\n    ];\n\n    instance.run(assertions, mockCallback);\n    expect(mockCallback).toHaveBeenNthCalledWith(1, assertions[0], false);\n    expect(mockCallback).toHaveBeenCalledTimes(1);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('s');\n    expect(mockCallback).toHaveBeenNthCalledWith(2, assertions[1], false);\n    expect(mockCallback).toHaveBeenCalledTimes(2);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('u');\n    expect(mockCallback).toHaveBeenNthCalledWith(3, assertions[1], true);\n    expect(mockCallback).toHaveBeenCalledTimes(3);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    pipe.write.mockClear();\n\n    instance.put('r');\n    expect(instance.getSkippedNum()).toBe(0);\n    expect(mockCallback).toHaveBeenNthCalledWith(4, assertions[0], false);\n    expect(mockCallback).toHaveBeenCalledTimes(4);\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`SnapshotInteractiveMode skip 1 test, then quit 1`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>1 snapshot remaining</intensity></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode skip 1 test, then quit 2`] = `\n\"<clearTerminal>\n\n<bold>Interactive Snapshot Result</intensity>\n › <bold><dim>1 snapshot reviewed</intensity></intensity>, <bold><yellow>1 snapshot skipped</color></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>r<dim> to restart Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode skip 1 test, then restart 1`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>1 snapshot remaining</intensity></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode skip 1 test, then restart 2`] = `\n\"<clearTerminal>\n\n<bold>Interactive Snapshot Result</intensity>\n › <bold><dim>1 snapshot reviewed</intensity></intensity>, <bold><yellow>1 snapshot skipped</color></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>r<dim> to restart Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode skip 1 test, then restart 3`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>1 snapshot remaining</intensity></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode skip 1 test, update 1 test, then finish and restart 1`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>2 snapshots remaining</intensity></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode skip 1 test, update 1 test, then finish and restart 2`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>1 snapshot remaining</intensity></intensity>, <bold><yellow>1 snapshot skipped</color></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode skip 1 test, update 1 test, then finish and restart 3`] = `\n\"<clearTerminal>\n\n<bold>Interactive Snapshot Result</intensity>\n › <bold><dim>2 snapshots reviewed</intensity></intensity>, <bold><green>1 snapshot updated</color></intensity>, <bold><yellow>1 snapshot skipped</color></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>r<dim> to restart Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode skip 1 test, update 1 test, then finish and restart 4`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>1 snapshot remaining</intensity></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode skip 2 tests, then finish and restart 1`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>2 snapshots remaining</intensity></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode skip 2 tests, then finish and restart 2`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>1 snapshot remaining</intensity></intensity>, <bold><yellow>1 snapshot skipped</color></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode skip 2 tests, then finish and restart 3`] = `\n\"<clearTerminal>\n\n<bold>Interactive Snapshot Result</intensity>\n › <bold><dim>2 snapshots reviewed</intensity></intensity>, <bold><yellow>2 snapshots skipped</color></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>r<dim> to restart Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode skip 2 tests, then finish and restart 4`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>2 snapshots remaining</intensity></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode update 1 test, skip 1 test, then finish and restart 1`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>2 snapshots remaining</intensity></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode update 1 test, skip 1 test, then finish and restart 2`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>1 snapshot remaining</intensity></intensity>, <bold><green>1 snapshot updated</color></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode update 1 test, skip 1 test, then finish and restart 3`] = `\n\"<clearTerminal>\n\n<bold>Interactive Snapshot Result</intensity>\n › <bold><dim>2 snapshots reviewed</intensity></intensity>, <bold><green>1 snapshot updated</color></intensity>, <bold><yellow>1 snapshot skipped</color></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>r<dim> to restart Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode update 1 test, skip 1 test, then finish and restart 4`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>1 snapshot remaining</intensity></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode update 1 test, then finish and return 1`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>1 snapshot remaining</intensity></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode update 1 test, then finish and return 2`] = `\n\"<clearTerminal>\n\n<bold>Interactive Snapshot Result</intensity>\n › <bold><dim>1 snapshot reviewed</intensity></intensity>, <bold><green>1 snapshot updated</color></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>Enter<dim> to return to watch mode.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode update 2 tests, then finish and return 1`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>2 snapshots remaining</intensity></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode update 2 tests, then finish and return 2`] = `\n\"<moveCursorUpBy6Rows>\n<eraseScreenDown>\n\n<bold>Interactive Snapshot Progress</intensity>\n › <bold><dim>1 snapshot remaining</intensity></intensity>, <bold><green>1 snapshot updated</color></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>u<dim> to update failing snapshots for this test.</intensity>\n<dim> › Press </intensity>s<dim> to skip the current test.</intensity>\n<dim> › Press </intensity>q<dim> to quit Interactive Snapshot Mode.</intensity>\n<dim> › Press </intensity>Enter<dim> to trigger a test run.</intensity>\n\"\n`;\n\nexports[`SnapshotInteractiveMode update 2 tests, then finish and return 3`] = `\n\"<clearTerminal>\n\n<bold>Interactive Snapshot Result</intensity>\n › <bold><dim>2 snapshots reviewed</intensity></intensity>, <bold><green>2 snapshots updated</color></intensity>\n\n<bold>Watch Usage</intensity>\n<dim> › Press </intensity>Enter<dim> to return to watch mode.</intensity>\n\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {cleanup, extractSummary} from '../Utils';\nimport {json as runJestJson} from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../snapshot-mock-fs');\nconst snapshotDir = path.resolve(DIR, '__tests__/__snapshots__');\nconst snapshotFile = path.resolve(snapshotDir, 'snapshot.test.js.snap');\n\nbeforeEach(() => cleanup(snapshotDir));\nafterAll(() => cleanup(snapshotDir));\n\ntest('store snapshot even if fs is mocked', () => {\n  const {json, exitCode, stderr} = runJestJson(DIR, ['--ci=false']);\n\n  expect(exitCode).toBe(0);\n  expect(json.numTotalTests).toBe(1);\n  expect(json.numPassedTests).toBe(1);\n\n  expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n  expect(extractSummary(stderr).summary).toMatchSnapshot();\n\n  const content = require(snapshotFile);\n  expect(content['snapshot 1']).toBe(`\n{\n  \"foo\": \"bar\",\n}\n`);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`store snapshot even if fs is mocked 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   1 written, 1 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"defaults,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {makeProjectConfig} from '@jest/test-utils';\nimport {\n  type SnapshotResolver,\n  buildSnapshotResolver,\n} from '../SnapshotResolver';\n\ndescribe('defaults', () => {\n  let snapshotResolver: SnapshotResolver;\n  const projectConfig = makeProjectConfig({\n    rootDir: 'default',\n    // snapshotResolver: null,\n  });\n\n  beforeEach(async () => {\n    snapshotResolver = await buildSnapshotResolver(projectConfig);\n  });\n\n  it('returns cached object if called multiple times', async () => {\n    await expect(buildSnapshotResolver(projectConfig)).resolves.toBe(\n      snapshotResolver,\n    );\n  });\n\n  it('resolveSnapshotPath()', () => {\n    expect(snapshotResolver.resolveSnapshotPath('/abc/cde/a.test.js')).toBe(\n      path.join('/abc', 'cde', '__snapshots__', 'a.test.js.snap'),\n    );\n  });\n\n  it('resolveTestPath()', () => {\n    expect(\n      snapshotResolver.resolveTestPath('/abc/cde/__snapshots__/a.test.js.snap'),\n    ).toBe(path.resolve('/abc/cde/a.test.js'));\n  });\n});\n\ndescribe('custom resolver in project config', () => {\n  let snapshotResolver: SnapshotResolver;\n  const customSnapshotResolverFile = path.join(\n    __dirname,\n    'fixtures',\n    'customSnapshotResolver.js',\n  );\n  const projectConfig = makeProjectConfig({\n    rootDir: 'custom1',\n    snapshotResolver: customSnapshotResolverFile,\n  });\n\n  beforeEach(async () => {\n    snapshotResolver = await buildSnapshotResolver(projectConfig);\n  });\n\n  it('returns cached object if called multiple times', async () => {\n    await expect(buildSnapshotResolver(projectConfig)).resolves.toBe(\n      snapshotResolver,\n    );\n  });\n\n  it('resolveSnapshotPath()', () => {\n    expect(\n      snapshotResolver.resolveSnapshotPath(\n        path.resolve('/abc/cde/__tests__/a.test.js'),\n      ),\n    ).toBe(path.resolve('/abc/cde/__snapshots__/a.test.js.snap'));\n  });\n\n  it('resolveTestPath()', () => {\n    expect(\n      snapshotResolver.resolveTestPath(\n        path.resolve('/abc', 'cde', '__snapshots__', 'a.test.js.snap'),\n      ),\n    ).toBe(path.resolve('/abc/cde/__tests__/a.test.js'));\n  });\n});\n\ndescribe('malformed custom resolver in project config', () => {\n  const newProjectConfig = (filename: string) => {\n    const customSnapshotResolverFile = path.join(\n      __dirname,\n      'fixtures',\n      filename,\n    );\n    return makeProjectConfig({\n      rootDir: 'missing-resolveSnapshotPath',\n      snapshotResolver: customSnapshotResolverFile,\n    });\n  };\n\n  it('missing resolveSnapshotPath throws ', async () => {\n    const projectConfig = newProjectConfig(\n      'customSnapshotResolver-missing-resolveSnapshotPath.js',\n    );\n    await expect(\n      buildSnapshotResolver(projectConfig),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('missing resolveTestPath throws ', async () => {\n    const projectConfig = newProjectConfig(\n      'customSnapshotResolver-missing-resolveTestPath.js',\n    );\n    await expect(\n      buildSnapshotResolver(projectConfig),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('missing testPathForConsistencyCheck throws ', async () => {\n    const projectConfig = newProjectConfig(\n      'customSnapshotResolver-missing-test-path-for-consistency-check.js',\n    );\n    await expect(\n      buildSnapshotResolver(projectConfig),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n\n  it('inconsistent functions throws ', async () => {\n    const projectConfig = newProjectConfig(\n      'customSnapshotResolver-inconsistent-fns.js',\n    );\n    await expect(\n      buildSnapshotResolver(projectConfig),\n    ).rejects.toThrowErrorMatchingSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`malformed custom resolver in project config inconsistent functions throws  1`] = `\"<bold>Custom snapshot resolver functions must transform paths consistently, i.e. expects resolveTestPath(resolveSnapshotPath('foo/__tests__/bar.test.js')) === foo/__SPECS__/bar.test.js</intensity>\"`;\n\nexports[`malformed custom resolver in project config missing resolveSnapshotPath throws  1`] = `\n\"<bold>Custom snapshot resolver must implement a \\`resolveSnapshotPath\\` as a function.</intensity>\nDocumentation: https://jestjs.io/docs/configuration#snapshotresolver-string\"\n`;\n\nexports[`malformed custom resolver in project config missing resolveTestPath throws  1`] = `\n\"<bold>Custom snapshot resolver must implement a \\`resolveTestPath\\` as a function.</intensity>\nDocumentation: https://jestjs.io/docs/configuration#snapshotresolver-string\"\n`;\n\nexports[`malformed custom resolver in project config missing testPathForConsistencyCheck throws  1`] = `\n\"<bold>Custom snapshot resolver must implement a \\`testPathForConsistencyCheck\\` as a string.</intensity>\nDocumentation: https://jestjs.io/docs/configuration#snapshotresolver-string\"\n`;"}
{"prompt":".each[1, 2, 3]test%d, n => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit.each([1, 2, 3])('test%d', n => {\n  expect(n).toMatchSnapshot();\n});\n\ndescribe.each([1, 2])('describe%d', () => {\n  it.each([4, 5, 6])('test%d', n => {\n    expect(n).toMatchSnapshot();\n  });\n});\n\ndescribe('describe3', () => {\n  it.each([10, 11, 12])('test%d', n => {\n    expect(n).toMatchSnapshot();\n  });\n\n  describe('describe4', () => {\n    it.each([13, 14, 15])('test%d', n => {\n      expect(n).toMatchSnapshot();\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`describe1 test4 1`] = `4`;\n\nexports[`describe1 test5 1`] = `5`;\n\nexports[`describe1 test6 1`] = `6`;\n\nexports[`describe2 test4 1`] = `4`;\n\nexports[`describe2 test5 1`] = `5`;\n\nexports[`describe2 test6 1`] = `6`;\n\nexports[`describe3 describe4 test13 1`] = `13`;\n\nexports[`describe3 describe4 test14 1`] = `14`;\n\nexports[`describe3 describe4 test15 1`] = `15`;\n\nexports[`describe3 test10 1`] = `10`;\n\nexports[`describe3 test11 1`] = `11`;\n\nexports[`describe3 test12 1`] = `12`;\n\nexports[`test1 1`] = `1`;\n\nexports[`test2 1`] = `2`;\n\nexports[`test3 1`] = `3`;"}
{"prompt":"Snapshot serializers,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {cleanup} from '../Utils';\nimport {json as runWithJson} from '../runJest';\n\nconst testDir = path.resolve(__dirname, '../snapshot-serializers');\nconst snapshotsDir = path.resolve(testDir, '__tests__/__snapshots__');\nconst snapshotPath = path.resolve(snapshotsDir, 'snapshot.test.js.snap');\n\nconst runAndAssert = () => {\n  const {exitCode, json} = runWithJson('snapshot-serializers', [\n    '-w=1',\n    '--ci=false',\n    '--no-cache',\n  ]);\n  expect(json.numTotalTests).toBe(9);\n  expect(json.numPassedTests).toBe(9);\n  expect(json.numFailedTests).toBe(0);\n  expect(json.numPendingTests).toBe(0);\n  expect(exitCode).toBe(0);\n};\n\ndescribe('Snapshot serializers', () => {\n  beforeEach(() => cleanup(snapshotsDir));\n  afterEach(() => cleanup(snapshotsDir));\n\n  it('renders snapshot', () => {\n    runAndAssert();\n    const snapshot = require(snapshotPath);\n    expect(snapshot).toMatchSnapshot();\n  });\n\n  it('compares snapshots correctly', () => {\n    // run twice, second run compares result with snapshot from first run\n    runAndAssert();\n    runAndAssert();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Snapshot serializers renders snapshot 1`] = `\nObject {\n  \"snapshot serializers works with array of strings in property matcher 1\": \"\n{\n  \"arrayOfStrings\": [\n    \"stream\",\n  ],\n}\n\",\n  \"snapshot serializers works with default serializers 1\": \"\n<div\n  id=\"foo\"\n/>\n\",\n  \"snapshot serializers works with expect.XXX within array in property matcher 1\": \"\n{\n  \"arrayOfStrings\": [\n    Any<String>,\n  ],\n}\n\",\n  \"snapshot serializers works with first plugin 1\": \"foo - 1\",\n  \"snapshot serializers works with nested serializable objects 1\": \"foo - bar - 2\",\n  \"snapshot serializers works with prepended plugins and default serializers 1\": \"\n<div\n  aProp={\n    {\n      \"a\": 6,\n    }\n  }\n  bProp={foo - 8}\n/>\n\",\n  \"snapshot serializers works with prepended plugins from expect method called once 1\": \"\n<div\n  aProp={\n    {\n      \"a\": 6,\n    }\n  }\n  bProp={Foo: 8}\n/>\n\",\n  \"snapshot serializers works with prepended plugins from expect method called twice 1\": \"\n<div\n  aProp={\n    {\n      \"a\": 6,\n    }\n  }\n  bProp={FOO: 8}\n/>\n\",\n  \"snapshot serializers works with second plugin 1\": \"bar - 2\",\n}\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\ntest('failing snapshot with hint', () => {\n  expect('foo').toMatchSnapshot('descriptive hint');\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`failing snapshot with hint: descriptive hint 1`] = `\"bar\"`;"}
{"prompt":"Given a Jest mock function, return a minimal mock of a spy.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as Immutable from 'immutable';\nimport {alignedAnsiStyleSerializer} from '@jest/test-utils';\nimport type {FunctionLike} from 'jest-mock';\nimport jestExpect from '..';\n\nexpect.addSnapshotSerializer(alignedAnsiStyleSerializer);\n\njestExpect.extend({\n  optionalFn(fn?: unknown) {\n    const pass = fn === undefined || typeof fn === 'function';\n    return {message: () => 'expect either a function or undefined', pass};\n  },\n});\n\ndeclare module '../types' {\n  interface AsymmetricMatchers {\n    optionalFn(fn?: unknown): void;\n  }\n}\n\n// Given a Jest mock function, return a minimal mock of a spy.\nconst createSpy = <T extends FunctionLike>(fn: jest.Mock<T>): jest.Mock<T> => {\n  const spy = function () {};\n\n  spy.calls = {\n    all() {\n      return fn.mock.calls.map(args => ({args}));\n    },\n    count() {\n      return fn.mock.calls.length;\n    },\n  };\n\n  return spy as unknown as jest.Mock<T>;\n};\n\ndescribe('toHaveBeenCalled', () => {\n  test('works only on spies or jest.fn', () => {\n    const fn = function fn() {};\n\n    expect(() =>\n      jestExpect(fn).toHaveBeenCalled(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('passes when called', () => {\n    const fn = jest.fn();\n    fn('arg0', 'arg1', 'arg2');\n    jestExpect(createSpy(fn)).toHaveBeenCalled();\n    jestExpect(fn).toHaveBeenCalled();\n    expect(() =>\n      jestExpect(fn).not.toHaveBeenCalled(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes when called', () => {\n    const fn = jest.fn();\n    const spy = createSpy(fn);\n\n    jestExpect(spy).not.toHaveBeenCalled();\n    jestExpect(fn).not.toHaveBeenCalled();\n    expect(() =>\n      jestExpect(spy).toHaveBeenCalled(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    fn();\n    expect(() =>\n      // @ts-expect-error: Testing runtime error\n      jestExpect(fn).toHaveBeenCalled(555),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    expect(() =>\n      // @ts-expect-error: Testing runtime error\n      jestExpect(fn).not.toHaveBeenCalled(555),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn().mockName('named-mock');\n\n    fn();\n    jestExpect(fn).toHaveBeenCalled();\n    expect(() =>\n      jestExpect(fn).not.toHaveBeenCalled(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe('toHaveBeenCalledTimes', () => {\n  test('.not works only on spies or jest.fn', () => {\n    const fn = function fn() {};\n\n    expect(() =>\n      jestExpect(fn).not.toHaveBeenCalledTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('only accepts a number argument', () => {\n    const fn = jest.fn();\n    fn();\n    jestExpect(fn).toHaveBeenCalledTimes(1);\n\n    for (const value of [{}, [], true, 'a', new Map(), () => {}]) {\n      expect(() =>\n        // @ts-expect-error: Testing runtime error\n        jestExpect(fn).toHaveBeenCalledTimes(value),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('.not only accepts a number argument', () => {\n    const fn = jest.fn();\n    jestExpect(fn).not.toHaveBeenCalledTimes(1);\n\n    for (const value of [{}, [], true, 'a', new Map(), () => {}]) {\n      expect(() =>\n        // @ts-expect-error: Testing runtime error\n        jestExpect(fn).not.toHaveBeenCalledTimes(value),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('passes if function called equal to expected times', () => {\n    const fn = jest.fn();\n    fn();\n    fn();\n\n    const spy = createSpy(fn);\n    jestExpect(spy).toHaveBeenCalledTimes(2);\n    jestExpect(fn).toHaveBeenCalledTimes(2);\n\n    expect(() =>\n      jestExpect(spy).not.toHaveBeenCalledTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes if function called more than expected times', () => {\n    const fn = jest.fn();\n    fn();\n    fn();\n    fn();\n\n    const spy = createSpy(fn);\n    jestExpect(spy).toHaveBeenCalledTimes(3);\n    jestExpect(spy).not.toHaveBeenCalledTimes(2);\n\n    jestExpect(fn).toHaveBeenCalledTimes(3);\n    jestExpect(fn).not.toHaveBeenCalledTimes(2);\n\n    expect(() =>\n      jestExpect(fn).toHaveBeenCalledTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes if function called less than expected times', () => {\n    const fn = jest.fn();\n    fn();\n\n    const spy = createSpy(fn);\n    jestExpect(spy).toHaveBeenCalledTimes(1);\n    jestExpect(spy).not.toHaveBeenCalledTimes(2);\n\n    jestExpect(fn).toHaveBeenCalledTimes(1);\n    jestExpect(fn).not.toHaveBeenCalledTimes(2);\n\n    expect(() =>\n      jestExpect(fn).toHaveBeenCalledTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn().mockName('named-mock');\n    fn();\n\n    expect(() =>\n      jestExpect(fn).toHaveBeenCalledTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n});\n\ndescribe.each([\n  'toHaveBeenLastCalledWith',\n  'toHaveBeenNthCalledWith',\n  'toHaveBeenCalledWith',\n] as const)('%s', calledWith => {\n  function isToHaveNth(\n    calledWith: string,\n  ): calledWith is 'toHaveBeenNthCalledWith' {\n    return calledWith === 'toHaveBeenNthCalledWith';\n  }\n\n  test('works only on spies or jest.fn', () => {\n    const fn = function fn() {};\n\n    if (isToHaveNth(calledWith)) {\n      expect(() =>\n        jestExpect(fn)[calledWith](3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      expect(() => jestExpect(fn)[calledWith]()).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works when not called', () => {\n    const fn = jest.fn();\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](1, 'foo', 'bar');\n      jestExpect(fn).not[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', 'bar');\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with no arguments', () => {\n    const fn = jest.fn();\n    fn();\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn))[calledWith](1);\n      jestExpect(fn)[calledWith](1);\n    } else {\n      jestExpect(createSpy(fn))[calledWith]();\n      jestExpect(fn)[calledWith]();\n    }\n  });\n\n  test(\"works with arguments that don't match\", () => {\n    const fn = jest.fn();\n    fn('foo', 'bar1');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](1, 'foo', 'bar');\n      jestExpect(fn).not[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', 'bar');\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test(\"works with arguments that don't match in number of arguments\", () => {\n    const fn = jest.fn();\n    fn('foo', 'bar', 'plop');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](1, 'foo', 'bar');\n      jestExpect(fn).not[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', 'bar');\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test(\"works with arguments that don't match with matchers\", () => {\n    const fn = jest.fn();\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n      jestExpect(fn).not[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n\n      expect(() =>\n        jestExpect(fn)[calledWith](\n          1,\n          jestExpect.any(String),\n          jestExpect.any(Number),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n      jestExpect(fn).not[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(Number),\n      );\n\n      expect(() =>\n        jestExpect(fn)[calledWith](\n          jestExpect.any(String),\n          jestExpect.any(Number),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test(\"works with arguments that don't match with matchers even when argument is undefined\", () => {\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn)).not[calledWith](\n        1,\n        'foo',\n        jestExpect.any(String),\n      );\n      jestExpect(fn).not[calledWith](1, 'foo', jestExpect.any(String));\n\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', jestExpect.any(String)),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn)).not[calledWith]('foo', jestExpect.any(String));\n      jestExpect(fn).not[calledWith]('foo', jestExpect.any(String));\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', jestExpect.any(String)),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test(\"works with arguments that don't match in size even if one is an optional matcher\", () => {\n    // issue 12463\n    const fn = jest.fn();\n    fn('foo');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn).not[calledWith](1, 'foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[calledWith]('foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with arguments that match', () => {\n    const fn = jest.fn();\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn))[calledWith](1, 'foo', 'bar');\n      jestExpect(fn)[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn))[calledWith]('foo', 'bar');\n      jestExpect(fn)[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with arguments that match with matchers', () => {\n    const fn = jest.fn();\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(createSpy(fn))[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n      jestExpect(fn)[calledWith](\n        1,\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](\n          1,\n          jestExpect.any(String),\n          jestExpect.any(String),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(createSpy(fn))[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n      jestExpect(fn)[calledWith](\n        jestExpect.any(String),\n        jestExpect.any(String),\n      );\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](\n          jestExpect.any(String),\n          jestExpect.any(String),\n        ),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with trailing undefined arguments', () => {\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      expect(() =>\n        jestExpect(fn)[calledWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with trailing undefined arguments if requested by the match query', () => {\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, 'foo', undefined);\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith]('foo', undefined);\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with trailing undefined arguments when explicitly requested as optional by matcher', () => {\n    // issue 12463\n    const fn = jest.fn();\n    fn('foo', undefined);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, 'foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith]('foo', jestExpect.optionalFn());\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', jestExpect.optionalFn()),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Map', () => {\n    const fn = jest.fn();\n\n    const m1 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m2 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m3 = new Map([\n      ['a', 'b'],\n      ['b', 'a'],\n    ]);\n\n    fn(m1);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, m2);\n      jestExpect(fn).not[calledWith](1, m3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](1, m3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith](m2);\n      jestExpect(fn).not[calledWith](m3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](m3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Set', () => {\n    const fn = jest.fn();\n\n    const s1 = new Set([1, 2]);\n    const s2 = new Set([1, 2]);\n    const s3 = new Set([3, 4]);\n\n    fn(s1);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, s2);\n      jestExpect(fn).not[calledWith](1, s3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](1, s3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith](s2);\n      jestExpect(fn).not[calledWith](s3);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[calledWith](s3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Immutable.js objects', () => {\n    const fn = jest.fn();\n    const directlyCreated = Immutable.Map([['a', {b: 'c'}]]);\n    const indirectlyCreated = Immutable.Map().set('a', {b: 'c'});\n    fn(directlyCreated, indirectlyCreated);\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, indirectlyCreated, directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, indirectlyCreated, directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith](indirectlyCreated, directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](indirectlyCreated, directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  if (!isToHaveNth(calledWith)) {\n    test('works with many arguments', () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n      fn('foo', 'bar1');\n      fn('foo', 'bar');\n\n      jestExpect(fn)[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test(\"works with many arguments that don't match\", () => {\n      const fn = jest.fn();\n      fn('foo', 'bar1');\n      fn('foo', 'bar2');\n      fn('foo', 'bar3');\n\n      jestExpect(fn).not[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn)[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  if (isToHaveNth(calledWith)) {\n    test('works with three calls', () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n      fn('foo', 'bar1');\n      fn('foo', 'bar');\n\n      jestExpect(fn)[calledWith](1, 'foo1', 'bar');\n      jestExpect(fn)[calledWith](2, 'foo', 'bar1');\n      jestExpect(fn)[calledWith](3, 'foo', 'bar');\n\n      expect(() => {\n        jestExpect(fn).not[calledWith](1, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('positive throw matcher error for n that is not positive integer', async () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n\n      expect(() => {\n        jestExpect(fn)[calledWith](0, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('positive throw matcher error for n that is not integer', async () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n\n      expect(() => {\n        jestExpect(fn)[calledWith](0.1, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('negative throw matcher error for n that is not integer', async () => {\n      const fn = jest.fn();\n      fn('foo1', 'bar');\n\n      expect(() => {\n        jestExpect(fn).not[calledWith](Number.POSITIVE_INFINITY, 'foo1', 'bar');\n      }).toThrowErrorMatchingSnapshot();\n    });\n  }\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn().mockName('named-mock');\n    fn('foo', 'bar');\n\n    if (isToHaveNth(calledWith)) {\n      jestExpect(fn)[calledWith](1, 'foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith](1, 'foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[calledWith]('foo', 'bar');\n\n      expect(() =>\n        jestExpect(fn).not[calledWith]('foo', 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n});\n\ndescribe('toHaveReturned', () => {\n  test('.not works only on jest.fn', () => {\n    const fn = function fn() {};\n\n    expect(() =>\n      jestExpect(fn).not.toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('throw matcher error if received is spy', () => {\n    const spy = createSpy(jest.fn());\n\n    expect(() =>\n      jestExpect(spy).toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('passes when returned', () => {\n    const fn = jest.fn(() => 42);\n    fn();\n    jestExpect(fn).toHaveReturned();\n    expect(() =>\n      jestExpect(fn).not.toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('passes when undefined is returned', () => {\n    const fn = jest.fn(() => undefined);\n    fn();\n    jestExpect(fn).toHaveReturned();\n    expect(() =>\n      jestExpect(fn).not.toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('passes when at least one call does not throw', () => {\n    const fn = jest.fn((causeError: boolean) => {\n      if (causeError) {\n        throw new Error('Error!');\n      }\n\n      return 42;\n    });\n\n    fn(false);\n\n    try {\n      fn(true);\n    } catch {\n      // ignore error\n    }\n\n    fn(false);\n\n    jestExpect(fn).toHaveReturned();\n    expect(() =>\n      jestExpect(fn).not.toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes when not returned', () => {\n    const fn = jest.fn();\n\n    jestExpect(fn).not.toHaveReturned();\n    expect(() =>\n      jestExpect(fn).toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes when all calls throw', () => {\n    const fn = jest.fn(() => {\n      throw new Error('Error!');\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    jestExpect(fn).not.toHaveReturned();\n    expect(() =>\n      jestExpect(fn).toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes when a call throws undefined', () => {\n    const fn = jest.fn(() => {\n      // eslint-disable-next-line no-throw-literal\n      throw undefined;\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    jestExpect(fn).not.toHaveReturned();\n    expect(() =>\n      jestExpect(fn).toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    fn();\n    expect(() =>\n      // @ts-expect-error: Testing runtime error\n      jestExpect(fn).toHaveReturned(555),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not fails with any argument passed', () => {\n    const fn = jest.fn();\n\n    expect(() =>\n      // @ts-expect-error: Testing runtime error\n      jestExpect(fn).not.toHaveReturned(555),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn(() => 42).mockName('named-mock');\n    fn();\n    jestExpect(fn).toHaveReturned();\n    expect(() =>\n      jestExpect(fn).not.toHaveReturned(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('incomplete recursive calls are handled properly', () => {\n    // sums up all integers from 0 -> value, using recursion\n    const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n      if (value === 0) {\n        // Before returning from the base case of recursion, none of the\n        // calls have returned yet.\n        jestExpect(fn).not.toHaveReturned();\n        expect(() =>\n          jestExpect(fn).toHaveReturned(),\n        ).toThrowErrorMatchingSnapshot();\n        return 0;\n      } else {\n        return value + fn(value - 1);\n      }\n    });\n\n    fn(3);\n  });\n});\n\ndescribe('toHaveReturnedTimes', () => {\n  test('throw matcher error if received is spy', () => {\n    const spy = createSpy(jest.fn());\n\n    expect(() =>\n      jestExpect(spy).not.toHaveReturnedTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('only accepts a number argument', () => {\n    const fn = jest.fn(() => 42);\n    fn();\n    jestExpect(fn).toHaveReturnedTimes(1);\n\n    for (const value of [{}, [], true, 'a', new Map(), () => {}]) {\n      expect(() =>\n        // @ts-expect-error: Testing runtime error\n        jestExpect(fn).toHaveReturnedTimes(value),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('.not only accepts a number argument', () => {\n    const fn = jest.fn(() => 42);\n    jestExpect(fn).not.toHaveReturnedTimes(2);\n\n    for (const value of [{}, [], true, 'a', new Map(), () => {}]) {\n      expect(() =>\n        // @ts-expect-error: Testing runtime error\n        jestExpect(fn).not.toHaveReturnedTimes(value),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('passes if function returned equal to expected times', () => {\n    const fn = jest.fn(() => 42);\n    fn();\n    fn();\n\n    jestExpect(fn).toHaveReturnedTimes(2);\n\n    expect(() =>\n      jestExpect(fn).not.toHaveReturnedTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('calls that return undefined are counted as returns', () => {\n    const fn = jest.fn(() => undefined);\n    fn();\n    fn();\n\n    jestExpect(fn).toHaveReturnedTimes(2);\n\n    expect(() =>\n      jestExpect(fn).not.toHaveReturnedTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes if function returned more than expected times', () => {\n    const fn = jest.fn(() => 42);\n    fn();\n    fn();\n    fn();\n\n    jestExpect(fn).toHaveReturnedTimes(3);\n    jestExpect(fn).not.toHaveReturnedTimes(2);\n\n    expect(() =>\n      jestExpect(fn).toHaveReturnedTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('.not passes if function called less than expected times', () => {\n    const fn = jest.fn(() => 42);\n    fn();\n\n    jestExpect(fn).toHaveReturnedTimes(1);\n    jestExpect(fn).not.toHaveReturnedTimes(2);\n\n    expect(() =>\n      jestExpect(fn).toHaveReturnedTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('calls that throw are not counted', () => {\n    const fn = jest.fn((causeError: boolean) => {\n      if (causeError) {\n        throw new Error('Error!');\n      }\n\n      return 42;\n    });\n\n    fn(false);\n\n    try {\n      fn(true);\n    } catch {\n      // ignore error\n    }\n\n    fn(false);\n\n    jestExpect(fn).not.toHaveReturnedTimes(3);\n\n    expect(() =>\n      jestExpect(fn).toHaveReturnedTimes(3),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('calls that throw undefined are not counted', () => {\n    const fn = jest.fn((causeError: boolean) => {\n      if (causeError) {\n        // eslint-disable-next-line no-throw-literal\n        throw undefined;\n      }\n\n      return 42;\n    });\n\n    fn(false);\n\n    try {\n      fn(true);\n    } catch {\n      // ignore error\n    }\n\n    fn(false);\n\n    jestExpect(fn).toHaveReturnedTimes(2);\n\n    expect(() =>\n      jestExpect(fn).not.toHaveReturnedTimes(2),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn(() => 42).mockName('named-mock');\n    fn();\n    fn();\n\n    jestExpect(fn).toHaveReturnedTimes(2);\n\n    expect(() =>\n      jestExpect(fn).toHaveReturnedTimes(1),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('incomplete recursive calls are handled properly', () => {\n    // sums up all integers from 0 -> value, using recursion\n    const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n      if (value === 0) {\n        return 0;\n      } else {\n        const recursiveResult = fn(value - 1);\n\n        if (value === 2) {\n          // Only 2 of the recursive calls have returned at this point\n          jestExpect(fn).toHaveReturnedTimes(2);\n          expect(() =>\n            jestExpect(fn).not.toHaveReturnedTimes(2),\n          ).toThrowErrorMatchingSnapshot();\n        }\n\n        return value + recursiveResult;\n      }\n    });\n\n    fn(3);\n  });\n});\n\ndescribe.each([\n  'toHaveLastReturnedWith',\n  'toHaveNthReturnedWith',\n  'toHaveReturnedWith',\n] as const)('%s', returnedWith => {\n  function isToHaveNth(\n    returnedWith: string,\n  ): returnedWith is 'toHaveNthReturnedWith' {\n    return returnedWith === 'toHaveNthReturnedWith';\n  }\n\n  function isToHaveLast(\n    returnedWith: string,\n  ): returnedWith is 'toHaveLastReturnedWith' {\n    return returnedWith === 'toHaveLastReturnedWith';\n  }\n  test('works only on spies or jest.fn', () => {\n    const fn = function fn() {};\n\n    // @ts-expect-error: Testing runtime error\n    expect(() => jestExpect(fn)[returnedWith]()).toThrowErrorMatchingSnapshot();\n  });\n\n  test('works when not called', () => {\n    const fn = jest.fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn).not[returnedWith](1, 'foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[returnedWith]('foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with no arguments', () => {\n    const fn = jest.fn();\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1);\n    } else {\n      jestExpect(fn)[returnedWith]();\n    }\n  });\n\n  test('works with argument that does not match', () => {\n    const fn = jest.fn(() => 'foo');\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn).not[returnedWith](1, 'bar');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, 'bar'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[returnedWith]('bar');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith]('bar'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with argument that does match', () => {\n    const fn = jest.fn(() => 'foo');\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, 'foo');\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith]('foo');\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with undefined', () => {\n    const fn = jest.fn(() => undefined);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, undefined);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](undefined);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Map', () => {\n    const m1 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m2 = new Map([\n      [1, 2],\n      [2, 1],\n    ]);\n    const m3 = new Map([\n      ['a', 'b'],\n      ['b', 'a'],\n    ]);\n\n    const fn = jest.fn(() => m1);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, m2);\n      jestExpect(fn).not[returnedWith](1, m3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, m3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](m2);\n      jestExpect(fn).not[returnedWith](m3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](m2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](m3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Set', () => {\n    const s1 = new Set([1, 2]);\n    const s2 = new Set([1, 2]);\n    const s3 = new Set([3, 4]);\n\n    const fn = jest.fn(() => s1);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, s2);\n      jestExpect(fn).not[returnedWith](1, s3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, s3),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](s2);\n      jestExpect(fn).not[returnedWith](s3);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](s2),\n      ).toThrowErrorMatchingSnapshot();\n      expect(() =>\n        jestExpect(fn)[returnedWith](s3),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Immutable.js objects directly created', () => {\n    const directlyCreated = Immutable.Map([['a', {b: 'c'}]]);\n    const fn = jest.fn(() => directlyCreated);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](directlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](directlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('works with Immutable.js objects indirectly created', () => {\n    const indirectlyCreated = Immutable.Map().set('a', {b: 'c'});\n    const fn = jest.fn(() => indirectlyCreated);\n    fn();\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn)[returnedWith](1, indirectlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](1, indirectlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn)[returnedWith](indirectlyCreated);\n\n      expect(() =>\n        jestExpect(fn).not[returnedWith](indirectlyCreated),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('a call that throws is not considered to have returned', () => {\n    const fn = jest.fn(() => {\n      throw new Error('Error!');\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    if (isToHaveNth(returnedWith)) {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith](1, 'foo');\n      jestExpect(fn).not[returnedWith](1, null);\n      jestExpect(fn).not[returnedWith](1, undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith]('foo');\n      jestExpect(fn).not[returnedWith](null);\n      jestExpect(fn).not[returnedWith](undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  test('a call that throws undefined is not considered to have returned', () => {\n    const fn = jest.fn(() => {\n      // eslint-disable-next-line no-throw-literal\n      throw undefined;\n    });\n\n    try {\n      fn();\n    } catch {\n      // ignore error\n    }\n\n    if (isToHaveNth(returnedWith)) {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith](1, 'foo');\n      jestExpect(fn).not[returnedWith](1, null);\n      jestExpect(fn).not[returnedWith](1, undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, undefined),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      // It doesn't matter what return value is tested if the call threw\n      jestExpect(fn).not[returnedWith]('foo');\n      jestExpect(fn).not[returnedWith](null);\n      jestExpect(fn).not[returnedWith](undefined);\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](undefined),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n\n  if (!isToHaveNth(returnedWith)) {\n    describe('toHaveReturnedWith', () => {\n      test('works with more calls than the limit', () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn.mockReturnValueOnce('foo4');\n        fn.mockReturnValueOnce('foo5');\n        fn.mockReturnValueOnce('foo6');\n\n        fn();\n        fn();\n        fn();\n        fn();\n        fn();\n        fn();\n\n        jestExpect(fn).not[returnedWith]('bar');\n\n        expect(() => {\n          jestExpect(fn)[returnedWith]('bar');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('incomplete recursive calls are handled properly', () => {\n        // sums up all integers from 0 -> value, using recursion\n        const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n          if (value === 0) {\n            // Before returning from the base case of recursion, none of the\n            // calls have returned yet.\n            // This test ensures that the incomplete calls are not incorrectly\n            // interpreted as have returned undefined\n            jestExpect(fn).not[returnedWith](undefined);\n            expect(() =>\n              jestExpect(fn)[returnedWith](undefined),\n            ).toThrowErrorMatchingSnapshot();\n\n            return 0;\n          } else {\n            return value + fn(value - 1);\n          }\n        });\n\n        fn(3);\n      });\n    });\n  }\n\n  if (isToHaveNth(returnedWith)) {\n    describe('toHaveNthReturnedWith', () => {\n      test('works with three calls', () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn();\n        fn();\n        fn();\n\n        jestExpect(fn)[returnedWith](1, 'foo1');\n        jestExpect(fn)[returnedWith](2, 'foo2');\n        jestExpect(fn)[returnedWith](3, 'foo3');\n\n        expect(() => {\n          jestExpect(fn).not[returnedWith](1, 'foo1');\n          jestExpect(fn).not[returnedWith](2, 'foo2');\n          jestExpect(fn).not[returnedWith](3, 'foo3');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('should replace 1st, 2nd, 3rd with first, second, third', async () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn();\n        fn();\n        fn();\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](1, 'bar1');\n          jestExpect(fn)[returnedWith](2, 'bar2');\n          jestExpect(fn)[returnedWith](3, 'bar3');\n        }).toThrowErrorMatchingSnapshot();\n\n        expect(() => {\n          jestExpect(fn).not[returnedWith](1, 'foo1');\n          jestExpect(fn).not[returnedWith](2, 'foo2');\n          jestExpect(fn).not[returnedWith](3, 'foo3');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('positive throw matcher error for n that is not positive integer', async () => {\n        const fn = jest.fn(() => 'foo');\n        fn();\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](0, 'foo');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('should reject nth value greater than number of calls', async () => {\n        const fn = jest.fn(() => 'foo');\n        fn();\n        fn();\n        fn();\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](4, 'foo');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('positive throw matcher error for n that is not integer', async () => {\n        const fn = jest.fn<(a: string) => string>(() => 'foo');\n        fn('foo');\n\n        expect(() => {\n          jestExpect(fn)[returnedWith](0.1, 'foo');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('negative throw matcher error for n that is not number', async () => {\n        const fn = jest.fn<(a: string) => string>(() => 'foo');\n        fn('foo');\n\n        expect(() => {\n          // @ts-expect-error: Testing runtime error\n          jestExpect(fn).not[returnedWith]();\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('incomplete recursive calls are handled properly', () => {\n        // sums up all integers from 0 -> value, using recursion\n        const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n          if (value === 0) {\n            return 0;\n          } else {\n            const recursiveResult = fn(value - 1);\n\n            if (value === 2) {\n              // Only 2 of the recursive calls have returned at this point\n              jestExpect(fn).not[returnedWith](1, 6);\n              jestExpect(fn).not[returnedWith](2, 3);\n              jestExpect(fn)[returnedWith](3, 1);\n              jestExpect(fn)[returnedWith](4, 0);\n\n              expect(() =>\n                jestExpect(fn)[returnedWith](1, 6),\n              ).toThrowErrorMatchingSnapshot();\n              expect(() =>\n                jestExpect(fn)[returnedWith](2, 3),\n              ).toThrowErrorMatchingSnapshot();\n              expect(() =>\n                jestExpect(fn).not[returnedWith](3, 1),\n              ).toThrowErrorMatchingSnapshot();\n              expect(() =>\n                jestExpect(fn).not[returnedWith](4, 0),\n              ).toThrowErrorMatchingSnapshot();\n            }\n\n            return value + recursiveResult;\n          }\n        });\n\n        fn(3);\n      });\n    });\n  }\n\n  if (isToHaveLast(returnedWith)) {\n    describe('toHaveLastReturnedWith', () => {\n      test('works with three calls', () => {\n        const fn = jest.fn<() => string>();\n        fn.mockReturnValueOnce('foo1');\n        fn.mockReturnValueOnce('foo2');\n        fn.mockReturnValueOnce('foo3');\n        fn();\n        fn();\n        fn();\n\n        jestExpect(fn)[returnedWith]('foo3');\n\n        expect(() => {\n          jestExpect(fn).not[returnedWith]('foo3');\n        }).toThrowErrorMatchingSnapshot();\n      });\n\n      test('incomplete recursive calls are handled properly', () => {\n        // sums up all integers from 0 -> value, using recursion\n        const fn: jest.Mock<(value: number) => number> = jest.fn(value => {\n          if (value === 0) {\n            // Before returning from the base case of recursion, none of the\n            // calls have returned yet.\n            jestExpect(fn).not[returnedWith](0);\n            expect(() =>\n              jestExpect(fn)[returnedWith](0),\n            ).toThrowErrorMatchingSnapshot();\n            return 0;\n          } else {\n            return value + fn(value - 1);\n          }\n        });\n\n        fn(3);\n      });\n    });\n  }\n\n  test('includes the custom mock name in the error message', () => {\n    const fn = jest.fn().mockName('named-mock');\n\n    if (isToHaveNth(returnedWith)) {\n      jestExpect(fn).not[returnedWith](1, 'foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith](1, 'foo'),\n      ).toThrowErrorMatchingSnapshot();\n    } else {\n      jestExpect(fn).not[returnedWith]('foo');\n\n      expect(() =>\n        jestExpect(fn)[returnedWith]('foo'),\n      ).toThrowErrorMatchingSnapshot();\n    }\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`toHaveBeenCalled .not fails with any argument passed 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveBeenCalled<d>()</>\n\n<b>Matcher error</>: this matcher must not have an expected argument\n\nExpected has type:  number\nExpected has value: <g>555</>\n`;\n\nexports[`toHaveBeenCalled .not passes when called 1`] = `\n<d>expect(</><r>spy</><d>).</>toHaveBeenCalled<d>()</>\n\nExpected number of calls: >= <g>1</>\nReceived number of calls:    <r>0</>\n`;\n\nexports[`toHaveBeenCalled fails with any argument passed 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveBeenCalled<d>()</>\n\n<b>Matcher error</>: this matcher must not have an expected argument\n\nExpected has type:  number\nExpected has value: <g>555</>\n`;\n\nexports[`toHaveBeenCalled includes the custom mock name in the error message 1`] = `\n<d>expect(</><r>named-mock</><d>).</>not<d>.</>toHaveBeenCalled<d>()</>\n\nExpected number of calls: <g>0</>\nReceived number of calls: <r>1</>\n\n1: called with 0 arguments\n`;\n\nexports[`toHaveBeenCalled passes when called 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenCalled<d>()</>\n\nExpected number of calls: <g>0</>\nReceived number of calls: <r>1</>\n\n1: <r>\"arg0\"</>, <r>\"arg1\"</>, <r>\"arg2\"</>\n`;\n\nexports[`toHaveBeenCalled works only on spies or jest.fn 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveBeenCalled<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a mock or spy function\n\nReceived has type:  function\nReceived has value: <r>[Function fn]</>\n`;\n\nexports[`toHaveBeenCalledTimes .not only accepts a number argument 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  object\nExpected has value: <g>{}</>\n`;\n\nexports[`toHaveBeenCalledTimes .not only accepts a number argument 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  array\nExpected has value: <g>[]</>\n`;\n\nexports[`toHaveBeenCalledTimes .not only accepts a number argument 3`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  boolean\nExpected has value: <g>true</>\n`;\n\nexports[`toHaveBeenCalledTimes .not only accepts a number argument 4`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  string\nExpected has value: <g>\"a\"</>\n`;\n\nexports[`toHaveBeenCalledTimes .not only accepts a number argument 5`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  map\nExpected has value: <g>Map {}</>\n`;\n\nexports[`toHaveBeenCalledTimes .not only accepts a number argument 6`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  function\nExpected has value: <g>[Function anonymous]</>\n`;\n\nexports[`toHaveBeenCalledTimes .not passes if function called less than expected times 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\nExpected number of calls: <g>2</>\nReceived number of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledTimes .not passes if function called more than expected times 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\nExpected number of calls: <g>2</>\nReceived number of calls: <r>3</>\n`;\n\nexports[`toHaveBeenCalledTimes .not works only on spies or jest.fn 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a mock or spy function\n\nReceived has type:  function\nReceived has value: <r>[Function fn]</>\n`;\n\nexports[`toHaveBeenCalledTimes includes the custom mock name in the error message 1`] = `\n<d>expect(</><r>named-mock</><d>).</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\nExpected number of calls: <g>2</>\nReceived number of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledTimes only accepts a number argument 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  object\nExpected has value: <g>{}</>\n`;\n\nexports[`toHaveBeenCalledTimes only accepts a number argument 2`] = `\n<d>expect(</><r>received</><d>).</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  array\nExpected has value: <g>[]</>\n`;\n\nexports[`toHaveBeenCalledTimes only accepts a number argument 3`] = `\n<d>expect(</><r>received</><d>).</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  boolean\nExpected has value: <g>true</>\n`;\n\nexports[`toHaveBeenCalledTimes only accepts a number argument 4`] = `\n<d>expect(</><r>received</><d>).</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  string\nExpected has value: <g>\"a\"</>\n`;\n\nexports[`toHaveBeenCalledTimes only accepts a number argument 5`] = `\n<d>expect(</><r>received</><d>).</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  map\nExpected has value: <g>Map {}</>\n`;\n\nexports[`toHaveBeenCalledTimes only accepts a number argument 6`] = `\n<d>expect(</><r>received</><d>).</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  function\nExpected has value: <g>[Function anonymous]</>\n`;\n\nexports[`toHaveBeenCalledTimes passes if function called equal to expected times 1`] = `\n<d>expect(</><r>spy</><d>).</>not<d>.</>toHaveBeenCalledTimes<d>(</><g>expected</><d>)</>\n\nExpected number of calls: not <g>2</>\n`;\n\nexports[`toHaveBeenCalledWith includes the custom mock name in the error message 1`] = `\n<d>expect(</><r>named-mock</><d>).</>not<d>.</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>\"foo\"</>, <g>\"bar\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works only on spies or jest.fn 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a mock or spy function\n\nReceived has type:  function\nReceived has value: <r>[Function fn]</>\n`;\n\nexports[`toHaveBeenCalledWith works when not called 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>\"foo\"</>, <g>\"bar\"</>\n\nNumber of calls: <r>0</>\n`;\n\nexports[`toHaveBeenCalledWith works with Immutable.js objects 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>Immutable.Map {\"a\": {\"b\": \"c\"}}</>, <g>Immutable.Map {\"a\": {\"b\": \"c\"}}</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works with Map 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>Map {1 => 2, 2 => 1}</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works with Map 2`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\n<g>- Expected</>\n<r>+ Received</>\n\n<d>  Map {</>\n<g>-   \"a\" => \"b\",</>\n<g>-   \"b\" => \"a\",</>\n<r>+   1 => 2,</>\n<r>+   2 => 1,</>\n<d>  }</>,\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works with Set 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>Set {1, 2}</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works with Set 2`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\n<g>- Expected</>\n<r>+ Received</>\n\n<d>  Set {</>\n<g>-   3,</>\n<g>-   4,</>\n<r>+   1,</>\n<r>+   2,</>\n<d>  }</>,\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works with arguments that don't match 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>\"foo\"</>, <g>\"bar\"</>\nReceived: <d>\"foo\"</>, <r>\"bar1\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works with arguments that don't match in number of arguments 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>\"foo\"</>, <g>\"bar\"</>\nReceived: <d>\"foo\"</>, <d>\"bar\"</>, <r>\"plop\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works with arguments that don't match in size even if one is an optional matcher 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>\"foo\"</>, <g>optionalFn<></>\nReceived: <d>\"foo\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works with arguments that don't match with matchers 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>Any<String></>, <g>Any<Number></>\nReceived: <d>\"foo\"</>, <r>\"bar\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works with arguments that don't match with matchers even when argument is undefined 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>\"foo\"</>, <g>Any<String></>\nReceived: <d>\"foo\"</>, <r>undefined</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works with arguments that match 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>\"foo\"</>, <g>\"bar\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works with arguments that match with matchers 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>Any<String></>, <g>Any<String></>\nReceived:     <r>0</>, <r>[\"foo\", \"bar\"]</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works with many arguments 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>\"foo\"</>, <g>\"bar\"</>\nReceived\n       3:     <d>\"foo\"</>, <d>\"bar\"</>\n\nNumber of calls: <r>3</>\n`;\n\nexports[`toHaveBeenCalledWith works with many arguments that don't match 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>\"foo\"</>, <g>\"bar\"</>\nReceived\n       1: <d>\"foo\"</>, <r>\"bar1\"</>\n       2: <d>\"foo\"</>, <r>\"bar2\"</>\n       3: <d>\"foo\"</>, <r>\"bar3\"</>\n\nNumber of calls: <r>3</>\n`;\n\nexports[`toHaveBeenCalledWith works with trailing undefined arguments 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>\"foo\"</>\nReceived: <d>\"foo\"</>, <r>undefined</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works with trailing undefined arguments if requested by the match query 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>\"foo\"</>, <g>undefined</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenCalledWith works with trailing undefined arguments when explicitly requested as optional by matcher 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>\"foo\"</>, <g>optionalFn<></>\nReceived:     <r>0</>, <r>[\"foo\", undefined]</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith includes the custom mock name in the error message 1`] = `\n<d>expect(</><r>named-mock</><d>).</>not<d>.</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>\"foo\"</>, <g>\"bar\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works only on spies or jest.fn 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a mock or spy function\n\nReceived has type:  function\nReceived has value: <r>[Function fn]</>\n`;\n\nexports[`toHaveBeenLastCalledWith works when not called 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>\"foo\"</>, <g>\"bar\"</>\n\nNumber of calls: <r>0</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with Immutable.js objects 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>Immutable.Map {\"a\": {\"b\": \"c\"}}</>, <g>Immutable.Map {\"a\": {\"b\": \"c\"}}</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with Map 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>Map {1 => 2, 2 => 1}</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with Map 2`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\n<g>- Expected</>\n<r>+ Received</>\n\n<d>  Map {</>\n<g>-   \"a\" => \"b\",</>\n<g>-   \"b\" => \"a\",</>\n<r>+   1 => 2,</>\n<r>+   2 => 1,</>\n<d>  }</>,\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with Set 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>Set {1, 2}</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with Set 2`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\n<g>- Expected</>\n<r>+ Received</>\n\n<d>  Set {</>\n<g>-   3,</>\n<g>-   4,</>\n<r>+   1,</>\n<r>+   2,</>\n<d>  }</>,\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with arguments that don't match 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>\"foo\"</>, <g>\"bar\"</>\nReceived: <d>\"foo\"</>, <r>\"bar1\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with arguments that don't match in number of arguments 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>\"foo\"</>, <g>\"bar\"</>\nReceived: <d>\"foo\"</>, <d>\"bar\"</>, <r>\"plop\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with arguments that don't match in size even if one is an optional matcher 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>\"foo\"</>, <g>optionalFn<></>\nReceived: <d>\"foo\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with arguments that don't match with matchers 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>Any<String></>, <g>Any<Number></>\nReceived: <d>\"foo\"</>, <r>\"bar\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with arguments that don't match with matchers even when argument is undefined 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>\"foo\"</>, <g>Any<String></>\nReceived: <d>\"foo\"</>, <r>undefined</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with arguments that match 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>\"foo\"</>, <g>\"bar\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with arguments that match with matchers 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>Any<String></>, <g>Any<String></>\nReceived:     <r>0</>, <r>[\"foo\", \"bar\"]</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with many arguments 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>\"foo\"</>, <g>\"bar\"</>\nReceived\n       2:     <d>\"foo\"</>, <r>\"bar1\"</>\n->     3:     <d>\"foo\"</>, <d>\"bar\"</>\n\nNumber of calls: <r>3</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with many arguments that don't match 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>\"foo\"</>, <g>\"bar\"</>\nReceived\n       2: <d>\"foo\"</>, <r>\"bar2\"</>\n->     3: <d>\"foo\"</>, <r>\"bar3\"</>\n\nNumber of calls: <r>3</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with trailing undefined arguments 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: <g>\"foo\"</>\nReceived: <d>\"foo\"</>, <r>undefined</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with trailing undefined arguments if requested by the match query 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>\"foo\"</>, <g>undefined</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenLastCalledWith works with trailing undefined arguments when explicitly requested as optional by matcher 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenLastCalledWith<d>(</><g>...expected</><d>)</>\n\nExpected: not <g>\"foo\"</>, <g>optionalFn<></>\nReceived:     <r>0</>, <r>[\"foo\", undefined]</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith includes the custom mock name in the error message 1`] = `\n<d>expect(</><r>named-mock</><d>).</>not<d>.</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: not <g>\"foo\"</>, <g>\"bar\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith negative throw matcher error for n that is not integer 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\n<b>Matcher error</>: n must be a positive integer\n\nn has type:  number\nn has value: Infinity\n`;\n\nexports[`toHaveBeenNthCalledWith positive throw matcher error for n that is not integer 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\n<b>Matcher error</>: n must be a positive integer\n\nn has type:  number\nn has value: 0.1\n`;\n\nexports[`toHaveBeenNthCalledWith positive throw matcher error for n that is not positive integer 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\n<b>Matcher error</>: n must be a positive integer\n\nn has type:  number\nn has value: 0\n`;\n\nexports[`toHaveBeenNthCalledWith works only on spies or jest.fn 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a mock or spy function\n\nReceived has type:  function\nReceived has value: <r>[Function fn]</>\n`;\n\nexports[`toHaveBeenNthCalledWith works when not called 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: <g>\"foo\"</>, <g>\"bar\"</>\n\nNumber of calls: <r>0</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with Immutable.js objects 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: not <g>Immutable.Map {\"a\": {\"b\": \"c\"}}</>, <g>Immutable.Map {\"a\": {\"b\": \"c\"}}</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with Map 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: not <g>Map {1 => 2, 2 => 1}</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with Map 2`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\n<g>- Expected</>\n<r>+ Received</>\n\n<d>  Map {</>\n<g>-   \"a\" => \"b\",</>\n<g>-   \"b\" => \"a\",</>\n<r>+   1 => 2,</>\n<r>+   2 => 1,</>\n<d>  }</>,\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with Set 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: not <g>Set {1, 2}</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with Set 2`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\n<g>- Expected</>\n<r>+ Received</>\n\n<d>  Set {</>\n<g>-   3,</>\n<g>-   4,</>\n<r>+   1,</>\n<r>+   2,</>\n<d>  }</>,\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with arguments that don't match 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: <g>\"foo\"</>, <g>\"bar\"</>\nReceived: <d>\"foo\"</>, <r>\"bar1\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with arguments that don't match in number of arguments 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: <g>\"foo\"</>, <g>\"bar\"</>\nReceived: <d>\"foo\"</>, <d>\"bar\"</>, <r>\"plop\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with arguments that don't match in size even if one is an optional matcher 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: <g>\"foo\"</>, <g>optionalFn<></>\nReceived: <d>\"foo\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with arguments that don't match with matchers 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: <g>Any<String></>, <g>Any<Number></>\nReceived: <d>\"foo\"</>, <r>\"bar\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with arguments that don't match with matchers even when argument is undefined 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: <g>\"foo\"</>, <g>Any<String></>\nReceived: <d>\"foo\"</>, <r>undefined</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with arguments that match 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: not <g>\"foo\"</>, <g>\"bar\"</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with arguments that match with matchers 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: not <g>Any<String></>, <g>Any<String></>\nReceived:     <r>0</>, <r>[\"foo\", \"bar\"]</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with three calls 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: not <g>\"foo1\"</>, <g>\"bar\"</>\nReceived\n->     1:     <d>\"foo1\"</>, <d>\"bar\"</>\n       2:     <r>\"foo\"</>, <r>\"bar1\"</>\n\nNumber of calls: <r>3</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with trailing undefined arguments 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: <g>\"foo\"</>\nReceived: <d>\"foo\"</>, <r>undefined</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with trailing undefined arguments if requested by the match query 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: not <g>\"foo\"</>, <g>undefined</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveBeenNthCalledWith works with trailing undefined arguments when explicitly requested as optional by matcher 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveBeenNthCalledWith<d>(</>n<d>, </><g>...expected</><d>)</>\n\nn: 1\nExpected: not <g>\"foo\"</>, <g>optionalFn<></>\nReceived:     <r>0</>, <r>[\"foo\", undefined]</>\n\nNumber of calls: <r>1</>\n`;\n\nexports[`toHaveLastReturnedWith a call that throws is not considered to have returned 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>undefined</>\nReceived: function call threw an error\n\nNumber of returns: <r>0</>\nNumber of calls:   <r>1</>\n`;\n\nexports[`toHaveLastReturnedWith a call that throws undefined is not considered to have returned 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>undefined</>\nReceived: function call threw an error\n\nNumber of returns: <r>0</>\nNumber of calls:   <r>1</>\n`;\n\nexports[`toHaveLastReturnedWith includes the custom mock name in the error message 1`] = `\n<d>expect(</><r>named-mock</><d>).</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>\"foo\"</>\n\nNumber of returns: <r>0</>\n`;\n\nexports[`toHaveLastReturnedWith toHaveLastReturnedWith incomplete recursive calls are handled properly 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>0</>\nReceived\n       3: function call has not returned yet\n->     4: function call has not returned yet\n\nNumber of returns: <r>0</>\nNumber of calls:   <r>4</>\n`;\n\nexports[`toHaveLastReturnedWith toHaveLastReturnedWith works with three calls 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: not <g>\"foo3\"</>\nReceived\n       2:     <r>\"foo2\"</>\n->     3:     <d>\"foo3\"</>\n\nNumber of returns: <r>3</>\n`;\n\nexports[`toHaveLastReturnedWith toHaveReturnedWith incomplete recursive calls are handled properly 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>undefined</>\nReceived\n       3: function call has not returned yet\n->     4: function call has not returned yet\n\nNumber of returns: <r>0</>\nNumber of calls:   <r>4</>\n`;\n\nexports[`toHaveLastReturnedWith toHaveReturnedWith works with more calls than the limit 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>\"bar\"</>\nReceived\n       5: <r>\"foo5\"</>\n->     6: <r>\"foo6\"</>\n\nNumber of returns: <r>6</>\n`;\n\nexports[`toHaveLastReturnedWith works only on spies or jest.fn 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a mock function\n\nReceived has type:  function\nReceived has value: <r>[Function fn]</>\n`;\n\nexports[`toHaveLastReturnedWith works when not called 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>\"foo\"</>\n\nNumber of returns: <r>0</>\n`;\n\nexports[`toHaveLastReturnedWith works with Immutable.js objects directly created 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: not <g>Immutable.Map {\"a\": {\"b\": \"c\"}}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveLastReturnedWith works with Immutable.js objects indirectly created 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: not <g>Immutable.Map {\"a\": {\"b\": \"c\"}}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveLastReturnedWith works with Map 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: not <g>Map {1 => 2, 2 => 1}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveLastReturnedWith works with Map 2`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>Map {\"a\" => \"b\", \"b\" => \"a\"}</>\nReceived: <r>Map {1 => 2, 2 => 1}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveLastReturnedWith works with Set 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: not <g>Set {1, 2}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveLastReturnedWith works with Set 2`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>Set {3, 4}</>\nReceived: <r>Set {1, 2}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveLastReturnedWith works with argument that does match 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: not <g>\"foo\"</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveLastReturnedWith works with argument that does not match 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>\"bar\"</>\nReceived: <r>\"foo\"</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveLastReturnedWith works with undefined 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveLastReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: not <g>undefined</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveNthReturnedWith a call that throws is not considered to have returned 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: <g>undefined</>\nReceived: function call threw an error\n\nNumber of returns: <r>0</>\nNumber of calls:   <r>1</>\n`;\n\nexports[`toHaveNthReturnedWith a call that throws undefined is not considered to have returned 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: <g>undefined</>\nReceived: function call threw an error\n\nNumber of returns: <r>0</>\nNumber of calls:   <r>1</>\n`;\n\nexports[`toHaveNthReturnedWith includes the custom mock name in the error message 1`] = `\n<d>expect(</><r>named-mock</><d>).</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: <g>\"foo\"</>\n\nNumber of returns: <r>0</>\n`;\n\nexports[`toHaveNthReturnedWith toHaveNthReturnedWith incomplete recursive calls are handled properly 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: <g>6</>\nReceived\n->     1: function call has not returned yet\n       2: function call has not returned yet\n\nNumber of returns: <r>2</>\nNumber of calls:   <r>4</>\n`;\n\nexports[`toHaveNthReturnedWith toHaveNthReturnedWith incomplete recursive calls are handled properly 2`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 2\nExpected: <g>3</>\nReceived\n       1: function call has not returned yet\n->     2: function call has not returned yet\n       3: <r>1</>\n\nNumber of returns: <r>2</>\nNumber of calls:   <r>4</>\n`;\n\nexports[`toHaveNthReturnedWith toHaveNthReturnedWith incomplete recursive calls are handled properly 3`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 3\nExpected: not <g>1</>\nReceived\n       2:     function call has not returned yet\n->     3:     <d>1</>\n       4:     <r>0</>\n\nNumber of returns: <r>2</>\nNumber of calls:   <r>4</>\n`;\n\nexports[`toHaveNthReturnedWith toHaveNthReturnedWith incomplete recursive calls are handled properly 4`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 4\nExpected: not <g>0</>\nReceived\n       3:     <r>1</>\n->     4:     <d>0</>\n\nNumber of returns: <r>2</>\nNumber of calls:   <r>4</>\n`;\n\nexports[`toHaveNthReturnedWith toHaveNthReturnedWith negative throw matcher error for n that is not number 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\n<b>Matcher error</>: n must be a positive integer\n\nn has value: undefined\n`;\n\nexports[`toHaveNthReturnedWith toHaveNthReturnedWith positive throw matcher error for n that is not integer 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\n<b>Matcher error</>: n must be a positive integer\n\nn has type:  number\nn has value: 0.1\n`;\n\nexports[`toHaveNthReturnedWith toHaveNthReturnedWith positive throw matcher error for n that is not positive integer 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\n<b>Matcher error</>: n must be a positive integer\n\nn has type:  number\nn has value: 0\n`;\n\nexports[`toHaveNthReturnedWith toHaveNthReturnedWith should reject nth value greater than number of calls 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 4\nExpected: <g>\"foo\"</>\nReceived\n       3: <d>\"foo\"</>\n\nNumber of returns: <r>3</>\n`;\n\nexports[`toHaveNthReturnedWith toHaveNthReturnedWith should replace 1st, 2nd, 3rd with first, second, third 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: <g>\"bar1\"</>\nReceived\n->     1: <r>\"foo1\"</>\n       2: <r>\"foo2\"</>\n\nNumber of returns: <r>3</>\n`;\n\nexports[`toHaveNthReturnedWith toHaveNthReturnedWith should replace 1st, 2nd, 3rd with first, second, third 2`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: not <g>\"foo1\"</>\nReceived\n->     1:     <d>\"foo1\"</>\n       2:     <r>\"foo2\"</>\n\nNumber of returns: <r>3</>\n`;\n\nexports[`toHaveNthReturnedWith toHaveNthReturnedWith works with three calls 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: not <g>\"foo1\"</>\nReceived\n->     1:     <d>\"foo1\"</>\n       2:     <r>\"foo2\"</>\n\nNumber of returns: <r>3</>\n`;\n\nexports[`toHaveNthReturnedWith works only on spies or jest.fn 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a mock function\n\nReceived has type:  function\nReceived has value: <r>[Function fn]</>\n`;\n\nexports[`toHaveNthReturnedWith works when not called 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: <g>\"foo\"</>\n\nNumber of returns: <r>0</>\n`;\n\nexports[`toHaveNthReturnedWith works with Immutable.js objects directly created 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: not <g>Immutable.Map {\"a\": {\"b\": \"c\"}}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveNthReturnedWith works with Immutable.js objects indirectly created 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: not <g>Immutable.Map {\"a\": {\"b\": \"c\"}}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveNthReturnedWith works with Map 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: not <g>Map {1 => 2, 2 => 1}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveNthReturnedWith works with Map 2`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: <g>Map {\"a\" => \"b\", \"b\" => \"a\"}</>\nReceived: <r>Map {1 => 2, 2 => 1}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveNthReturnedWith works with Set 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: not <g>Set {1, 2}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveNthReturnedWith works with Set 2`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: <g>Set {3, 4}</>\nReceived: <r>Set {1, 2}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveNthReturnedWith works with argument that does match 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: not <g>\"foo\"</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveNthReturnedWith works with argument that does not match 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: <g>\"bar\"</>\nReceived: <r>\"foo\"</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveNthReturnedWith works with undefined 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveNthReturnedWith<d>(</>n<d>, </><g>expected</><d>)</>\n\nn: 1\nExpected: not <g>undefined</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveReturned .not fails with any argument passed 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveReturned<d>()</>\n\n<b>Matcher error</>: this matcher must not have an expected argument\n\nExpected has type:  number\nExpected has value: <g>555</>\n`;\n\nexports[`toHaveReturned .not passes when a call throws undefined 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturned<d>()</>\n\nExpected number of returns: >= <g>1</>\nReceived number of returns:    <r>0</>\nReceived number of calls:      <r>1</>\n`;\n\nexports[`toHaveReturned .not passes when all calls throw 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturned<d>()</>\n\nExpected number of returns: >= <g>1</>\nReceived number of returns:    <r>0</>\nReceived number of calls:      <r>2</>\n`;\n\nexports[`toHaveReturned .not passes when not returned 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturned<d>()</>\n\nExpected number of returns: >= <g>1</>\nReceived number of returns:    <r>0</>\n`;\n\nexports[`toHaveReturned .not works only on jest.fn 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveReturned<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a mock function\n\nReceived has type:  function\nReceived has value: <r>[Function fn]</>\n`;\n\nexports[`toHaveReturned fails with any argument passed 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveReturned<d>()</>\n\n<b>Matcher error</>: this matcher must not have an expected argument\n\nExpected has type:  number\nExpected has value: <g>555</>\n`;\n\nexports[`toHaveReturned includes the custom mock name in the error message 1`] = `\n<d>expect(</><r>named-mock</><d>).</>not<d>.</>toHaveReturned<d>()</>\n\nExpected number of returns: <g>0</>\nReceived number of returns: <r>1</>\n\n1: <r>42</>\n`;\n\nexports[`toHaveReturned incomplete recursive calls are handled properly 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturned<d>()</>\n\nExpected number of returns: >= <g>1</>\nReceived number of returns:    <r>0</>\nReceived number of calls:      <r>4</>\n`;\n\nexports[`toHaveReturned passes when at least one call does not throw 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveReturned<d>()</>\n\nExpected number of returns: <g>0</>\nReceived number of returns: <r>2</>\n\n1: <r>42</>\n3: <r>42</>\n\nReceived number of calls:   <r>3</>\n`;\n\nexports[`toHaveReturned passes when returned 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveReturned<d>()</>\n\nExpected number of returns: <g>0</>\nReceived number of returns: <r>1</>\n\n1: <r>42</>\n`;\n\nexports[`toHaveReturned passes when undefined is returned 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveReturned<d>()</>\n\nExpected number of returns: <g>0</>\nReceived number of returns: <r>1</>\n\n1: <r>undefined</>\n`;\n\nexports[`toHaveReturned throw matcher error if received is spy 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveReturned<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a mock function\n\nReceived has type:  function\nReceived has value: <r>[Function spy]</>\n`;\n\nexports[`toHaveReturnedTimes .not only accepts a number argument 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  object\nExpected has value: <g>{}</>\n`;\n\nexports[`toHaveReturnedTimes .not only accepts a number argument 2`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  array\nExpected has value: <g>[]</>\n`;\n\nexports[`toHaveReturnedTimes .not only accepts a number argument 3`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  boolean\nExpected has value: <g>true</>\n`;\n\nexports[`toHaveReturnedTimes .not only accepts a number argument 4`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  string\nExpected has value: <g>\"a\"</>\n`;\n\nexports[`toHaveReturnedTimes .not only accepts a number argument 5`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  map\nExpected has value: <g>Map {}</>\n`;\n\nexports[`toHaveReturnedTimes .not only accepts a number argument 6`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  function\nExpected has value: <g>[Function anonymous]</>\n`;\n\nexports[`toHaveReturnedTimes .not passes if function called less than expected times 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\nExpected number of returns: <g>2</>\nReceived number of returns: <r>1</>\n`;\n\nexports[`toHaveReturnedTimes .not passes if function returned more than expected times 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\nExpected number of returns: <g>2</>\nReceived number of returns: <r>3</>\n`;\n\nexports[`toHaveReturnedTimes calls that return undefined are counted as returns 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\nExpected number of returns: not <g>2</>\n`;\n\nexports[`toHaveReturnedTimes calls that throw are not counted 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\nExpected number of returns: <g>3</>\nReceived number of returns: <r>2</>\nReceived number of calls:   <r>3</>\n`;\n\nexports[`toHaveReturnedTimes calls that throw undefined are not counted 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\nExpected number of returns: not <g>2</>\n\nReceived number of calls:       <r>3</>\n`;\n\nexports[`toHaveReturnedTimes includes the custom mock name in the error message 1`] = `\n<d>expect(</><r>named-mock</><d>).</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\nExpected number of returns: <g>1</>\nReceived number of returns: <r>2</>\n`;\n\nexports[`toHaveReturnedTimes incomplete recursive calls are handled properly 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\nExpected number of returns: not <g>2</>\n\nReceived number of calls:       <r>4</>\n`;\n\nexports[`toHaveReturnedTimes only accepts a number argument 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  object\nExpected has value: <g>{}</>\n`;\n\nexports[`toHaveReturnedTimes only accepts a number argument 2`] = `\n<d>expect(</><r>received</><d>).</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  array\nExpected has value: <g>[]</>\n`;\n\nexports[`toHaveReturnedTimes only accepts a number argument 3`] = `\n<d>expect(</><r>received</><d>).</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  boolean\nExpected has value: <g>true</>\n`;\n\nexports[`toHaveReturnedTimes only accepts a number argument 4`] = `\n<d>expect(</><r>received</><d>).</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  string\nExpected has value: <g>\"a\"</>\n`;\n\nexports[`toHaveReturnedTimes only accepts a number argument 5`] = `\n<d>expect(</><r>received</><d>).</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  map\nExpected has value: <g>Map {}</>\n`;\n\nexports[`toHaveReturnedTimes only accepts a number argument 6`] = `\n<d>expect(</><r>received</><d>).</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a non-negative integer\n\nExpected has type:  function\nExpected has value: <g>[Function anonymous]</>\n`;\n\nexports[`toHaveReturnedTimes passes if function returned equal to expected times 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\nExpected number of returns: not <g>2</>\n`;\n\nexports[`toHaveReturnedTimes throw matcher error if received is spy 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toHaveReturnedTimes<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a mock function\n\nReceived has type:  function\nReceived has value: <r>[Function spy]</>\n`;\n\nexports[`toHaveReturnedWith a call that throws is not considered to have returned 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>undefined</>\nReceived: function call threw an error\n\nNumber of returns: <r>0</>\nNumber of calls:   <r>1</>\n`;\n\nexports[`toHaveReturnedWith a call that throws undefined is not considered to have returned 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>undefined</>\nReceived: function call threw an error\n\nNumber of returns: <r>0</>\nNumber of calls:   <r>1</>\n`;\n\nexports[`toHaveReturnedWith includes the custom mock name in the error message 1`] = `\n<d>expect(</><r>named-mock</><d>).</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>\"foo\"</>\n\nNumber of returns: <r>0</>\n`;\n\nexports[`toHaveReturnedWith toHaveReturnedWith incomplete recursive calls are handled properly 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>undefined</>\nReceived\n       1: function call has not returned yet\n       2: function call has not returned yet\n       3: function call has not returned yet\n\nNumber of returns: <r>0</>\nNumber of calls:   <r>4</>\n`;\n\nexports[`toHaveReturnedWith toHaveReturnedWith works with more calls than the limit 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>\"bar\"</>\nReceived\n       1: <r>\"foo1\"</>\n       2: <r>\"foo2\"</>\n       3: <r>\"foo3\"</>\n\nNumber of returns: <r>6</>\n`;\n\nexports[`toHaveReturnedWith works only on spies or jest.fn 1`] = `\n<d>expect(</><r>received</><d>).</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <r>received</> value must be a mock function\n\nReceived has type:  function\nReceived has value: <r>[Function fn]</>\n`;\n\nexports[`toHaveReturnedWith works when not called 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>\"foo\"</>\n\nNumber of returns: <r>0</>\n`;\n\nexports[`toHaveReturnedWith works with Immutable.js objects directly created 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: not <g>Immutable.Map {\"a\": {\"b\": \"c\"}}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveReturnedWith works with Immutable.js objects indirectly created 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: not <g>Immutable.Map {\"a\": {\"b\": \"c\"}}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveReturnedWith works with Map 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: not <g>Map {1 => 2, 2 => 1}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveReturnedWith works with Map 2`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>Map {\"a\" => \"b\", \"b\" => \"a\"}</>\nReceived: <r>Map {1 => 2, 2 => 1}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveReturnedWith works with Set 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: not <g>Set {1, 2}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveReturnedWith works with Set 2`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>Set {3, 4}</>\nReceived: <r>Set {1, 2}</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveReturnedWith works with argument that does match 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: not <g>\"foo\"</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveReturnedWith works with argument that does not match 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: <g>\"bar\"</>\nReceived: <r>\"foo\"</>\n\nNumber of returns: <r>1</>\n`;\n\nexports[`toHaveReturnedWith works with undefined 1`] = `\n<d>expect(</><r>jest.fn()</><d>).</>not<d>.</>toHaveReturnedWith<d>(</><g>expected</><d>)</>\n\nExpected: not <g>undefined</>\n\nNumber of returns: <r>1</>\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\n/* globals spyOn */\nconst subject = {\n  func: () => 'foo',\n};\n\ntest('spyOn', () => {\n  spyOn(subject, 'func').and.returnValue('bar');\n  expect(subject.func()).toBe('bar');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\n/* globals spyOnProperty */\n\nconst myObject = {};\nObject.defineProperties(myObject, {\n  name: () => 'Jordan',\n});\n\ntest('spyOnProperty', () => {\n  let isOriginalCalled = false;\n  const obj = {\n    get method() {\n      return () => (isOriginalCalled = true);\n    },\n  };\n\n  const spy = spyOnProperty(obj, 'method', 'get');\n\n  obj.method();\n\n  expect(isOriginalCalled).toBe(true);\n  expect(spy).toHaveBeenCalled();\n});"}
{"prompt":"stack trace,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ndescribe('stack trace', () => {\n  it('fails', () => {\n    expect(1).toBe(3);\n  });\n});"}
{"prompt":"stack trace points to correct location when using matchers,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport jestExpect from '..';\n\njestExpect.extend({\n  toCustomMatch(callback: () => unknown, expected: unknown) {\n    const actual = callback();\n\n    if (actual !== expected) {\n      return {\n        message: () => `Expected \"${expected}\" but got \"${actual}\"`,\n        pass: false,\n      };\n    }\n\n    return {\n      message: () => '',\n      pass: true,\n    };\n  },\n  toMatchPredicate(received: unknown, expected: (a: unknown) => void) {\n    expected(received);\n    return {\n      message: () => '',\n      pass: true,\n    };\n  },\n});\n\ndeclare module '../types' {\n  interface Matchers<R> {\n    toCustomMatch(expected: unknown): R;\n    toMatchPredicate(expected: (a: unknown) => void): R;\n  }\n}\n\nit('stack trace points to correct location when using matchers', () => {\n  try {\n    jestExpect(true).toBe(false);\n  } catch (error: any) {\n    expect(error.stack).toContain('stacktrace.test.ts:45:22');\n  }\n});\n\nit('stack trace points to correct location when using nested matchers', () => {\n  try {\n    jestExpect(true).toMatchPredicate((value: unknown) => {\n      jestExpect(value).toBe(false);\n    });\n  } catch (error: any) {\n    expect(error.stack).toContain('stacktrace.test.ts:54:25');\n  }\n});\n\nit('stack trace points to correct location when throwing from a custom matcher', () => {\n  try {\n    jestExpect(() => {\n      const foo = () => bar();\n      const bar = () => baz();\n      const baz = () => {\n        throw new Error('Expected');\n      };\n\n      foo();\n    }).toCustomMatch('bar');\n  } catch (error: any) {\n    expect(error.stack).toContain('stacktrace.test.ts:67:15');\n  }\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Stack Trace does not print a stack trace for errors when --noStackTrace is given 1`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       3 failed, 3 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching testError.test.js.\"\n`;\n\nexports[`Stack Trace does not print a stack trace for matching errors when --noStackTrace is given 1`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       1 failed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching stackTrace.test.js.\"\n`;\n\nexports[`Stack Trace does not print a stack trace for runtime errors when --noStackTrace is given 1`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       0 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching runtimeError.test.js.\"\n`;\n\nexports[`Stack Trace prints a stack trace for errors 1`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       3 failed, 3 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching testError.test.js.\"\n`;\n\nexports[`Stack Trace prints a stack trace for errors without message in stack trace 1`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       1 failed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching stackTraceWithoutMessage.test.js.\"\n`;\n\nexports[`Stack Trace prints a stack trace for matching errors 1`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       1 failed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching stackTrace.test.js.\"\n`;\n\nexports[`Stack Trace prints a stack trace for runtime errors 1`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       0 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching runtimeError.test.js.\"\n`;"}
{"prompt":"prints a usable stack trace even if no Error.captureStackTrace,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\nit('prints a usable stack trace even if no Error.captureStackTrace', () => {\n  const {stderr, exitCode} = runJest('stack-trace-no-capture-stack-trace');\n  expect(stderr).not.toMatch('Error.captureStackTrace is not a function');\n  expect(exitCode).toBe(1);\n});"}
{"prompt":"processes stack traces and code frames with source maps,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {runYarnInstall} from '../Utils';\nimport runJest from '../runJest';\n\nit('processes stack traces and code frames with source maps', () => {\n  const dir = path.resolve(__dirname, '../stack-trace-source-maps');\n  runYarnInstall(dir);\n  const {stderr} = runJest(dir, ['--no-cache']);\n  expect(stderr).toMatch('> 15 |   (() => expect(false).toBe(true))();');\n  expect(stderr).toMatch(`at __tests__/fails.ts:15:24\n      at Object.<anonymous> (__tests__/fails.ts:15:35)`);\n});"}
{"prompt":"processes stack traces and code frames with source maps with coverage,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport * as path from 'path';\nimport {extractSummary, runYarnInstall} from '../Utils';\nimport runJest from '../runJest';\n\nit('processes stack traces and code frames with source maps with coverage', () => {\n  const dir = path.resolve(\n    __dirname,\n    '../stack-trace-source-maps-with-coverage',\n  );\n  runYarnInstall(dir);\n  const {stderr} = runJest(dir, ['--no-cache', '--coverage']);\n\n  // Should report an error at source line 13 in lib.ts at line 10 of the test\n  expect(extractSummary(stderr).rest).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`processes stack traces and code frames with source maps with coverage 1`] = `\n\"FAIL __tests__/fails.ts\n  ✕ fails\n\n  ● fails\n\n    This did not work!\n\n      12 |\n      13 | export function error() {\n    > 14 |   throw new Error('This did not work!');\n         |         ^\n      15 | }\n      16 |\n\n      at error (lib.ts:14:9)\n      at Object.<anonymous> (__tests__/fails.ts:10:8)\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('fails with error without proper message', () => {\n  const error = new Error('important message');\n  error.stack = error.stack.replace('Error: important message', 'Error   ');\n  throw error;\n});"}
{"prompt":"passes,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit('passes', () => {\n  expect(10).toBe(10);\n});\n\nit('fails', () => {\n  expect(10).toBe(101);\n});\n\nit.skip('skips', () => {\n  expect(10).toBe(101);\n});\n\nit.todo('todo');"}
{"prompt":"numeric input,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport stringToBytes from '../stringToBytes';\n\ndescribe('numeric input', () => {\n  test('> 1 represents bytes', () => {\n    expect(stringToBytes(50.8)).toBe(50);\n  });\n\n  test('1.1 should be a 1', () => {\n    expect(stringToBytes(1.1, 54)).toBe(1);\n  });\n\n  test('< 1 represents a %', () => {\n    expect(stringToBytes(0.3, 51)).toBe(15);\n  });\n\n  test('should throw when no reference supplied', () => {\n    expect(() => stringToBytes(0.3)).toThrow(\n      'For a percentage based memory limit a percentageReference must be supplied',\n    );\n  });\n\n  test('should throw on a bad input', () => {\n    expect(() => stringToBytes(-0.3, 51)).toThrow('Unexpected numerical input');\n  });\n});\n\ndescribe('string input', () => {\n  describe('numeric passthrough', () => {\n    test('> 1 represents bytes', () => {\n      expect(stringToBytes('50.8')).toBe(50);\n    });\n\n    test('< 1 represents a %', () => {\n      expect(stringToBytes('0.3', 51)).toBe(15);\n    });\n\n    test('should throw when no reference supplied', () => {\n      expect(() => stringToBytes('0.3')).toThrow(\n        'For a percentage based memory limit a percentageReference must be supplied',\n      );\n    });\n\n    test('should throw on a bad input', () => {\n      expect(() => stringToBytes('-0.3', 51)).toThrow(\n        'Unexpected numerical input',\n      );\n    });\n  });\n\n  describe('parsing', () => {\n    test('0% should throw an error', () => {\n      expect(() => stringToBytes('0%', 51)).toThrow(\n        'Unexpected numerical input',\n      );\n    });\n\n    test('30%', () => {\n      expect(stringToBytes('30%', 51)).toBe(15);\n    });\n\n    test('80%', () => {\n      expect(stringToBytes('80%', 51)).toBe(40);\n    });\n\n    test('100%', () => {\n      expect(stringToBytes('100%', 51)).toBe(51);\n    });\n\n    // The units caps is intentionally janky to test for forgiving string parsing.\n    describe('k', () => {\n      test('30k', () => {\n        expect(stringToBytes('30K')).toBe(30_000);\n      });\n\n      test('30KB', () => {\n        expect(stringToBytes('30kB')).toBe(30_000);\n      });\n\n      test('30KiB', () => {\n        expect(stringToBytes('30kIb')).toBe(30_720);\n      });\n    });\n\n    describe('m', () => {\n      test('30M', () => {\n        expect(stringToBytes('30M')).toBe(30_000_000);\n      });\n\n      test('30MB', () => {\n        expect(stringToBytes('30MB')).toBe(30_000_000);\n      });\n\n      test('30MiB', () => {\n        expect(stringToBytes('30MiB')).toBe(31_457_280);\n      });\n    });\n\n    describe('g', () => {\n      test('30G', () => {\n        expect(stringToBytes('30G')).toBe(30_000_000_000);\n      });\n\n      test('30GB', () => {\n        expect(stringToBytes('30gB')).toBe(30_000_000_000);\n      });\n\n      test('30GiB', () => {\n        expect(stringToBytes('30GIB')).toBe(32_212_254_720);\n      });\n    });\n\n    test('unknown unit', () => {\n      expect(() => stringToBytes('50XX')).toThrow('Unexpected input');\n    });\n  });\n});\n\ntest('nesting', () => {\n  expect(stringToBytes(stringToBytes(stringToBytes('30%', 51)))).toBe(15);\n});\n\ntest('null', () => {\n  expect(stringToBytes(null)).toBeNull();\n});\n\ntest('undefined', () => {\n  expect(stringToBytes(undefined)).toBeUndefined();\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.\n\nimport {expect, it} from '@jest/globals';\nimport sub from '../sub';\n\nit('subtracts 5 - 1 to equal 4 in TypeScript', () => {\n  expect(sub(5, 1)).toBe(4);\n});"}
{"prompt":"test1,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit('test1', () => {\n  expect(true).toBe(true);\n});\n\nit('test2', () => {\n  expect(true).toBe(true);\n});\n\nit('test3', () => {\n  expect(true).toBe(true);\n});\n\ndescribe('describe1', () => {\n  it('test4', () => {\n    expect(true).toBe(true);\n  });\n\n  it('test5', () => {\n    expect(true).toBe(true);\n  });\n\n  it('test6', () => {\n    expect(true).toBe(true);\n  });\n});\n\ndescribe('describe2', () => {\n  it('test7', () => {\n    expect(true).toBe(true);\n  });\n\n  it('test8', () => {\n    expect(true).toBe(true);\n  });\n\n  it('test9', () => {\n    expect(true).toBe(true);\n  });\n});\n\ndescribe('describe3', () => {\n  it('test10', () => {\n    expect(true).toBe(true);\n  });\n\n  it('test11', () => {\n    expect(true).toBe(true);\n  });\n\n  it('test12', () => {\n    expect(true).toBe(true);\n  });\n\n  describe('describe4', () => {\n    it('test13', () => {\n      expect(true).toBe(true);\n    });\n\n    it('test14', () => {\n      expect(true).toBe(true);\n    });\n\n    it('test15', () => {\n      expect(true).toBe(true);\n    });\n  });\n});"}
{"prompt":"Suite,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport Suite, {type Attributes} from '../jasmine/Suite';\n\ndescribe('Suite', () => {\n  let suite: Suite;\n\n  beforeEach(() => {\n    suite = new Suite({\n      getTestPath: () => '',\n    } as Attributes);\n  });\n\n  it(\"doesn't throw on addExpectationResult when there are no children\", () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      suite.addExpectationResult();\n    }).not.toThrow();\n  });\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.\n\nimport {expect, it} from '@jest/globals';\n\nit('adds 1 + 2 to equal 3 in TScript', () => {\n  // Generally, `import` should be used for TypeScript\n  // as using `require` will not return any type information.\n  const sum = require('../sum.ts').default;\n  expect(sum(1, 2)).toBe(3);\n});\n\nit('adds 1 + 2 to equal 3 in JavaScript', () => {\n  const sum = require('../sum.js');\n  expect(sum(1, 2)).toBe(3);\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\nimport {expect, it} from '@jest/globals';\n\nit('adds 1 + 2 to equal 3 in Typescript', () => {\n  const sum = require('../sum.ts').default;\n  expect(sum(1, 2)).toBe(3);\n});\n\nit('adds 1 + 2 to equal 3 in JavaScript', () => {\n  const sum = require('../sum.js');\n  expect(sum(1, 2)).toBe(3);\n});"}
{"prompt":"summaryThreshold option,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nimport {TestPathPatterns} from '@jest/pattern';\n\nlet SummaryReporter;\n\nconst env = {...process.env};\nconst now = Date.now;\nconst write = process.stderr.write;\nconst globalConfig = {\n  rootDir: 'root',\n  testPathPatterns: new TestPathPatterns([]),\n  watch: false,\n};\n\nlet results = [];\n\nfunction requireReporter() {\n  jest.isolateModules(() => {\n    SummaryReporter = require('../SummaryReporter').default;\n  });\n}\n\nbeforeEach(() => {\n  process.env.npm_lifecycle_event = 'test';\n  process.env.npm_lifecycle_script = 'jest';\n  process.stderr.write = result => results.push(result);\n  Date.now = () => 10;\n});\n\nafterEach(() => {\n  results = [];\n  process.env = env;\n  process.stderr.write = write;\n  Date.now = now;\n});\n\ntest('snapshots needs update with npm test', () => {\n  const aggregatedResults = {\n    numFailedTestSuites: 1,\n    numFailedTests: 1,\n    numPassedTestSuites: 0,\n    numTotalTestSuites: 1,\n    numTotalTests: 1,\n    snapshot: {\n      filesUnmatched: 1,\n      total: 2,\n      uncheckedKeysByFile: [],\n      unmatched: 2,\n    },\n    startTime: 0,\n    testResults: [],\n  };\n\n  process.env.npm_config_user_agent = 'npm';\n  requireReporter();\n  const testReporter = new SummaryReporter(globalConfig);\n  testReporter.onRunComplete(new Set(), aggregatedResults);\n  expect(results.join('')).toMatchSnapshot();\n});\n\ntest('snapshots needs update with yarn test', () => {\n  const aggregatedResults = {\n    numFailedTestSuites: 1,\n    numFailedTests: 1,\n    numPassedTestSuites: 0,\n    numTotalTestSuites: 1,\n    numTotalTests: 1,\n    snapshot: {\n      filesRemovedList: [],\n      filesUnmatched: 1,\n      total: 2,\n      uncheckedKeysByFile: [],\n      unmatched: 2,\n    },\n    startTime: 0,\n    testResults: [],\n  };\n\n  process.env.npm_config_user_agent = 'yarn';\n  requireReporter();\n  const testReporter = new SummaryReporter(globalConfig);\n  testReporter.onRunComplete(new Set(), aggregatedResults);\n  expect(results.join('')).toMatchSnapshot();\n});\n\ntest('snapshots all have results (no update)', () => {\n  const aggregatedResults = {\n    numFailedTestSuites: 1,\n    numFailedTests: 1,\n    numPassedTestSuites: 0,\n    numTotalTestSuites: 1,\n    numTotalTests: 1,\n    snapshot: {\n      added: 1,\n      didUpdate: false,\n      filesAdded: 1,\n      filesRemoved: 1,\n      filesRemovedList: [],\n      filesUnmatched: 1,\n      filesUpdated: 1,\n      matched: 2,\n      total: 2,\n      unchecked: 1,\n      uncheckedKeysByFile: [\n        {\n          filePath: 'path/to/suite_one',\n          keys: ['unchecked snapshot 1'],\n        },\n      ],\n      unmatched: 1,\n      updated: 1,\n    },\n    startTime: 0,\n    testResults: [],\n  };\n\n  requireReporter();\n  const testReporter = new SummaryReporter(globalConfig);\n  testReporter.onRunComplete(new Set(), aggregatedResults);\n  expect(results.join('').replaceAll('\\\\', '/')).toMatchSnapshot();\n});\n\ntest('snapshots all have results (after update)', () => {\n  const aggregatedResults = {\n    numFailedTestSuites: 1,\n    numFailedTests: 1,\n    numPassedTestSuites: 0,\n    numTotalTestSuites: 1,\n    numTotalTests: 1,\n    snapshot: {\n      added: 1,\n      didUpdate: true,\n      filesAdded: 1,\n      filesRemoved: 1,\n      filesRemovedList: [],\n      filesUnmatched: 1,\n      filesUpdated: 1,\n      matched: 2,\n      total: 2,\n      unchecked: 1,\n      uncheckedKeysByFile: [\n        {\n          filePath: 'path/to/suite_one',\n          keys: ['unchecked snapshot 1'],\n        },\n      ],\n      unmatched: 1,\n      updated: 1,\n    },\n    startTime: 0,\n    testResults: [],\n  };\n\n  requireReporter();\n  const testReporter = new SummaryReporter(globalConfig);\n  testReporter.onRunComplete(new Set(), aggregatedResults);\n  expect(results.join('').replaceAll('\\\\', '/')).toMatchSnapshot();\n});\n\ndescribe('summaryThreshold option', () => {\n  const aggregatedResults = {\n    numFailedTestSuites: 1,\n    numFailedTests: 1,\n    numPassedTestSuites: 2,\n    numRuntimeErrorTestSuites: 0,\n    numTotalTestSuites: 3,\n    numTotalTests: 3,\n    snapshot: {\n      filesRemovedList: [],\n      filesUnmatched: 0,\n      total: 0,\n      uncheckedKeysByFile: [],\n      unmatched: 0,\n    },\n    startTime: 0,\n    testResults: [\n      {\n        failureMessage: 'FailureMessage1',\n        numFailingTests: 1,\n        testFilePath: 'path1',\n      },\n      {\n        failureMessage: 'FailureMessage2',\n        numFailingTests: 1,\n        testFilePath: 'path2',\n      },\n    ],\n  };\n\n  it('Should print failure messages when number of test suites is over the threshold', () => {\n    const options = {\n      summaryThreshold: aggregatedResults.numTotalTestSuites - 1,\n    };\n\n    requireReporter();\n    const testReporter = new SummaryReporter(globalConfig, options);\n    testReporter.onRunComplete(new Set(), aggregatedResults);\n    expect(results.join('').replaceAll('\\\\', '/')).toMatchSnapshot();\n  });\n\n  it('Should not print failure messages when number of test suites is under the threshold', () => {\n    const options = {\n      summaryThreshold: aggregatedResults.numTotalTestSuites + 1,\n    };\n\n    requireReporter();\n    const testReporter = new SummaryReporter(globalConfig, options);\n    testReporter.onRunComplete(new Set(), aggregatedResults);\n    expect(results.join('').replaceAll('\\\\', '/')).toMatchSnapshot();\n  });\n\n  it('Should not print failure messages when number of test suites is equal to the threshold', () => {\n    const options = {\n      summaryThreshold: aggregatedResults.numTotalTestSuites,\n    };\n\n    requireReporter();\n    const testReporter = new SummaryReporter(globalConfig, options);\n    testReporter.onRunComplete(new Set(), aggregatedResults);\n    expect(results.join('').replaceAll('\\\\', '/')).toMatchSnapshot();\n  });\n\n  it('Should throw error if threshold is not a number', () => {\n    const options = {\n      summaryThreshold: 'not a number',\n    };\n\n    requireReporter();\n    expect(() => new SummaryReporter(globalConfig, options)).toThrow(\n      'The option summaryThreshold should be a number',\n    );\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`snapshots all have results (after update) 1`] = `\n\"<bold>Snapshot Summary</intensity>\n<bold><green> › 1 snapshot written </color></intensity>from 1 test suite.\n<bold><red> › 1 snapshot failed</color></intensity> from 1 test suite. <dim>Inspect your code changes or run \\`yarn test -u\\` to update them.</intensity>\n<bold><green> › 1 snapshot updated </color></intensity>from 1 test suite.\n<bold><green> › 1 snapshot file removed </color></intensity>from 1 test suite.\n<bold><green> › 1 snapshot removed </color></intensity>from 1 test suite.\n   ↳ <dim>../path/to/</intensity><bold>suite_one</intensity>\n       • unchecked snapshot 1\n\n<bold>Test Suites: </intensity><bold><red>1 failed</color></intensity>, 1 total\n<bold>Tests:       </intensity><bold><red>1 failed</color></intensity>, 1 total\n<bold>Snapshots:   </intensity><bold><red>1 failed</color></intensity>, <bold><green>1 removed</color></intensity>, <bold><green>1 file removed</color></intensity>, <bold><green>1 updated</color></intensity>, <bold><green>1 written</color></intensity>, <bold><green>2 passed</color></intensity>, 2 total\n<bold>Time:</intensity>        0.01 s\n<dim>Ran all test suites</intensity><dim>.</intensity>\n\"\n`;\n\nexports[`snapshots all have results (no update) 1`] = `\n\"<bold>Snapshot Summary</intensity>\n<bold><green> › 1 snapshot written </color></intensity>from 1 test suite.\n<bold><red> › 1 snapshot failed</color></intensity> from 1 test suite. <dim>Inspect your code changes or run \\`yarn test -u\\` to update them.</intensity>\n<bold><green> › 1 snapshot updated </color></intensity>from 1 test suite.\n<bold><yellow> › 1 snapshot file obsolete </color></intensity>from 1 test suite. <dim>To remove it, run \\`yarn test -u\\`.</intensity>\n<bold><yellow> › 1 snapshot obsolete </color></intensity>from 1 test suite. <dim>To remove it, run \\`yarn test -u\\`.</intensity>\n   ↳ <dim>../path/to/</intensity><bold>suite_one</intensity>\n       • unchecked snapshot 1\n\n<bold>Test Suites: </intensity><bold><red>1 failed</color></intensity>, 1 total\n<bold>Tests:       </intensity><bold><red>1 failed</color></intensity>, 1 total\n<bold>Snapshots:   </intensity><bold><red>1 failed</color></intensity>, <bold><yellow>1 obsolete</color></intensity>, <bold><yellow>1 file obsolete</color></intensity>, <bold><green>1 updated</color></intensity>, <bold><green>1 written</color></intensity>, <bold><green>2 passed</color></intensity>, 2 total\n<bold>Time:</intensity>        0.01 s\n<dim>Ran all test suites</intensity><dim>.</intensity>\n\"\n`;\n\nexports[`snapshots needs update with npm test 1`] = `\n\"<bold>Snapshot Summary</intensity>\n<bold><red> › 2 snapshots failed</color></intensity> from 1 test suite. <dim>Inspect your code changes or run \\`npm test -- -u\\` to update them.</intensity>\n\n<bold>Test Suites: </intensity><bold><red>1 failed</color></intensity>, 1 total\n<bold>Tests:       </intensity><bold><red>1 failed</color></intensity>, 1 total\n<bold>Snapshots:   </intensity><bold><red>2 failed</color></intensity>, 2 total\n<bold>Time:</intensity>        0.01 s\n<dim>Ran all test suites</intensity><dim>.</intensity>\n\"\n`;\n\nexports[`snapshots needs update with yarn test 1`] = `\n\"<bold>Snapshot Summary</intensity>\n<bold><red> › 2 snapshots failed</color></intensity> from 1 test suite. <dim>Inspect your code changes or run \\`yarn test -u\\` to update them.</intensity>\n\n<bold>Test Suites: </intensity><bold><red>1 failed</color></intensity>, 1 total\n<bold>Tests:       </intensity><bold><red>1 failed</color></intensity>, 1 total\n<bold>Snapshots:   </intensity><bold><red>2 failed</color></intensity>, 2 total\n<bold>Time:</intensity>        0.01 s\n<dim>Ran all test suites</intensity><dim>.</intensity>\n\"\n`;\n\nexports[`summaryThreshold option Should not print failure messages when number of test suites is equal to the threshold 1`] = `\n\"<bold>Test Suites: </intensity><bold><red>1 failed</color></intensity>, <bold><green>2 passed</color></intensity>, 3 total\n<bold>Tests:       </intensity><bold><red>1 failed</color></intensity>, 3 total\n<bold>Snapshots:   </intensity>0 total\n<bold>Time:</intensity>        0.01 s\n<dim>Ran all test suites</intensity><dim>.</intensity>\n\"\n`;\n\nexports[`summaryThreshold option Should not print failure messages when number of test suites is under the threshold 1`] = `\n\"<bold>Test Suites: </intensity><bold><red>1 failed</color></intensity>, <bold><green>2 passed</color></intensity>, 3 total\n<bold>Tests:       </intensity><bold><red>1 failed</color></intensity>, 3 total\n<bold>Snapshots:   </intensity>0 total\n<bold>Time:</intensity>        0.01 s\n<dim>Ran all test suites</intensity><dim>.</intensity>\n\"\n`;\n\nexports[`summaryThreshold option Should print failure messages when number of test suites is over the threshold 1`] = `\n\"<bold>Summary of all failing tests</intensity>\n</><inverse><bold><red> FAIL </color></intensity></inverse></> <dim>../</intensity><bold>path1</intensity>\nFailureMessage1\n</><inverse><bold><red> FAIL </color></intensity></inverse></> <dim>../</intensity><bold>path2</intensity>\nFailureMessage2\n\n<bold>Test Suites: </intensity><bold><red>1 failed</color></intensity>, <bold><green>2 passed</color></intensity>, 3 total\n<bold>Tests:       </intensity><bold><red>1 failed</color></intensity>, 3 total\n<bold>Snapshots:   </intensity>0 total\n<bold>Time:</intensity>        0.01 s\n<dim>Ran all test suites</intensity><dim>.</intensity>\n\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('fails', () => {\n  expect(1).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('fails', () => {\n  expect(2).toBe(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('passes', () => {\n  expect(1).toBe(1);\n});"}
{"prompt":"${reporter} reporter,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\nfor (const reporter of ['default', 'summary']) {\n  describe(`${reporter} reporter`, () => {\n    test('prints failure messages when total number of test suites is over summaryThreshold', () => {\n      const {exitCode, stderr} = runJest('summary-threshold', [\n        '--config',\n        JSON.stringify({\n          reporters: [[reporter, {summaryThreshold: 2}]],\n        }),\n      ]);\n\n      expect(exitCode).toBe(1);\n      expect(stderr).toMatch(\n        /Summary of all failing tests(\\n|.)*expect\\(1\\)\\.toBe\\(0\\)/,\n      );\n      expect(stderr).toMatch(\n        /Summary of all failing tests(\\n|.)*expect\\(2\\)\\.toBe\\(0\\)/,\n      );\n    });\n  });\n}"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nexport class SuperTestClass {\n  static staticTestProperty = 'staticTestProperty';\n\n  static get staticTestAccessor(): string {\n    return 'staticTestAccessor';\n  }\n\n  static set staticTestAccessor(_x: string) {\n    return;\n  }\n\n  static staticTestMethod(): string {\n    return 'staticTestMethod';\n  }\n\n  testProperty = 'testProperty';\n\n  get testAccessor(): string {\n    return 'testAccessor';\n  }\n  set testAccessor(_x: string) {\n    return;\n  }\n\n  testMethod(): string {\n    return 'testMethod';\n  }\n}"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport runJest from '../runJest';\n\nconst consoleDir = path.resolve(__dirname, '../console');\nconst eachDir = path.resolve(__dirname, '../each');\n\nexpect.addSnapshotSerializer({\n  print: value => value,\n  test: received => typeof received === 'string',\n});\n\ntest('works with passing tests', () => {\n  const {exitCode} = runJest(eachDir, [\n    'success.test.js',\n    '--runInBand',\n    '--collect-coverage',\n    '--coverageReporters',\n    'text-summary',\n    '--clear-mocks',\n    '--useStderr',\n  ]);\n  expect(exitCode).toBe(0);\n});\n\ntest('throws error for unknown dashed & camelcase args', () => {\n  const {exitCode, stderr} = runJest(consoleDir, [\n    'success.test.js',\n    '--runInBand',\n    '--collect-coverage',\n    '--coverageReporters',\n    'text-summary',\n    '--clear-mocks',\n    '--doesNotExist',\n    '--also-does-not-exist',\n    '--useStderr',\n  ]);\n  expect(stderr).toMatchInlineSnapshot(`\n    ● Unrecognized CLI Parameters:\n\n      Following options were not recognized:\n      [\"doesNotExist\", \"also-does-not-exist\"]\n\n      CLI Options Documentation:\n      https://jestjs.io/docs/cli\n\n  `);\n  expect(exitCode).toBe(1);\n});"}
{"prompt":"@ts-expect-error","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('Symbol deletion', () => {\n  // @ts-expect-error\n  globalThis.Symbol = undefined;\n\n  expect({}).toEqual({});\n});"}
{"prompt":"Symbol in objects,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {expect} from '@jest/globals';\n\ndescribe('Symbol in objects', () => {\n  test('should compare objects with Symbol keys', () => {\n    const sym = Symbol('foo');\n    const obj1 = {[sym]: 'one'};\n    const obj2 = {[sym]: 'two'};\n    const obj3 = {[sym]: 'one'};\n\n    expect(obj1).toEqual(obj3);\n    expect(obj1).not.toEqual(obj2);\n  });\n\n  test('should compare objects with mixed keys and Symbol', () => {\n    const sym = Symbol('foo2');\n    const obj1 = {foo: 2, [sym]: 'one'};\n    const obj2 = {foo: 2, [sym]: 'two'};\n    const obj3 = {foo: 2, [sym]: 'one'};\n\n    expect(obj1).toEqual(obj3);\n    expect(obj1).not.toEqual(obj2);\n  });\n\n  test('should compare objects with different Symbol keys', () => {\n    const sym = Symbol('foo');\n    const sym2 = Symbol('foo');\n    const obj1 = {[sym]: 'one'};\n    const obj2 = {[sym2]: 'one'};\n    const obj3 = {[sym]: 'one'};\n\n    expect(obj1).toEqual(obj3);\n    expect(obj1).not.toEqual(obj2);\n  });\n});"}
{"prompt":"Custom matcher,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nfunction toCustomMatch(callback, expectation) {\n  const actual = callback();\n\n  if (actual === expectation) {\n    return {pass: true};\n  } else {\n    return {\n      message: () => `Expected \"${expectation}\" but got \"${actual}\"`,\n      pass: false,\n    };\n  }\n}\n\nexpect.extend({\n  toCustomMatch,\n});\n\ndescribe('Custom matcher', () => {\n  it('passes', () => {\n    // This expectation should pass\n    expect(() => 'foo').toCustomMatch('foo');\n  });\n\n  it('fails', () => {\n    expect(() => {\n      // This expectation should fail,\n      // Which is why it's wrapped in a .toThrow() block.\n      expect(() => 'foo').toCustomMatch('bar');\n    }).toThrow('Expected \"bar\" but got \"foo\"');\n  });\n\n  it('preserves error stack', () => {\n    const foo = () => bar();\n    const bar = () => baz();\n    const baz = () => {\n      // eslint-disable-next-line unicorn/throw-new-error,unicorn/new-for-builtins\n      throw Error('qux');\n    };\n\n    // This expectation fails due to an error we throw (intentionally)\n    // The stack trace should point to the line that throws the error though,\n    // Not to the line that calls the matcher.\n    expect(() => {\n      foo();\n    }).toCustomMatch('test');\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\n\nconst DIR = path.join(os.tmpdir(), 'jest-global-teardown');\n\ntest('should not exist teardown file', () => {\n  const files = fs.readdirSync(DIR);\n  expect(files).toHaveLength(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\n\nconst DIR = path.join(os.tmpdir(), 'jest-global-teardown');\n\ntest('should not exist teardown file', () => {\n  const files = fs.readdirSync(DIR);\n  expect(files).toHaveLength(0);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nconst fs = require('fs');\nconst os = require('os');\nconst path = require('path');\n\nconst DIR = path.join(os.tmpdir(), 'jest-global-teardown');\n\ntest('should not exist teardown file', () => {\n  const files = fs.readdirSync(DIR);\n  expect(files).toHaveLength(0);\n});"}
{"prompt":": jest.fn,","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {Global} from '@jest/types';\nimport each from '..';\n\nconst noop = () => {};\nconst expectFunction = expect.any(Function);\n\nconst get = <T>(\n  object: T,\n  lensPath: Array<string>,\n): ((...args: Array<unknown>) => unknown) =>\n  lensPath.reduce((acc, key) => acc[key], object);\n\nconst getGlobalTestMocks =\n  (): jest.MockedObject<Global.TestFrameworkGlobals> => {\n    const globals: any = {\n      describe: jest.fn(),\n      fdescribe: jest.fn(),\n      fit: jest.fn(),\n      it: jest.fn(),\n      test: jest.fn(),\n      xdescribe: jest.fn(),\n      xit: jest.fn(),\n      xtest: jest.fn(),\n    };\n    globals.test.only = jest.fn();\n    globals.test.skip = jest.fn();\n    globals.test.concurrent = jest.fn();\n    globals.test.concurrent.only = jest.fn();\n    globals.test.concurrent.skip = jest.fn();\n    globals.it.only = jest.fn();\n    globals.it.skip = jest.fn();\n    globals.describe.only = jest.fn();\n    globals.describe.skip = jest.fn();\n    return globals;\n  };\n\ndescribe('jest-each', () => {\n  for (const keyPath of [\n    ['test'],\n    ['test', 'concurrent'],\n    ['test', 'concurrent', 'only'],\n    ['test', 'concurrent', 'skip'],\n    ['test', 'only'],\n    ['it'],\n    ['fit'],\n    ['it', 'only'],\n    ['describe'],\n    ['fdescribe'],\n    ['describe', 'only'],\n  ]) {\n    describe(`.${keyPath.join('.')}`, () => {\n      test('throws error when there are additional words in first column heading', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a is the left | b    | expected\n          ${1}          | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('this will blow up :(', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          jest.mocked(globalMock).mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n        expect(testCallBack).not.toHaveBeenCalled();\n      });\n\n      test('does not throw error when there are multibyte characters in first column headings', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n         ʅ(ツ)ʃ  | b    | expected\n          ${1}          | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('accept multibyte characters', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() => jest.mocked(globalMock).mock.calls[0][1]()).not.toThrow();\n        expect(testCallBack).toHaveBeenCalledWith({\n          b: 1,\n          expected: 2,\n          'ʅ(ツ)ʃ': 1,\n        });\n      });\n\n      test('throws error when there are additional words in second column heading', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b is the right | expected\n          ${1}          | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('this will blow up :(', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          jest.mocked(globalMock).mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n        expect(testCallBack).not.toHaveBeenCalled();\n      });\n\n      test('does not throw error when there are multibyte characters in second column headings', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | ☝(ʕ⊙ḕ⊙ʔ)☝  | expected\n          ${1} | ${1}           | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('accept multibyte characters', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() => jest.mocked(globalMock).mock.calls[0][1]()).not.toThrow();\n        expect(testCallBack).toHaveBeenCalledWith({\n          a: 1,\n          expected: 2,\n          '☝(ʕ⊙ḕ⊙ʔ)☝': 1,\n        });\n      });\n\n      test('throws error when there are additional words in last column heading', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected value\n          ${1}          | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('this will blow up :(', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          jest.mocked(globalMock).mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n        expect(testCallBack).not.toHaveBeenCalled();\n      });\n\n      test('does not throw error when there are multibyte characters in last column headings', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | (๑ఠ‿ఠ๑)＜expected\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('accept multibyte characters', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() => jest.mocked(globalMock).mock.calls[0][1]()).not.toThrow();\n        expect(testCallBack).toHaveBeenCalledWith({\n          '(๑ఠ‿ఠ๑)＜expected': 2,\n          a: 1,\n          b: 1,\n        });\n      });\n\n      test('does not throw error when there is additional words in template after heading row', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          foo\n          bar\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('test title', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'test title',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('does not throw error when there is only one column', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a\n          ${1}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('test title', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'test title',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('does not throw error when there is only one column with additional words in template after heading', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a\n          hello world\n          ${1}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('test title $a', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'test title 1',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('throws error when there are no arguments for given headings', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('this will blow up :(', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          jest.mocked(globalMock).mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n        expect(testCallBack).not.toHaveBeenCalled();\n      });\n\n      test('throws error when there are fewer arguments than headings when given one row', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} |\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('this will blow up :(', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          jest.mocked(globalMock).mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n        expect(testCallBack).not.toHaveBeenCalled();\n      });\n\n      test('throws error when there are fewer arguments than headings over multiple rows', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} |\n        `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('this will blow up :(', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          jest.mocked(globalMock).mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n        expect(testCallBack).not.toHaveBeenCalled();\n      });\n\n      test('throws an error when called with an empty string', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`   `;\n        const testFunction = get(eachObject, keyPath);\n        const testCallBack = jest.fn();\n        testFunction('this will blow up :(', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        expect(() =>\n          jest.mocked(globalMock).mock.calls[0][1](),\n        ).toThrowErrorMatchingSnapshot();\n        expect(testCallBack).not.toHaveBeenCalled();\n      });\n\n      test('calls global with given title', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with given title when multiple tests cases exist', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using $variable format', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction(\n          'expected string: a=$a, b=$b, expected=$expected index=$#',\n          noop,\n        );\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: a=0, b=1, expected=1 index=0',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: a=1, b=1, expected=2 index=1',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing $key in multiple positions', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction(\n          'add($a, $b) expected string: a=$a, b=$b, expected=$expected index=$#',\n          noop,\n        );\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'add(0, 1) expected string: a=0, b=1, expected=1 index=0',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'add(1, 1) expected string: a=1, b=1, expected=2 index=1',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing $key.path', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a\n          ${{foo: {bar: 'baz'}}}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('interpolates object keyPath to value: $a.foo.bar', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'interpolates object keyPath to value: baz',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test.each([null, undefined])(\n        'calls global with title containing $key.path for %s',\n        value => {\n          const globalTestMocks = getGlobalTestMocks();\n          const eachObject = each.withGlobal(globalTestMocks)`\n          a\n          ${{foo: value}}\n        `;\n          const testFunction = get(eachObject, keyPath);\n          testFunction(\n            'interpolates object keyPath to value: $a.foo.bar',\n            noop,\n          );\n\n          const globalMock = get(globalTestMocks, keyPath);\n          expect(globalMock).toHaveBeenCalledTimes(1);\n          expect(globalMock).toHaveBeenCalledWith(\n            `interpolates object keyPath to value: ${value}`,\n            expectFunction,\n            undefined,\n          );\n        },\n      );\n\n      test('calls global with title containing last seen object when $key.path is invalid', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a\n          ${{foo: {bar: 'baz'}}}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('interpolates object keyPath to value: $a.foo.qux', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'interpolates object keyPath to value: {\"bar\": \"baz\"}',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with cb function with object built from table headings and values', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const testCallBack = jest.fn();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', testCallBack);\n\n        const globalMock = get(globalTestMocks, keyPath);\n\n        jest.mocked(globalMock).mock.calls[0][1]();\n        expect(testCallBack).toHaveBeenCalledTimes(1);\n        expect(testCallBack).toHaveBeenCalledWith({a: 0, b: 1, expected: 1});\n\n        jest.mocked(globalMock).mock.calls[1][1]();\n        expect(testCallBack).toHaveBeenCalledTimes(2);\n        expect(testCallBack).toHaveBeenCalledWith({a: 1, b: 1, expected: 2});\n      });\n\n      test('calls global with given timeout', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n        `;\n\n        const testFunction = get(eachObject, keyPath);\n        testFunction('some test', noop, 10_000);\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledWith(\n          'some test',\n          expect.any(Function),\n          10_000,\n        );\n      });\n\n      test('formats primitive values using .toString()', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const number = 1;\n        const string = 'hello';\n        const boolean = true;\n        const symbol = Symbol('world');\n        const nullValue = null;\n        const undefinedValue = undefined;\n        const eachObject = each.withGlobal(globalTestMocks)`\n          number | string | boolean | symbol | nullValue | undefinedValue\n          ${number} | ${string} | ${boolean} | ${symbol} | ${nullValue} | ${undefinedValue}\n        `;\n\n        const testFunction = get(eachObject, keyPath);\n        testFunction(\n          'number: $number | string: $string | boolean: $boolean | symbol: $symbol | null: $nullValue | undefined: $undefinedValue',\n          noop,\n        );\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledWith(\n          'number: 1 | string: hello | boolean: true | symbol: Symbol(world) | null: null | undefined: undefined',\n          expect.any(Function),\n          undefined,\n        );\n      });\n    });\n  }\n\n  describe('done callback', () => {\n    test.each([\n      [['test']],\n      [['test', 'only']],\n      [['test', 'concurrent', 'only']],\n      [['it']],\n      [['fit']],\n      [['it', 'only']],\n    ])(\n      'calls %O with done when cb function has more args than params of given test row',\n      keyPath => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n        a    | b    | expected\n        ${0} | ${1} | ${1}\n      `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', ({a, b, expected}, done) => {\n          expect(a).toBe(0);\n          expect(b).toBe(1);\n          expect(expected).toBe(1);\n          expect(done).toBe('DONE');\n        });\n        get(globalTestMocks, keyPath).mock.calls[0][1]('DONE');\n      },\n    );\n\n    test.each([[['describe']], [['fdescribe']], [['describe', 'only']]])(\n      'does not call %O with done when test function has more args than params of given test row',\n      keyPath => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n        a    | b    | expected\n        ${0} | ${1} | ${1}\n      `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', function ({a, b, expected}, done) {\n          expect(a).toBe(0);\n          expect(b).toBe(1);\n          expect(expected).toBe(1);\n          expect(done).toBeUndefined();\n          // eslint-disable-next-line prefer-rest-params\n          expect(arguments).toHaveLength(1);\n        });\n        get(globalTestMocks, keyPath).mock.calls[0][1]('DONE');\n      },\n    );\n  });\n\n  for (const keyPath of [\n    ['xtest'],\n    ['test', 'skip'],\n    ['test', 'concurrent'],\n    ['test', 'concurrent', 'skip'],\n    ['xit'],\n    ['it', 'skip'],\n    ['xdescribe'],\n    ['describe', 'skip'],\n  ]) {\n    describe(`.${keyPath.join('.')}`, () => {\n      test('calls global with given title', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(1);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with given title when multiple tests cases exist', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction('expected string', noop);\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using $variable format', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction(\n          'expected string: a=$a, b=$b, expected=$expected index=$#',\n          noop,\n        );\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: a=0, b=1, expected=1 index=0',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: a=1, b=1, expected=2 index=1',\n          expectFunction,\n          undefined,\n        );\n      });\n\n      test('calls global with title containing param values when using fake $variable', () => {\n        const globalTestMocks = getGlobalTestMocks();\n        const eachObject = each.withGlobal(globalTestMocks)`\n          a    | b    | expected\n          ${0} | ${1} | ${1}\n          ${1} | ${1} | ${2}\n        `;\n        const testFunction = get(eachObject, keyPath);\n        testFunction(\n          'expected string: a=$a, b=$b, b=$b, b=$b.b, b=$fake, expected=$expected index=$#',\n          noop,\n        );\n\n        const globalMock = get(globalTestMocks, keyPath);\n        expect(globalMock).toHaveBeenCalledTimes(2);\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: a=0, b=1, b=1, b=1, b=$fake, expected=1 index=0',\n          expectFunction,\n          undefined,\n        );\n        expect(globalMock).toHaveBeenCalledWith(\n          'expected string: a=1, b=1, b=1, b=1, b=$fake, expected=2 index=1',\n          expectFunction,\n          undefined,\n        );\n      });\n    });\n  }\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`jest-each .describe throws an error when called with an empty string 1`] = `\n\"Error: \\`.each\\` called with an empty Tagged Template Literal of table data.\n\"\n`;\n\nexports[`jest-each .describe throws error when there are additional words in first column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a is the left | b    | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .describe throws error when there are additional words in last column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b    | expected value</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .describe throws error when there are additional words in second column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b is the right | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .describe throws error when there are fewer arguments than headings over multiple rows 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .describe throws error when there are fewer arguments than headings when given one row 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .describe throws error when there are no arguments for given headings 1`] = `\n\"Error: \\`.each\\` called with a Tagged Template Literal with no data, remember to interpolate with \\${expression} syntax.\n\"\n`;\n\nexports[`jest-each .describe.only throws an error when called with an empty string 1`] = `\n\"Error: \\`.each\\` called with an empty Tagged Template Literal of table data.\n\"\n`;\n\nexports[`jest-each .describe.only throws error when there are additional words in first column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a is the left | b    | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .describe.only throws error when there are additional words in last column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b    | expected value</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .describe.only throws error when there are additional words in second column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b is the right | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .describe.only throws error when there are fewer arguments than headings over multiple rows 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .describe.only throws error when there are fewer arguments than headings when given one row 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .describe.only throws error when there are no arguments for given headings 1`] = `\n\"Error: \\`.each\\` called with a Tagged Template Literal with no data, remember to interpolate with \\${expression} syntax.\n\"\n`;\n\nexports[`jest-each .fdescribe throws an error when called with an empty string 1`] = `\n\"Error: \\`.each\\` called with an empty Tagged Template Literal of table data.\n\"\n`;\n\nexports[`jest-each .fdescribe throws error when there are additional words in first column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a is the left | b    | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .fdescribe throws error when there are additional words in last column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b    | expected value</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .fdescribe throws error when there are additional words in second column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b is the right | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .fdescribe throws error when there are fewer arguments than headings over multiple rows 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .fdescribe throws error when there are fewer arguments than headings when given one row 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .fdescribe throws error when there are no arguments for given headings 1`] = `\n\"Error: \\`.each\\` called with a Tagged Template Literal with no data, remember to interpolate with \\${expression} syntax.\n\"\n`;\n\nexports[`jest-each .fit throws an error when called with an empty string 1`] = `\n\"Error: \\`.each\\` called with an empty Tagged Template Literal of table data.\n\"\n`;\n\nexports[`jest-each .fit throws error when there are additional words in first column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a is the left | b    | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .fit throws error when there are additional words in last column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b    | expected value</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .fit throws error when there are additional words in second column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b is the right | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .fit throws error when there are fewer arguments than headings over multiple rows 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .fit throws error when there are fewer arguments than headings when given one row 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .fit throws error when there are no arguments for given headings 1`] = `\n\"Error: \\`.each\\` called with a Tagged Template Literal with no data, remember to interpolate with \\${expression} syntax.\n\"\n`;\n\nexports[`jest-each .it throws an error when called with an empty string 1`] = `\n\"Error: \\`.each\\` called with an empty Tagged Template Literal of table data.\n\"\n`;\n\nexports[`jest-each .it throws error when there are additional words in first column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a is the left | b    | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .it throws error when there are additional words in last column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b    | expected value</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .it throws error when there are additional words in second column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b is the right | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .it throws error when there are fewer arguments than headings over multiple rows 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .it throws error when there are fewer arguments than headings when given one row 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .it throws error when there are no arguments for given headings 1`] = `\n\"Error: \\`.each\\` called with a Tagged Template Literal with no data, remember to interpolate with \\${expression} syntax.\n\"\n`;\n\nexports[`jest-each .it.only throws an error when called with an empty string 1`] = `\n\"Error: \\`.each\\` called with an empty Tagged Template Literal of table data.\n\"\n`;\n\nexports[`jest-each .it.only throws error when there are additional words in first column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a is the left | b    | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .it.only throws error when there are additional words in last column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b    | expected value</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .it.only throws error when there are additional words in second column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b is the right | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .it.only throws error when there are fewer arguments than headings over multiple rows 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .it.only throws error when there are fewer arguments than headings when given one row 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .it.only throws error when there are no arguments for given headings 1`] = `\n\"Error: \\`.each\\` called with a Tagged Template Literal with no data, remember to interpolate with \\${expression} syntax.\n\"\n`;\n\nexports[`jest-each .test throws an error when called with an empty string 1`] = `\n\"Error: \\`.each\\` called with an empty Tagged Template Literal of table data.\n\"\n`;\n\nexports[`jest-each .test throws error when there are additional words in first column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a is the left | b    | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test throws error when there are additional words in last column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b    | expected value</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test throws error when there are additional words in second column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b is the right | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test throws error when there are fewer arguments than headings over multiple rows 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .test throws error when there are fewer arguments than headings when given one row 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .test throws error when there are no arguments for given headings 1`] = `\n\"Error: \\`.each\\` called with a Tagged Template Literal with no data, remember to interpolate with \\${expression} syntax.\n\"\n`;\n\nexports[`jest-each .test.concurrent throws an error when called with an empty string 1`] = `\n\"Error: \\`.each\\` called with an empty Tagged Template Literal of table data.\n\"\n`;\n\nexports[`jest-each .test.concurrent throws error when there are additional words in first column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a is the left | b    | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test.concurrent throws error when there are additional words in last column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b    | expected value</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test.concurrent throws error when there are additional words in second column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b is the right | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test.concurrent throws error when there are fewer arguments than headings over multiple rows 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .test.concurrent throws error when there are fewer arguments than headings when given one row 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .test.concurrent throws error when there are no arguments for given headings 1`] = `\n\"Error: \\`.each\\` called with a Tagged Template Literal with no data, remember to interpolate with \\${expression} syntax.\n\"\n`;\n\nexports[`jest-each .test.concurrent.only throws an error when called with an empty string 1`] = `\n\"Error: \\`.each\\` called with an empty Tagged Template Literal of table data.\n\"\n`;\n\nexports[`jest-each .test.concurrent.only throws error when there are additional words in first column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a is the left | b    | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test.concurrent.only throws error when there are additional words in last column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b    | expected value</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test.concurrent.only throws error when there are additional words in second column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b is the right | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test.concurrent.only throws error when there are fewer arguments than headings over multiple rows 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .test.concurrent.only throws error when there are fewer arguments than headings when given one row 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .test.concurrent.only throws error when there are no arguments for given headings 1`] = `\n\"Error: \\`.each\\` called with a Tagged Template Literal with no data, remember to interpolate with \\${expression} syntax.\n\"\n`;\n\nexports[`jest-each .test.concurrent.skip throws an error when called with an empty string 1`] = `\n\"Error: \\`.each\\` called with an empty Tagged Template Literal of table data.\n\"\n`;\n\nexports[`jest-each .test.concurrent.skip throws error when there are additional words in first column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a is the left | b    | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test.concurrent.skip throws error when there are additional words in last column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b    | expected value</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test.concurrent.skip throws error when there are additional words in second column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b is the right | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test.concurrent.skip throws error when there are fewer arguments than headings over multiple rows 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .test.concurrent.skip throws error when there are fewer arguments than headings when given one row 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .test.concurrent.skip throws error when there are no arguments for given headings 1`] = `\n\"Error: \\`.each\\` called with a Tagged Template Literal with no data, remember to interpolate with \\${expression} syntax.\n\"\n`;\n\nexports[`jest-each .test.only throws an error when called with an empty string 1`] = `\n\"Error: \\`.each\\` called with an empty Tagged Template Literal of table data.\n\"\n`;\n\nexports[`jest-each .test.only throws error when there are additional words in first column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a is the left | b    | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test.only throws error when there are additional words in last column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b    | expected value</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test.only throws error when there are additional words in second column heading 1`] = `\n\"Table headings do not conform to expected format:\n\n<green>heading1 | headingN</color>\n\nReceived:\n\n<red>\"</color>\n<red>          a    | b is the right | expected</color>\n<red>          \"</color>\"\n`;\n\nexports[`jest-each .test.only throws error when there are fewer arguments than headings over multiple rows 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .test.only throws error when there are fewer arguments than headings when given one row 1`] = `\n\"Not enough arguments supplied for given headings:\n<green>a | b | expected</color>\n\nReceived:\n<red>Array [</color>\n<red>  0,</color>\n<red>  1,</color>\n<red>]</color>\n\nMissing <red>1</color> argument\"\n`;\n\nexports[`jest-each .test.only throws error when there are no arguments for given headings 1`] = `\n\"Error: \\`.each\\` called with a Tagged Template Literal with no data, remember to interpolate with \\${expression} syntax.\n\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('cjs extension', () => {\n  expect(1).toBe(1);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('cts extension', () => {\n  expect(1).toBe(1);\n});"}
{"prompt":"test.foobar","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// test.foobar\n\nrequire('../module.foobar');"}
{"prompt":"test.js","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// test.js\n\nrequire('../module.jsx');"}
{"prompt":"test.jsx","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// test.jsx\n\nrequire('../module.jsx');"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('mjs extension', () => {\n  expect(1).toBe(1);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('mts extension', () => {\n  expect(1).toBe(1);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('js extension', () => {\n  expect(1).toBe(1);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('ts extension', () => {\n  expect(1).toBe(1);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('tsx extension', () => {\n  expect(1).toBe(1);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('basic test', () => {\n  expect(true).toBeTruthy();\n});"}
{"prompt":"test,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ndescribe('test', () => {\n  it('has predefined global variable', () => {\n    expect(globalThis.definedInSetupFile).toBe(true);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('basic test', () => {\n  expect(true).toBeTruthy();\n});"}
{"prompt":"test,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ndescribe('test', () => {\n  it('has predefined global variable', () => {\n    expect(globalThis.definedInSetupFile).toBe(true);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('basic test', () => {\n  expect(true).toBeTruthy();\n});"}
{"prompt":"test,  => {};","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nit('test', () => {});"}
{"prompt":"test,  => {};","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nit('test', () => {});"}
{"prompt":"test,  => {};","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nit('test', () => {});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {SuperTestClass} from './SuperTestClass';\n\nexport default class TestClass extends SuperTestClass {}"}
{"prompt":"respects testEnvironment docblock,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {json as runWithJson} from '../runJest';\nimport * as testFixturePackage from '../test-environment/package.json';\n\nit('respects testEnvironment docblock', () => {\n  expect(testFixturePackage.jest.testEnvironment).toBe('node');\n\n  const {json: result} = runWithJson('test-environment');\n\n  expect(result.success).toBe(true);\n  expect(result.numTotalTests).toBe(4);\n});"}
{"prompt":"triggers setup/teardown hooks,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {cleanup} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = `${tmpdir()}/jest-test-environment`;\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\nit('triggers setup/teardown hooks', () => {\n  const testDir = path.resolve(\n    __dirname,\n    '..',\n    'test-environment-async',\n    '__tests__',\n  );\n  const testFile = path.join(testDir, 'custom.test.js');\n\n  const result = runJest('test-environment-async');\n  expect(result.exitCode).toBe(0);\n  expect(result.stdout).toContain(`TestEnvironment.setup: ${testFile}`);\n\n  const teardown = fs.readFileSync(`${DIR}/teardown`, 'utf8');\n  expect(teardown).toBe('teardown');\n});"}
{"prompt":"calls testEnvironment handleTestEvent,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJasmine();\n\nit('calls testEnvironment handleTestEvent', () => {\n  const result = runJest('test-environment-circus');\n  expect(result.failed).toBe(false);\n  expect(result.stdout.split('\\n')).toMatchInlineSnapshot(`\n    Array [\n      \"setup\",\n      \"add_hook\",\n      \"add_hook\",\n      \"add_test\",\n      \"add_test\",\n      \"run_start\",\n      \"run_describe_start\",\n      \"test_start: test name here\",\n      \"test_started: test name here\",\n      \"hook_start\",\n      \"hook_success: test name here\",\n      \"hook_start\",\n      \"hook_success: test name here\",\n      \"test_fn_start: test name here\",\n      \"test_fn_success: test name here\",\n      \"test_done: test name here\",\n      \"test_start: second test name here\",\n      \"test_started: second test name here\",\n      \"hook_start\",\n      \"hook_success: second test name here\",\n      \"hook_start\",\n      \"hook_success: second test name here\",\n      \"test_fn_start: second test name here\",\n      \"test_fn_success: second test name here\",\n      \"test_done: second test name here\",\n      \"run_describe_finish\",\n      \"run_finish\",\n      \"teardown\",\n    ]\n  `);\n});"}
{"prompt":"calls asynchronous handleTestEvent in testEnvironment,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJasmine();\n\nit('calls asynchronous handleTestEvent in testEnvironment', () => {\n  const result = runJest('test-environment-circus-async');\n  expect(result.failed).toBe(true);\n\n  const lines = result.stdout.split('\\n');\n  expect(lines).toMatchInlineSnapshot(`\n    Array [\n      \"setup\",\n      \"warning: add_hook is a sync event\",\n      \"warning: start_describe_definition is a sync event\",\n      \"warning: add_hook is a sync event\",\n      \"warning: add_hook is a sync event\",\n      \"warning: add_test is a sync event\",\n      \"warning: add_test is a sync event\",\n      \"warning: finish_describe_definition is a sync event\",\n      \"add_hook\",\n      \"start_describe_definition\",\n      \"add_hook\",\n      \"add_hook\",\n      \"add_test\",\n      \"add_test\",\n      \"finish_describe_definition\",\n      \"run_start\",\n      \"run_describe_start\",\n      \"run_describe_start\",\n      \"test_start: passing test\",\n      \"test_started: passing test\",\n      \"hook_start: beforeEach\",\n      \"hook_success: beforeEach\",\n      \"hook_start: beforeEach\",\n      \"hook_success: beforeEach\",\n      \"test_fn_start: passing test\",\n      \"test_fn_success: passing test\",\n      \"hook_start: afterEach\",\n      \"hook_failure: afterEach\",\n      \"test_done: passing test\",\n      \"test_start: failing test\",\n      \"test_started: failing test\",\n      \"hook_start: beforeEach\",\n      \"hook_success: beforeEach\",\n      \"hook_start: beforeEach\",\n      \"hook_success: beforeEach\",\n      \"test_fn_start: failing test\",\n      \"test_fn_failure: failing test\",\n      \"hook_start: afterEach\",\n      \"hook_failure: afterEach\",\n      \"test_done: failing test\",\n      \"run_describe_finish\",\n      \"run_describe_finish\",\n      \"run_finish\",\n      \"teardown\",\n    ]\n  `);\n});"}
{"prompt":"support test environment written in ESM,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {resolve} from 'path';\nimport runJest from '../runJest';\n\nit('support test environment written in ESM', () => {\n  const DIR = resolve(__dirname, '../test-environment-esm');\n  const {exitCode} = runJest(DIR);\n\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"throw error if test env does not have getVmContext,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {resolve, sep} from 'path';\nimport runJest from '../runJest';\n\nit('throw error if test env does not have getVmContext', () => {\n  const DIR = resolve(__dirname, '../test-environment-run-script');\n  const {exitCode, stderr} = runJest(DIR);\n\n  expect(stderr.replace(`${DIR}${sep}`, '<rootDir>/')).toMatchSnapshot();\n  expect(exitCode).toBe(1);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`throw error if test env does not have getVmContext 1`] = `\"Test environment found at \"<rootDir>/EnvUsingRunScript.js\" does not export a \"getVmContext\" method, which is mandatory from Jest 27. This method is a replacement for \"runScript\".\"`;"}
{"prompt":"error stack trace,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ndescribe('error stack trace', () => {\n  it('fails', () => {\n    throw new Error('this is unexpected.');\n  });\n\n  it('fails strings', () => {\n    // eslint-disable-next-line no-throw-literal\n    throw 'this is a string.';\n  });\n\n  it('tests', () => {\n    jest.unmock('this-module-does-not-exist');\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport {extractSummary} from '../Utils';\nimport runJest, {json as runWithJson} from '../runJest';\n\nskipSuiteOnJasmine();\n\nconst dir = path.resolve(__dirname, '../test-failing');\n\ntest('works with all statuses', () => {\n  const result = runJest(dir, ['statuses.test.js']);\n  expect(result.exitCode).toBe(1);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('works with only mode', () => {\n  const result = runJest(dir, ['worksWithOnlyMode.test.js']);\n  expect(result.exitCode).toBe(1);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('works with skip mode', () => {\n  const result = runJest(dir, ['worksWithSkipMode.test.js']);\n  expect(result.exitCode).toBe(1);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('works with concurrent mode', () => {\n  const result = runWithJson(dir, ['worksWithConcurrentMode.test.js']);\n  expect(result.exitCode).toBe(1);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('works with concurrent and only mode', () => {\n  const result = runWithJson(dir, ['worksWithConcurrentOnlyMode.test.js']);\n  expect(result.exitCode).toBe(1);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`works with all statuses 1`] = `\n\"FAIL __tests__/statuses.test.js\n  ✓ passes\n  ✕ fails\n  ✓ failing fails = passes\n  ✓ failing fails = passes with test syntax\n  ✕ .add(1, 1)\n  ✕ .add(1, 2)\n  ✕ .add(2, 1)\n  ✕ failing passes = fails\n  ○ skipped skips\n  ○ skipped skipped failing 1\n  ○ skipped skipped failing 2\n  ○ skipped skipped failing with different syntax\n  ○ skipped skipped failing with another different syntax\n  ✎ todo todo\n\n  ● fails\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 101\n    Received: 10\n\n      11 |\n      12 | it('fails', () => {\n    > 13 |   expect(10).toBe(101);\n         |              ^\n      14 | });\n      15 |\n      16 | it.skip('skips', () => {\n\n      at Object.toBe (__tests__/statuses.test.js:13:14)\n\n  ● .add(1, 1)\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      28 | });\n      29 |\n    > 30 | test.failing.each([\n         |              ^\n      31 |   {a: 1, b: 1, expected: 2},\n      32 |   {a: 1, b: 2, expected: 3},\n      33 |   {a: 2, b: 1, expected: 3},\n\n      at Object.each (__tests__/statuses.test.js:30:14)\n\n  ● .add(1, 2)\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      28 | });\n      29 |\n    > 30 | test.failing.each([\n         |              ^\n      31 |   {a: 1, b: 1, expected: 2},\n      32 |   {a: 1, b: 2, expected: 3},\n      33 |   {a: 2, b: 1, expected: 3},\n\n      at Object.each (__tests__/statuses.test.js:30:14)\n\n  ● .add(2, 1)\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      28 | });\n      29 |\n    > 30 | test.failing.each([\n         |              ^\n      31 |   {a: 1, b: 1, expected: 2},\n      32 |   {a: 1, b: 2, expected: 3},\n      33 |   {a: 2, b: 1, expected: 3},\n\n      at Object.each (__tests__/statuses.test.js:30:14)\n\n  ● failing passes = fails\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      44 | });\n      45 |\n    > 46 | it.failing('failing passes = fails', () => {\n         |    ^\n      47 |   expect(10).toBe(10);\n      48 | });\n      49 |\n\n      at Object.failing (__tests__/statuses.test.js:46:4)\"\n`;\n\nexports[`works with concurrent and only mode 1`] = `\n\"FAIL __tests__/worksWithConcurrentOnlyMode.test.js\n  block with concurrent\n    ✕ .only.failing() should fail\n    ✓ .only.failing() should pass\n    ✕ .add(1, 1) .only.failing.each() should fail\n    ✕ .add(1, 2) .only.failing.each() should fail\n    ✕ .add(2, 1) .only.failing.each() should fail\n    ✓ .add(1, 1) .only.failing.each() should pass\n    ✓ .add(1, 2) .only.failing.each() should pass\n    ✓ .add(2, 1) .only.failing.each() should pass\n    ○ skipped skipped failing test\n    ○ skipped .add(1, 1) skipped each\n    ○ skipped .add(1, 2) skipped each\n    ○ skipped .add(2, 1) skipped each\n    ○ skipped skipped failing fails\n\n  ● block with concurrent › .only.failing() should fail\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      11 |   });\n      12 |\n    > 13 |   it.concurrent.only.failing('.only.failing() should fail', () => {\n         |                      ^\n      14 |     expect(10).toBe(10);\n      15 |   });\n      16 |\n\n      at failing (__tests__/worksWithConcurrentOnlyMode.test.js:13:22)\n      at Object.describe (__tests__/worksWithConcurrentOnlyMode.test.js:8:1)\n\n  ● block with concurrent › .add(1, 1) .only.failing.each() should fail\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      19 |   });\n      20 |\n    > 21 |   test.concurrent.only.failing.each([\n         |                                ^\n      22 |     {a: 1, b: 1, expected: 2},\n      23 |     {a: 1, b: 2, expected: 3},\n      24 |     {a: 2, b: 1, expected: 3},\n\n      at each (__tests__/worksWithConcurrentOnlyMode.test.js:21:32)\n      at Object.describe (__tests__/worksWithConcurrentOnlyMode.test.js:8:1)\n\n  ● block with concurrent › .add(1, 2) .only.failing.each() should fail\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      19 |   });\n      20 |\n    > 21 |   test.concurrent.only.failing.each([\n         |                                ^\n      22 |     {a: 1, b: 1, expected: 2},\n      23 |     {a: 1, b: 2, expected: 3},\n      24 |     {a: 2, b: 1, expected: 3},\n\n      at each (__tests__/worksWithConcurrentOnlyMode.test.js:21:32)\n      at Object.describe (__tests__/worksWithConcurrentOnlyMode.test.js:8:1)\n\n  ● block with concurrent › .add(2, 1) .only.failing.each() should fail\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      19 |   });\n      20 |\n    > 21 |   test.concurrent.only.failing.each([\n         |                                ^\n      22 |     {a: 1, b: 1, expected: 2},\n      23 |     {a: 1, b: 2, expected: 3},\n      24 |     {a: 2, b: 1, expected: 3},\n\n      at each (__tests__/worksWithConcurrentOnlyMode.test.js:21:32)\n      at Object.describe (__tests__/worksWithConcurrentOnlyMode.test.js:8:1)\"\n`;\n\nexports[`works with concurrent mode 1`] = `\n\"FAIL __tests__/worksWithConcurrentMode.test.js\n  block with concurrent\n    ✕ test should fail\n    ✕ .failing() should fail\n    ✓ .failing() should pass\n    ✕ .add(1, 1) .failing.each() should fail\n    ✕ .add(1, 2) .failing.each() should fail\n    ✕ .add(2, 1) .failing.each() should fail\n    ✓ .add(1, 1) .failing.each() should pass\n    ✓ .add(1, 2) .failing.each() should pass\n    ✓ .add(2, 1) .failing.each() should pass\n    ○ skipped skipped failing fails\n\n  ● block with concurrent › test should fail\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 101\n    Received: 10\n\n       8 | describe('block with concurrent', () => {\n       9 |   it('test should fail', () => {\n    > 10 |     expect(10).toBe(101);\n         |                ^\n      11 |   });\n      12 |\n      13 |   it.concurrent.failing('.failing() should fail', () => {\n\n      at Object.toBe (__tests__/worksWithConcurrentMode.test.js:10:16)\n\n  ● block with concurrent › .failing() should fail\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      11 |   });\n      12 |\n    > 13 |   it.concurrent.failing('.failing() should fail', () => {\n         |                 ^\n      14 |     expect(10).toBe(10);\n      15 |   });\n      16 |\n\n      at failing (__tests__/worksWithConcurrentMode.test.js:13:17)\n      at Object.describe (__tests__/worksWithConcurrentMode.test.js:8:1)\n\n  ● block with concurrent › .add(1, 1) .failing.each() should fail\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      19 |   });\n      20 |\n    > 21 |   test.concurrent.failing.each([\n         |                           ^\n      22 |     {a: 1, b: 1, expected: 2},\n      23 |     {a: 1, b: 2, expected: 3},\n      24 |     {a: 2, b: 1, expected: 3},\n\n      at each (__tests__/worksWithConcurrentMode.test.js:21:27)\n      at Object.describe (__tests__/worksWithConcurrentMode.test.js:8:1)\n\n  ● block with concurrent › .add(1, 2) .failing.each() should fail\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      19 |   });\n      20 |\n    > 21 |   test.concurrent.failing.each([\n         |                           ^\n      22 |     {a: 1, b: 1, expected: 2},\n      23 |     {a: 1, b: 2, expected: 3},\n      24 |     {a: 2, b: 1, expected: 3},\n\n      at each (__tests__/worksWithConcurrentMode.test.js:21:27)\n      at Object.describe (__tests__/worksWithConcurrentMode.test.js:8:1)\n\n  ● block with concurrent › .add(2, 1) .failing.each() should fail\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      19 |   });\n      20 |\n    > 21 |   test.concurrent.failing.each([\n         |                           ^\n      22 |     {a: 1, b: 1, expected: 2},\n      23 |     {a: 1, b: 2, expected: 3},\n      24 |     {a: 2, b: 1, expected: 3},\n\n      at each (__tests__/worksWithConcurrentMode.test.js:21:27)\n      at Object.describe (__tests__/worksWithConcurrentMode.test.js:8:1)\"\n`;\n\nexports[`works with only mode 1`] = `\n\"FAIL __tests__/worksWithOnlyMode.test.js\n  block with only, should pass\n    ✓ failing fails = passes, should pass\n    ✕ .add(1, 1)\n    ✕ .add(1, 2)\n    ✕ .add(2, 1)\n    ○ skipped failing test but skipped\n    ○ skipped passing test but skipped\n  block with only, should fail\n    ✕ failing passes = fails, should fail\n    ○ skipped failing test but skipped\n    ○ skipped passing test but skipped\n  block with only in other it, should skip\n    ✕ failing test\n    ○ skipped failing passes = fails, should fail but skipped\n    ○ skipped passing test but skipped\n  block with only with different syntax, should fail\n    ✕ failing passes = fails, should fail 1\n    ✕ failing passes = fails, should fail 2\n    ○ skipped failing test but skipped\n    ○ skipped passing test but skipped\n\n  ● block with only, should pass › .add(1, 1)\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      13 |   });\n      14 |\n    > 15 |   it.only.failing.each([\n         |                   ^\n      16 |     {a: 1, b: 1, expected: 2},\n      17 |     {a: 1, b: 2, expected: 3},\n      18 |     {a: 2, b: 1, expected: 3},\n\n      at each (__tests__/worksWithOnlyMode.test.js:15:19)\n      at Object.describe (__tests__/worksWithOnlyMode.test.js:10:1)\n\n  ● block with only, should pass › .add(1, 2)\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      13 |   });\n      14 |\n    > 15 |   it.only.failing.each([\n         |                   ^\n      16 |     {a: 1, b: 1, expected: 2},\n      17 |     {a: 1, b: 2, expected: 3},\n      18 |     {a: 2, b: 1, expected: 3},\n\n      at each (__tests__/worksWithOnlyMode.test.js:15:19)\n      at Object.describe (__tests__/worksWithOnlyMode.test.js:10:1)\n\n  ● block with only, should pass › .add(2, 1)\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      13 |   });\n      14 |\n    > 15 |   it.only.failing.each([\n         |                   ^\n      16 |     {a: 1, b: 1, expected: 2},\n      17 |     {a: 1, b: 2, expected: 3},\n      18 |     {a: 2, b: 1, expected: 3},\n\n      at each (__tests__/worksWithOnlyMode.test.js:15:19)\n      at Object.describe (__tests__/worksWithOnlyMode.test.js:10:1)\n\n  ● block with only, should fail › failing passes = fails, should fail\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      31 |\n      32 | describe('block with only, should fail', () => {\n    > 33 |   it.only.failing('failing passes = fails, should fail', () => {\n         |           ^\n      34 |     expect(10).toBe(10);\n      35 |   });\n      36 |\n\n      at failing (__tests__/worksWithOnlyMode.test.js:33:11)\n      at Object.describe (__tests__/worksWithOnlyMode.test.js:32:1)\n\n  ● block with only in other it, should skip › failing test\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 101\n    Received: 10\n\n      50 |\n      51 |   it.only('failing test', () => {\n    > 52 |     expect(10).toBe(101);\n         |                ^\n      53 |   });\n      54 |\n      55 |   it('passing test but skipped', () => {\n\n      at Object.toBe (__tests__/worksWithOnlyMode.test.js:52:16)\n\n  ● block with only with different syntax, should fail › failing passes = fails, should fail 1\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      59 |\n      60 | describe('block with only with different syntax, should fail', () => {\n    > 61 |   fit.failing('failing passes = fails, should fail 1', () => {\n         |       ^\n      62 |     expect(10).toBe(10);\n      63 |   });\n      64 |\n\n      at failing (__tests__/worksWithOnlyMode.test.js:61:7)\n      at Object.describe (__tests__/worksWithOnlyMode.test.js:60:1)\n\n  ● block with only with different syntax, should fail › failing passes = fails, should fail 2\n\n    Failing test passed even though it was supposed to fail. Remove \\`.failing\\` to remove error.\n\n      63 |   });\n      64 |\n    > 65 |   test.only.failing('failing passes = fails, should fail 2', () => {\n         |             ^\n      66 |     expect(10).toBe(10);\n      67 |   });\n      68 |\n\n      at failing (__tests__/worksWithOnlyMode.test.js:65:13)\n      at Object.describe (__tests__/worksWithOnlyMode.test.js:60:1)\"\n`;\n\nexports[`works with skip mode 1`] = `\n\"FAIL __tests__/worksWithSkipMode.test.js\n  block with only, should pass\n    ✕ failing test\n    ✓ failing fails = passes\n    ○ skipped skipped failing fails = passes, should pass\n    ○ skipped .add(1, 1)\n    ○ skipped .add(1, 2)\n    ○ skipped .add(2, 1)\n    ○ skipped passing test\n  block with only, should fail\n    ✓ passing test\n    ✓ failing passes = fails\n    ○ skipped failing passes = fails, should fail\n    ○ skipped failing test\n\n  ● block with only, should pass › failing test\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 101\n    Received: 10\n\n      20 |\n      21 |   it('failing test', () => {\n    > 22 |     expect(10).toBe(101);\n         |                ^\n      23 |   });\n      24 |\n      25 |   it.skip('passing test', () => {\n\n      at Object.toBe (__tests__/worksWithSkipMode.test.js:22:16)\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {skipSuiteOnJestCircus} from '@jest/test-utils';\nimport {extractSortedSummary} from '../Utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJestCircus();\n\nconst dir = path.resolve(__dirname, '../test-failing');\n\ntest('throws an error about unsupported modifier', () => {\n  const result = runJest(dir);\n  expect(result.exitCode).toBe(1);\n  const {rest} = extractSortedSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`throws an error about unsupported modifier 1`] = `\n\"FAIL __tests__/statuses.test.js\n  ● Test suite failed to run\n\n    Jest: \\`failing\\` tests are only supported in \\`jest-circus\\`.\n\n      20 | it.todo('todo');\n      21 |\n    > 22 | it.failing('failing fails = passes', () => {\n         |    ^\n      23 |   expect(10).toBe(101);\n      24 | });\n      25 |\n\n      at Object.failing (__tests__/statuses.test.js:22:4)\n\nFAIL __tests__/worksWithConcurrentMode.test.js\n  ● block with concurrent › test should fail\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 101\n    Received: 10\n\n       8 | describe('block with concurrent', () => {\n       9 |   it('test should fail', () => {\n    > 10 |     expect(10).toBe(101);\n         |                ^\n      11 |   });\n      12 |\n      13 |   it.concurrent.failing('.failing() should fail', () => {\n\n      at Object.toBe (__tests__/worksWithConcurrentMode.test.js:10:16)\n\n  ● block with concurrent › encountered a declaration exception\n\n    Jest: \\`failing\\` tests are only supported in \\`jest-circus\\`.\n\n      11 |   });\n      12 |\n    > 13 |   it.concurrent.failing('.failing() should fail', () => {\n         |                 ^\n      14 |     expect(10).toBe(10);\n      15 |   });\n      16 |\n\n      at Function.failing (../../packages/jest-jasmine2/build/index.js:311:17)\n      at Suite.failing (__tests__/worksWithConcurrentMode.test.js:13:17)\n      at Object.describe (__tests__/worksWithConcurrentMode.test.js:8:1)\n\nFAIL __tests__/worksWithConcurrentOnlyMode.test.js\n  ● block with concurrent › skipped failing test\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 101\n    Received: 10\n\n       8 | describe('block with concurrent', () => {\n       9 |   it('skipped failing test', () => {\n    > 10 |     expect(10).toBe(101);\n         |                ^\n      11 |   });\n      12 |\n      13 |   it.concurrent.only.failing('.only.failing() should fail', () => {\n\n      at Object.toBe (__tests__/worksWithConcurrentOnlyMode.test.js:10:16)\n\n  ● block with concurrent › encountered a declaration exception\n\n    Jest: \\`failing\\` tests are only supported in \\`jest-circus\\`.\n\n      11 |   });\n      12 |\n    > 13 |   it.concurrent.only.failing('.only.failing() should fail', () => {\n         |                      ^\n      14 |     expect(10).toBe(10);\n      15 |   });\n      16 |\n\n      at Function.failing (../../packages/jest-jasmine2/build/index.js:311:17)\n      at Suite.failing (__tests__/worksWithConcurrentOnlyMode.test.js:13:22)\n      at Object.describe (__tests__/worksWithConcurrentOnlyMode.test.js:8:1)\n\nFAIL __tests__/worksWithOnlyMode.test.js\n  ● block with only, should pass › encountered a declaration exception\n\n    Jest: \\`failing\\` tests are only supported in \\`jest-circus\\`.\n\n       9 |\n      10 | describe('block with only, should pass', () => {\n    > 11 |   it.only.failing('failing fails = passes, should pass', () => {\n         |           ^\n      12 |     expect(10).toBe(101);\n      13 |   });\n      14 |\n\n      at Suite.failing (__tests__/worksWithOnlyMode.test.js:11:11)\n      at Object.describe (__tests__/worksWithOnlyMode.test.js:10:1)\n\n  ● block with only, should fail › encountered a declaration exception\n\n    Jest: \\`failing\\` tests are only supported in \\`jest-circus\\`.\n\n      31 |\n      32 | describe('block with only, should fail', () => {\n    > 33 |   it.only.failing('failing passes = fails, should fail', () => {\n         |           ^\n      34 |     expect(10).toBe(10);\n      35 |   });\n      36 |\n\n      at Suite.failing (__tests__/worksWithOnlyMode.test.js:33:11)\n      at Object.describe (__tests__/worksWithOnlyMode.test.js:32:1)\n\n  ● block with only in other it, should skip › encountered a declaration exception\n\n    Jest: \\`failing\\` tests are only supported in \\`jest-circus\\`.\n\n      45 |\n      46 | describe('block with only in other it, should skip', () => {\n    > 47 |   it.failing('failing passes = fails, should fail but skipped', () => {\n         |      ^\n      48 |     expect(10).toBe(10);\n      49 |   });\n      50 |\n\n      at Suite.failing (__tests__/worksWithOnlyMode.test.js:47:6)\n      at Object.describe (__tests__/worksWithOnlyMode.test.js:46:1)\n\n  ● block with only with different syntax, should fail › encountered a declaration exception\n\n    Jest: \\`failing\\` tests are only supported in \\`jest-circus\\`.\n\n      59 |\n      60 | describe('block with only with different syntax, should fail', () => {\n    > 61 |   fit.failing('failing passes = fails, should fail 1', () => {\n         |       ^\n      62 |     expect(10).toBe(10);\n      63 |   });\n      64 |\n\n      at Suite.failing (__tests__/worksWithOnlyMode.test.js:61:7)\n      at Object.describe (__tests__/worksWithOnlyMode.test.js:60:1)\n\nFAIL __tests__/worksWithSkipMode.test.js\n  ● block with only, should pass › encountered a declaration exception\n\n    Jest: \\`failing\\` tests are only supported in \\`jest-circus\\`.\n\n       7 |\n       8 | describe('block with only, should pass', () => {\n    >  9 |   it.skip.failing('skipped failing fails = passes, should pass', () => {\n         |           ^\n      10 |     expect(10).toBe(101);\n      11 |   });\n      12 |\n\n      at Suite.failing (__tests__/worksWithSkipMode.test.js:9:11)\n      at Object.describe (__tests__/worksWithSkipMode.test.js:8:1)\n\n  ● block with only, should fail › encountered a declaration exception\n\n    Jest: \\`failing\\` tests are only supported in \\`jest-circus\\`.\n\n      33 |\n      34 | describe('block with only, should fail', () => {\n    > 35 |   it.skip.failing('failing passes = fails, should fail', () => {\n         |           ^\n      36 |     expect(10).toBe(10);\n      37 |   });\n      38 |\n\n      at Suite.failing (__tests__/worksWithSkipMode.test.js:35:11)\n      at Object.describe (__tests__/worksWithSkipMode.test.js:34:1)\"\n`;"}
{"prompt":"test.failing,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJasmine();\n\ndescribe('test.failing', () => {\n  describe('should pass when', () => {\n    test.failing('snapshot matchers fails', () => {\n      expect('0').toMatchSnapshot();\n    });\n\n    test.failing(\"snapshot doesn't exist\", () => {\n      expect('0').toMatchSnapshot();\n    });\n\n    test.failing('inline snapshot matchers fails', () => {\n      expect('0').toMatchInlineSnapshot('0');\n    });\n\n    test.failing('at least one snapshot fails', () => {\n      expect('1').toMatchSnapshot();\n      expect('0').toMatchSnapshot();\n    });\n  });\n\n  describe('should fail when', () => {\n    test.each([\n      ['snapshot', 'snapshot'],\n      ['inline snapshot', 'inlineSnapshot'],\n    ])('%s matchers pass', (_, fileName) => {\n      const dir = path.resolve(__dirname, '../test-failing-snapshot-all-pass');\n      const result = runJest(dir, [`./__tests__/${fileName}.test.js`]);\n      expect(result.exitCode).toBe(1);\n    });\n  });\n\n  it('doesnt update or remove snapshots', () => {\n    const dir = path.resolve(__dirname, '../test-failing-snapshot');\n    const result = runJest(dir, ['-u']);\n    expect(result.exitCode).toBe(0);\n    expect(result.stdout).not.toMatch(/snapshots? (written|removed|obsolete)/);\n\n    const snapshot = fs\n      .readFileSync(\n        path.resolve(dir, './__tests__/__snapshots__/snapshot.test.js.snap'),\n      )\n      .toString();\n    expect(snapshot).toMatchSnapshot();\n\n    const inlineSnapshot = fs\n      .readFileSync(path.resolve(dir, './__tests__/inlineSnapshot.test.js'))\n      .toString();\n    expect(inlineSnapshot).toMatchSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`test.failing doesnt update or remove snapshots 1`] = `\n\"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[\\`snapshots not updated nor removed 1\\`] = \\`\"1\"\\`;\n\nexports[\\`snapshots not updated nor removed 2\\`] = \\`\"1\"\\`;\n\nexports[\\`snapshots not updated nor removed 3\\`] = \\`\"1\"\\`;\n\"\n`;\n\nexports[`test.failing doesnt update or remove snapshots 2`] = `\n\"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest.failing('inline snapshot not updated', () => {\n  // eslint-disable-next-line quotes\n  expect('0').toMatchInlineSnapshot(\\`\"1\"\\`);\n});\n\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'test-failure-exit-code-test');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('exits with a specified code when test fail', () => {\n  writeFiles(DIR, {\n    '__tests__/test.test.js': \"test('test', () => { expect(1).toBe(2); });\",\n    'package.json': JSON.stringify({\n      jest: {testEnvironment: 'node', testFailureExitCode: 99},\n    }),\n  });\n\n  let {exitCode} = runJest(DIR);\n  expect(exitCode).toBe(99);\n\n  ({exitCode} = runJest(DIR, ['--testFailureExitCode', '77']));\n  expect(exitCode).toBe(77);\n\n  writeFiles(DIR, {\n    '__tests__/test.test.js': \"test('test', () => { expect(1).toBe(2); });\",\n    'package.json': JSON.stringify({\n      jest: {testEnvironment: 'node'},\n    }),\n  });\n  ({exitCode} = runJest(DIR));\n  expect(exitCode).toBe(1);\n});\n\ntest('exits with a specified code when bailing from a failed test', () => {\n  writeFiles(DIR, {\n    '__tests__/test.test.js': \"test('test', () => { expect(1).toBe(2); });\",\n    '__tests__/test2.test.js': \"test('test2', () => { expect(1).toBe(2); });\",\n    'package.json': JSON.stringify({\n      jest: {testEnvironment: 'node', testFailureExitCode: 99},\n    }),\n  });\n\n  let {exitCode} = runJest(DIR, ['--bail']);\n  expect(exitCode).toBe(99);\n\n  ({exitCode} = runJest(DIR, ['--bail', '--testFailureExitCode', '77']));\n  expect(exitCode).toBe(77);\n\n  writeFiles(DIR, {\n    '__tests__/test.test.js': \"test('test', () => { expect(1).toBe(2); });\",\n    '__tests__/test2.test.js': \"test('test2', () => { expect(1).toBe(2); });\",\n    'package.json': JSON.stringify({\n      jest: {testEnvironment: 'node'},\n    }),\n  });\n  ({exitCode} = runJest(DIR));\n  expect(exitCode).toBe(1);\n});"}
{"prompt":"runs tests in only test.js and spec.js,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {json as runWithJson} from '../runJest';\n\nit('runs tests in only test.js and spec.js', () => {\n  const {json: result} = runWithJson('test-in-root');\n\n  expect(result.success).toBe(true);\n  expect(result.numTotalTests).toBe(2);\n\n  const testNames = result.testResults\n    .map(res => res.name)\n    .map(name => path.basename(name))\n    .sort();\n\n  expect(testNames).toHaveLength(2);\n  expect(testNames[0]).toBe('spec.js');\n  expect(testNames[1]).toBe('test.js');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nconst shouldEqual = require('../macros');\n\ntest('use some imported macro to make assertion', () => {\n  shouldEqual(1, 2);\n});"}
{"prompt":"testMatch should able to match file with cjs and mjs extension,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nit('testMatch should able to match file with cjs and mjs extension', () => {\n  const result = runJest('test-match');\n  expect(result.exitCode).toBe(0);\n  const {summary} = extractSummary(result.stderr);\n  expect(summary).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`testMatch should able to match file with cjs and mjs extension 1`] = `\n\"Test Suites: 2 passed, 2 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"testMatch should able to match file with ?[mc][jt]s?x by default,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nit('testMatch should able to match file with `?([mc])[jt]s?(x)` by default', () => {\n  const result = runJest('test-match-default');\n  expect(result.exitCode).toBe(0);\n  const {summary} = extractSummary(result.stderr);\n  expect(summary).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`testMatch should able to match file with \\`?([mc])[jt]s?(x)\\` by default 1`] = `\n\"Test Suites: 16 passed, 16 total\nTests:       16 passed, 16 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"testMatch should able to match file with cts and mts extension,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nit('testMatch should able to match file with cts and mts extension', () => {\n  const result = runJest('test-match-ts');\n  expect(result.exitCode).toBe(0);\n  const {summary} = extractSummary(result.stderr);\n  expect(summary).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`testMatch should able to match file with cts and mts extension 1`] = `\n\"Test Suites: 2 passed, 2 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nexports.moduleNameMapperResolutionWorks = true;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('should match 1', () => expect(1).toBe(1));\ntest('should match 2', () => expect(1).toBe(1));\ntest('should not match 1', () => expect(1).toBe(1));\ntest('wisconsin', () => expect(1).toBe(1));\ntest.concurrent('should not match 2', () => expect(1).toBe(1));"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport {json as runWithJson} from '../runJest';\n\ntest('testNamePattern', () => {\n  const {stderr, exitCode} = runWithJson('test-name-pattern', [\n    '--testNamePattern',\n    'should match',\n  ]);\n  const {summary} = extractSummary(stderr);\n\n  expect(exitCode).toBe(0);\n  expect(summary).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`testNamePattern 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       3 skipped, 2 passed, 5 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites with tests matching \"should match\".\"\n`;"}
{"prompt":"First suite,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ndescribe('First suite', () => {\n  it('true equals true', () => {\n    expect(true).toBe(true);\n  });\n});\n\ndescribe('Second suite', () => {\n  it('false equals false', () => {\n    expect(false).toBe(false);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport {json as runWithJson} from '../runJest';\n\ntest('testNamePattern skipped', () => {\n  const {stderr, exitCode} = runWithJson('test-name-pattern-skipped', [\n    '--testNamePattern',\n    'false',\n  ]);\n  const {summary} = extractSummary(stderr);\n\n  expect(exitCode).toBe(0);\n  expect(summary).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`testNamePattern skipped 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 skipped, 1 passed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites with tests matching \"false\".\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'jest-path-pattern-reporter-message');\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ntest('prints a message with path pattern at the end', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    '__tests__/a.test.js': \"test('a', () => {});\",\n    '__tests__/b.test.js': \"test('b', () => {});\",\n    'package.json': '{}',\n  });\n  let stderr;\n\n  ({stderr} = runJest(DIR, ['a']));\n  expect(stderr).toMatch('Ran all test suites matching a');\n\n  ({stderr} = runJest(DIR, ['a', 'b']));\n  expect(stderr).toMatch('Ran all test suites matching a|b');\n\n  ({stderr} = runJest(DIR, ['--testPathPatterns', 'a']));\n  expect(stderr).toMatch('Ran all test suites matching a');\n\n  ({stderr} = runJest(DIR, ['--testPathPatterns', 'a|b']));\n  expect(stderr).toMatch('Ran all test suites matching a|b');\n});"}
{"prompt":"isSet,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {\n  TestPathPatterns,\n  TestPathPatternsExecutor,\n  type TestPathPatternsExecutorOptions,\n} from '../TestPathPatterns';\n\nconst mockSep: jest.Mock<() => string> = jest.fn();\nconst mockIsAbsolute: jest.Mock<(p: string) => boolean> = jest.fn();\nconst mockRelative: jest.Mock<(from: string, to: string) => string> = jest.fn();\njest.mock('path', () => {\n  const actualPath = jest.requireActual('path');\n  return {\n    ...actualPath,\n    isAbsolute(p) {\n      return mockIsAbsolute(p) || actualPath.isAbsolute(p);\n    },\n    relative(from, to) {\n      return mockRelative(from, to) || actualPath.relative(from, to);\n    },\n    get sep() {\n      return mockSep() || actualPath.sep;\n    },\n  } as typeof path;\n});\nconst forcePosix = () => {\n  mockSep.mockReturnValue(path.posix.sep);\n  mockIsAbsolute.mockImplementation(path.posix.isAbsolute);\n  mockRelative.mockImplementation(path.posix.relative);\n};\nconst forceWindows = () => {\n  mockSep.mockReturnValue(path.win32.sep);\n  mockIsAbsolute.mockImplementation(path.win32.isAbsolute);\n  mockRelative.mockImplementation(path.win32.relative);\n};\nbeforeEach(() => {\n  jest.resetAllMocks();\n  forcePosix();\n});\n\nconst config = {rootDir: ''};\n\ninterface TestPathPatternsLike {\n  isSet(): boolean;\n  isValid(): boolean;\n  toPretty(): string;\n}\n\nconst testPathPatternsLikeTests = (\n  makePatterns: (\n    patterns: Array<string>,\n    options: TestPathPatternsExecutorOptions,\n  ) => TestPathPatternsLike,\n) => {\n  describe('isSet', () => {\n    it('returns false if no patterns specified', () => {\n      const testPathPatterns = makePatterns([], config);\n      expect(testPathPatterns.isSet()).toBe(false);\n    });\n\n    it('returns true if patterns specified', () => {\n      const testPathPatterns = makePatterns(['a'], config);\n      expect(testPathPatterns.isSet()).toBe(true);\n    });\n  });\n\n  describe('isValid', () => {\n    it('succeeds for empty patterns', () => {\n      const testPathPatterns = makePatterns([], config);\n      expect(testPathPatterns.isValid()).toBe(true);\n    });\n\n    it('succeeds for valid patterns', () => {\n      const testPathPatterns = makePatterns(['abc+', 'z.*'], config);\n      expect(testPathPatterns.isValid()).toBe(true);\n    });\n\n    it('fails for at least one invalid pattern', () => {\n      const testPathPatterns = makePatterns(['abc+', '(', 'z.*'], config);\n      expect(testPathPatterns.isValid()).toBe(false);\n    });\n  });\n\n  describe('toPretty', () => {\n    it('renders a human-readable string', () => {\n      const testPathPatterns = makePatterns(['a/b', 'c/d'], config);\n      expect(testPathPatterns.toPretty()).toMatchSnapshot();\n    });\n  });\n};\n\ndescribe('TestPathPatterns', () => {\n  testPathPatternsLikeTests(\n    (patterns: Array<string>, _: TestPathPatternsExecutorOptions) =>\n      new TestPathPatterns(patterns),\n  );\n});\n\ndescribe('TestPathPatternsExecutor', () => {\n  const makeExecutor = (\n    patterns: Array<string>,\n    options: TestPathPatternsExecutorOptions,\n  ) => new TestPathPatternsExecutor(new TestPathPatterns(patterns), options);\n\n  testPathPatternsLikeTests(makeExecutor);\n\n  describe('isMatch', () => {\n    it('returns true with no patterns', () => {\n      const testPathPatterns = makeExecutor([], config);\n      expect(testPathPatterns.isMatch('/a/b')).toBe(true);\n    });\n\n    it('returns true for same path', () => {\n      const testPathPatterns = makeExecutor(['/a/b'], config);\n      expect(testPathPatterns.isMatch('/a/b')).toBe(true);\n    });\n\n    it('returns true for same path with case insensitive', () => {\n      const testPathPatternsUpper = makeExecutor(['/A/B'], config);\n      expect(testPathPatternsUpper.isMatch('/a/b')).toBe(true);\n      expect(testPathPatternsUpper.isMatch('/A/B')).toBe(true);\n\n      const testPathPatternsLower = makeExecutor(['/a/b'], config);\n      expect(testPathPatternsLower.isMatch('/A/B')).toBe(true);\n      expect(testPathPatternsLower.isMatch('/a/b')).toBe(true);\n    });\n\n    it('returns true for contained path', () => {\n      const testPathPatterns = makeExecutor(['b/c'], config);\n      expect(testPathPatterns.isMatch('/a/b/c/d')).toBe(true);\n    });\n\n    it('returns true for explicit relative path', () => {\n      const testPathPatterns = makeExecutor(['./b/c'], {\n        rootDir: '/a',\n      });\n      expect(testPathPatterns.isMatch('/a/b/c')).toBe(true);\n    });\n\n    it('returns true for explicit relative path for Windows with ./', () => {\n      forceWindows();\n      const testPathPatterns = makeExecutor(['./b/c'], {\n        rootDir: 'C:\\\\a',\n      });\n      expect(testPathPatterns.isMatch('C:\\\\a\\\\b\\\\c')).toBe(true);\n    });\n\n    it('returns true for explicit relative path for Windows with .\\\\', () => {\n      forceWindows();\n      const testPathPatterns = makeExecutor(['.\\\\b\\\\c'], {\n        rootDir: 'C:\\\\a',\n      });\n      expect(testPathPatterns.isMatch('C:\\\\a\\\\b\\\\c')).toBe(true);\n    });\n\n    it('returns true for partial file match', () => {\n      const testPathPatterns = makeExecutor(['aaa'], config);\n      expect(testPathPatterns.isMatch('/foo/..aaa..')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/..aaa')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/aaa..')).toBe(true);\n    });\n\n    it('returns true for path suffix', () => {\n      const testPathPatterns = makeExecutor(['c/d'], config);\n      expect(testPathPatterns.isMatch('/a/b/c/d')).toBe(true);\n    });\n\n    it('returns true if regex matches', () => {\n      const testPathPatterns = makeExecutor(['ab*c?'], config);\n\n      expect(testPathPatterns.isMatch('/foo/a')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/ab')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/abb')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/ac')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/abc')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/abbc')).toBe(true);\n\n      expect(testPathPatterns.isMatch('/foo/bc')).toBe(false);\n    });\n\n    it('returns true only if matches relative path', () => {\n      const testPathPatterns = makeExecutor(['home'], {\n        rootDir: '/home/myuser/',\n      });\n      expect(testPathPatterns.isMatch('/home/myuser/LoginPage.js')).toBe(false);\n      expect(testPathPatterns.isMatch('/home/myuser/HomePage.js')).toBe(true);\n    });\n\n    it('matches absolute paths regardless of rootDir', () => {\n      forcePosix();\n      const testPathPatterns = makeExecutor(['/a/b'], {\n        rootDir: '/foo/bar',\n      });\n      expect(testPathPatterns.isMatch('/a/b')).toBe(true);\n    });\n\n    it('matches absolute paths for Windows', () => {\n      forceWindows();\n      const testPathPatterns = makeExecutor(['C:\\\\a\\\\b'], {\n        rootDir: 'C:\\\\foo\\\\bar',\n      });\n      expect(testPathPatterns.isMatch('C:\\\\a\\\\b')).toBe(true);\n    });\n\n    it('returns true if match any paths', () => {\n      const testPathPatterns = makeExecutor(['a/b', 'c/d'], config);\n\n      expect(testPathPatterns.isMatch('/foo/a/b')).toBe(true);\n      expect(testPathPatterns.isMatch('/foo/c/d')).toBe(true);\n\n      expect(testPathPatterns.isMatch('/foo/a')).toBe(false);\n      expect(testPathPatterns.isMatch('/foo/b/c')).toBe(false);\n    });\n\n    it('does not normalize Windows paths on POSIX', () => {\n      forcePosix();\n      const testPathPatterns = makeExecutor(['a\\\\z', 'a\\\\\\\\z'], config);\n      expect(testPathPatterns.isMatch('/foo/a/z')).toBe(false);\n    });\n\n    it('normalizes paths for Windows', () => {\n      forceWindows();\n      const testPathPatterns = makeExecutor(['a/b'], config);\n      expect(testPathPatterns.isMatch('C:\\\\foo\\\\a\\\\b')).toBe(true);\n    });\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`TestPathPatterns toPretty renders a human-readable string 1`] = `\"a/b|c/d\"`;\n\nexports[`TestPathPatternsExecutor toPretty renders a human-readable string 1`] = `\"a/b|c/d\"`;"}
{"prompt":"works when specifying --testPathPatterns when config is in subdir,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {json} from '../runJest';\n\nit('works when specifying --testPathPatterns when config is in subdir', () => {\n  const {\n    json: {numTotalTests},\n  } = json('test-path-patterns-subprojects', [\n    '--config=config/jest.config.js',\n    '--testPathPatterns=testA',\n  ]);\n  expect(numTotalTests).toBe(1);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {json as runWithJson} from '../runJest';\n\ntest('testResultsProcessor', () => {\n  const processorPath = path.resolve(\n    __dirname,\n    '../test-results-processor/processor.js',\n  );\n  const {json} = runWithJson('test-results-processor', [\n    '--json',\n    `--testResultsProcessor=${processorPath}`,\n  ]);\n  expect(json.processed).toBe(true);\n});\n\ntest('testResultsProcessor async', () => {\n  const processorPath = path.resolve(\n    __dirname,\n    '../test-results-processor/processorAsync.js',\n  );\n  const {json} = runWithJson('test-results-processor', [\n    '--json',\n    `--testResultsProcessor=${processorPath}`,\n  ]);\n  expect(json.processed).toBe(true);\n});\n\ntest('testResultsProcessor written in ESM', () => {\n  const processorPath = path.resolve(\n    __dirname,\n    '../test-results-processor/processor.mjs',\n  );\n  const {json} = runWithJson('test-results-processor', [\n    '--json',\n    `--testResultsProcessor=${processorPath}`,\n  ]);\n  expect(json.processed).toBe(true);\n});"}
{"prompt":"Test Retries,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nskipSuiteOnJasmine();\n\ndescribe('Test Retries', () => {\n  const outputFileName = 'retries.result.json';\n  const outputFilePath = path.join(\n    process.cwd(),\n    'e2e/test-retries/',\n    outputFileName,\n  );\n  const logErrorsBeforeRetryErrorMessage = 'LOGGING RETRY ERRORS';\n\n  afterAll(() => {\n    fs.unlinkSync(outputFilePath);\n  });\n\n  it('retries failed tests', () => {\n    const result = runJest('test-retries', ['e2e.test.js']);\n\n    expect(result.exitCode).toBe(0);\n    expect(result.failed).toBe(false);\n    expect(result.stderr).not.toContain(logErrorsBeforeRetryErrorMessage);\n  });\n\n  it('logs error(s) before retry', () => {\n    const result = runJest('test-retries', ['logErrorsBeforeRetries.test.js']);\n    expect(result.exitCode).toBe(0);\n    expect(result.failed).toBe(false);\n    expect(result.stderr).toContain(logErrorsBeforeRetryErrorMessage);\n    expect(extractSummary(result.stderr).rest).toMatchSnapshot();\n  });\n\n  it('wait before retry', () => {\n    const result = runJest('test-retries', ['waitBeforeRetry.test.js']);\n    expect(result.exitCode).toBe(0);\n    expect(result.failed).toBe(false);\n    expect(result.stderr).toContain(logErrorsBeforeRetryErrorMessage);\n    expect(extractSummary(result.stderr).rest).toMatchSnapshot();\n  });\n\n  it('wait before retry with fake timers', () => {\n    const result = runJest('test-retries', [\n      'waitBeforeRetryFakeTimers.test.js',\n    ]);\n    expect(result.exitCode).toBe(0);\n    expect(result.failed).toBe(false);\n    expect(result.stderr).toContain(logErrorsBeforeRetryErrorMessage);\n    expect(extractSummary(result.stderr).rest).toMatchSnapshot();\n  });\n\n  it('with flag retryImmediately retry immediately after failed test', () => {\n    const logMessage = `console.log\n    FIRST TRUTHY TEST\n\n      at Object.log (__tests__/retryImmediately.test.js:14:13)\n\n  console.log\n    SECOND TRUTHY TEST\n\n      at Object.log (__tests__/retryImmediately.test.js:21:11)`;\n\n    const result = runJest('test-retries', ['retryImmediately.test.js']);\n    const stdout = result.stdout.trim();\n    expect(result.exitCode).toBe(0);\n    expect(result.failed).toBe(false);\n    expect(result.stderr).toContain(logErrorsBeforeRetryErrorMessage);\n    expect(stdout).toBe(logMessage);\n    expect(extractSummary(result.stderr).rest).toMatchSnapshot();\n  });\n\n  it('reporter shows more than 1 invocation if test is retried', () => {\n    let jsonResult;\n\n    const reporterConfig = {\n      reporters: [\n        ['<rootDir>/reporters/RetryReporter.js', {output: outputFilePath}],\n      ],\n    };\n\n    runJest('test-retries', [\n      '--config',\n      JSON.stringify(reporterConfig),\n      '__tests__/retry.test.js',\n    ]);\n\n    const testOutput = fs.readFileSync(outputFilePath, 'utf8');\n\n    try {\n      jsonResult = JSON.parse(testOutput);\n    } catch (error: any) {\n      throw new Error(\n        `Can't parse the JSON result from ${outputFileName}, ${error.toString()}`,\n      );\n    }\n\n    expect(jsonResult.numPassedTests).toBe(0);\n    expect(jsonResult.numFailedTests).toBe(1);\n    expect(jsonResult.numPendingTests).toBe(0);\n    expect(jsonResult.testResults[0].testResults[0].invocations).toBe(4);\n  });\n\n  it('reporter shows 1 invocation if tests are not retried', () => {\n    let jsonResult;\n\n    const reporterConfig = {\n      reporters: [\n        ['<rootDir>/reporters/RetryReporter.js', {output: outputFilePath}],\n      ],\n    };\n\n    runJest('test-retries', [\n      '--config',\n      JSON.stringify(reporterConfig),\n      'control.test.js',\n    ]);\n\n    const testOutput = fs.readFileSync(outputFilePath, 'utf8');\n\n    try {\n      jsonResult = JSON.parse(testOutput);\n    } catch (error: any) {\n      throw new Error(\n        `Can't parse the JSON result from ${outputFileName}, ${error.toString()}`,\n      );\n    }\n\n    expect(jsonResult.numPassedTests).toBe(0);\n    expect(jsonResult.numFailedTests).toBe(1);\n    expect(jsonResult.numPendingTests).toBe(0);\n    expect(jsonResult.testResults[0].testResults[0].invocations).toBe(1);\n  });\n\n  it('tests are not retried if beforeAll hook failure occurs', () => {\n    let jsonResult;\n\n    const reporterConfig = {\n      reporters: [\n        ['<rootDir>/reporters/RetryReporter.js', {output: outputFilePath}],\n      ],\n    };\n\n    runJest('test-retries', [\n      '--config',\n      JSON.stringify(reporterConfig),\n      'beforeAllFailure.test.js',\n    ]);\n\n    const testOutput = fs.readFileSync(outputFilePath, 'utf8');\n\n    try {\n      jsonResult = JSON.parse(testOutput);\n    } catch (error: any) {\n      throw new Error(\n        `Can't parse the JSON result from ${outputFileName}, ${error.toString()}`,\n      );\n    }\n\n    expect(jsonResult.numPassedTests).toBe(0);\n    expect(jsonResult.numFailedTests).toBe(1);\n    expect(jsonResult.numPendingTests).toBe(0);\n    expect(jsonResult.testResults[0].testResults[0].invocations).toBe(1);\n  });\n});\n\ndescribe('Concurrent Test Retries', () => {\n  const outputFileName = 'retries.result.json';\n  const outputFilePath = path.join(\n    process.cwd(),\n    'e2e/test-retries/',\n    outputFileName,\n  );\n  const logErrorsBeforeRetryErrorMessage = 'LOGGING RETRY ERRORS';\n\n  afterAll(() => {\n    fs.unlinkSync(outputFilePath);\n  });\n\n  it('retries failed tests', () => {\n    const result = runJest('test-retries', ['e2eConcurrent.test.js']);\n\n    expect(result.exitCode).toBe(0);\n    expect(result.failed).toBe(false);\n    expect(result.stderr).not.toContain(logErrorsBeforeRetryErrorMessage);\n  });\n\n  it('with flag retryImmediately retry immediately after failed test', () => {\n    const logMessage = `console.log\n    FIRST TRUTHY TEST\n\n      at Object.log (__tests__/retryImmediatelyConcurrent.test.js:32:11)\n\n  console.log\n    SECOND TRUTHY TEST\n\n      at Object.log (__tests__/retryImmediatelyConcurrent.test.js:14:13)\n          at async Promise.all (index 0)\n\n  console.log\n    THIRD TRUTHY TEST\n\n      at Object.log (__tests__/retryImmediatelyConcurrent.test.js:25:13)\n          at async Promise.all (index 1)`;\n\n    const result = runJest('test-retries', [\n      'retryImmediatelyConcurrent.test.js',\n    ]);\n    const stdout = result.stdout.trim();\n    expect(result.exitCode).toBe(0);\n    expect(result.failed).toBe(false);\n    expect(result.stderr).toContain(logErrorsBeforeRetryErrorMessage);\n    expect(stdout).toBe(logMessage);\n    expect(extractSummary(result.stderr).rest).toMatchSnapshot();\n  });\n\n  it('reporter shows more than 1 invocation if test is retried', () => {\n    let jsonResult;\n\n    const reporterConfig = {\n      reporters: [\n        ['<rootDir>/reporters/RetryReporter.js', {output: outputFilePath}],\n      ],\n    };\n\n    runJest('test-retries', [\n      '--config',\n      JSON.stringify(reporterConfig),\n      '__tests__/retryConcurrent.test.js',\n    ]);\n\n    const testOutput = fs.readFileSync(outputFilePath, 'utf8');\n\n    try {\n      jsonResult = JSON.parse(testOutput);\n    } catch (error: any) {\n      throw new Error(\n        `Can't parse the JSON result from ${outputFileName}, ${error.toString()}`,\n      );\n    }\n\n    expect(jsonResult.numPassedTests).toBe(1);\n    expect(jsonResult.numFailedTests).toBe(1);\n    expect(jsonResult.numPendingTests).toBe(0);\n    expect(jsonResult.testResults[0].testResults[0].invocations).toBe(4);\n    expect(jsonResult.testResults[0].testResults[1].invocations).toBe(1);\n  });\n\n  it('reporter shows 1 invocation if tests are not retried', () => {\n    let jsonResult;\n\n    const reporterConfig = {\n      reporters: [\n        ['<rootDir>/reporters/RetryReporter.js', {output: outputFilePath}],\n      ],\n    };\n\n    runJest('test-retries', [\n      '--config',\n      JSON.stringify(reporterConfig),\n      'controlConcurrent.test.js',\n    ]);\n\n    const testOutput = fs.readFileSync(outputFilePath, 'utf8');\n\n    try {\n      jsonResult = JSON.parse(testOutput);\n    } catch (error: any) {\n      throw new Error(\n        `Can't parse the JSON result from ${outputFileName}, ${error.toString()}`,\n      );\n    }\n\n    expect(jsonResult.numPassedTests).toBe(0);\n    expect(jsonResult.numFailedTests).toBe(1);\n    expect(jsonResult.numPendingTests).toBe(0);\n    expect(jsonResult.testResults[0].testResults[0].invocations).toBe(1);\n  });\n\n  it('tests are not retried if beforeAll hook failure occurs', () => {\n    let jsonResult;\n\n    const reporterConfig = {\n      reporters: [\n        ['<rootDir>/reporters/RetryReporter.js', {output: outputFilePath}],\n      ],\n    };\n\n    runJest('test-retries', [\n      '--config',\n      JSON.stringify(reporterConfig),\n      'beforeAllFailureConcurrent.test.js',\n    ]);\n\n    const testOutput = fs.readFileSync(outputFilePath, 'utf8');\n\n    try {\n      jsonResult = JSON.parse(testOutput);\n    } catch (error: any) {\n      throw new Error(\n        `Can't parse the JSON result from ${outputFileName}, ${error.toString()}`,\n      );\n    }\n\n    expect(jsonResult.numPassedTests).toBe(0);\n    expect(jsonResult.numFailedTests).toBe(2);\n    expect(jsonResult.numPendingTests).toBe(0);\n    expect(jsonResult.testResults[0].testResults[0].invocations).toBe(1);\n    expect(jsonResult.testResults[0].testResults[1].invocations).toBe(1);\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Concurrent Test Retries with flag retryImmediately retry immediately after failed test 1`] = `\n\"LOGGING RETRY ERRORS  retryable test 1\n RETRY 1 \n\n    expect(received).toBeFalsy()\n\n    Received: true\n\n      15 |     expect(true).toBeTruthy();\n      16 |   } else {\n    > 17 |     expect(true).toBeFalsy();\n         |                  ^\n      18 |   }\n      19 | });\n      20 |\n\n      at Object.toBeFalsy (__tests__/retryImmediatelyConcurrent.test.js:17:18)\n\n RETRY 2 \n\n    expect(received).toBeFalsy()\n\n    Received: true\n\n      15 |     expect(true).toBeTruthy();\n      16 |   } else {\n    > 17 |     expect(true).toBeFalsy();\n         |                  ^\n      18 |   }\n      19 | });\n      20 |\n\n      at Object.toBeFalsy (__tests__/retryImmediatelyConcurrent.test.js:17:18)\n          at async Promise.all (index 0)\n\n LOGGING RETRY ERRORS  retryable test 2\n RETRY 1 \n\n    expect(received).toBeFalsy()\n\n    Received: true\n\n      26 |     expect(true).toBeTruthy();\n      27 |   } else {\n    > 28 |     expect(true).toBeFalsy();\n         |                  ^\n      29 |   }\n      30 | });\n      31 | it.concurrent('truthy test', () => {\n\n      at Object.toBeFalsy (__tests__/retryImmediatelyConcurrent.test.js:28:18)\n\n RETRY 2 \n\n    expect(received).toBeFalsy()\n\n    Received: true\n\n      26 |     expect(true).toBeTruthy();\n      27 |   } else {\n    > 28 |     expect(true).toBeFalsy();\n         |                  ^\n      29 |   }\n      30 | });\n      31 | it.concurrent('truthy test', () => {\n\n      at Object.toBeFalsy (__tests__/retryImmediatelyConcurrent.test.js:28:18)\n          at async Promise.all (index 1)\n\nPASS __tests__/retryImmediatelyConcurrent.test.js\n  ✓ retryable test 1\n  ✓ retryable test 2\n  ✓ truthy test\"\n`;\n\nexports[`Test Retries logs error(s) before retry 1`] = `\n\"LOGGING RETRY ERRORS  retryTimes set\n RETRY 1 \n\n    expect(received).toBeFalsy()\n\n    Received: true\n\n      14 |     expect(true).toBeTruthy();\n      15 |   } else {\n    > 16 |     expect(true).toBeFalsy();\n         |                  ^\n      17 |   }\n      18 | });\n      19 |\n\n      at Object.toBeFalsy (__tests__/logErrorsBeforeRetries.test.js:16:18)\n\n RETRY 2 \n\n    expect(received).toBeFalsy()\n\n    Received: true\n\n      14 |     expect(true).toBeTruthy();\n      15 |   } else {\n    > 16 |     expect(true).toBeFalsy();\n         |                  ^\n      17 |   }\n      18 | });\n      19 |\n\n      at Object.toBeFalsy (__tests__/logErrorsBeforeRetries.test.js:16:18)\n\nPASS __tests__/logErrorsBeforeRetries.test.js\n  ✓ retryTimes set\"\n`;\n\nexports[`Test Retries wait before retry 1`] = `\n\"LOGGING RETRY ERRORS  retryTimes set\n RETRY 1 \n\n    expect(received).toBeFalsy()\n\n    Received: true\n\n      15 |     expect(Date.now() - startTimeInSeconds).toBeGreaterThan(200);\n      16 |   } else {\n    > 17 |     expect(true).toBeFalsy();\n         |                  ^\n      18 |   }\n      19 | });\n      20 |\n\n      at Object.toBeFalsy (__tests__/waitBeforeRetry.test.js:17:18)\n\n RETRY 2 \n\n    expect(received).toBeFalsy()\n\n    Received: true\n\n      15 |     expect(Date.now() - startTimeInSeconds).toBeGreaterThan(200);\n      16 |   } else {\n    > 17 |     expect(true).toBeFalsy();\n         |                  ^\n      18 |   }\n      19 | });\n      20 |\n\n      at Object.toBeFalsy (__tests__/waitBeforeRetry.test.js:17:18)\n\nPASS __tests__/waitBeforeRetry.test.js\n  ✓ retryTimes set\"\n`;\n\nexports[`Test Retries wait before retry with fake timers 1`] = `\n\"LOGGING RETRY ERRORS  retryTimes set with fake timers\n RETRY 1 \n\n    expect(received).toBeFalsy()\n\n    Received: true\n\n      16 |     expect(Date.now() - startTimeInSeconds).toBeGreaterThan(200);\n      17 |   } else {\n    > 18 |     expect(true).toBeFalsy();\n         |                  ^\n      19 |     jest.runAllTimers();\n      20 |   }\n      21 | });\n\n      at Object.toBeFalsy (__tests__/waitBeforeRetryFakeTimers.test.js:18:18)\n\n RETRY 2 \n\n    expect(received).toBeFalsy()\n\n    Received: true\n\n      16 |     expect(Date.now() - startTimeInSeconds).toBeGreaterThan(200);\n      17 |   } else {\n    > 18 |     expect(true).toBeFalsy();\n         |                  ^\n      19 |     jest.runAllTimers();\n      20 |   }\n      21 | });\n\n      at Object.toBeFalsy (__tests__/waitBeforeRetryFakeTimers.test.js:18:18)\n\nPASS __tests__/waitBeforeRetryFakeTimers.test.js\n  ✓ retryTimes set with fake timers\"\n`;\n\nexports[`Test Retries with flag retryImmediately retry immediately after failed test 1`] = `\n\"LOGGING RETRY ERRORS  retryTimes set\n RETRY 1 \n\n    expect(received).toBeFalsy()\n\n    Received: true\n\n      15 |     expect(true).toBeTruthy();\n      16 |   } else {\n    > 17 |     expect(true).toBeFalsy();\n         |                  ^\n      18 |   }\n      19 | });\n      20 | it('truthy test', () => {\n\n      at Object.toBeFalsy (__tests__/retryImmediately.test.js:17:18)\n\n RETRY 2 \n\n    expect(received).toBeFalsy()\n\n    Received: true\n\n      15 |     expect(true).toBeTruthy();\n      16 |   } else {\n    > 17 |     expect(true).toBeFalsy();\n         |                  ^\n      18 |   }\n      19 | });\n      20 | it('truthy test', () => {\n\n      at Object.toBeFalsy (__tests__/retryImmediately.test.js:17:18)\n\nPASS __tests__/retryImmediately.test.js\n  ✓ retryTimes set\n  ✓ truthy test\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {TestContext} from '@jest/test-result';\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport {TestWatcher} from 'jest-watcher';\nimport TestRunner from '../index';\n\nlet mockWorkerFarm;\n\njest.mock('jest-worker', () => ({\n  Worker: jest.fn(\n    worker =>\n      (mockWorkerFarm = {\n        end: jest.fn().mockResolvedValue({forceExited: false}),\n        getStderr: jest.fn(),\n        getStdout: jest.fn(),\n        worker: jest.fn((data, callback) => require(worker)(data, callback)),\n      }),\n  ),\n}));\n\njest.mock('../testWorker', () => {});\n\ntest('injects the serializable module map into each worker in watch mode', async () => {\n  const globalConfig = makeGlobalConfig({maxWorkers: 2, watch: true});\n  const config = makeProjectConfig({rootDir: '/path/'});\n  const runContext = {};\n  const mockTestContext = {\n    config,\n    moduleMap: {toJSON: jest.fn()},\n  } as unknown as TestContext;\n\n  await new TestRunner(globalConfig, runContext).runTests(\n    [\n      {context: mockTestContext, path: './file.test.js'},\n      {context: mockTestContext, path: './file2.test.js'},\n    ],\n    new TestWatcher({isWatchMode: globalConfig.watch}),\n    {serial: false},\n  );\n\n  expect(mockWorkerFarm.worker).toHaveBeenCalledTimes(2);\n\n  expect(mockWorkerFarm.worker).toHaveBeenNthCalledWith(1, {\n    config,\n    context: runContext,\n    globalConfig,\n    path: './file.test.js',\n  });\n\n  expect(mockWorkerFarm.worker).toHaveBeenNthCalledWith(2, {\n    config,\n    context: runContext,\n    globalConfig,\n    path: './file2.test.js',\n  });\n});\n\ntest('assign process.env.JEST_WORKER_ID = 1 when in runInBand mode', async () => {\n  const globalConfig = makeGlobalConfig({maxWorkers: 1, watch: false});\n  const config = makeProjectConfig({rootDir: '/path/'});\n  const context = {config} as TestContext;\n\n  await new TestRunner(globalConfig, {}).runTests(\n    [{context, path: './file.test.js'}],\n    new TestWatcher({isWatchMode: globalConfig.watch}),\n    {serial: true},\n  );\n\n  expect(process.env.JEST_WORKER_ID).toBe('1');\n});"}
{"prompt":"describe,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable jest/no-focused-tests */\n\n'use strict';\n\ndescribe('describe', () => {\n  it('it', () => {\n    expect(1).toBe(1);\n  });\n});\n\ndescribe.only('describe only', () => {\n  it.only('it only', () => {\n    expect(1).toBe(1);\n  });\n\n  it('it', () => {\n    expect(1).toBe(1);\n  });\n});"}
{"prompt":"my test,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ndescribe('my test', () => {\n  test('it passes', () => {\n    expect(true).toBe(false);\n  });\n\n  it('fails :(', () => {\n    expect(true).toBe(false);\n  });\n\n  test('a snapshot failure', () => {\n    expect({\n      p1: 'hello',\n      p2: 'world',\n    }).toMatchInlineSnapshot(`\n      {\n        \"p1\": \"hello\",\n        \"p2\": \"sunshine\",\n      }\n    `);\n  });\n});\n\nit('throws!', () => {\n  throw new Error();\n});\n\ntest('promise rejection', async () => {\n  // eslint-disable-next-line jest/require-to-throw-message\n  await expect(Promise.resolve(1)).rejects.toThrow();\n});"}
{"prompt":"reporters,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {\n  CoverageReporter,\n  DefaultReporter,\n  GitHubActionsReporter,\n  NotifyReporter,\n  SummaryReporter,\n  VerboseReporter,\n} from '@jest/reporters';\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport * as transform from '@jest/transform';\nimport {createTestScheduler} from '../TestScheduler';\nimport * as testSchedulerHelper from '../testSchedulerHelper';\n\njest\n  .mock('ci-info', () => ({GITHUB_ACTIONS: true}))\n  .mock('@jest/reporters')\n  .mock(\n    '/custom-reporter.js',\n    () =>\n      jest.fn(() => ({\n        onTestStart() {},\n      })),\n    {virtual: true},\n  )\n  .mock('@jest/transform', () => {\n    return {\n      __esModule: true,\n      ...jest.requireActual('@jest/transform'),\n    };\n  });\nconst mockSerialRunner = {\n  isSerial: true,\n  runTests: jest.fn(),\n};\njest.mock('jest-runner-serial', () => jest.fn(() => mockSerialRunner), {\n  virtual: true,\n});\n\nconst mockParallelRunner = {\n  runTests: jest.fn(),\n};\njest.mock('jest-runner-parallel', () => jest.fn(() => mockParallelRunner), {\n  virtual: true,\n});\n\nconst spyShouldRunInBand = jest.spyOn(testSchedulerHelper, 'shouldRunInBand');\n\nbeforeEach(() => {\n  mockSerialRunner.runTests.mockClear();\n  mockParallelRunner.runTests.mockClear();\n  spyShouldRunInBand.mockClear();\n});\n\ndescribe('reporters', () => {\n  const CustomReporter = require('/custom-reporter.js');\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  test('works with default value', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        reporters: undefined,\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(1);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n  });\n\n  test('does not enable any reporters, if empty list is passed', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        reporters: [],\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(0);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(0);\n  });\n\n  test('sets up default reporters', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        reporters: [['default', {}]],\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(1);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n  });\n\n  test('sets up verbose reporter', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        reporters: [['default', {}]],\n        verbose: true,\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(0);\n    expect(VerboseReporter).toHaveBeenCalledTimes(1);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n  });\n\n  test('sets up github actions reporter', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        reporters: [\n          ['default', {}],\n          ['github-actions', {}],\n        ],\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(1);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(1);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n  });\n\n  test('sets up notify reporter', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        notify: true,\n        reporters: [['default', {}]],\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(1);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(1);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n  });\n\n  test('sets up coverage reporter', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        collectCoverage: true,\n        reporters: [['default', {}]],\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(1);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(1);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n  });\n\n  test('allows enabling summary reporter separately', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        reporters: [['summary', {}]],\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(0);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n  });\n\n  test('sets up custom reporter', async () => {\n    await createTestScheduler(\n      makeGlobalConfig({\n        reporters: [\n          ['default', {}],\n          ['/custom-reporter.js', {}],\n        ],\n      }),\n      {},\n      {},\n    );\n\n    expect(DefaultReporter).toHaveBeenCalledTimes(1);\n    expect(VerboseReporter).toHaveBeenCalledTimes(0);\n    expect(GitHubActionsReporter).toHaveBeenCalledTimes(0);\n    expect(NotifyReporter).toHaveBeenCalledTimes(0);\n    expect(CoverageReporter).toHaveBeenCalledTimes(0);\n    expect(SummaryReporter).toHaveBeenCalledTimes(1);\n    expect(CustomReporter).toHaveBeenCalledTimes(1);\n  });\n});\n\ntest('.addReporter() .removeReporter()', async () => {\n  const scheduler = await createTestScheduler(makeGlobalConfig(), {}, {});\n  const reporter = new SummaryReporter();\n  scheduler.addReporter(reporter);\n  expect(scheduler._dispatcher._reporters).toContain(reporter);\n  scheduler.removeReporter(SummaryReporter);\n  expect(scheduler._dispatcher._reporters).not.toContain(reporter);\n});\n\ndescribe('scheduleTests should always dispatch runStart and runComplete events', () => {\n  const mockReporter = {\n    onRunComplete: jest.fn(),\n    onRunStart: jest.fn(),\n  };\n\n  const errorMsg = 'runtime-error';\n  let scheduler, t;\n\n  beforeEach(async () => {\n    mockReporter.onRunStart.mockClear();\n    mockReporter.onRunComplete.mockClear();\n\n    t = {\n      context: {\n        config: makeProjectConfig({\n          moduleFileExtensions: ['.js'],\n          rootDir: './',\n          runner: 'jest-runner-serial',\n          transform: [],\n        }),\n        hasteFS: {\n          matchFiles: jest.fn(() => []),\n        },\n      },\n      path: './test/path.js',\n    };\n\n    scheduler = await createTestScheduler(makeGlobalConfig(), {}, {});\n    scheduler.addReporter(mockReporter);\n  });\n\n  test('during normal run', async () => {\n    expect.hasAssertions();\n    const result = await scheduler.scheduleTests([t], {\n      isInterrupted: jest.fn(),\n      isWatchMode: () => true,\n      setState: jest.fn(),\n    });\n\n    expect(result.numTotalTestSuites).toBe(1);\n\n    expect(mockReporter.onRunStart).toHaveBeenCalledTimes(1);\n    expect(mockReporter.onRunComplete).toHaveBeenCalledTimes(1);\n    const aggregatedResult = mockReporter.onRunComplete.mock.calls[0][1];\n    expect(aggregatedResult.runExecError).toBeUndefined();\n\n    expect(aggregatedResult).toEqual(result);\n  });\n  test.each`\n    runtimeError                                  | message\n    ${errorMsg}                                   | ${errorMsg}\n    ${123}                                        | ${'123'}\n    ${new Error(errorMsg)}                        | ${errorMsg}\n    ${{message: errorMsg}}                        | ${errorMsg}\n    ${{message: errorMsg, stack: 'stack-string'}} | ${errorMsg}\n    ${`${errorMsg}\\n Require stack:xxxx`}         | ${errorMsg}\n  `('with runtime error: $runtimeError', async ({runtimeError, message}) => {\n    expect.hasAssertions();\n\n    const spyCreateScriptTransformer = jest.spyOn(\n      transform,\n      'createScriptTransformer',\n    );\n    spyCreateScriptTransformer.mockImplementation(async () => {\n      throw runtimeError;\n    });\n\n    await expect(\n      scheduler.scheduleTests([t], {\n        isInterrupted: jest.fn(),\n        isWatchMode: () => true,\n        setState: jest.fn(),\n      }),\n    ).rejects.toEqual(runtimeError);\n\n    expect(mockReporter.onRunStart).toHaveBeenCalledTimes(1);\n    expect(mockReporter.onRunComplete).toHaveBeenCalledTimes(1);\n    const aggregatedResult = mockReporter.onRunComplete.mock.calls[0][1];\n    expect(aggregatedResult.runExecError.message).toEqual(message);\n    expect(aggregatedResult.runExecError.stack.length).toBeGreaterThan(0);\n\n    spyCreateScriptTransformer.mockRestore();\n  });\n  test.each`\n    watchMode | isInterrupted | hasExecError\n    ${false}  | ${false}      | ${true}\n    ${true}   | ${false}      | ${true}\n    ${true}   | ${true}       | ${false}\n  `(\n    'with runner exception: watchMode=$watchMode, isInterrupted=$isInterrupted',\n    async ({watchMode, isInterrupted, hasExecError}) => {\n      expect.hasAssertions();\n\n      mockSerialRunner.runTests.mockImplementation(() => {\n        throw errorMsg;\n      });\n\n      try {\n        const result = await scheduler.scheduleTests([t], {\n          isInterrupted: () => isInterrupted,\n          isWatchMode: () => watchMode,\n          setState: jest.fn(),\n        });\n        if (hasExecError) {\n          throw new Error('should throw exception');\n        }\n        expect(result.runExecError).toBeUndefined();\n      } catch (error) {\n        expect(error).toEqual(errorMsg);\n      }\n\n      expect(mockReporter.onRunStart).toHaveBeenCalledTimes(1);\n      expect(mockReporter.onRunComplete).toHaveBeenCalledTimes(1);\n\n      const aggregatedResult = mockReporter.onRunComplete.mock.calls[0][1];\n      if (hasExecError) {\n        expect(aggregatedResult.runExecError.message).toEqual(errorMsg);\n        expect(aggregatedResult.runExecError.stack.length).toBeGreaterThan(0);\n      } else {\n        expect(aggregatedResult.runExecError).toBeUndefined();\n      }\n\n      mockSerialRunner.runTests.mockReset();\n    },\n  );\n});\n\ntest('schedule tests run in parallel per default', async () => {\n  const scheduler = await createTestScheduler(makeGlobalConfig(), {}, {});\n  const test = {\n    context: {\n      config: makeProjectConfig({\n        moduleFileExtensions: ['.js'],\n        runner: 'jest-runner-parallel',\n        transform: [],\n      }),\n      hasteFS: {\n        matchFiles: jest.fn(() => []),\n      },\n    },\n    path: './test/path.js',\n  };\n  const tests = [test, test];\n\n  await scheduler.scheduleTests(tests, {isInterrupted: jest.fn()});\n\n  expect(mockParallelRunner.runTests).toHaveBeenCalled();\n  expect(mockParallelRunner.runTests.mock.calls[0][5].serial).toBeFalsy();\n});\n\ntest('schedule tests run in serial if the runner flags them', async () => {\n  const scheduler = await createTestScheduler(makeGlobalConfig(), {}, {});\n  const test = {\n    context: {\n      config: makeProjectConfig({\n        moduleFileExtensions: ['.js'],\n        runner: 'jest-runner-serial',\n        transform: [],\n      }),\n      hasteFS: {\n        matchFiles: jest.fn(() => []),\n      },\n    },\n    path: './test/path.js',\n  };\n\n  const tests = [test, test];\n  await scheduler.scheduleTests(tests, {isInterrupted: jest.fn()});\n\n  expect(mockSerialRunner.runTests).toHaveBeenCalled();\n  expect(mockSerialRunner.runTests.mock.calls[0][5].serial).toBeTruthy();\n});\n\ntest('should bail after `n` failures', async () => {\n  const scheduler = await createTestScheduler(\n    makeGlobalConfig({bail: 2}),\n    {},\n    {},\n  );\n  const test = {\n    context: {\n      config: makeProjectConfig({\n        moduleFileExtensions: ['.js'],\n        rootDir: './',\n        runner: 'jest-runner-serial',\n        transform: [],\n      }),\n      hasteFS: {\n        matchFiles: jest.fn(() => []),\n      },\n    },\n    path: './test/path.js',\n  };\n\n  const tests = [test];\n  const setState = jest.fn();\n  await scheduler.scheduleTests(tests, {\n    isInterrupted: jest.fn(),\n    isWatchMode: () => true,\n    setState,\n  });\n  await mockSerialRunner.runTests.mock.calls[0][3](test, {\n    numFailingTests: 2,\n    snapshot: {},\n    testResults: [{}],\n  });\n  expect(setState).toHaveBeenCalledWith({interrupted: true});\n});\n\ntest('should not bail if less than `n` failures', async () => {\n  const scheduler = await createTestScheduler(\n    makeGlobalConfig({bail: 2}),\n    {},\n    {},\n  );\n  const test = {\n    context: {\n      config: makeProjectConfig({\n        moduleFileExtensions: ['.js'],\n        rootDir: './',\n        runner: 'jest-runner-serial',\n        transform: [],\n      }),\n      hasteFS: {\n        matchFiles: jest.fn(() => []),\n      },\n    },\n    path: './test/path.js',\n  };\n\n  const tests = [test];\n  const setState = jest.fn();\n  await scheduler.scheduleTests(tests, {\n    isInterrupted: jest.fn(),\n    isWatchMode: () => true,\n    setState,\n  });\n  await mockSerialRunner.runTests.mock.calls[0][3](test, {\n    numFailingTests: 1,\n    snapshot: {},\n    testResults: [{}],\n  });\n  expect(setState).not.toHaveBeenCalled();\n});\n\ntest('should set runInBand to run in serial', async () => {\n  const scheduler = await createTestScheduler(makeGlobalConfig(), {}, {});\n  const test = {\n    context: {\n      config: makeProjectConfig({\n        moduleFileExtensions: ['.js'],\n        runner: 'jest-runner-parallel',\n        transform: [],\n      }),\n      hasteFS: {\n        matchFiles: jest.fn(() => []),\n      },\n    },\n    path: './test/path.js',\n  };\n  const tests = [test, test];\n\n  spyShouldRunInBand.mockReturnValue(true);\n\n  await scheduler.scheduleTests(tests, {isInterrupted: jest.fn()});\n\n  expect(spyShouldRunInBand).toHaveBeenCalled();\n  expect(mockParallelRunner.runTests).toHaveBeenCalled();\n  expect(mockParallelRunner.runTests.mock.calls[0][5].serial).toBeTruthy();\n});\n\ntest('should set runInBand to not run in serial', async () => {\n  const scheduler = await createTestScheduler(makeGlobalConfig(), {}, {});\n  const test = {\n    context: {\n      config: makeProjectConfig({\n        moduleFileExtensions: ['.js'],\n        runner: 'jest-runner-parallel',\n        transform: [],\n      }),\n      hasteFS: {\n        matchFiles: jest.fn(() => []),\n      },\n    },\n    path: './test/path.js',\n  };\n  const tests = [test, test];\n\n  spyShouldRunInBand.mockReturnValue(false);\n\n  await scheduler.scheduleTests(tests, {isInterrupted: jest.fn()});\n\n  expect(spyShouldRunInBand).toHaveBeenCalled();\n  expect(mockParallelRunner.runTests).toHaveBeenCalled();\n  expect(mockParallelRunner.runTests.mock.calls[0][5].serial).toBeFalsy();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nimport {shouldRunInBand} from '../testSchedulerHelper';\n\nconst getTestMock = () => ({\n  context: {\n    config: {\n      runner: 'jest-runner-parallel',\n    },\n    hasteFS: {\n      matchFiles: jest.fn(() => []),\n    },\n  },\n  path: './test/path.js',\n});\n\nconst getTestsMock = () => [getTestMock(), getTestMock()];\n\ntest.each`\n  tests                       | timings        | detectOpenHandles | runInBand | maxWorkers   | watch    | workerIdleMemoryLimit | expectedResult\n  ${[getTestMock()]}          | ${[500, 500]}  | ${false}          | ${false}  | ${undefined} | ${true}  | ${undefined}          | ${false}\n  ${getTestsMock()}           | ${[2000, 500]} | ${false}          | ${false}  | ${1}         | ${true}  | ${undefined}          | ${false}\n  ${getTestsMock()}           | ${[2000, 500]} | ${false}          | ${false}  | ${2}         | ${true}  | ${undefined}          | ${false}\n  ${getTestsMock()}           | ${[2000, 500]} | ${false}          | ${true}   | ${1}         | ${true}  | ${undefined}          | ${true}\n  ${[getTestMock()]}          | ${[2000, 500]} | ${false}          | ${false}  | ${undefined} | ${true}  | ${undefined}          | ${false}\n  ${getTestMock()}            | ${[500, 500]}  | ${false}          | ${false}  | ${undefined} | ${true}  | ${undefined}          | ${false}\n  ${getTestsMock()}           | ${[2000, 500]} | ${false}          | ${false}  | ${1}         | ${false} | ${undefined}          | ${true}\n  ${getTestMock()}            | ${[2000, 500]} | ${false}          | ${false}  | ${2}         | ${false} | ${undefined}          | ${false}\n  ${[getTestMock()]}          | ${[2000]}      | ${false}          | ${false}  | ${undefined} | ${false} | ${undefined}          | ${true}\n  ${getTestsMock()}           | ${[500, 500]}  | ${false}          | ${false}  | ${undefined} | ${false} | ${undefined}          | ${true}\n  ${Array.from({length: 45})} | ${[500]}       | ${false}          | ${false}  | ${undefined} | ${false} | ${undefined}          | ${false}\n  ${getTestsMock()}           | ${[2000, 500]} | ${false}          | ${false}  | ${undefined} | ${false} | ${undefined}          | ${false}\n  ${getTestsMock()}           | ${[2000, 500]} | ${true}           | ${false}  | ${undefined} | ${false} | ${undefined}          | ${true}\n  ${[getTestMock()]}          | ${[500, 500]}  | ${false}          | ${false}  | ${undefined} | ${true}  | ${'500MB'}            | ${false}\n  ${getTestsMock()}           | ${[2000, 500]} | ${false}          | ${false}  | ${1}         | ${true}  | ${'500MB'}            | ${false}\n  ${getTestsMock()}           | ${[2000, 500]} | ${false}          | ${false}  | ${1}         | ${false} | ${'500MB'}            | ${false}\n  ${[getTestMock()]}          | ${[2000]}      | ${false}          | ${false}  | ${undefined} | ${false} | ${'500MB'}            | ${false}\n  ${getTestsMock()}           | ${[500, 500]}  | ${false}          | ${false}  | ${undefined} | ${false} | ${'500MB'}            | ${false}\n  ${getTestsMock()}           | ${[2000, 500]} | ${true}           | ${false}  | ${undefined} | ${false} | ${'500MB'}            | ${true}\n`(\n  'shouldRunInBand() - should return $expectedResult for runInBand mode',\n  ({\n    tests,\n    timings,\n    detectOpenHandles,\n    maxWorkers,\n    runInBand,\n    watch,\n    workerIdleMemoryLimit,\n    expectedResult,\n  }) => {\n    expect(\n      shouldRunInBand(tests, timings, {\n        detectOpenHandles,\n        maxWorkers,\n        runInBand,\n        watch,\n        workerIdleMemoryLimit,\n      }),\n    ).toBe(expectedResult);\n  },\n);"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\nconst dir = path.resolve(__dirname, '../test-todo');\n\ntest('works with all statuses', () => {\n  const result = runJest(dir, ['statuses.test.js']);\n  expect(result.exitCode).toBe(1);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('shows error messages when called with no arguments', () => {\n  const result = runJest(dir, ['todoNoArgs.test.js']);\n  expect(result.exitCode).toBe(1);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('shows error messages when called with multiple arguments', () => {\n  const result = runJest(dir, ['todoMultipleArgs.test.js']);\n  expect(result.exitCode).toBe(1);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('shows error messages when called with invalid argument', () => {\n  const result = runJest(dir, ['todoNonString.test.js']);\n  expect(result.exitCode).toBe(1);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('shows todo messages when in verbose mode', () => {\n  const result = runJest(dir, ['verbose.test.js', '--verbose']);\n  expect(result.exitCode).toBe(0);\n  const {rest} = extractSummary(result.stderr);\n  expect(rest).toMatchSnapshot();\n});\n\ntest('counts todo tests when inside of a `describe.only`', () => {\n  const result = runJest(dir, ['only-todo.test.js']);\n  expect(result.exitCode).toBe(0);\n  const {rest, summary} = extractSummary(result.stderr);\n  expect(`${rest}\\n\\n${summary}`).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`counts todo tests when inside of a \\`describe.only\\` 1`] = `\n\"PASS __tests__/only-todo.test.js\n  with .only, should show 'passed', 'todo', 'todo'\n    ✓ passing test\n    ✎ todo todo test 1\n    ✎ todo todo test 2\n\nTest Suites: 1 passed, 1 total\nTests:       2 todo, 1 passed, 3 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching only-todo.test.js.\"\n`;\n\nexports[`shows error messages when called with invalid argument 1`] = `\n\"FAIL __tests__/todoNonString.test.js\n  ● Test suite failed to run\n\n    Todo must be called with only a description.\n\n      6 |  */\n      7 |\n    > 8 | it.todo(() => {});\n        |    ^\n      9 |\n\n      at Object.todo (__tests__/todoNonString.test.js:8:4)\"\n`;\n\nexports[`shows error messages when called with multiple arguments 1`] = `\n\"FAIL __tests__/todoMultipleArgs.test.js\n  ● Test suite failed to run\n\n    Todo must be called with only a description.\n\n      6 |  */\n      7 |\n    > 8 | it.todo('todo later', () => {});\n        |    ^\n      9 |\n\n      at Object.todo (__tests__/todoMultipleArgs.test.js:8:4)\"\n`;\n\nexports[`shows error messages when called with no arguments 1`] = `\n\"FAIL __tests__/todoNoArgs.test.js\n  ● Test suite failed to run\n\n    Todo must be called with only a description.\n\n      6 |  */\n      7 |\n    > 8 | it.todo();\n        |    ^\n      9 |\n\n      at Object.todo (__tests__/todoNoArgs.test.js:8:4)\"\n`;\n\nexports[`shows todo messages when in verbose mode 1`] = `\n\"PASS __tests__/verbose.test.js\n  todos in verbose reporter\n    ✎ todo this\n    ✎ todo should\n    ✎ todo work\"\n`;\n\nexports[`works with all statuses 1`] = `\n\"FAIL __tests__/statuses.test.js\n  ✓ passes\n  ✕ fails\n  ○ skipped skips\n  ✎ todo todo\n\n  ● fails\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: 101\n    Received: 10\n\n      11 |\n      12 | it('fails', () => {\n    > 13 |   expect(10).toBe(101);\n         |              ^\n      14 | });\n      15 |\n      16 | it.skip('skips', () => {\n\n      at Object.toBe (__tests__/statuses.test.js:13:14)\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('dummy', () => {\n  expect(globalThis.someVar).toBe(42);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports.process = source => {\n  const json = JSON.parse(source);\n  for (const k of Object.keys(json)) json[k] = k;\n  return {code: JSON.stringify(json)};\n};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports.process = () => ({\n  code: \"throw new Error('preprocessor must not run.');\",\n});"}
{"prompt":"this is missing runtime to test that  is calculated","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as mockedFs from 'graceful-fs';\nimport type {AggregatedResult, Test, TestContext} from '@jest/test-result';\nimport {makeGlobalConfig, makeProjectConfig} from '@jest/test-utils';\nimport TestSequencer from '../index';\n\njest.mock('graceful-fs', () => ({\n  ...jest.createMockFromModule<typeof import('fs')>('fs'),\n  existsSync: jest.fn(() => true),\n  readFileSync: jest.fn(() => '{}'),\n}));\nconst FAIL = 0;\nconst SUCCESS = 1;\n\nlet sequencer: TestSequencer;\n\nconst fs = jest.mocked(mockedFs);\n\nconst context: TestContext = {\n  config: makeProjectConfig({\n    cache: true,\n    cacheDirectory: '/cache',\n    haste: {},\n    id: 'test',\n  }),\n  hasteFS: {\n    getSize: path => path.length,\n  },\n};\n\nconst secondContext: TestContext = {\n  config: makeProjectConfig({\n    cache: true,\n    cacheDirectory: '/cache2',\n    haste: {},\n    id: 'test2',\n  }),\n  hasteFS: {\n    getSize: path => path.length,\n  },\n};\n\nconst toTests = (paths: Array<string>) =>\n  paths.map<Test>(path => ({\n    context,\n    duration: undefined,\n    path,\n  }));\n\nbeforeEach(() => {\n  jest.clearAllMocks();\n  sequencer = new TestSequencer({\n    contexts: [],\n    globalConfig: makeGlobalConfig(),\n  });\n});\n\ntest('sorts by file size if there is no timing information', () => {\n  expect(sequencer.sort(toTests(['/test-a.js', '/test-ab.js']))).toEqual([\n    {context, duration: undefined, path: '/test-ab.js'},\n    {context, duration: undefined, path: '/test-a.js'},\n  ]);\n});\n\ntest('sorts based on timing information', () => {\n  fs.readFileSync.mockImplementationOnce(() =>\n    JSON.stringify({\n      '/test-a.js': [SUCCESS, 5],\n      '/test-ab.js': [SUCCESS, 3],\n    }),\n  );\n  expect(sequencer.sort(toTests(['/test-a.js', '/test-ab.js']))).toEqual([\n    {context, duration: 5, path: '/test-a.js'},\n    {context, duration: 3, path: '/test-ab.js'},\n  ]);\n});\n\ntest('sorts based on failures and timing information', () => {\n  fs.readFileSync.mockImplementationOnce(() =>\n    JSON.stringify({\n      '/test-a.js': [SUCCESS, 5],\n      '/test-ab.js': [FAIL, 0],\n      '/test-c.js': [FAIL, 6],\n      '/test-d.js': [SUCCESS, 2],\n    }),\n  );\n  expect(\n    sequencer.sort(\n      toTests(['/test-a.js', '/test-ab.js', '/test-c.js', '/test-d.js']),\n    ),\n  ).toEqual([\n    {context, duration: 6, path: '/test-c.js'},\n    {context, duration: 0, path: '/test-ab.js'},\n    {context, duration: 5, path: '/test-a.js'},\n    {context, duration: 2, path: '/test-d.js'},\n  ]);\n});\n\ntest('sorts based on failures, timing information and file size', () => {\n  fs.readFileSync.mockImplementationOnce(() =>\n    JSON.stringify({\n      '/test-a.js': [SUCCESS, 5],\n      '/test-ab.js': [FAIL, 1],\n      '/test-c.js': [FAIL],\n      '/test-d.js': [SUCCESS, 2],\n      '/test-efg.js': [FAIL],\n    }),\n  );\n  expect(\n    sequencer.sort(\n      toTests([\n        '/test-a.js',\n        '/test-ab.js',\n        '/test-c.js',\n        '/test-d.js',\n        '/test-efg.js',\n      ]),\n    ),\n  ).toEqual([\n    {context, duration: undefined, path: '/test-efg.js'},\n    {context, duration: undefined, path: '/test-c.js'},\n    {context, duration: 1, path: '/test-ab.js'},\n    {context, duration: 5, path: '/test-a.js'},\n    {context, duration: 2, path: '/test-d.js'},\n  ]);\n});\n\ntest('writes the cache based on results without existing cache', async () => {\n  fs.readFileSync.mockImplementationOnce(() => {\n    throw new Error('File does not exist.');\n  });\n\n  const testPaths = ['/test-a.js', '/test-b.js', '/test-c.js'];\n  const tests = await sequencer.sort(toTests(testPaths));\n  sequencer.cacheResults(tests, {\n    testResults: [\n      {\n        numFailingTests: 0,\n        perfStats: {end: 2, runtime: 1, start: 1},\n        testFilePath: '/test-a.js',\n      },\n      {\n        numFailingTests: 0,\n        perfStats: {end: 0, runtime: 0, start: 0},\n        skipped: true,\n        testFilePath: '/test-b.js',\n      },\n      {\n        numFailingTests: 1,\n        // this is missing `runtime` to test that it is calculated\n        perfStats: {end: 4, start: 1},\n        testFilePath: '/test-c.js',\n      },\n      {\n        numFailingTests: 1,\n        perfStats: {end: 2, runtime: 1, start: 1},\n        testFilePath: '/test-x.js',\n      },\n    ],\n  });\n  const fileData = JSON.parse(\n    fs.writeFileSync.mock.calls[0][1],\n  ) as AggregatedResult;\n  expect(fileData).toEqual({\n    '/test-a.js': [SUCCESS, 1],\n    '/test-c.js': [FAIL, 3],\n  });\n});\n\ntest('returns failed tests in sorted order', () => {\n  fs.readFileSync.mockImplementationOnce(() =>\n    JSON.stringify({\n      '/test-a.js': [SUCCESS, 5],\n      '/test-ab.js': [FAIL, 1],\n      '/test-c.js': [FAIL],\n    }),\n  );\n  const testPaths = ['/test-a.js', '/test-ab.js', '/test-c.js'];\n  expect(sequencer.allFailedTests(toTests(testPaths))).toEqual([\n    {context, duration: undefined, path: '/test-c.js'},\n    {context, duration: 1, path: '/test-ab.js'},\n  ]);\n});\n\ntest('writes the cache based on the results', async () => {\n  fs.readFileSync.mockImplementationOnce(() =>\n    JSON.stringify({\n      '/test-a.js': [SUCCESS, 5],\n      '/test-b.js': [FAIL, 1],\n      '/test-c.js': [FAIL],\n    }),\n  );\n\n  const testPaths = ['/test-a.js', '/test-b.js', '/test-c.js'];\n  const tests = await sequencer.sort(toTests(testPaths));\n  sequencer.cacheResults(tests, {\n    testResults: [\n      {\n        numFailingTests: 0,\n        perfStats: {end: 2, runtime: 1, start: 1},\n        testFilePath: '/test-a.js',\n      },\n      {\n        numFailingTests: 0,\n        perfStats: {end: 0, runtime: 0, start: 0},\n        skipped: true,\n        testFilePath: '/test-b.js',\n      },\n      {\n        numFailingTests: 1,\n        perfStats: {end: 4, runtime: 3, start: 1},\n        testFilePath: '/test-c.js',\n      },\n      {\n        numFailingTests: 1,\n        perfStats: {end: 2, runtime: 1, start: 1},\n        testFilePath: '/test-x.js',\n      },\n    ],\n  });\n  const fileData = JSON.parse(\n    fs.writeFileSync.mock.calls[0][1],\n  ) as AggregatedResult;\n  expect(fileData).toEqual({\n    '/test-a.js': [SUCCESS, 1],\n    '/test-b.js': [FAIL, 1],\n    '/test-c.js': [FAIL, 3],\n  });\n});\n\ntest('works with multiple contexts', async () => {\n  fs.readFileSync.mockImplementationOnce(cacheName => {\n    if (typeof cacheName !== 'string') {\n      throw new TypeError('Must be called with a string');\n    }\n\n    return cacheName.startsWith(`${path.sep}cache${path.sep}`)\n      ? JSON.stringify({\n          '/test-a.js': [SUCCESS, 5],\n          '/test-b.js': [FAIL, 1],\n        })\n      : JSON.stringify({\n          '/test-c.js': [FAIL],\n        });\n  });\n\n  const testPaths = [\n    {context, duration: null, path: '/test-a.js'},\n    {context, duration: null, path: '/test-b.js'},\n    {context: secondContext, duration: null, path: '/test-c.js'},\n  ];\n  const tests = await sequencer.sort(testPaths);\n  sequencer.cacheResults(tests, {\n    testResults: [\n      {\n        numFailingTests: 0,\n        perfStats: {end: 2, runtime: 1, start: 1},\n        testFilePath: '/test-a.js',\n      },\n      {\n        numFailingTests: 0,\n        perfStats: {end: 0, runtime: 1, start: 0},\n        skipped: true,\n        testFilePath: '/test-b.js',\n      },\n      {\n        numFailingTests: 0,\n        perfStats: {end: 4, runtime: 3, start: 1},\n        testFilePath: '/test-c.js',\n      },\n      {\n        numFailingTests: 1,\n        perfStats: {end: 2, runtime: 1, start: 1},\n        testFilePath: '/test-x.js',\n      },\n    ],\n  });\n  const fileDataA = JSON.parse(\n    fs.writeFileSync.mock.calls[0][1],\n  ) as AggregatedResult;\n  expect(fileDataA).toEqual({\n    '/test-a.js': [SUCCESS, 1],\n    '/test-b.js': [FAIL, 1],\n  });\n  const fileDataB = JSON.parse(\n    fs.writeFileSync.mock.calls[1][1],\n  ) as AggregatedResult;\n  expect(fileDataB).toEqual({\n    '/test-c.js': [SUCCESS, 3],\n  });\n});\n\ntest('does not shard by default', async () => {\n  const tests = await sequencer.shard(toTests(['/test-a.js', '/test-ab.js']), {\n    shardCount: 1,\n    shardIndex: 1,\n  });\n\n  expect(tests.map(test => test.path)).toEqual(['/test-ab.js', '/test-a.js']);\n});\n\ntest('return first shard', async () => {\n  const tests = await sequencer.shard(\n    toTests(['/test-a.js', '/test-abc.js', '/test-ab.js']),\n    {\n      shardCount: 3,\n      shardIndex: 1,\n    },\n  );\n\n  expect(tests.map(test => test.path)).toEqual(['/test-ab.js']);\n});\n\ntest('return second shard', async () => {\n  const tests = await sequencer.shard(\n    toTests(['/test-a.js', '/test-abc.js', '/test-ab.js']),\n    {\n      shardCount: 3,\n      shardIndex: 2,\n    },\n  );\n\n  expect(tests.map(test => test.path)).toEqual(['/test-abc.js']);\n});\n\ntest('return third shard', async () => {\n  const tests = await sequencer.shard(\n    toTests(['/test-abc.js', '/test-a.js', '/test-ab.js']),\n    {\n      shardCount: 3,\n      shardIndex: 3,\n    },\n  );\n\n  expect(tests.map(test => test.path)).toEqual(['/test-a.js']);\n});\n\ntest('returns expected 100/10 shards', async () => {\n  const allTests = toTests(Array.from({length: 100}).map((_, i) => `/${i}.js`));\n\n  const shards = await Promise.all(\n    Array.from({length: 10}).map((_, i) =>\n      sequencer.shard(allTests, {\n        shardCount: 10,\n        shardIndex: i + 1,\n      }),\n    ),\n  );\n\n  expect(shards.map(shard => shard.length)).toEqual([\n    10, 10, 10, 10, 10, 10, 10, 10, 10, 10,\n  ]);\n});\n\ntest('returns expected 100/8 shards', async () => {\n  const allTests = toTests(Array.from({length: 100}).map((_, i) => `/${i}.js`));\n\n  const shards = await Promise.all(\n    Array.from({length: 8}).map((_, i) =>\n      sequencer.shard(allTests, {\n        shardCount: 8,\n        shardIndex: i + 1,\n      }),\n    ),\n  );\n\n  expect(shards.map(shard => shard.length)).toEqual([\n    13, 13, 13, 13, 12, 12, 12, 12,\n  ]);\n});\n\ntest('returns expected 55/12 shards', async () => {\n  const allTests = toTests(Array.from({length: 55}).map((_, i) => `/${i}.js`));\n\n  const shards = await Promise.all(\n    Array.from({length: 12}).map((_, i) =>\n      sequencer.shard(allTests, {\n        shardCount: 12,\n        shardIndex: i + 1,\n      }),\n    ),\n  );\n\n  expect(shards.map(shard => shard.length)).toEqual([\n    5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4,\n  ]);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst Thing = require('../Thing');\n\nconsole.log(Thing);\ntest.todo('whatever');"}
{"prompt":"Jest Worker Process Integration,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EventEmitter} from 'events';\nimport type {Worker as ThreadWorker} from 'worker_threads';\nimport type {JestWorkerFarm, Worker} from '..';\nimport {CHILD_MESSAGE_CALL, PARENT_MESSAGE_OK} from '../types';\n\nlet WorkerFarm: typeof Worker;\nlet mockForkedProcesses: Array<ThreadWorker>;\n\nfunction replySuccess(i: number, result: unknown) {\n  mockForkedProcesses[i].emit('message', [PARENT_MESSAGE_OK, result]);\n}\n\nfunction assertCallsToChild(\n  childNum: number,\n  ...calls: Array<[unknown, ...[unknown]]>\n) {\n  expect(mockForkedProcesses[childNum].postMessage).toHaveBeenCalledTimes(\n    calls.length + 1,\n  );\n\n  for (const [numCall, [methodName, ...args]] of calls.entries()) {\n    expect(\n      jest.mocked(mockForkedProcesses[childNum].postMessage).mock.calls[\n        numCall + 1\n      ][0],\n    ).toEqual([CHILD_MESSAGE_CALL, true, methodName, args]);\n  }\n}\n\ndescribe('Jest Worker Process Integration', () => {\n  beforeEach(() => {\n    mockForkedProcesses = [];\n\n    class MockForkedProcess extends EventEmitter {\n      postMessage = jest.fn();\n    }\n\n    jest.mock('worker_threads', () => {\n      const fakeClass = jest.fn(() => {\n        const forkedProcess =\n          new MockForkedProcess() as unknown as ThreadWorker;\n\n        mockForkedProcesses.push(forkedProcess);\n\n        return forkedProcess;\n      });\n\n      return {\n        Worker: fakeClass,\n        __esModule: true,\n      };\n    });\n\n    WorkerFarm = (require('../') as typeof import('..')).Worker;\n  });\n\n  afterEach(() => {\n    jest.resetModules();\n  });\n\n  it('calls a single method from the worker', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      enableWorkerThreads: true,\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(): void}>;\n\n    const promise = farm.foo();\n\n    replySuccess(0, 42);\n\n    expect(await promise).toBe(42);\n  });\n\n  it('distributes sequential calls across child processes', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      enableWorkerThreads: true,\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // The first call will go to the first child process.\n    const promise0 = farm.foo('param-0');\n    assertCallsToChild(0, ['foo', 'param-0']);\n    replySuccess(0, 'worker-0');\n    expect(await promise0).toBe('worker-0');\n\n    // The second call will go to the second child process.\n    const promise1 = farm.foo(1);\n    assertCallsToChild(1, ['foo', 1]);\n    replySuccess(1, 'worker-1');\n    expect(await promise1).toBe('worker-1');\n  });\n\n  it('schedules the task on the first available child processes if the scheduling policy is in-order', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      enableWorkerThreads: true,\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n      workerSchedulingPolicy: 'in-order',\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // The first call will go to the first child process.\n    const promise0 = farm.foo('param-0');\n    assertCallsToChild(0, ['foo', 'param-0']);\n\n    // The second call will go to the second child process.\n    const promise1 = farm.foo(1);\n\n    // The first task on worker 0 completes.\n    replySuccess(0, 'worker-0');\n    expect(await promise0).toBe('worker-0');\n\n    // The second task on worker 1 completes.\n    assertCallsToChild(1, ['foo', 1]);\n    replySuccess(1, 'worker-1');\n    expect(await promise1).toBe('worker-1');\n\n    // The third call will go to the first child process.\n    const promise2 = farm.foo('param-2');\n    assertCallsToChild(0, ['foo', 'param-0'], ['foo', 'param-2']);\n    replySuccess(0, 'worker-0');\n    expect(await promise2).toBe('worker-0');\n  });\n\n  it('schedules the task on the first available child processes', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      enableWorkerThreads: true,\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // The first call will go to the first child process.\n    const promise0 = farm.foo('param-0');\n    assertCallsToChild(0, ['foo', 'param-0']);\n    replySuccess(0, 'worker-0');\n    expect(await promise0).toBe('worker-0');\n\n    // The second call will go to the second child process.\n    const promise1 = farm.foo(1);\n    assertCallsToChild(1, ['foo', 1]);\n    replySuccess(1, 'worker-1');\n    expect(await promise1).toBe('worker-1');\n  });\n\n  it('distributes concurrent calls across child processes', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      enableWorkerThreads: true,\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // Do 3 calls to the farm in parallel.\n    const promise0 = farm.foo('param-0');\n    const promise1 = farm.foo('param-1');\n    const promise2 = farm.foo('param-2');\n\n    // Check that the method calls are sent to each separate child process.\n    assertCallsToChild(0, ['foo', 'param-0']);\n    assertCallsToChild(1, ['foo', 'param-1']);\n    assertCallsToChild(2, ['foo', 'param-2']);\n\n    // Send different responses from each child.\n    replySuccess(0, 'worker-0');\n    replySuccess(1, 'worker-1');\n    replySuccess(2, 'worker-2');\n\n    // Check\n    expect(await promise0).toBe('worker-0');\n    expect(await promise1).toBe('worker-1');\n    expect(await promise2).toBe('worker-2');\n  });\n\n  it('sticks parallel calls to children', async () => {\n    const farm = new WorkerFarm('/tmp/baz.js', {\n      computeWorkerKey: () => '1234567890abcdef',\n      enableWorkerThreads: true,\n      exposedMethods: ['foo', 'bar'],\n      numWorkers: 4,\n    }) as JestWorkerFarm<{foo(a: unknown): void}>;\n\n    // Do 3 calls to the farm in parallel.\n    const promise0 = farm.foo('param-0');\n    const promise1 = farm.foo('param-1');\n    const promise2 = farm.foo('param-2');\n\n    // Send different responses for each call (from the same child).\n    replySuccess(0, 'worker-0');\n    replySuccess(0, 'worker-1');\n    replySuccess(0, 'worker-2');\n\n    // Check that all the calls have been received by the same child.\n    assertCallsToChild(\n      0,\n      ['foo', 'param-0'],\n      ['foo', 'param-1'],\n      ['foo', 'param-2'],\n    );\n\n    // Check that responses are correct.\n    expect(await promise0).toBe('worker-0');\n    expect(await promise1).toBe('worker-1');\n    expect(await promise2).toBe('worker-2');\n  });\n});"}
{"prompt":"eslint-disable-next-line no-throw-leral","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {EventEmitter} from 'events';\nimport type {MessagePort} from 'worker_threads';\nimport {\n  CHILD_MESSAGE_CALL,\n  CHILD_MESSAGE_END,\n  CHILD_MESSAGE_INITIALIZE,\n  PARENT_MESSAGE_CLIENT_ERROR,\n  PARENT_MESSAGE_OK,\n} from '../../types';\n\nclass MockedParentPort extends EventEmitter {\n  postMessage = jest.fn();\n}\n\njest.mock('worker_threads', () => {\n  return {\n    isMainThread: false,\n    parentPort: new MockedParentPort(),\n  };\n});\n\nclass MockExtendedError extends ReferenceError {\n  baz = 123;\n  qux = 456;\n}\n\nconst mockError = new TypeError('Boo');\nconst mockExtendedError = new MockExtendedError('Boo extended');\nconst uninitializedParam = {};\nconst sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));\n\nlet ended: boolean;\nlet mockCount: number;\nlet initializeParm = uninitializedParam;\n\nlet messagePort: MessagePort;\n\nbeforeEach(() => {\n  mockCount = 0;\n  ended = false;\n\n  jest.mock(\n    '../my-fancy-worker',\n    () => {\n      mockCount++;\n\n      return {\n        fooPromiseThrows() {\n          return new Promise((_resolve, reject) => {\n            setTimeout(() => reject(mockError), 5);\n          });\n        },\n\n        fooPromiseWorks() {\n          return new Promise(resolve => {\n            setTimeout(() => resolve(1989), 5);\n          });\n        },\n\n        fooThrows() {\n          throw mockError;\n        },\n\n        fooThrowsANumber() {\n          // eslint-disable-next-line no-throw-literal\n          throw 412;\n        },\n\n        fooThrowsAnErrorWithExtraProperties() {\n          throw mockExtendedError;\n        },\n\n        fooThrowsNull() {\n          // eslint-disable-next-line no-throw-literal\n          throw null;\n        },\n\n        fooWorks() {\n          return 1989;\n        },\n\n        setup(param: Record<string, unknown>) {\n          initializeParm = param;\n        },\n\n        teardown() {\n          ended = true;\n        },\n      };\n    },\n    {virtual: true},\n  );\n\n  jest.mock('../my-fancy-standalone-worker', () => jest.fn(() => 12_345), {\n    virtual: true,\n  });\n\n  // This mock emulates a transpiled Babel module that carries a default export\n  // that corresponds to a method.\n  jest.mock(\n    '../my-fancy-babel-worker',\n    () => ({\n      __esModule: true,\n      default: jest.fn(() => 67_890),\n    }),\n    {virtual: true},\n  );\n\n  messagePort = (require('worker_threads') as typeof import('worker_threads'))\n    .parentPort!;\n\n  // Require the child!\n  require('../threadChild');\n});\n\nbeforeEach(() => {\n  jest.mocked(messagePort.postMessage).mockClear();\n});\n\nafterEach(() => {\n  jest.resetModules();\n\n  messagePort.removeAllListeners('message');\n});\n\nit('sets env.JEST_WORKER_ID', () => {\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n    [],\n    '3',\n  ]);\n\n  expect(process.env.JEST_WORKER_ID).toBe('3');\n});\n\nit('lazily requires the file', () => {\n  expect(mockCount).toBe(0);\n\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n  ]);\n\n  expect(mockCount).toBe(0);\n  expect(initializeParm).toBe(uninitializedParam); // Not called yet.\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooWorks', []]);\n\n  expect(mockCount).toBe(1);\n  expect(initializeParm).toBeUndefined();\n});\n\nit('calls initialize with the correct arguments', () => {\n  expect(mockCount).toBe(0);\n\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n    ['foo'], // Pass empty initialize params so the initialize method is called.\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooWorks', []]);\n\n  expect(initializeParm).toBe('foo');\n});\n\nit('returns results immediately when function is synchronous', () => {\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooWorks', []]);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[0][0]).toEqual([\n    PARENT_MESSAGE_OK,\n    1989,\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooThrows', []]);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[1][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'TypeError',\n    'Boo',\n    mockError.stack,\n    {},\n  ]);\n\n  messagePort.emit('message', [\n    CHILD_MESSAGE_CALL,\n    true,\n    'fooThrowsANumber',\n    [],\n  ]);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[2][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'Number',\n    void 0,\n    void 0,\n    412,\n  ]);\n\n  messagePort.emit('message', [\n    CHILD_MESSAGE_CALL,\n    true,\n    'fooThrowsAnErrorWithExtraProperties',\n    [],\n  ]);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[3][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'MockExtendedError',\n    'Boo extended',\n    mockExtendedError.stack,\n    {baz: 123, qux: 456},\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooThrowsNull', []]);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[4][0][0]).toBe(\n    PARENT_MESSAGE_CLIENT_ERROR,\n  );\n  expect(jest.mocked(messagePort.postMessage).mock.calls[4][0][1]).toBe(\n    'Error',\n  );\n  expect(jest.mocked(messagePort.postMessage).mock.calls[4][0][2]).toBe(\n    '\"null\" or \"undefined\" thrown',\n  );\n\n  expect(messagePort.postMessage).toHaveBeenCalledTimes(5);\n});\n\nit('returns results when it gets resolved if function is asynchronous', async () => {\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n  ]);\n\n  messagePort.emit('message', [\n    CHILD_MESSAGE_CALL,\n    true,\n    'fooPromiseWorks',\n    [],\n  ]);\n\n  await sleep(10);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[0][0]).toEqual([\n    PARENT_MESSAGE_OK,\n    1989,\n  ]);\n\n  messagePort.emit('message', [\n    CHILD_MESSAGE_CALL,\n    true,\n    'fooPromiseThrows',\n    [],\n  ]);\n\n  await sleep(10);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[1][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'TypeError',\n    'Boo',\n    mockError.stack,\n    {},\n  ]);\n\n  expect(messagePort.postMessage).toHaveBeenCalledTimes(2);\n});\n\nit('calls the main module if the method call is \"default\"', () => {\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-standalone-worker',\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'default', []]);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[0][0]).toEqual([\n    PARENT_MESSAGE_OK,\n    12_345,\n  ]);\n});\n\nit('calls the main export if the method call is \"default\" and it is a Babel transpiled one', () => {\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-babel-worker',\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'default', []]);\n\n  expect(jest.mocked(messagePort.postMessage).mock.calls[0][0]).toEqual([\n    PARENT_MESSAGE_OK,\n    67_890,\n  ]);\n});\n\nit('removes the message listener on END message', () => {\n  // So that there are no more open handles preventing Node from exiting\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_END, true]);\n\n  expect(messagePort.listenerCount('message')).toBe(0);\n});\n\nit('calls the teardown method ', () => {\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n  ]);\n\n  messagePort.emit('message', [CHILD_MESSAGE_END, true]);\n\n  expect(ended).toBe(true);\n});\n\nit('throws if an invalid message is detected', () => {\n  // Type 27 does not exist.\n  expect(() => {\n    messagePort.emit('message', [27]);\n  }).toThrow(TypeError);\n});\n\nit('throws if child is not forked', () => {\n  // @ts-expect-error: Testing purpose\n  delete messagePort.postMessage;\n\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n  ]);\n\n  expect(() => {\n    messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooWorks', []]);\n  }).toThrow('_worker_threads.parentPort.postMessage is not a function');\n\n  expect(() => {\n    messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooThrows', []]);\n  }).toThrow('_worker_threads.parentPort.postMessage is not a function');\n});\n\nit('handle error if `postMessage` throws an error', () => {\n  messagePort.emit('message', [\n    CHILD_MESSAGE_INITIALIZE,\n    true,\n    './my-fancy-worker',\n  ]);\n\n  jest.mocked(messagePort.postMessage).mockImplementationOnce(() => {\n    throw mockError;\n  });\n\n  messagePort.emit('message', [CHILD_MESSAGE_CALL, true, 'fooWorks', []]);\n  expect(jest.mocked(messagePort.postMessage).mock.calls[1][0]).toEqual([\n    PARENT_MESSAGE_CLIENT_ERROR,\n    'TypeError',\n    'Boo',\n    mockError.stack,\n    {},\n  ]);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport function sum() {\n  throw new Error('throwing fn');\n}"}
{"prompt":"Test generated from existing file","test":"{\n  \"version\": 3,\n  \"sources\": [\n    \"../throwing-mapped-fn.js\"\n  ],\n  \"names\": [\n    \"sum\",\n    \"Error\"\n  ],\n  \"mappings\": \";;;;;QAQgBA,G,GAAAA,G;AARhB;;;;;;;;AAQO,SAASA,GAAT,GAAe;AACpB,QAAM,IAAIC,KAAJ,CAAU,aAAV,CAAN;AACD\",\n  \"file\": \"throwing-mapped-fn.js\",\n  \"sourcesContent\": [\n    \"/**\\n * Copyright (c) Meta Platforms, Inc. and affiliates.\\n *\\n * This source code is licensed under the BSD-style license found in the\\n * LICENSE file in the root directory of this source tree. An additional grant\\n * of patent rights can be found in the PATENTS file in the same directory.\\n */\\n\\nexport function sum() {\\n  throw new Error('throwing fn');\\n};\\n\"\n  ]\n}"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nthrow new Error('throwing');"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports = function sum() {\n  throw new Error('throwing fn');\n};"}
{"prompt":"throw matcher can take func,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {type Context, toThrowErrorMatchingSnapshot} from '..';\n\nconst mockedMatch = jest.fn<\n  (args: {received: string; testName: string}) => unknown\n>(() => ({\n  actual: 'coconut',\n  expected: 'coconut',\n}));\n\nconst mockedContext = {\n  snapshotState: {match: mockedMatch},\n} as unknown as Context;\n\nafterEach(() => {\n  jest.clearAllMocks();\n});\n\nit('throw matcher can take func', () => {\n  toThrowErrorMatchingSnapshot.call(\n    mockedContext,\n    () => {\n      throw new Error('coconut');\n    },\n    undefined,\n    false,\n  );\n\n  expect(mockedMatch).toHaveBeenCalledTimes(1);\n  expect(mockedMatch).toHaveBeenCalledWith(\n    expect.objectContaining({received: 'coconut', testName: ''}),\n  );\n});\n\ndescribe('throw matcher from promise', () => {\n  it('can take error', () => {\n    toThrowErrorMatchingSnapshot.call(\n      mockedContext,\n      new Error('coco'),\n      'testName',\n      true,\n    );\n\n    expect(mockedMatch).toHaveBeenCalledTimes(1);\n    expect(mockedMatch).toHaveBeenCalledWith(\n      expect.objectContaining({received: 'coco', testName: ''}),\n    );\n  });\n\n  it('can take custom error', () => {\n    class CustomError extends Error {}\n\n    toThrowErrorMatchingSnapshot.call(\n      mockedContext,\n      new CustomError('nut'),\n      'testName',\n      true,\n    );\n\n    expect(mockedMatch).toHaveBeenCalledTimes(1);\n    expect(mockedMatch).toHaveBeenCalledWith(\n      expect.objectContaining({received: 'nut', testName: ''}),\n    );\n  });\n});"}
{"prompt":"eslint-disable-next-line no-throw-leral","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n// eslint-disable-next-line no-throw-literal\nthrow 1;"}
{"prompt":"eslint-disable-next-line no-throw-leral","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n// eslint-disable-next-line no-throw-literal\nthrow {};"}
{"prompt":"eslint-disable-next-line no-throw-leral","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n// eslint-disable-next-line no-throw-literal\nthrow {stack: 42};"}
{"prompt":"eslint-disable-next-line no-throw-leral","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n// eslint-disable-next-line no-throw-literal\nthrow 'banana';"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {cleanup, extractSummary, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../timeouts');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('exceeds the timeout', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': `\n      jest.setTimeout(20);\n\n      test('banana', () => {\n        return new Promise(resolve => {\n          setTimeout(resolve, 100);\n        });\n      });\n    `,\n    'package.json': '{}',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false']);\n  const {rest, summary} = extractSummary(stderr);\n  const regexToMatch =\n    process.env.JEST_JASMINE === '1'\n      ? /(Async callback was not invoked within the 20 ms timeout specified by jest\\.setTimeout\\.)/\n      : /(Exceeded timeout of 20 ms for a test\\.)/;\n\n  expect(rest).toMatch(/(jest\\.setTimeout\\(20\\))/);\n  expect(rest).toMatch(regexToMatch);\n  expect(summary).toMatchSnapshot();\n  expect(exitCode).toBe(1);\n});\n\ntest('does not exceed the timeout', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': `\n      jest.setTimeout(1000);\n\n      test('banana', () => {\n        return new Promise(resolve => {\n          setTimeout(resolve, 20);\n        });\n      });\n    `,\n    'package.json': '{}',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false']);\n  const {rest, summary} = extractSummary(stderr);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n  expect(exitCode).toBe(0);\n});\n\ntest('exceeds the command line testTimeout', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': `\n\n      test('banana', () => {\n        return new Promise(resolve => {\n          setTimeout(resolve, 1000);\n        });\n      });\n    `,\n    'package.json': '{}',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, [\n    '-w=1',\n    '--ci=false',\n    '--testTimeout=200',\n  ]);\n  const {rest, summary} = extractSummary(stderr);\n  const regexToMatch =\n    process.env.JEST_JASMINE === '1'\n      ? /(Async callback was not invoked within the 200 ms timeout specified by jest\\.setTimeout\\.)/\n      : /(Exceeded timeout of 200 ms for a test\\.)/;\n  expect(rest).toMatch(regexToMatch);\n  expect(summary).toMatchSnapshot();\n  expect(exitCode).toBe(1);\n});\n\ntest('does not exceed the command line testTimeout', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': `\n\n      test('banana', () => {\n        return new Promise(resolve => {\n          setTimeout(resolve, 200);\n        });\n      });\n    `,\n    'package.json': '{}',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, [\n    '-w=1',\n    '--ci=false',\n    '--testTimeout=1000',\n  ]);\n  const {rest, summary} = extractSummary(stderr);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n  expect(exitCode).toBe(0);\n});\n\ntest('exceeds the timeout parameter', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': `\n\n      test('banana', () => {\n        return new Promise(resolve => {\n          setTimeout(resolve, 1000);\n        });\n      }, 200);\n    `,\n    'package.json': '{}',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false']);\n  const {rest, summary} = extractSummary(stderr);\n  const regexToMatch =\n    process.env.JEST_JASMINE === '1'\n      ? /(Async callback was not invoked within the 200 ms timeout specified by jest\\.setTimeout\\.)/\n      : /(Exceeded timeout of 200 ms for a test\\.)/;\n  expect(rest).toMatch(regexToMatch);\n  expect(summary).toMatchSnapshot();\n  expect(exitCode).toBe(1);\n});\n\ntest('does not exceed the timeout parameter', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': `\n\n      test('banana', () => {\n        return new Promise(resolve => {\n          setTimeout(resolve, 200);\n        });\n      }, 1000);\n    `,\n    'package.json': '{}',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false']);\n  const {rest, summary} = extractSummary(stderr);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n  expect(exitCode).toBe(0);\n});\n\ntest('exceeds the timeout specifying that `done` has not been called', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': `\n      jest.setTimeout(20);\n\n      test('banana', (done) => {\n        expect(1 + 1).toBe(2);\n      });\n    `,\n    'package.json': '{}',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false']);\n  const {rest, summary} = extractSummary(stderr);\n  const regexToMatch =\n    process.env.JEST_JASMINE === '1'\n      ? /(Async callback was not invoked within the 20 ms timeout specified by jest\\.setTimeout\\.)/\n      : /(Exceeded timeout of 20 ms for a test while waiting for `done\\(\\)` to be called\\.)/;\n  expect(rest).toMatch(/(jest\\.setTimeout\\(20\\))/);\n  expect(rest).toMatch(regexToMatch);\n  expect(summary).toMatchSnapshot();\n  expect(exitCode).toBe(1);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`does not exceed the command line testTimeout 1`] = `\n\"PASS __tests__/a-banana.js\n  ✓ banana\"\n`;\n\nexports[`does not exceed the command line testTimeout 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`does not exceed the timeout 1`] = `\n\"PASS __tests__/a-banana.js\n  ✓ banana\"\n`;\n\nexports[`does not exceed the timeout 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`does not exceed the timeout parameter 1`] = `\n\"PASS __tests__/a-banana.js\n  ✓ banana\"\n`;\n\nexports[`does not exceed the timeout parameter 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`exceeds the command line testTimeout 1`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       1 failed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`exceeds the timeout 1`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       1 failed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`exceeds the timeout parameter 1`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       1 failed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`exceeds the timeout specifying that \\`done\\` has not been called 1`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       1 failed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {skipSuiteOnJestCircus} from '@jest/test-utils';\nimport {cleanup, extractSummary, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\n/**\n * NOTE: This test should be removed once jest-circus is rolled out as a breaking change.\n */\n\nconst DIR = path.resolve(__dirname, '../timeouts-legacy');\n\nskipSuiteOnJestCircus();\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('exceeds the timeout set using jasmine.DEFAULT_TIMEOUT_INTERVAL', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': `\n      jasmine.DEFAULT_TIMEOUT_INTERVAL = 20;\n\n      test('banana', () => {\n        return new Promise(resolve => {\n          setTimeout(resolve, 100);\n        });\n      });\n    `,\n    'package.json': '{}',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false']);\n  const {rest, summary} = extractSummary(stderr);\n  expect(rest).toMatch(\n    /(jest\\.setTimeout|jasmine\\.DEFAULT_TIMEOUT_INTERVAL|Exceeded timeout)/,\n  );\n  expect(summary).toMatchSnapshot();\n  expect(exitCode).toBe(1);\n});\n\ntest('does not exceed the timeout using jasmine.DEFAULT_TIMEOUT_INTERVAL', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': `\n      jasmine.DEFAULT_TIMEOUT_INTERVAL = 1000;\n\n      test('banana', () => {\n        return new Promise(resolve => {\n          setTimeout(resolve, 20);\n        });\n      });\n    `,\n    'package.json': '{}',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false']);\n  const {rest, summary} = extractSummary(stderr);\n  expect(rest).toMatchSnapshot();\n  expect(summary).toMatchSnapshot();\n  expect(exitCode).toBe(0);\n});\n\ntest('can read and write jasmine.DEFAULT_TIMEOUT_INTERVAL', () => {\n  writeFiles(DIR, {\n    '__tests__/a-banana.js': `\n      const timeout = jasmine.DEFAULT_TIMEOUT_INTERVAL;\n      jasmine.DEFAULT_TIMEOUT_INTERVAL = 154;\n      const newTimeout = jasmine.DEFAULT_TIMEOUT_INTERVAL;\n\n      test('banana', () => {\n        expect(timeout).toBe(5000);\n        expect(newTimeout).toBe(154);\n      });\n    `,\n    'package.json': '{}',\n  });\n\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false']);\n  const {summary} = extractSummary(stderr);\n  expect(summary).toMatchSnapshot();\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`can read and write jasmine.DEFAULT_TIMEOUT_INTERVAL 1`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`does not exceed the timeout using jasmine.DEFAULT_TIMEOUT_INTERVAL 1`] = `\n\"PASS __tests__/a-banana.js\n  ✓ banana\"\n`;\n\nexports[`does not exceed the timeout using jasmine.DEFAULT_TIMEOUT_INTERVAL 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`exceeds the timeout set using jasmine.DEFAULT_TIMEOUT_INTERVAL 1`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       1 failed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ntest('reads timerLimit from Jest config', () => {\n  jest.useFakeTimers();\n\n  setTimeout(function infinitelyRecursingCallback() {\n    setTimeout(infinitelyRecursingCallback, 0);\n  }, 0);\n\n  expect(() => {\n    jest.runAllTimers();\n  }).toThrow(\n    new Error('Aborting after running 10 timers, assuming an infinite loop!'),\n  );\n});\n\ntest('allows to override timerLimit set via Jest config', () => {\n  jest.useFakeTimers({timerLimit: 100});\n\n  setTimeout(function infinitelyRecursingCallback() {\n    setTimeout(infinitelyRecursingCallback, 0);\n  }, 0);\n\n  expect(() => {\n    jest.runAllTimers();\n  }).toThrow(\n    new Error('Aborting after running 100 timers, assuming an infinite loop!'),\n  );\n});\n\ntest('allows to override timerLimit set via Jest object', () => {\n  jest.useFakeTimers({timerLimit: 1000});\n\n  setTimeout(function infinitelyRecursingCallback() {\n    setTimeout(infinitelyRecursingCallback, 0);\n  }, 0);\n\n  expect(() => {\n    jest.runAllTimers();\n  }).toThrow(\n    new Error('Aborting after running 1000 timers, assuming an infinite loop!'),\n  );\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\n'use strict';\n\njest.useFakeTimers();\n\ndescribe('timerGame', () => {\n  beforeEach(() => {\n    jest.spyOn(globalThis, 'setTimeout');\n  });\n  it('waits 1 second before ending the game', () => {\n    const timerGame = require('../timerGame');\n    timerGame();\n\n    expect(setTimeout).toHaveBeenCalledTimes(1);\n    expect(setTimeout).toHaveBeenCalledWith(expect.any(Function), 1000);\n  });\n\n  it('calls the callback after 1 second via runAllTimers', () => {\n    const timerGame = require('../timerGame');\n    const callback = jest.fn();\n\n    timerGame(callback);\n\n    // At this point in time, the callback should not have been called yet\n    expect(callback).not.toHaveBeenCalled();\n\n    // Fast-forward until all timers have been executed\n    jest.runAllTimers();\n\n    // Now our callback should have been called!\n    expect(callback).toHaveBeenCalled();\n    expect(callback).toHaveBeenCalledTimes(1);\n  });\n\n  it('calls the callback after 1 second via advanceTimersByTime', () => {\n    const timerGame = require('../timerGame');\n    const callback = jest.fn();\n\n    timerGame(callback);\n\n    // At this point in time, the callback should not have been called yet\n    expect(callback).not.toHaveBeenCalled();\n\n    // Fast-forward until all timers have been executed\n    jest.advanceTimersByTime(1000);\n\n    // Now our callback should have been called!\n    expect(callback).toHaveBeenCalled();\n    expect(callback).toHaveBeenCalledTimes(1);\n  });\n});"}
{"prompt":"Custom Reporters,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\ndescribe('Custom Reporters', () => {\n  it.todo('sample');\n});"}
{"prompt":"test/it.todo error throwing,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\ndescribe('test/it.todo error throwing', () => {\n  it('it throws error when given no arguments', () => {\n    expect(() => {\n      // @ts-expect-error\n      it.todo();\n    }).toThrow('Todo must be called with only a description.');\n  });\n  it('it throws error when given more than one argument', () => {\n    expect(() => {\n      // @ts-expect-error: Testing runtime errors here\n      it.todo('test1', () => {});\n    }).toThrow('Todo must be called with only a description.');\n  });\n  it('it throws error when given none string description', () => {\n    expect(() => {\n      it.todo(() => {});\n    }).toThrow('Todo must be called with only a description.');\n  });\n});"}
{"prompt":".todotodo later,  => {};","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit.todo('todo later', () => {});"}
{"prompt":".todo;","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit.todo();"}
{"prompt":".todo => {};","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nit.todo(() => {});"}
{"prompt":"/ <reference lib=dom />","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n/// <reference lib=\"dom\" />\n\n/* global document */\n\nimport {expect} from '@jest/globals';\n\ndescribe('toEqual', () => {\n  describe('duck type', () => {\n    // https://github.com/jestjs/jest/issues/7786\n\n    const createElement = (name: string, ...childNodes: Array<unknown>) => ({\n      childNodes,\n      nodeType: 1,\n      tagName: name.toUpperCase(),\n    });\n\n    const createTextNode = (data: unknown) => ({\n      data,\n      nodeType: 3,\n    });\n\n    const createDocumentFragment = (...children: Array<unknown>) => ({\n      children,\n      nodeType: 11,\n    });\n\n    describe('Text', () => {\n      test('isNot false', () => {\n        const data = 'deep equal';\n\n        const a = createTextNode(data);\n        const b = createTextNode(data);\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });\n\n      test('isNot true', () => {\n        const a = createTextNode('not deep equal a');\n        const b = createTextNode('not deep equal b');\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });\n    });\n\n    describe('Element', () => {\n      test('isNot false', () => {\n        const name = 'span';\n        const data = 'deep equal';\n\n        const a = createElement(name, createTextNode(data));\n        const b = createElement(name, createTextNode(data));\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });\n\n      test('isNot true', () => {\n        const data = 'not deep equal';\n\n        const a = createElement('strong', createTextNode(data));\n        const b = createElement('span', createTextNode(data));\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });\n    });\n\n    describe('Fragment', () => {\n      test('isNot false', () => {\n        const name1 = 'strong';\n        const name2 = 'span';\n        const data1 = 'deep';\n        const data2 = 'equal';\n\n        const a = createDocumentFragment(\n          createElement(name1, createTextNode(data1)),\n          createElement(name2, createTextNode(data2)),\n        );\n        const b = createDocumentFragment(\n          createElement(name1, createTextNode(data1)),\n          createElement(name2, createTextNode(data2)),\n        );\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });\n\n      test('isNot true', () => {\n        const name = 'span';\n        const data1 = 'not';\n        const data2 = 'deep equal';\n\n        const a = createDocumentFragment(\n          createElement('strong', createTextNode(data1)),\n          createElement(name, createTextNode(data2)),\n        );\n        const b = createDocumentFragment(\n          createElement(name, createTextNode(data1)),\n          createElement(name, createTextNode(data2)),\n        );\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });\n    });\n  });\n\n  describe('document', () => {\n    describe('createTextNode', () => {\n      test('isNot false', () => {\n        const data = 'deep equal';\n\n        const a = document.createTextNode(data);\n        const b = document.createTextNode(data);\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });\n\n      test('isNot true', () => {\n        const a = document.createTextNode('not deep equal a');\n        const b = document.createTextNode('not deep equal b');\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });\n    });\n\n    describe('createElement', () => {\n      test('isNot false', () => {\n        const name = 'span';\n        const data = 'deep equal';\n\n        const a = document.createElement(name);\n        const b = document.createElement(name);\n        a.append(document.createTextNode(data));\n        b.append(document.createTextNode(data));\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });\n\n      test('isNot true', () => {\n        const data = 'not deep equal';\n\n        const a = document.createElement('strong');\n        const b = document.createElement('span');\n        a.append(document.createTextNode(data));\n        b.append(document.createTextNode(data));\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });\n    });\n\n    describe('createDocumentFragment', () => {\n      test('isNot false', () => {\n        const name1 = 'strong';\n        const name2 = 'span';\n        const data1 = 'deep';\n        const data2 = 'equal';\n\n        const aSpan1 = document.createElement(name1);\n        const bSpan1 = document.createElement(name1);\n        aSpan1.append(document.createTextNode(data1));\n        bSpan1.append(document.createTextNode(data1));\n\n        const aSpan2 = document.createElement(name2);\n        const bSpan2 = document.createElement(name2);\n        aSpan2.append(document.createTextNode(data2));\n        bSpan2.append(document.createTextNode(data2));\n\n        const a = document.createDocumentFragment();\n        const b = document.createDocumentFragment();\n        a.append(aSpan1);\n        a.append(aSpan2);\n        b.append(bSpan1);\n        b.append(bSpan2);\n\n        expect(a).toEqual(b);\n        expect(b).toEqual(a);\n      });\n\n      test('isNot true', () => {\n        const name = 'span';\n        const data1 = 'not';\n        const data2 = 'deep equal';\n\n        const aSpan1 = document.createElement('strong');\n        const bSpan1 = document.createElement(name);\n        aSpan1.append(document.createTextNode(data1));\n        bSpan1.append(document.createTextNode(data1));\n\n        const aSpan2 = document.createElement(name);\n        const bSpan2 = document.createElement(name);\n        aSpan2.append(document.createTextNode(data2));\n        bSpan2.append(document.createTextNode(data2));\n\n        const a = document.createDocumentFragment();\n        const b = document.createDocumentFragment();\n        a.append(aSpan1);\n        a.append(aSpan2);\n        b.append(bSpan1);\n        b.append(bSpan2);\n\n        expect(a).not.toEqual(b);\n        expect(b).not.toEqual(a);\n      });\n    });\n  });\n});"}
{"prompt":"works with inline snapshots,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {cleanup, extractSummary, makeTemplate, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../to-match-inline-snapshot');\nconst TESTS_DIR = path.resolve(DIR, '__tests__');\n\nconst readFile = (filename: string) =>\n  fs.readFileSync(path.join(TESTS_DIR, filename), 'utf8');\n\nbeforeEach(() => cleanup(TESTS_DIR));\nafterAll(() => cleanup(TESTS_DIR));\n\ntest('basic support', () => {\n  const filename = 'basic-support.test.js';\n  const template = makeTemplate(\n    \"test('inline snapshots', () => expect($1).toMatchInlineSnapshot());\\n\",\n  );\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['{apple: \"original value\"}']),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n    expect(fileAfter).toMatchSnapshot('initial write');\n  }\n\n  {\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(stderr).not.toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n    expect(fileAfter).toMatchSnapshot('snapshot passed');\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: readFile(filename).replace('original value', 'updated value'),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('Snapshot name: `inline snapshots 1`');\n    expect(exitCode).toBe(1);\n    expect(fileAfter).toMatchSnapshot('snapshot mismatch');\n  }\n\n  {\n    const {stderr, exitCode} = runJest(DIR, [\n      '-w=1',\n      '--ci=false',\n      filename,\n      '-u',\n    ]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('1 snapshot updated from 1 test suite.');\n    expect(exitCode).toBe(0);\n    expect(fileAfter).toMatchSnapshot('snapshot updated');\n  }\n});\n\ntest('do not indent empty lines', () => {\n  const filename = 'empty-line-indent.test.js';\n  const template = makeTemplate(\n    \"test('inline snapshots', () => expect($1).toMatchInlineSnapshot());\\n\",\n  );\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['`hello\\n\\nworld`']),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n    expect(fileAfter).toMatchSnapshot('initial write');\n  }\n\n  {\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(stderr).not.toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n    expect(fileAfter).toMatchSnapshot('snapshot passed');\n  }\n});\n\ntest('handles property matchers', () => {\n  const filename = 'handle-property-matchers.test.js';\n  const template = makeTemplate(`test('handles property matchers', () => {\n      expect({createdAt: $1}).toMatchInlineSnapshot({createdAt: expect.any(Date)});\n    });\n    `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template(['new Date()'])});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n    expect(fileAfter).toMatchSnapshot('initial write');\n  }\n\n  {\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(exitCode).toBe(0);\n    expect(fileAfter).toMatchSnapshot('snapshot passed');\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: readFile(filename).replace('new Date()', '\"string\"'),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('Snapshot name: `handles property matchers 1`');\n    expect(stderr).toMatch('Snapshots:   1 failed, 1 total');\n    expect(exitCode).toBe(1);\n    expect(fileAfter).toMatchSnapshot('snapshot failed');\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: readFile(filename).replace('any(Date)', 'any(String)'),\n    });\n    const {stderr, exitCode} = runJest(DIR, [\n      '-w=1',\n      '--ci=false',\n      filename,\n      '-u',\n    ]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('1 snapshot updated from 1 test suite.');\n    expect(exitCode).toBe(0);\n    expect(fileAfter).toMatchSnapshot('snapshot updated');\n  }\n});\n\ntest('removes obsolete external snapshots', () => {\n  const filename = 'removes-obsolete-external-snapshots.test.js';\n  const snapshotPath = path.join(\n    TESTS_DIR,\n    '__snapshots__',\n    `${filename}.snap`,\n  );\n  const template = makeTemplate(`\n    test('removes obsolete external snapshots', () => {\n      expect('1').$1();\n    });\n  `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template(['toMatchSnapshot'])});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n    expect(fileAfter).toMatchSnapshot('initial write');\n    expect(fs.existsSync(snapshotPath)).toBe(true);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template(['toMatchInlineSnapshot'])});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('Snapshots:   1 obsolete, 1 written, 1 total');\n    expect(exitCode).toBe(1);\n    expect(fileAfter).toMatchSnapshot('inline snapshot written');\n    expect(fs.existsSync(snapshotPath)).toBe(true);\n  }\n\n  {\n    const {stderr, exitCode} = runJest(DIR, [\n      '-w=1',\n      '--ci=false',\n      filename,\n      '-u',\n    ]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('Snapshots:   1 file removed, 1 passed, 1 total');\n    expect(exitCode).toBe(0);\n    expect(fileAfter).toMatchSnapshot('external snapshot cleaned');\n    expect(fs.existsSync(snapshotPath)).toBe(false);\n  }\n});\n\ntest('supports async matchers', () => {\n  const filename = 'async-matchers.test.js';\n  const test = `\n    test('inline snapshots', async () => {\n      expect(Promise.resolve('success')).resolves.toMatchInlineSnapshot();\n      expect(Promise.reject('fail')).rejects.toMatchInlineSnapshot();\n    });\n  `;\n\n  writeFiles(TESTS_DIR, {[filename]: test});\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n  const fileAfter = readFile(filename);\n  expect(stderr).toMatch('2 snapshots written from 1 test suite.');\n  expect(exitCode).toBe(0);\n  expect(fileAfter).toMatchSnapshot();\n});\n\ntest('supports async tests', () => {\n  const filename = 'async.test.js';\n  const test = `\n    test('inline snapshots', async () => {\n      await 'next tick';\n      expect(42).toMatchInlineSnapshot();\n    });\n  `;\n\n  writeFiles(TESTS_DIR, {[filename]: test});\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n  const fileAfter = readFile(filename);\n  expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n  expect(exitCode).toBe(0);\n  expect(fileAfter).toMatchSnapshot();\n});\n\ntest('writes snapshots with non-literals in expect(...)', () => {\n  const filename = 'async.test.js';\n  const test = `\n    it('works with inline snapshots', () => {\n      expect({a: 1}).toMatchInlineSnapshot();\n    });\n  `;\n\n  writeFiles(TESTS_DIR, {[filename]: test});\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n\n  const fileAfter = readFile(filename);\n  expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n  expect(exitCode).toBe(0);\n  expect(fileAfter).toMatchSnapshot();\n});\n\n// issue: https://github.com/jestjs/jest/issues/6702\ntest('handles mocking native modules prettier relies on', () => {\n  const filename = 'mockFail.test.js';\n  const test = `\n    jest.mock('path', () => ({}));\n    jest.mock('fs', () => ({}));\n    jest.mock('graceful-fs', () => ({}));\n    test('inline snapshots', () => {\n      expect({}).toMatchInlineSnapshot();\n    });\n  `;\n\n  writeFiles(TESTS_DIR, {[filename]: test});\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n  expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n  expect(exitCode).toBe(0);\n});\n\ntest('supports custom matchers', () => {\n  const filename = 'custom-matchers.test.js';\n  const test = `\n    const { toMatchInlineSnapshot } = require('jest-snapshot');\n    expect.extend({\n      toMatchCustomInlineSnapshot(received, ...args) {\n        return toMatchInlineSnapshot.call(this, received, ...args);\n      }\n    });\n    test('inline snapshots', () => {\n      expect({apple: \"original value\"}).toMatchCustomInlineSnapshot();\n    });\n  `;\n\n  writeFiles(TESTS_DIR, {[filename]: test});\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n  const fileAfter = readFile(filename);\n  expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n  expect(exitCode).toBe(0);\n  expect(fileAfter).toMatchSnapshot('custom matchers');\n});\n\ntest('supports custom matchers with property matcher', () => {\n  const filename = 'custom-matchers-with-property-matcher.test.js';\n  const test = `\n    const { toMatchInlineSnapshot } = require('jest-snapshot');\n    expect.extend({\n      toMatchCustomInlineSnapshot(received, ...args) {\n        return toMatchInlineSnapshot.call(this, received, ...args);\n      },\n      toMatchUserInlineSnapshot(received, ...args) {\n        return toMatchInlineSnapshot.call(\n          this,\n          received,\n          {\n            createdAt: expect.any(Date),\n            id: expect.any(Number),\n          },\n          ...args\n        );\n      },\n    });\n    test('inline snapshots', () => {\n      const user = {\n        createdAt: new Date(),\n        id: Math.floor(Math.random() * 20),\n        name: 'LeBron James',\n      };\n      expect(user).toMatchCustomInlineSnapshot({\n        createdAt: expect.any(Date),\n        id: expect.any(Number),\n      });\n      expect(user).toMatchUserInlineSnapshot();\n    });\n  `;\n\n  writeFiles(TESTS_DIR, {[filename]: test});\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n  const fileAfter = readFile(filename);\n  expect(stderr).toMatch('2 snapshots written from 1 test suite.');\n  expect(exitCode).toBe(0);\n  expect(fileAfter).toMatchSnapshot('custom matchers with property matcher');\n});\n\ntest('multiple custom matchers and native matchers', () => {\n  const filename = 'multiple-matchers.test.js';\n  const test = `\n    const { toMatchInlineSnapshot } = require('jest-snapshot');\n    expect.extend({\n      toMatchCustomInlineSnapshot(received, ...args) {\n        return toMatchInlineSnapshot.call(this, received, ...args);\n      },\n      toMatchCustomInlineSnapshot2(received, ...args) {\n        return toMatchInlineSnapshot.call(this, received, ...args);\n      },\n    });\n    test('inline snapshots', () => {\n      expect({apple: \"value 1\"}).toMatchCustomInlineSnapshot();\n      expect({apple: \"value 2\"}).toMatchInlineSnapshot();\n      expect({apple: \"value 3\"}).toMatchCustomInlineSnapshot2();\n      expect({apple: \"value 4\"}).toMatchInlineSnapshot();\n    });\n  `;\n\n  writeFiles(TESTS_DIR, {[filename]: test});\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n  const fileAfter = readFile(filename);\n  expect(stderr).toMatch('4 snapshots written from 1 test suite.');\n  expect(exitCode).toBe(0);\n  expect(fileAfter).toMatchSnapshot('multiple matchers');\n});\n\ntest('indentation is correct in the presences of existing snapshots', () => {\n  const filename = 'existing-snapshot.test.js';\n  const test = `\n    test('existing snapshot', () => {\n      expect({ hello: 'world' }).toMatchInlineSnapshot(\\`\n        {\n          \"hello\": \"world\",\n        }\n      \\`);\n      expect({ hello: 'world' }).toMatchInlineSnapshot();\n    });\n  `;\n\n  writeFiles(TESTS_DIR, {[filename]: test});\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n  const fileAfter = readFile(filename);\n  expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n  expect(exitCode).toBe(0);\n  expect(fileAfter).toMatchSnapshot('existing snapshot');\n});\n\ntest('indentation is correct in the presences of existing snapshots, when the file is correctly formatted by prettier', () => {\n  const filename = 'existing-snapshot.test.js';\n  const test = `\n    it('is true', () => {\n      expect(true).toMatchInlineSnapshot(\\`true\\`);\n      expect([1, 2, 3]).toMatchInlineSnapshot();\n    });\\\\n\n  `;\n\n  writeFiles(TESTS_DIR, {[filename]: test});\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n  const fileAfter = readFile(filename);\n  expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n  expect(exitCode).toBe(0);\n  expect(fileAfter).toMatchSnapshot('existing snapshot');\n});\n\ntest('diff with prototype is correct', () => {\n  const filename = 'with-prototype-diff.test.js';\n  const test = `\n    test('diff with prototype is correct', () => {\n      expect({ hello: 'world' }).toMatchInlineSnapshot(\\`\n        Object {\n          \"hello\": \"world\",\n        }\n      \\`);\n    });\n  `;\n\n  writeFiles(TESTS_DIR, {[filename]: test});\n  const {stderr, exitCode} = runJest(DIR, ['--run-in-band', filename]);\n  expect(extractSummary(stderr).rest).toMatchSnapshot();\n  expect(exitCode).toBe(1);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`basic support: initial write 1`] = `\n\"test('inline snapshots', () =>\n  expect({apple: 'original value'}).toMatchInlineSnapshot(\\`\n    {\n      \"apple\": \"original value\",\n    }\n  \\`));\n\"\n`;\n\nexports[`basic support: snapshot mismatch 1`] = `\n\"test('inline snapshots', () =>\nexpect({apple: 'updated value'}).toMatchInlineSnapshot(\\`\n  {\n    \"apple\": \"original value\",\n  }\n\\`));\"\n`;\n\nexports[`basic support: snapshot passed 1`] = `\n\"test('inline snapshots', () =>\n  expect({apple: 'original value'}).toMatchInlineSnapshot(\\`\n    {\n      \"apple\": \"original value\",\n    }\n  \\`));\n\"\n`;\n\nexports[`basic support: snapshot updated 1`] = `\n\"test('inline snapshots', () =>\n  expect({apple: 'updated value'}).toMatchInlineSnapshot(\\`\n    {\n      \"apple\": \"updated value\",\n    }\n  \\`));\n\"\n`;\n\nexports[`diff with prototype is correct 1`] = `\n\"FAIL __tests__/with-prototype-diff.test.js\n  ✕ diff with prototype is correct\n\n  ● diff with prototype is correct\n\n    expect(received).toMatchInlineSnapshot(snapshot)\n\n    Snapshot name: \\`diff with prototype is correct 1\\`\n\n    - Snapshot  - 1\n    + Received  + 1\n\n    - Object {\n    + {\n        \"hello\": \"world\",\n      }\n\n      1 | test('diff with prototype is correct', () => {\n    > 2 |   expect({ hello: 'world' }).toMatchInlineSnapshot(\\`\n        |                              ^\n      3 |     Object {\n      4 |       \"hello\": \"world\",\n      5 |     }\n\n      at Object.toMatchInlineSnapshot (__tests__/with-prototype-diff.test.js:2:30)\n\n › 1 snapshot failed.\nSnapshot Summary\n › 1 snapshot failed from 1 test suite. Inspect your code changes or re-run jest with \\`-u\\` to update them.\"\n`;\n\nexports[`do not indent empty lines: initial write 1`] = `\n\"test('inline snapshots', () =>\n  expect(\\`hello\n\nworld\\`).toMatchInlineSnapshot(\\`\n    \"hello\n\n    world\"\n  \\`));\n\"\n`;\n\nexports[`do not indent empty lines: snapshot passed 1`] = `\n\"test('inline snapshots', () =>\n  expect(\\`hello\n\nworld\\`).toMatchInlineSnapshot(\\`\n    \"hello\n\n    world\"\n  \\`));\n\"\n`;\n\nexports[`handles property matchers: initial write 1`] = `\n\"test('handles property matchers', () => {\n  expect({createdAt: new Date()}).toMatchInlineSnapshot(\n    {createdAt: expect.any(Date)},\n    \\`\n    {\n      \"createdAt\": Any<Date>,\n    }\n  \\`,\n  );\n});\n\"\n`;\n\nexports[`handles property matchers: snapshot failed 1`] = `\n\"test('handles property matchers', () => {\nexpect({createdAt: \"string\"}).toMatchInlineSnapshot(\n  {createdAt: expect.any(Date)},\n  \\`\n  {\n    \"createdAt\": Any<Date>,\n  }\n\\`,\n);\n});\"\n`;\n\nexports[`handles property matchers: snapshot passed 1`] = `\n\"test('handles property matchers', () => {\n  expect({createdAt: new Date()}).toMatchInlineSnapshot(\n    {createdAt: expect.any(Date)},\n    \\`\n    {\n      \"createdAt\": Any<Date>,\n    }\n  \\`,\n  );\n});\n\"\n`;\n\nexports[`handles property matchers: snapshot updated 1`] = `\n\"test('handles property matchers', () => {\n  expect({createdAt: 'string'}).toMatchInlineSnapshot(\n    {createdAt: expect.any(String)},\n    \\`\n    {\n      \"createdAt\": Any<String>,\n    }\n  \\`,\n  );\n});\n\"\n`;\n\nexports[`indentation is correct in the presences of existing snapshots, when the file is correctly formatted by prettier: existing snapshot 1`] = `\n\"it('is true', () => {\n  expect(true).toMatchInlineSnapshot(\\`true\\`);\n  expect([1, 2, 3]).toMatchInlineSnapshot(\\`\n    [\n      1,\n      2,\n      3,\n    ]\n  \\`);\n});\n\"\n`;\n\nexports[`indentation is correct in the presences of existing snapshots: existing snapshot 1`] = `\n\"test('existing snapshot', () => {\n  expect({hello: 'world'}).toMatchInlineSnapshot(\\`\n    {\n      \"hello\": \"world\",\n    }\n  \\`);\n  expect({hello: 'world'}).toMatchInlineSnapshot(\\`\n    {\n      \"hello\": \"world\",\n    }\n  \\`);\n});\n\"\n`;\n\nexports[`multiple custom matchers and native matchers: multiple matchers 1`] = `\n\"const {toMatchInlineSnapshot} = require('jest-snapshot');\nexpect.extend({\n  toMatchCustomInlineSnapshot(received, ...args) {\n    return toMatchInlineSnapshot.call(this, received, ...args);\n  },\n  toMatchCustomInlineSnapshot2(received, ...args) {\n    return toMatchInlineSnapshot.call(this, received, ...args);\n  },\n});\ntest('inline snapshots', () => {\n  expect({apple: 'value 1'}).toMatchCustomInlineSnapshot(\\`\n    {\n      \"apple\": \"value 1\",\n    }\n  \\`);\n  expect({apple: 'value 2'}).toMatchInlineSnapshot(\\`\n    {\n      \"apple\": \"value 2\",\n    }\n  \\`);\n  expect({apple: 'value 3'}).toMatchCustomInlineSnapshot2(\\`\n    {\n      \"apple\": \"value 3\",\n    }\n  \\`);\n  expect({apple: 'value 4'}).toMatchInlineSnapshot(\\`\n    {\n      \"apple\": \"value 4\",\n    }\n  \\`);\n});\n\"\n`;\n\nexports[`removes obsolete external snapshots: external snapshot cleaned 1`] = `\n\"test('removes obsolete external snapshots', () => {\n  expect('1').toMatchInlineSnapshot(\\`\"1\"\\`);\n});\n\"\n`;\n\nexports[`removes obsolete external snapshots: initial write 1`] = `\n\"test('removes obsolete external snapshots', () => {\n  expect('1').toMatchSnapshot();\n});\"\n`;\n\nexports[`removes obsolete external snapshots: inline snapshot written 1`] = `\n\"test('removes obsolete external snapshots', () => {\n  expect('1').toMatchInlineSnapshot(\\`\"1\"\\`);\n});\n\"\n`;\n\nexports[`supports async matchers 1`] = `\n\"test('inline snapshots', async () => {\n  expect(Promise.resolve('success')).resolves.toMatchInlineSnapshot(\n    \\`\"success\"\\`,\n  );\n  expect(Promise.reject('fail')).rejects.toMatchInlineSnapshot(\\`\"fail\"\\`);\n});\n\"\n`;\n\nexports[`supports async tests 1`] = `\n\"test('inline snapshots', async () => {\n  await 'next tick';\n  expect(42).toMatchInlineSnapshot(\\`42\\`);\n});\n\"\n`;\n\nexports[`supports custom matchers with property matcher: custom matchers with property matcher 1`] = `\n\"const {toMatchInlineSnapshot} = require('jest-snapshot');\nexpect.extend({\n  toMatchCustomInlineSnapshot(received, ...args) {\n    return toMatchInlineSnapshot.call(this, received, ...args);\n  },\n  toMatchUserInlineSnapshot(received, ...args) {\n    return toMatchInlineSnapshot.call(\n      this,\n      received,\n      {\n        createdAt: expect.any(Date),\n        id: expect.any(Number),\n      },\n      ...args,\n    );\n  },\n});\ntest('inline snapshots', () => {\n  const user = {\n    createdAt: new Date(),\n    id: Math.floor(Math.random() * 20),\n    name: 'LeBron James',\n  };\n  expect(user).toMatchCustomInlineSnapshot(\n    {\n      createdAt: expect.any(Date),\n      id: expect.any(Number),\n    },\n    \\`\n    {\n      \"createdAt\": Any<Date>,\n      \"id\": Any<Number>,\n      \"name\": \"LeBron James\",\n    }\n  \\`,\n  );\n  expect(user).toMatchUserInlineSnapshot(\\`\n    {\n      \"createdAt\": Any<Date>,\n      \"id\": Any<Number>,\n      \"name\": \"LeBron James\",\n    }\n  \\`);\n});\n\"\n`;\n\nexports[`supports custom matchers: custom matchers 1`] = `\n\"const {toMatchInlineSnapshot} = require('jest-snapshot');\nexpect.extend({\n  toMatchCustomInlineSnapshot(received, ...args) {\n    return toMatchInlineSnapshot.call(this, received, ...args);\n  },\n});\ntest('inline snapshots', () => {\n  expect({apple: 'original value'}).toMatchCustomInlineSnapshot(\\`\n    {\n      \"apple\": \"original value\",\n    }\n  \\`);\n});\n\"\n`;\n\nexports[`writes snapshots with non-literals in expect(...) 1`] = `\n\"it('works with inline snapshots', () => {\n  expect({a: 1}).toMatchInlineSnapshot(\\`\n    {\n      \"a\": 1,\n    }\n  \\`);\n});\n\"\n`;"}
{"prompt":"successfully runs the tests with external babel config,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {\n  type PackageJson,\n  cleanup,\n  createEmptyPackage,\n  runYarnInstall,\n  writeFiles,\n} from '../Utils';\nimport runJest, {json as runWithJson} from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'to-match-inline-snapshot-with-jsx');\n\nconst babelConfig = {\n  presets: [\n    ['@babel/preset-env', {targets: {node: 'current'}}],\n    '@babel/preset-react',\n  ],\n};\n\nconst pkg: PackageJson = {\n  dependencies: {\n    react: '^17.0.0',\n  },\n  devDependencies: {\n    '@babel/core': '^7.14.4',\n    '@babel/preset-env': '^7.14.4',\n    '@babel/preset-react': '^7.13.13',\n    'react-test-renderer': '^17.0.2',\n  },\n  jest: {\n    testEnvironment: 'jsdom',\n  },\n};\n\nbeforeEach(() => {\n  cleanup(DIR);\n\n  createEmptyPackage(DIR, pkg);\n\n  writeFiles(DIR, {\n    '__tests__/MismatchingSnapshot.test.js': `\n      import React from 'react';\n      import renderer from 'react-test-renderer';\n\n      test('<div>x</div>', () => {\n        expect(renderer.create(<div>x</div>).toJSON()).toMatchInlineSnapshot(\\`\n          <div>\n            y\n          </div>\n        \\`);\n      });`,\n  });\n\n  runYarnInstall(DIR, {\n    YARN_ENABLE_GLOBAL_CACHE: 'true',\n    YARN_NODE_LINKER: 'node-modules',\n  });\n});\n\nafterAll(() => {\n  cleanup(DIR);\n});\n\nit('successfully runs the tests with external babel config', () => {\n  writeFiles(DIR, {\n    'babel.config.js': `module.exports = ${JSON.stringify(babelConfig)};`,\n  });\n\n  const normalRun = runWithJson(DIR, []);\n  expect(normalRun.exitCode).toBe(1);\n  expect(normalRun.stderr).toContain('1 snapshot failed from 1 test suite.');\n  expect(normalRun.json.testResults[0].message).toMatchInlineSnapshot(`\n    \"  ● <div>x</div>\n\n        expect(received).toMatchInlineSnapshot(snapshot)\n\n        Snapshot name: \\`<div>x</div> 1\\`\n\n        - Snapshot  - 1\n        + Received  + 1\n\n          <div>\n        -   y\n        +   x\n          </div>\n\n          3 |\n          4 | test('<div>x</div>', () => {\n        > 5 |   expect(renderer.create(<div>x</div>).toJSON()).toMatchInlineSnapshot(\\`\n            |                                                  ^\n          6 |     <div>\n          7 |       y\n          8 |     </div>\n\n          at Object.toMatchInlineSnapshot (__tests__/MismatchingSnapshot.test.js:5:50)\n    \"\n  `);\n\n  const updateSnapshotRun = runJest(DIR, ['--updateSnapshot']);\n\n  expect(updateSnapshotRun.exitCode).toBe(0);\n  expect(updateSnapshotRun.stderr).toContain('1 snapshot updated.');\n});\n\nit('successfully runs the tests with inline babel config', () => {\n  writeFiles(DIR, {\n    'package.json': JSON.stringify({\n      ...pkg,\n      jest: {\n        testEnvironment: 'jsdom',\n        transform: {\n          '^.+\\\\.(js|jsx)$': ['babel-jest', babelConfig],\n        },\n      },\n    }),\n  });\n\n  const normalRun = runWithJson(DIR, []);\n  expect(normalRun.exitCode).toBe(1);\n  expect(normalRun.stderr).toContain('1 snapshot failed from 1 test suite.');\n  expect(normalRun.json.testResults[0].message).toMatchInlineSnapshot(`\n    \"  ● <div>x</div>\n\n        expect(received).toMatchInlineSnapshot(snapshot)\n\n        Snapshot name: \\`<div>x</div> 1\\`\n\n        - Snapshot  - 1\n        + Received  + 1\n\n          <div>\n        -   y\n        +   x\n          </div>\n\n          3 |\n          4 | test('<div>x</div>', () => {\n        > 5 |   expect(renderer.create(<div>x</div>).toJSON()).toMatchInlineSnapshot(\\`\n            |                                                  ^\n          6 |     <div>\n          7 |       y\n          8 |     </div>\n\n          at Object.toMatchInlineSnapshot (__tests__/MismatchingSnapshot.test.js:5:50)\n    \"\n  `);\n\n  const updateSnapshotRun = runJest(DIR, ['--updateSnapshot']);\n\n  expect(updateSnapshotRun.exitCode).toBe(0);\n  expect(updateSnapshotRun.stderr).toContain('1 snapshot updated.');\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {cleanup, runYarnInstall, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(\n  __dirname,\n  '../to-match-inline-snapshot-with-prettier-3',\n);\nconst TESTS_DIR = path.resolve(DIR, '__tests__');\nconst JEST_CONFIG_PATH = path.resolve(DIR, 'jest.config.js');\n\nbeforeAll(() => {\n  runYarnInstall(DIR);\n});\nbeforeEach(() => {\n  cleanup(TESTS_DIR);\n  cleanup(JEST_CONFIG_PATH);\n});\nafterAll(() => {\n  cleanup(TESTS_DIR);\n  cleanup(JEST_CONFIG_PATH);\n});\n\ntest('supports passing `null` as `prettierPath`', () => {\n  writeFiles(DIR, {\n    'jest.config.js': `\n        module.exports = {prettierPath: null};\n      `,\n  });\n  writeFiles(TESTS_DIR, {\n    'test.js': `\n        test('snapshots', () => {\n          expect(3).toMatchInlineSnapshot();\n        });\n      `,\n  });\n  const {stderr, exitCode} = runJest(DIR, ['--ci=false']);\n  expect(stderr).toContain('Snapshots:   1 written, 1 total');\n  expect(exitCode).toBe(0);\n});\n\ntest('supports passing `prettier-2` as `prettierPath`', () => {\n  writeFiles(DIR, {\n    'jest.config.js': `\n        module.exports = {prettierPath: require.resolve('prettier-2')};\n      `,\n  });\n  writeFiles(TESTS_DIR, {\n    'test.js': `\n        test('snapshots', () => {\n          expect(3).toMatchInlineSnapshot();\n        });\n      `,\n  });\n  const {stderr, exitCode} = runJest(DIR, ['--ci=false']);\n  expect(stderr).toContain('Snapshots:   1 written, 1 total');\n  expect(exitCode).toBe(0);\n});\n\ntest('supports passing `prettier` as `prettierPath`', () => {\n  writeFiles(DIR, {\n    'jest.config.js': `\n        module.exports = {prettierPath: require.resolve('prettier')};\n      `,\n  });\n  writeFiles(TESTS_DIR, {\n    'test.js': `\n        test('snapshots', () => {\n          expect(3).toMatchInlineSnapshot();\n        });\n      `,\n  });\n  const {stderr, exitCode} = runJest(DIR, ['--ci=false']);\n  expect(stderr).toContain('Snapshots:   1 written, 1 total');\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"with retries,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport {cleanup, makeTemplate, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../to-match-inline-snapshot-with-retries');\nconst TESTS_DIR = path.resolve(DIR, '__tests__');\n\nbeforeEach(() => cleanup(TESTS_DIR));\nafterAll(() => cleanup(TESTS_DIR));\n\nskipSuiteOnJasmine();\n\ntest('works with a single snapshot', () => {\n  const filename = 'basic-support.test.js';\n  const template = makeTemplate(`\n    let index = 0;\n    afterEach(() => {\n      index += 1;\n    });\n    jest.retryTimes($2);\n    test('snapshots', () => expect($1).toMatchInlineSnapshot(\\`3\\`));\n  `);\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['3', '1' /* retries */]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['index', '2' /* retries */]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Received: 2');\n    expect(stderr).toMatch('1 snapshot failed from 1 test suite.');\n    expect(exitCode).toBe(1);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['index', '4' /* retries */]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(exitCode).toBe(0);\n  }\n});\n\ntest('works when a different assertion is failing', () => {\n  const filename = 'basic-support.test.js';\n  const template = makeTemplate(`\n    jest.retryTimes($1);\n    test('snapshots', () => {\n      expect(3).toMatchInlineSnapshot(\\`3\\`);\n      expect(false).toBe(true);\n    });\n  `);\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['4']),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Test Suites: 1 failed, 1 total');\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(exitCode).toBe(1);\n  }\n});\n\ntest('works when multiple tests have snapshots but only one of them failed multiple times', () => {\n  const filename = 'basic-support.test.js';\n  const template = makeTemplate(`\n    test('passing snapshots', () => expect(1).toMatchInlineSnapshot(\\`1\\`));\n    describe('with retries', () => {\n      let index = 0;\n      afterEach(() => {\n        index += 1;\n      });\n      jest.retryTimes($2);\n      test('snapshots', () => expect($1).toMatchInlineSnapshot(\\`3\\`));\n    });\n  `);\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['3', '2' /* retries */]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshots:   2 passed, 2 total');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['index', '2' /* retries */]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshot name: `with retries snapshots 1`');\n    expect(stderr).toMatch('Received: 2');\n    expect(stderr).toMatch('1 snapshot failed from 1 test suite.');\n    expect(exitCode).toBe(1);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['index', '4' /* retries */]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(exitCode).toBe(0);\n  }\n});"}
{"prompt":"Match lines separately because empty line has been replaced wh space:","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {cleanup, makeTemplate, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../to-match-snapshot');\nconst TESTS_DIR = path.resolve(DIR, '__tests__');\n\nbeforeEach(() => cleanup(TESTS_DIR));\nafterAll(() => cleanup(TESTS_DIR));\n\ntest('basic support', () => {\n  const filename = 'basic-support.test.js';\n  const template = makeTemplate(\n    \"test('snapshots', () => expect($1).toMatchSnapshot());\",\n  );\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['{apple: \"original value\"}']),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(stderr).not.toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['{apple: \"updated value\"}']),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshot name: `snapshots 1`');\n    expect(exitCode).toBe(1);\n  }\n\n  {\n    const {stderr, exitCode} = runJest(DIR, [\n      '-w=1',\n      '--ci=false',\n      filename,\n      '-u',\n    ]);\n    expect(stderr).toMatch('1 snapshot updated from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n});\n\ntest('error thrown before snapshot', () => {\n  const filename = 'error-thrown-before-snapshot.test.js';\n  const template = makeTemplate(`test('snapshots', () => {\n      expect($1).toBeTruthy();\n      expect($2).toMatchSnapshot();\n    });`);\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['true', '{a: \"original\"}']),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['false', '{a: \"original\"}']),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).not.toMatch('1 obsolete snapshot found');\n    expect(exitCode).toBe(1);\n  }\n});\n\ntest('first snapshot fails, second passes', () => {\n  const filename = 'first-snapshot-fails-second-passes.test.js';\n  const template = makeTemplate(`test('snapshots', () => {\n      expect($1).toMatchSnapshot();\n      expect($2).toMatchSnapshot();\n    });`);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template([\"'apple'\", \"'banana'\"])});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('2 snapshots written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template([\"'kiwi'\", \"'banana'\"])});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshot name: `snapshots 1`');\n    // Match lines separately because empty line has been replaced with space:\n    expect(stderr).toMatch('Snapshot: \"apple\"');\n    expect(stderr).toMatch('Received: \"kiwi\"');\n    expect(stderr).not.toMatch('1 obsolete snapshot found');\n    expect(exitCode).toBe(1);\n  }\n});\n\ntest('does not mark snapshots as obsolete in skipped tests', () => {\n  const filename = 'no-obsolete-if-skipped.test.js';\n  const template = makeTemplate(`test('snapshots', () => {\n      expect(true).toBe(true);\n    });\n\n    $1('will be skipped', () => {\n      expect({a: 6}).toMatchSnapshot();\n    });\n    `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template(['test'])});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template(['test.skip'])});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).not.toMatch('1 obsolete snapshot found');\n    expect(exitCode).toBe(0);\n  }\n});\n\ntest('accepts custom snapshot name', () => {\n  const filename = 'accept-custom-snapshot-name.test.js';\n  const template = makeTemplate(`test('accepts custom snapshot name', () => {\n      expect(true).toMatchSnapshot('custom-name');\n    });\n    `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template()});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n});\n\ntest('handles property matchers', () => {\n  const filename = 'handle-property-matchers.test.js';\n  const template = makeTemplate(`test('handles property matchers', () => {\n      expect({createdAt: $1}).toMatchSnapshot({createdAt: expect.any(Date)});\n    });\n    `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template(['new Date()'])});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template(['\"string\"'])});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshot name: `handles property matchers 1`');\n    expect(stderr).toMatch('Snapshots:   1 failed, 1 total');\n    expect(exitCode).toBe(1);\n  }\n});\n\ntest('handles invalid property matchers', () => {\n  const filename = 'handle-property-matchers.test.js';\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: `test('invalid property matchers', () => {\n        expect({foo: 'bar'}).toMatchSnapshot(null);\n      });\n    `,\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Expected properties must be an object');\n    expect(exitCode).toBe(1);\n  }\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: `test('invalid property matchers', () => {\n        expect({foo: 'bar'}).toMatchSnapshot(null, 'test-name');\n      });\n    `,\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Expected properties must be an object');\n    expect(stderr).toMatch(\n      \"To provide a hint without properties: toMatchSnapshot('hint')\",\n    );\n    expect(exitCode).toBe(1);\n  }\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: `test('invalid property matchers', () => {\n        expect({foo: 'bar'}).toMatchSnapshot(undefined, 'test-name');\n      });\n    `,\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Expected properties must be an object');\n    expect(stderr).toMatch(\n      \"To provide a hint without properties: toMatchSnapshot('hint')\",\n    );\n    expect(exitCode).toBe(1);\n  }\n});\n\ntest('handles property matchers with hint', () => {\n  const filename = 'handle-property-matchers-with-hint.test.js';\n  const template =\n    makeTemplate(`test('handles property matchers with hint', () => {\n      expect({createdAt: $1}).toMatchSnapshot({createdAt: expect.any(Date)}, 'descriptive hint');\n    });\n    `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template(['new Date()'])});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template(['\"string\"'])});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch(\n      'Snapshot name: `handles property matchers with hint: descriptive hint 1`',\n    );\n    expect(stderr).toMatch('Expected properties');\n    expect(stderr).toMatch('Snapshots:   1 failed, 1 total');\n    expect(exitCode).toBe(1);\n  }\n});\n\ntest('handles property matchers with deep properties', () => {\n  const filename = 'handle-property-matchers-with-name.test.js';\n  const template =\n    makeTemplate(`test('handles property matchers with deep properties', () => {\n      expect({ user: { createdAt: $1, name: $2 }}).toMatchSnapshot({ user: { createdAt: expect.any(Date), name: $2 }});\n    });\n    `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template(['new Date()', '\"Jest\"'])});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template(['\"string\"', '\"Jest\"'])});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch(\n      'Snapshot name: `handles property matchers with deep properties 1`',\n    );\n    expect(stderr).toMatch('Expected properties');\n    expect(stderr).toMatch('Snapshots:   1 failed, 1 total');\n    expect(exitCode).toBe(1);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template(['new Date()', '\"CHANGED\"'])});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch(\n      'Snapshot name: `handles property matchers with deep properties 1`',\n    );\n    expect(stderr).toMatch('Snapshots:   1 failed, 1 total');\n    expect(exitCode).toBe(1);\n  }\n});"}
{"prompt":"with retries,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {skipSuiteOnJasmine} from '@jest/test-utils';\nimport {cleanup, makeTemplate, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../to-match-snapshot-with-retries');\nconst TESTS_DIR = path.resolve(DIR, '__tests__');\n\nbeforeEach(() => cleanup(TESTS_DIR));\nafterAll(() => cleanup(TESTS_DIR));\n\nskipSuiteOnJasmine();\n\ntest('works with a single snapshot', () => {\n  const filename = 'basic-support.test.js';\n  const template = makeTemplate(`\n    let index = 0;\n    afterEach(() => {\n      index += 1;\n    });\n    jest.retryTimes($2);\n    test('snapshots', () => expect($1).toMatchSnapshot());\n  `);\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['3', '1' /* retries */]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['index', '2' /* retries */]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Received: 2');\n    expect(stderr).toMatch('1 snapshot failed from 1 test suite.');\n    expect(exitCode).toBe(1);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['index', '4' /* retries */]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(exitCode).toBe(0);\n  }\n});\n\ntest('works when multiple tests have snapshots but only one of them failed multiple times', () => {\n  const filename = 'basic-support.test.js';\n  const template = makeTemplate(`\n    test('passing snapshots', () => expect('foo').toMatchSnapshot());\n    describe('with retries', () => {\n      let index = 0;\n      afterEach(() => {\n        index += 1;\n      });\n      jest.retryTimes($2);\n      test('snapshots', () => expect($1).toMatchSnapshot());\n    });\n  `);\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['3', '2' /* retries */]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('2 snapshots written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['index', '2' /* retries */]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Received: 2');\n    expect(stderr).toMatch('1 snapshot failed from 1 test suite.');\n    expect(exitCode).toBe(1);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template(['index', '4' /* retries */]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(exitCode).toBe(0);\n  }\n});"}
{"prompt":"Because the not wrten error might include Received,","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {cleanup, makeTemplate, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(\n  __dirname,\n  '../to-match-snapshot-with-string-serializer',\n);\nconst TESTS_DIR = path.resolve(DIR, '__tests__');\n\nconst readFile = (filename: string) =>\n  fs.readFileSync(path.join(TESTS_DIR, filename), 'utf8');\n\nbeforeEach(() => cleanup(TESTS_DIR));\nafterAll(() => cleanup(TESTS_DIR));\n\n// Because the not written error might include Received,\n// match Snapshot as either diff annotation or concise label.\nconst ORDINARY_FAILURE = /- Snapshot|Snapshot:/;\n\nconst NOT_WRITTEN = 'not written'; // new snapshot with --ci option\n\ntest('empty external', () => {\n  // Make sure empty string as expected value of external snapshot\n  // is not confused with new snapshot not written because of --ci option.\n  const filename = 'empty-external.test.js';\n  const template = makeTemplate(\n    \"test('string serializer', () => { expect($1).toMatchSnapshot(); })\",\n  );\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template([\"''\"]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshots:   1 passed, 1 total');\n    expect(stderr).not.toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template([\"'non-empty'\"]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshots:   1 failed, 1 total');\n    expect(stderr).not.toMatch('not written'); // not confused with --ci option\n    expect(stderr).toMatch(ORDINARY_FAILURE);\n    expect(exitCode).toBe(1);\n  }\n});\n\ntest('empty internal ci false', () => {\n  // Make sure empty string as expected value of internal snapshot\n  // is not confused with absence of snapshot.\n  const filename = 'empty-internal-ci-false.test.js';\n  const template = makeTemplate(\n    \"test('string serializer', () => { expect($1).toMatchInlineSnapshot(); })\",\n  );\n\n  const received1 = \"''\";\n  const received2 = \"'non-empty'\";\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template([received1]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: readFile(filename).replace(received1, received2),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshots:   1 failed, 1 total');\n    expect(stderr).not.toMatch('1 snapshot written from 1 test suite.');\n    expect(stderr).toMatch(ORDINARY_FAILURE);\n    expect(exitCode).toBe(1);\n  }\n});\n\ntest('undefined internal ci true', () => {\n  // Make sure absence of internal snapshot\n  // is not confused with ordinary failure for empty string as expected value.\n  const filename = 'undefined-internal-ci-true.test.js';\n  const template = makeTemplate(\n    \"test('explicit update', () => { expect($1).toMatchInlineSnapshot(); })\",\n  );\n\n  {\n    writeFiles(TESTS_DIR, {\n      [filename]: template([\"'non-empty'\"]),\n    });\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=true', filename]);\n    expect(stderr).toMatch('Snapshots:   1 failed, 1 total');\n    expect(stderr).not.toMatch(ORDINARY_FAILURE);\n    expect(stderr).toMatch(NOT_WRITTEN);\n    expect(exitCode).toBe(1);\n  }\n});"}
{"prompt":"cause does not exist in old versions of node","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {cleanup, makeTemplate, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(\n  __dirname,\n  '../to-throw-error-matching-inline-snapshot',\n);\nconst TESTS_DIR = path.resolve(DIR, '__tests__');\n\nconst readFile = (filename: string) =>\n  fs.readFileSync(path.join(TESTS_DIR, filename), 'utf8');\n\nbeforeEach(() => cleanup(TESTS_DIR));\nafterAll(() => cleanup(TESTS_DIR));\n\ntest('works fine when function throws error', () => {\n  const filename = 'works-fine-when-function-throws-error.test.js';\n  const template = makeTemplate(`\n    test('works fine when function throws error', () => {\n      expect(() => {\n        throw new Error('apple');\n      })\n        .toThrowErrorMatchingInlineSnapshot();\n    });\n  `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template()});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(fileAfter).toMatchSnapshot('initial write');\n    expect(exitCode).toBe(0);\n  }\n});\n\ntest('works fine when function throws error with cause', () => {\n  const filename = 'works-fine-when-function-throws-error-with-cause.test.js';\n  const template = makeTemplate(`\n    test('works fine when function throws error', () => {\n      function ErrorWithCause(message, cause) {\n        const err = new Error(message, {cause});\n        if (err.cause !== cause) {\n          // cause does not exist in old versions of node\n          err.cause = cause;\n        }\n        return err;\n      }\n      expect(() => {\n        throw ErrorWithCause('apple',\n          ErrorWithCause('banana',\n            ErrorWithCause('orange')\n          )\n        );\n      })\n        .toThrowErrorMatchingInlineSnapshot();\n    });\n  `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template()});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(fileAfter).toMatchSnapshot('initial write with cause');\n    expect(exitCode).toBe(0);\n  }\n});\n\ntest('works fine when function throws error with string cause', () => {\n  const filename =\n    'works-fine-when-function-throws-error-with-string-cause.test.js';\n  const template = makeTemplate(`\n    test('works fine when function throws error', () => {\n      function ErrorWithCause(message, cause) {\n        const err = new Error(message, {cause});\n        if (err.cause !== cause) {\n          // cause does not exist in old versions of node\n          err.cause = cause;\n        }\n        return err;\n      }\n      expect(() => {\n        throw ErrorWithCause('apple', 'here is a cause');\n      })\n        .toThrowErrorMatchingInlineSnapshot();\n    });\n  `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template()});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(fileAfter).toMatchSnapshot('initial write with cause');\n    expect(exitCode).toBe(0);\n  }\n});\n\ntest('updates existing snapshot', () => {\n  const filename = 'updates-existing-snapshot.test.js';\n  const template = makeTemplate(`\n    test('updates existing snapshot', () => {\n      expect(() => {\n        throw new Error('apple');\n      })\n        .toThrowErrorMatchingInlineSnapshot(\\`\"banana\"\\`);\n    });\n  `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template()});\n    const {stderr, exitCode} = runJest(DIR, [\n      '-w=1',\n      '--ci=false',\n      filename,\n      '-u',\n    ]);\n    const fileAfter = readFile(filename);\n    expect(stderr).toMatch('1 snapshot updated from 1 test suite.');\n    expect(fileAfter).toMatchSnapshot('updated snapshot');\n    expect(exitCode).toBe(0);\n  }\n});\n\ntest('cannot be used with .not', () => {\n  const filename = 'cannot-be-used-with-not.test.js';\n  const template = makeTemplate(`\n    test('cannot be used with .not', () => {\n      expect(() => { throw new Error('apple'); })\n        .not\n        .toThrowErrorMatchingInlineSnapshot();\n    });\n  `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template()});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshot matchers cannot be used with not');\n    expect(exitCode).toBe(1);\n  }\n});\n\ntest('should support rejecting promises', () => {\n  const filename = 'should-support-rejecting-promises.test.js';\n  const template = makeTemplate(`\n    test('should support rejecting promises', async () => {\n      await expect(Promise.reject(new Error('octopus')))\n        .rejects.toThrowErrorMatchingInlineSnapshot();\n    });\n  `);\n\n  writeFiles(TESTS_DIR, {[filename]: template()});\n  const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n  const fileAfter = readFile(filename);\n  expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n  expect(fileAfter).toMatchSnapshot();\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`should support rejecting promises 1`] = `\n\"test('should support rejecting promises', async () => {\n  await expect(\n    Promise.reject(new Error('octopus')),\n  ).rejects.toThrowErrorMatchingInlineSnapshot(\\`\"octopus\"\\`);\n});\n\"\n`;\n\nexports[`updates existing snapshot: updated snapshot 1`] = `\n\"test('updates existing snapshot', () => {\n  expect(() => {\n    throw new Error('apple');\n  }).toThrowErrorMatchingInlineSnapshot(\\`\"apple\"\\`);\n});\n\"\n`;\n\nexports[`works fine when function throws error with cause: initial write with cause 1`] = `\n\"test('works fine when function throws error', () => {\n  function ErrorWithCause(message, cause) {\n    const err = new Error(message, {cause});\n    if (err.cause !== cause) {\n      // cause does not exist in old versions of node\n      err.cause = cause;\n    }\n    return err;\n  }\n  expect(() => {\n    throw ErrorWithCause(\n      'apple',\n      ErrorWithCause('banana', ErrorWithCause('orange')),\n    );\n  }).toThrowErrorMatchingInlineSnapshot(\\`\n    \"apple\n    Cause: banana\n    Cause: orange\"\n  \\`);\n});\n\"\n`;\n\nexports[`works fine when function throws error with string cause: initial write with cause 1`] = `\n\"test('works fine when function throws error', () => {\n  function ErrorWithCause(message, cause) {\n    const err = new Error(message, {cause});\n    if (err.cause !== cause) {\n      // cause does not exist in old versions of node\n      err.cause = cause;\n    }\n    return err;\n  }\n  expect(() => {\n    throw ErrorWithCause('apple', 'here is a cause');\n  }).toThrowErrorMatchingInlineSnapshot(\\`\n    \"apple\n    Cause: here is a cause\"\n  \\`);\n});\n\"\n`;\n\nexports[`works fine when function throws error: initial write 1`] = `\n\"test('works fine when function throws error', () => {\n  expect(() => {\n    throw new Error('apple');\n  }).toThrowErrorMatchingInlineSnapshot(\\`\"apple\"\\`);\n});\n\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {cleanup, makeTemplate, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../to-throw-error-matching-snapshot');\nconst TESTS_DIR = path.resolve(DIR, '__tests__');\n\nbeforeEach(() => cleanup(TESTS_DIR));\nafterAll(() => cleanup(TESTS_DIR));\n\ntest('works fine when function throws error', () => {\n  const filename = 'works-fine-when-function-throws-error.test.js';\n  const template =\n    makeTemplate(`test('works fine when function throws error', () => {\n       expect(() => { throw new Error('apple'); })\n         .toThrowErrorMatchingSnapshot();\n    });\n    `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template()});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n});\n\ntest(\"throws the error if tested function didn't throw error\", () => {\n  const filename = 'throws-if-tested-function-did-not-throw.test.js';\n  const template =\n    makeTemplate(`test('throws the error if tested function did not throw error', () => {\n      expect(() => {}).toThrowErrorMatchingSnapshot();\n    });\n    `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template()});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Received function did not throw');\n    expect(exitCode).toBe(1);\n  }\n});\n\ntest('accepts custom snapshot name', () => {\n  const filename = 'accept-custom-snapshot-name.test.js';\n  const template = makeTemplate(`test('accepts custom snapshot name', () => {\n      expect(() => { throw new Error('apple'); })\n        .toThrowErrorMatchingSnapshot('custom-name');\n    });\n    `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template()});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(exitCode).toBe(0);\n  }\n});\n\ntest('cannot be used with .not', () => {\n  const filename = 'cannot-be-used-with-not.test.js';\n  const template = makeTemplate(`test('cannot be used with .not', () => {\n       expect(() => { throw new Error('apple'); })\n         .not\n         .toThrowErrorMatchingSnapshot();\n    });\n    `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template()});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n    expect(stderr).toMatch('Snapshot matchers cannot be used with not');\n    expect(exitCode).toBe(1);\n  }\n});\n\ntest('should support rejecting promises', () => {\n  const filename = 'should-support-rejecting-promises.test.js';\n  const template =\n    makeTemplate(`test('should support rejecting promises', () => {\n      return expect(Promise.reject(new Error('octopus'))).rejects.toThrowErrorMatchingSnapshot();\n    });\n  `);\n\n  {\n    writeFiles(TESTS_DIR, {[filename]: template()});\n    const {stderr, exitCode} = runJest(DIR, ['-w=1', '--ci=false', filename]);\n\n    const snapshot = fs.readFileSync(\n      `${TESTS_DIR}/__snapshots__/${filename}.snap`,\n      'utf8',\n    );\n\n    expect(stderr).toMatch('1 snapshot written from 1 test suite.');\n    expect(snapshot).toMatchSnapshot();\n    expect(exitCode).toBe(0);\n  }\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`should support rejecting promises 1`] = `\n\"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[\\`should support rejecting promises 1\\`] = \\`\"octopus\"\\`;\n\"\n`;"}
{"prompt":"Custom Error class because node versions have different stack trace strings.","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {alignedAnsiStyleSerializer} from '@jest/test-utils';\nimport jestExpect from '..';\n\nexpect.addSnapshotSerializer(alignedAnsiStyleSerializer);\n\n// Custom Error class because node versions have different stack trace strings.\nclass CustomError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = 'Error';\n    this.stack =\n      'Error\\n' +\n      '  at jestExpect' +\n      ' (packages/expect/src/__tests__/toThrowMatchers-test.js:24:74)';\n  }\n}\n\ndescribe('toThrow', () => {\n  class Err extends CustomError {}\n  class Err2 extends CustomError {}\n\n  test('to throw or not to throw', () => {\n    jestExpect(() => {\n      throw new CustomError('apple');\n    }).toThrow();\n    jestExpect(() => {}).not.toThrow();\n  });\n\n  describe('substring', () => {\n    it('passes', () => {\n      jestExpect(() => {\n        throw new CustomError('apple');\n      }).toThrow('apple');\n      jestExpect(() => {\n        throw new CustomError('banana');\n      }).not.toThrow('apple');\n      jestExpect(() => {}).not.toThrow('apple');\n    });\n\n    test('did not throw at all', () => {\n      expect(() =>\n        jestExpect(() => {}).toThrow('apple'),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message did not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('apple');\n        }).toThrow('banana');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message did not match (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw '';\n        }).toThrow('Server Error');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    it('properly escapes strings when matching against errors', () => {\n      jestExpect(() => {\n        throw new TypeError('\"this\"? throws.');\n      }).toThrow('\"this\"? throws.');\n    });\n\n    test('threw, but message should not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('Invalid array length');\n        }).not.toThrow('array');\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message should not match (non-error truthy)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw 'Internal Server Error';\n        }).not.toThrow('Server Error');\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('regexp', () => {\n    it('passes', () => {\n      jestExpect(() => {\n        throw new CustomError('apple');\n      }).toThrow(/apple/);\n      jestExpect(() => {\n        throw new CustomError('banana');\n      }).not.toThrow(/apple/);\n      jestExpect(() => {}).not.toThrow(/apple/);\n    });\n\n    test('did not throw at all', () => {\n      expect(() =>\n        jestExpect(() => {}).toThrow(/apple/),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message did not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('apple');\n        }).toThrow(/banana/);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message did not match (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw 0;\n        }).toThrow(/^[1-9]\\d*/);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message should not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new CustomError('Invalid array length');\n        }).not.toThrow(/ array /);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but message should not match (non-error truthy)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw 404;\n        }).not.toThrow(/^[1-9]\\d*/);\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('error class', () => {\n    class SubErr extends Err {\n      constructor(message?: string) {\n        super(message);\n        // In a carefully written error subclass,\n        // name property is equal to constructor name.\n        this.name = this.constructor.name;\n      }\n    }\n\n    class SubSubErr extends SubErr {\n      constructor(message?: string) {\n        super(message);\n        // In a carefully written error subclass,\n        // name property is equal to constructor name.\n        this.name = this.constructor.name;\n      }\n    }\n\n    it('passes', () => {\n      jestExpect(() => {\n        throw new Err();\n      }).toThrow(Err);\n      jestExpect(() => {\n        throw new Err();\n      }).toThrow(CustomError);\n      jestExpect(() => {\n        throw new SubErr();\n      }).toThrow(new SubErr());\n      jestExpect(() => {\n        throw new Err();\n      }).not.toThrow(Err2);\n      jestExpect(() => {}).not.toThrow(Err);\n      jestExpect(() => {\n        throw new SubErr();\n      }).not.toThrow(new SubSubErr());\n    });\n\n    test('did not throw at all', () => {\n      expect(() =>\n        expect(() => {}).toThrow(Err),\n      ).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class did not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new Err('apple');\n        }).toThrow(Err2);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class did not match (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw undefined;\n        }).toThrow(Err2);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class should not match (error)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new Err('apple');\n        }).not.toThrow(Err);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class should not match (error subclass)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new SubErr('apple');\n        }).not.toThrow(Err);\n      }).toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class should not match (error subsubclass)', () => {\n      expect(() => {\n        jestExpect(() => {\n          throw new SubSubErr('apple');\n        }).not.toThrow(Err);\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('error-message', () => {\n    // Received message in report if object has message property.\n    class ErrorMessage {\n      // not extending Error!\n      constructor(public message: string) {}\n    }\n    const expected = new ErrorMessage('apple');\n\n    describe('pass', () => {\n      test('isNot false', () => {\n        jestExpect(() => {\n          throw new ErrorMessage('apple');\n        }).toThrow(expected);\n      });\n\n      test('isNot true', () => {\n        jestExpect(() => {\n          throw new ErrorMessage('banana');\n        }).not.toThrow(expected);\n      });\n    });\n\n    describe('fail', () => {\n      test('isNot false', () => {\n        expect(() =>\n          jestExpect(() => {\n            throw new ErrorMessage('banana');\n          }).toThrow(expected),\n        ).toThrowErrorMatchingSnapshot();\n      });\n\n      test('isNot true', () => {\n        const message = 'Invalid array length';\n        expect(() =>\n          jestExpect(() => {\n            throw new ErrorMessage(message);\n          }).not.toThrow({message}),\n        ).toThrowErrorMatchingSnapshot();\n      });\n\n      test('multiline diff highlight incorrect expected space', () => {\n        // jest/issues/2673\n        const a =\n          \"There is no route defined for key Settings. \\nMust be one of: 'Home'\";\n        const b =\n          \"There is no route defined for key Settings.\\nMust be one of: 'Home'\";\n        expect(() =>\n          jestExpect(() => {\n            throw new ErrorMessage(b);\n          }).toThrow({message: a}),\n        ).toThrowErrorMatchingSnapshot();\n      });\n    });\n  });\n\n  describe('error message and cause', () => {\n    const errorA = new Error('A');\n    const errorB = new Error('B', {cause: errorA});\n    const expected = new Error('good', {cause: errorB});\n\n    describe('pass', () => {\n      test('isNot false', () => {\n        jestExpect(() => {\n          throw new Error('good', {cause: errorB});\n        }).toThrow(expected);\n      });\n\n      test('isNot true, incorrect message', () => {\n        jestExpect(() => {\n          throw new Error('bad', {cause: errorB});\n        }).not.toThrow(expected);\n      });\n\n      test('isNot true, incorrect cause', () => {\n        jestExpect(() => {\n          throw new Error('good', {cause: errorA});\n        }).not.toThrow(expected);\n      });\n    });\n\n    describe('fail', () => {\n      test('isNot false, incorrect message', () => {\n        expect(() =>\n          jestExpect(() => {\n            throw new Error('bad', {cause: errorB});\n          }).toThrow(expected),\n        ).toThrow(\n          /^(?=.*Expected message and cause: ).*Received message and cause: /s,\n        );\n      });\n\n      test('isNot true, incorrect cause', () => {\n        expect(() =>\n          jestExpect(() => {\n            throw new Error('good', {cause: errorA});\n          }).toThrow(expected),\n        ).toThrow(\n          /^(?=.*Expected message and cause: ).*Received message and cause: /s,\n        );\n      });\n    });\n  });\n\n  describe('asymmetric', () => {\n    describe('any-Class', () => {\n      describe('pass', () => {\n        test('isNot false', () => {\n          jestExpect(() => {\n            throw new Err('apple');\n          }).toThrow(expect.any(Err));\n        });\n\n        test('isNot true', () => {\n          jestExpect(() => {\n            throw new Err('apple');\n          }).not.toThrow(expect.any(Err2));\n        });\n      });\n\n      describe('fail', () => {\n        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new Err('apple');\n            }).toThrow(expect.any(Err2)),\n          ).toThrowErrorMatchingSnapshot();\n        });\n\n        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new Err('apple');\n            }).not.toThrow(expect.any(Err)),\n          ).toThrowErrorMatchingSnapshot();\n        });\n      });\n    });\n\n    describe('anything', () => {\n      describe('pass', () => {\n        test('isNot false', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          }).toThrow(expect.anything());\n        });\n\n        test('isNot true', () => {\n          jestExpect(() => {}).not.toThrow(expect.anything());\n          jestExpect(() => {\n            // eslint-disable-next-line no-throw-literal\n            throw null;\n          }).not.toThrow(expect.anything());\n        });\n      });\n\n      describe('fail', () => {\n        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              // eslint-disable-next-line no-throw-literal\n              throw null;\n            }).toThrow(expect.anything()),\n          ).toThrowErrorMatchingSnapshot();\n        });\n\n        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).not.toThrow(expect.anything()),\n          ).toThrowErrorMatchingSnapshot();\n        });\n      });\n    });\n\n    describe('no-symbol', () => {\n      // Test serialization of asymmetric matcher which has no property:\n      // this.$$typeof = Symbol.for('jest.asymmetricMatcher')\n      const matchError = {\n        asymmetricMatch(received: Error | null | undefined) {\n          return (\n            received !== null &&\n            received !== undefined &&\n            received.name === 'Error'\n          );\n        },\n      };\n      const matchNotError = {\n        asymmetricMatch(received: Error | null | undefined) {\n          return (\n            received !== null &&\n            received !== undefined &&\n            received.name !== 'Error'\n          );\n        },\n      };\n\n      describe('pass', () => {\n        test('isNot false', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          }).toThrow(matchError);\n        });\n\n        test('isNot true', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          }).not.toThrow(matchNotError);\n        });\n      });\n\n      describe('fail', () => {\n        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).toThrow(matchNotError),\n          ).toThrowErrorMatchingSnapshot();\n        });\n\n        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).not.toThrow(matchError),\n          ).toThrowErrorMatchingSnapshot();\n        });\n      });\n    });\n\n    describe('objectContaining', () => {\n      const matchError = expect.objectContaining({\n        name: 'Error',\n      });\n      const matchNotError = expect.objectContaining({\n        name: 'NotError',\n      });\n\n      describe('pass', () => {\n        test('isNot false', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          }).toThrow(matchError);\n        });\n\n        test('isNot true', () => {\n          jestExpect(() => {\n            throw new CustomError('apple');\n          }).not.toThrow(matchNotError);\n        });\n      });\n\n      describe('fail', () => {\n        test('isNot false', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).toThrow(matchNotError),\n          ).toThrowErrorMatchingSnapshot();\n        });\n\n        test('isNot true', () => {\n          expect(() =>\n            jestExpect(() => {\n              throw new CustomError('apple');\n            }).not.toThrow(matchError),\n          ).toThrowErrorMatchingSnapshot();\n        });\n      });\n    });\n  });\n\n  describe('promise/async throws if Error-like object is returned', () => {\n    const asyncFn = async (shouldThrow?: boolean, resolve?: boolean) => {\n      let err;\n      if (shouldThrow) {\n        err = new Err('async apple');\n      }\n      if (resolve) {\n        return err || 'apple';\n      } else {\n        throw err || 'apple';\n      }\n    };\n\n    test('passes', async () => {\n      expect.assertions(24);\n      await jestExpect(Promise.reject(new Error())).rejects.toThrow();\n\n      await jestExpect(asyncFn(true)).rejects.toThrow();\n      await jestExpect(asyncFn(true)).rejects.toThrow(Err);\n      await jestExpect(asyncFn(true)).rejects.toThrow(Error);\n      await jestExpect(asyncFn(true)).rejects.toThrow('apple');\n      await jestExpect(asyncFn(true)).rejects.toThrow(/app/);\n\n      await jestExpect(asyncFn(true)).rejects.not.toThrow(Err2);\n      await jestExpect(asyncFn(true)).rejects.not.toThrow('banana');\n      await jestExpect(asyncFn(true)).rejects.not.toThrow(/banana/);\n\n      await jestExpect(asyncFn(true, true)).resolves.toThrow();\n\n      await jestExpect(asyncFn(false, true)).resolves.not.toThrow();\n      await jestExpect(asyncFn(false, true)).resolves.not.toThrow(Error);\n      await jestExpect(asyncFn(false, true)).resolves.not.toThrow('apple');\n      await jestExpect(asyncFn(false, true)).resolves.not.toThrow(/apple/);\n      await jestExpect(asyncFn(false, true)).resolves.not.toThrow('banana');\n      await jestExpect(asyncFn(false, true)).resolves.not.toThrow(/banana/);\n\n      await jestExpect(asyncFn()).rejects.not.toThrow();\n      await jestExpect(asyncFn()).rejects.not.toThrow(Error);\n      await jestExpect(asyncFn()).rejects.not.toThrow('apple');\n      await jestExpect(asyncFn()).rejects.not.toThrow(/apple/);\n      await jestExpect(asyncFn()).rejects.not.toThrow('banana');\n      await jestExpect(asyncFn()).rejects.not.toThrow(/banana/);\n\n      // Works with nested functions inside promises\n      await jestExpect(\n        Promise.reject(() => {\n          throw new Error();\n        }),\n      ).rejects.toThrow();\n      await jestExpect(Promise.reject(() => {})).rejects.not.toThrow();\n    });\n\n    test('did not throw at all', async () => {\n      await expect(\n        jestExpect(asyncFn()).rejects.toThrow(),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but class did not match', async () => {\n      await expect(\n        jestExpect(asyncFn(true)).rejects.toThrow(Err2),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n\n    test('threw, but should not have', async () => {\n      await expect(\n        jestExpect(asyncFn(true)).rejects.not.toThrow(),\n      ).rejects.toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  describe('expected is undefined', () => {\n    test('threw, but should not have (non-error falsey)', () => {\n      expect(() => {\n        jestExpect(() => {\n          // eslint-disable-next-line no-throw-literal\n          throw null;\n        }).not.toThrow();\n      }).toThrowErrorMatchingSnapshot();\n    });\n  });\n\n  test('invalid arguments', () => {\n    expect(() =>\n      jestExpect(() => {}).not.toThrow(111),\n    ).toThrowErrorMatchingSnapshot();\n  });\n\n  test('invalid actual', () => {\n    expect(() =>\n      jestExpect('a string').toThrow(),\n    ).toThrowErrorMatchingSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`toThrow asymmetric any-Class fail isNot false 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected asymmetric matcher: <g>Any<Err2></>\n\nReceived name:    <r>\"Error\"</>\nReceived message: <r>\"apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow asymmetric any-Class fail isNot true 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected asymmetric matcher: not <g>Any<Err></>\n\nReceived name:    <r>\"Error\"</>\nReceived message: <r>\"apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow asymmetric anything fail isNot false 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected asymmetric matcher: <g>Anything</>\n\nThrown value: <r>null</>\n\n`;\n\nexports[`toThrow asymmetric anything fail isNot true 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected asymmetric matcher: not <g>Anything</>\n\nReceived name:    <r>\"Error\"</>\nReceived message: <r>\"apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow asymmetric no-symbol fail isNot false 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected asymmetric matcher: <g>{\"asymmetricMatch\": [Function asymmetricMatch]}</>\n\nReceived name:    <r>\"Error\"</>\nReceived message: <r>\"apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow asymmetric no-symbol fail isNot true 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected asymmetric matcher: not <g>{\"asymmetricMatch\": [Function asymmetricMatch]}</>\n\nReceived name:    <r>\"Error\"</>\nReceived message: <r>\"apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow asymmetric objectContaining fail isNot false 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected asymmetric matcher: <g>ObjectContaining {\"name\": \"NotError\"}</>\n\nReceived name:    <r>\"Error\"</>\nReceived message: <r>\"apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow asymmetric objectContaining fail isNot true 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected asymmetric matcher: not <g>ObjectContaining {\"name\": \"Error\"}</>\n\nReceived name:    <r>\"Error\"</>\nReceived message: <r>\"apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow error class did not throw at all 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected constructor: <g>Err</>\n\nReceived function did not throw\n`;\n\nexports[`toThrow error class threw, but class did not match (error) 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected constructor: <g>Err2</>\nReceived constructor: <r>Err</>\n\nReceived message: <r>\"apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow error class threw, but class did not match (non-error falsey) 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected constructor: <g>Err2</>\n\nReceived value: <r>undefined</>\n\n`;\n\nexports[`toThrow error class threw, but class should not match (error subclass) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected constructor: not <g>Err</>\nReceived constructor:     <r>SubErr</> extends <g>Err</>\n\nReceived message: <r>\"apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow error class threw, but class should not match (error subsubclass) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected constructor: not <g>Err</>\nReceived constructor:     <r>SubSubErr</> extends … extends <g>Err</>\n\nReceived message: <r>\"apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow error class threw, but class should not match (error) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected constructor: not <g>Err</>\n\nReceived message: <r>\"apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow error-message fail isNot false 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected message: <g>\"apple\"</>\nReceived message: <r>\"banana\"</>\n\n`;\n\nexports[`toThrow error-message fail isNot true 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected message: not <g>\"Invalid array length\"</>\n\n`;\n\nexports[`toThrow error-message fail multiline diff highlight incorrect expected space 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\n<g>- Expected message  - 1</>\n<r>+ Received message  + 1</>\n\n<g>- There is no route defined for key Settings.<i> </i></>\n<r>+ There is no route defined for key Settings.</>\n<d>  Must be one of: 'Home'</>\n\n`;\n\nexports[`toThrow expected is undefined threw, but should not have (non-error falsey) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrow<d>()</>\n\nThrown value: <r>null</>\n\n`;\n\nexports[`toThrow invalid actual 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>()</>\n\n<b>Matcher error</>: <r>received</> value must be a function\n\nReceived has type:  string\nReceived has value: <r>\"a string\"</>\n`;\n\nexports[`toThrow invalid arguments 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrow<d>(</><g>expected</><d>)</>\n\n<b>Matcher error</>: <g>expected</> value must be a string or regular expression or class or error\n\nExpected has type:  number\nExpected has value: <g>111</>\n`;\n\nexports[`toThrow promise/async throws if Error-like object is returned did not throw at all 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>toThrow<d>()</>\n\nReceived function did not throw\n`;\n\nexports[`toThrow promise/async throws if Error-like object is returned threw, but class did not match 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected constructor: <g>Err2</>\nReceived constructor: <r>Err</>\n\nReceived message: <r>\"async apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow promise/async throws if Error-like object is returned threw, but should not have 1`] = `\n<d>expect(</><r>received</><d>).</>rejects<d>.</>not<d>.</>toThrow<d>()</>\n\nError name:    <r>\"Error\"</>\nError message: <r>\"async apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow regexp did not throw at all 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected pattern: <g>/apple/</>\n\nReceived function did not throw\n`;\n\nexports[`toThrow regexp threw, but message did not match (error) 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected pattern: <g>/banana/</>\nReceived message: <r>\"apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow regexp threw, but message did not match (non-error falsey) 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected pattern: <g>/^[1-9]\\\\d*/</>\nReceived value:   <r>0</>\n\n`;\n\nexports[`toThrow regexp threw, but message should not match (error) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected pattern: not <g>/ array /</>\nReceived message:     <r>\"Invalid<i> array </i>length\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow regexp threw, but message should not match (non-error truthy) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected pattern: not <g>/^[1-9]\\\\d*/</>\nReceived value:       <r>404</>\n\n`;\n\nexports[`toThrow substring did not throw at all 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected substring: <g>\"apple\"</>\n\nReceived function did not throw\n`;\n\nexports[`toThrow substring threw, but message did not match (error) 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected substring: <g>\"banana\"</>\nReceived message:   <r>\"apple\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow substring threw, but message did not match (non-error falsey) 1`] = `\n<d>expect(</><r>received</><d>).</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected substring: <g>\"Server Error\"</>\nReceived value:     <r>\"\"</>\n\n`;\n\nexports[`toThrow substring threw, but message should not match (error) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected substring: not <g>\"array\"</>\nReceived message:       <r>\"Invalid <i>array</i> length\"</>\n\n      <d>at jestExpect (</>packages/expect/src/__tests__/toThrowMatchers-test.js<d>:24:74)</>\n`;\n\nexports[`toThrow substring threw, but message should not match (non-error truthy) 1`] = `\n<d>expect(</><r>received</><d>).</>not<d>.</>toThrow<d>(</><g>expected</><d>)</>\n\nExpected substring: not <g>\"Server Error\"</>\nReceived value:         <r>\"Internal Server Error\"</>\n\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst a = (b, c) => b + c;\n\nmodule.exports = {a};"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst {Track} = require('../../../src/storage/track/Track');\njest.mock('@@storage/track/Track');\n\ntest('relative import', () => {\n  const track = new Track();\n  expect(track.someRandomFunction).not.toHaveBeenCalled();\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst {Track} = require('@@storage/track/Track');\njest.mock('@@storage/track/Track');\n\ntest('through moduleNameMapper', () => {\n  const track = new Track();\n  expect(track.someRandomFunction).not.toHaveBeenCalled();\n});"}
{"prompt":"babel-jest,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {\n  cleanup,\n  copyDir,\n  createEmptyPackage,\n  extractSummary,\n  linkJestPackage,\n  runYarnInstall,\n} from '../Utils';\nimport runJest, {json as runWithJson} from '../runJest';\n\ndescribe('babel-jest', () => {\n  const dir = path.resolve(__dirname, '..', 'transform/babel-jest');\n\n  beforeAll(() => {\n    runYarnInstall(dir);\n  });\n\n  it('runs transpiled code', () => {\n    // --no-cache because babel can cache stuff and result in false green\n    const {json} = runWithJson(dir, ['--no-cache']);\n    expect(json.success).toBe(true);\n    expect(json.numTotalTests).toBeGreaterThanOrEqual(2);\n  });\n\n  it('instruments only specific files and collects coverage', () => {\n    const {stdout} = runJest(dir, ['--coverage', '--no-cache'], {\n      stripAnsi: true,\n    });\n    expect(stdout).toMatch('covered.js');\n    expect(stdout).not.toMatch('notCovered.js');\n    expect(stdout).not.toMatch('excludedFromCoverage.js');\n    // coverage result should not change\n    expect(stdout).toMatchSnapshot();\n  });\n});\n\ndescribe('babel-jest ignored', () => {\n  const dir = path.resolve(__dirname, '..', 'transform/babel-jest-ignored');\n\n  it('tells user to match ignored files', () => {\n    // --no-cache because babel can cache stuff and result in false green\n    const {exitCode, stderr} = runJest(dir, ['--no-cache']);\n    expect(exitCode).toBe(1);\n    expect(extractSummary(stderr).rest).toMatchSnapshot();\n  });\n});\n\ndescribe('babel-jest with manual transformer', () => {\n  const dir = path.resolve(__dirname, '..', 'transform/babel-jest-manual');\n\n  beforeEach(() => {\n    runYarnInstall(dir);\n  });\n\n  it('runs transpiled code', () => {\n    // --no-cache because babel can cache stuff and result in false green\n    const {json} = runWithJson(dir, ['--no-cache']);\n    expect(json.success).toBe(true);\n    expect(json.numTotalTests).toBeGreaterThanOrEqual(1);\n  });\n});\n\n// babel-jest is automatically linked at the root because it is a workspace now\n// a way to test this in isolation is to move the test suite into a temp folder\ndescribe('no babel-jest', () => {\n  const dir = path.resolve(__dirname, '..', 'transform/no-babel-jest');\n  // doing test in a temp directory because we don't want jest node_modules affect it\n  const tempDir = path.resolve(tmpdir(), 'transform-no-babel-jest');\n\n  beforeEach(() => {\n    cleanup(tempDir);\n    createEmptyPackage(tempDir);\n    copyDir(dir, tempDir);\n    linkJestPackage('babel-jest', tempDir);\n  });\n\n  test('fails with syntax error on flow types', () => {\n    const {stderr} = runJest(tempDir, ['--no-cache', '--no-watchman']);\n    expect(stderr).toMatch(/FAIL.*failsWithSyntaxError/);\n    expect(stderr).toMatch('Unexpected token');\n  });\n\n  test('instrumentation with no babel-jest', () => {\n    const {stdout} = runJest(\n      tempDir,\n      ['--no-cache', '--coverage', '--no-watchman'],\n      {stripAnsi: true},\n    );\n    expect(stdout).toMatch('covered.js');\n    expect(stdout).not.toMatch('excludedFromCoverage.js');\n    // coverage result should not change\n    expect(stdout).toMatchSnapshot();\n  });\n});\n\ndescribe('custom transformer', () => {\n  const dir = path.resolve(\n    __dirname,\n    '..',\n    'transform/custom-instrumenting-preprocessor',\n  );\n\n  it('preprocesses files', () => {\n    const {json, stderr} = runWithJson(dir, ['--no-cache']);\n    expect(stderr).toMatch(/FAIL/);\n    expect(stderr).toMatch(\n      /instruments by setting.*globalThis\\.__INSTRUMENTED__/,\n    );\n    expect(json.numTotalTests).toBe(2);\n    expect(json.numPassedTests).toBe(1);\n    expect(json.numFailedTests).toBe(1);\n  });\n\n  it('instruments files', () => {\n    const {stdout, exitCode} = runJest(dir, ['--no-cache', '--coverage'], {\n      stripAnsi: true,\n    });\n    // coverage should be empty because there's no real instrumentation\n    expect(stdout).toMatchSnapshot();\n    expect(exitCode).toBe(0);\n  });\n});\n\ndescribe('multiple-transformers', () => {\n  const dir = path.resolve(__dirname, '..', 'transform/multiple-transformers');\n\n  beforeEach(() => {\n    runYarnInstall(dir);\n  });\n\n  it('transforms dependencies using specific transformers', () => {\n    const {json, stderr} = runWithJson(dir, ['--no-cache']);\n\n    expect(stderr).toMatch(/PASS/);\n    expect(json.numTotalTests).toBe(1);\n    expect(json.numPassedTests).toBe(1);\n  });\n});\n\ndescribe('ecmascript-modules-support', () => {\n  const dir = path.resolve(\n    __dirname,\n    '..',\n    'transform/ecmascript-modules-support',\n  );\n\n  it('runs transpiled code', () => {\n    // --no-cache because babel can cache stuff and result in false green\n    const {json} = runWithJson(dir, ['--no-cache']);\n    expect(json.success).toBe(true);\n    expect(json.numTotalTests).toBeGreaterThanOrEqual(1);\n  });\n});\n\ndescribe('transformer-config', () => {\n  const dir = path.resolve(__dirname, '..', 'transform/transformer-config');\n\n  beforeEach(() => {\n    runYarnInstall(dir);\n  });\n\n  it('runs transpiled code', () => {\n    // --no-cache because babel can cache stuff and result in false green\n    const {json} = runWithJson(dir, ['--no-cache']);\n    expect(json.success).toBe(true);\n    expect(json.numTotalTests).toBeGreaterThanOrEqual(1);\n  });\n\n  it('instruments only specific files and collects coverage', () => {\n    const {stdout} = runJest(dir, ['--coverage', '--no-cache'], {\n      stripAnsi: true,\n    });\n    expect(stdout).toMatch('Covered.js');\n    expect(stdout).not.toMatch('NotCovered.js');\n    expect(stdout).not.toMatch('ExcludedFromCoverage.js');\n    // coverage result should not change\n    expect(stdout).toMatchSnapshot();\n  });\n});\n\ndescribe('transformer caching', () => {\n  const dir = path.resolve(__dirname, '../transform/cache');\n  const transformedFile = path.resolve(dir, './common-file.js');\n\n  it('does not rerun transform within worker', () => {\n    // --no-cache because babel can cache stuff and result in false green\n    const {stdout} = runJest(dir, ['--no-cache', '-w=2']);\n\n    const loggedFiles = stdout.split('\\n');\n\n    // Verify any lines logged are _just_ the file we care about\n    for (const line of loggedFiles) {\n      expect(line).toBe(transformedFile);\n    }\n\n    // We run with 2 workers, so the file should be transformed twice\n    expect(loggedFiles).toHaveLength(2);\n  });\n});\n\ndescribe('transform-snapshotResolver', () => {\n  const dir = path.resolve(\n    __dirname,\n    '..',\n    'transform/transform-snapshotResolver',\n  );\n  const snapshotDir = path.resolve(dir, '__snapshots__');\n  const snapshotFile = path.resolve(snapshotDir, 'snapshot.test.js.snap');\n\n  const cleanupTest = () => {\n    if (fs.existsSync(snapshotFile)) {\n      fs.unlinkSync(snapshotFile);\n    }\n    if (fs.existsSync(snapshotDir)) {\n      fs.rmdirSync(snapshotDir);\n    }\n  };\n\n  beforeAll(() => {\n    runYarnInstall(dir);\n  });\n  beforeEach(cleanupTest);\n  afterAll(cleanupTest);\n\n  it('should transform the snapshotResolver', () => {\n    const result = runJest(dir, ['-w=1', '--no-cache', '--ci=false']);\n\n    expect(result.stderr).toMatch('1 snapshot written from 1 test suite');\n\n    const contents = require(snapshotFile);\n    expect(contents).toHaveProperty(\n      'snapshots are written to custom location 1',\n    );\n  });\n});\n\ndescribe('transform-environment', () => {\n  const dir = path.resolve(__dirname, '../transform/transform-environment');\n\n  it('should transform the environment', () => {\n    const {json, stderr} = runWithJson(dir, ['--no-cache']);\n    expect(stderr).toMatch(/PASS/);\n    expect(json.success).toBe(true);\n    expect(json.numPassedTests).toBe(1);\n  });\n});\n\ndescribe('transform-runner', () => {\n  const dir = path.resolve(__dirname, '../transform/transform-runner');\n\n  it('should transform runner', () => {\n    const {json, stderr} = runWithJson(dir, ['--no-cache']);\n    expect(stderr).toMatch(/PASS/);\n    expect(json.success).toBe(true);\n    expect(json.numPassedTests).toBe(1);\n  });\n});\n\ndescribe('transform-testrunner', () => {\n  const dir = path.resolve(__dirname, '../transform/transform-testrunner');\n\n  it('should transform testRunner', () => {\n    runYarnInstall(dir);\n    const {json, stderr} = runWithJson(dir, ['--no-cache']);\n    expect(stderr).toMatch(/PASS/);\n    expect(json.success).toBe(true);\n    expect(json.numPassedTests).toBe(1);\n  });\n});\n\ndescribe('esm-transformer', () => {\n  const dir = path.resolve(__dirname, '../transform/esm-transformer');\n\n  it('should transform with transformer written in ESM', () => {\n    const {json, stderr} = runWithJson(dir, ['--no-cache']);\n    expect(stderr).toMatch(/PASS/);\n    expect(json.success).toBe(true);\n    expect(json.numPassedTests).toBe(1);\n  });\n});\n\ndescribe('async-transformer', () => {\n  const dir = path.resolve(__dirname, '../transform/async-transformer');\n\n  it('should transform with transformer with only async transforms', () => {\n    const {json, stderr} = runWithJson(dir, ['--no-cache'], {\n      nodeOptions: '--experimental-vm-modules --no-warnings',\n    });\n    expect(stderr).toMatch(/PASS/);\n    expect(json.success).toBe(true);\n    expect(json.numPassedTests).toBe(2);\n  });\n});\n\ndescribe('babel-jest-async', () => {\n  const dir = path.resolve(__dirname, '../transform/babel-jest-async');\n\n  beforeAll(() => {\n    runYarnInstall(dir);\n  });\n\n  it(\"should use babel-jest's async transforms\", () => {\n    const {json, stderr} = runWithJson(dir, ['--no-cache'], {\n      nodeOptions: '--experimental-vm-modules --no-warnings',\n    });\n    expect(stderr).toMatch(/PASS/);\n    expect(json.success).toBe(true);\n    expect(json.numPassedTests).toBe(1);\n  });\n});\n\ndescribe('transform-esm-runner', () => {\n  const dir = path.resolve(__dirname, '../transform/transform-esm-runner');\n  test('runs test with native ESM', () => {\n    const {json, stderr} = runWithJson(dir, ['--no-cache'], {\n      nodeOptions: '--experimental-vm-modules --no-warnings',\n    });\n\n    expect(stderr).toMatch(/PASS/);\n    expect(json.success).toBe(true);\n    expect(json.numPassedTests).toBe(1);\n  });\n});\n\ndescribe('transform-esm-testrunner', () => {\n  const dir = path.resolve(__dirname, '../transform/transform-esm-testrunner');\n  runYarnInstall(dir);\n  test('runs test with native ESM', () => {\n    const {json, stderr} = runWithJson(dir, ['--no-cache'], {\n      nodeOptions: '--experimental-vm-modules --no-warnings',\n    });\n\n    expect(stderr).toMatch(/PASS/);\n    expect(json.success).toBe(true);\n    expect(json.numPassedTests).toBe(1);\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`babel-jest ignored tells user to match ignored files 1`] = `\n\"FAIL __tests__/ignoredFile.test.js\n  ● Test suite failed to run\n\n    babel-jest: Babel ignores __tests__/ignoredFile.test.js - make sure to include the file in Jest's transformIgnorePatterns as well.\n\n      at assertLoadedBabelConfig (../../../packages/babel-jest/build/index.js:138:11)\"\n`;\n\nexports[`babel-jest instruments only specific files and collects coverage 1`] = `\n\"------------|---------|----------|---------|---------|-------------------\nFile        | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n------------|---------|----------|---------|---------|-------------------\nAll files   |   83.33 |      100 |      50 |      80 |                   \n covered.js |   83.33 |      100 |      50 |      80 | 13                \n------------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`custom transformer instruments files 1`] = `\n\"----------|---------|----------|---------|---------|-------------------\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n----------|---------|----------|---------|---------|-------------------\nAll files |       0 |        0 |       0 |       0 |                   \n----------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`no babel-jest instrumentation with no babel-jest 1`] = `\n\"------------|---------|----------|---------|---------|-------------------\nFile        | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n------------|---------|----------|---------|---------|-------------------\nAll files   |   83.33 |      100 |      50 |      80 |                   \n covered.js |   83.33 |      100 |      50 |      80 | 13                \n------------|---------|----------|---------|---------|-------------------\"\n`;\n\nexports[`transformer-config instruments only specific files and collects coverage 1`] = `\n\"------------|---------|----------|---------|---------|-------------------\nFile        | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n------------|---------|----------|---------|---------|-------------------\nAll files   |   83.33 |      100 |      50 |      80 |                   \n Covered.js |   83.33 |      100 |      50 |      80 | 13                \n------------|---------|----------|---------|---------|-------------------\"\n`;"}
{"prompt":"strips flowtypes using babel-jest and config passed to transformer,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nrequire('../this-directory-is-covered/ExcludedFromCoverage');\n\nit('strips flowtypes using babel-jest and config passed to transformer', () => {\n  const a: string = 'a';\n  expect(a).toBe('a');\n});"}
{"prompt":"should transform linked modules,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {json as runWithJson} from '../runJest';\n\nit('should transform linked modules', () => {\n  const {json: result} = runWithJson('transform-linked-modules', [\n    '--no-cache',\n  ]);\n\n  expect(result.success).toBe(true);\n  expect(result.numTotalTests).toBe(2);\n});"}
{"prompt":"Test generated from existing file","test":"{\n  \"extends\": \"../../../../tsconfig.test.json\",\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"types\": [\"node\", \"@jest/test-globals\"]\n  },\n  \"references\": [{\"path\": \"../../\"}]\n}"}
{"prompt":"when Config type is imported from @jest/types,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest, {getConfig} from '../runJest';\n\nconst DIR = path.resolve(__dirname, '../ts-node-integration');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ndescribe('when `Config` type is imported from \"@jest/types\"', () => {\n  test('with object config exported from TS file', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.ts': `\n        import type {Config} from '@jest/types';\n        const config: Config.InitialOptions = {displayName: 'ts-object-config', verbose: true};\n        export default config;\n        `,\n      'package.json': '{}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-object-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('with function config exported from TS file', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.ts': `\n        import type {Config} from '@jest/types';\n        async function getVerbose() {return true;}\n        export default async (): Promise<Config.InitialOptions> => {\n          const verbose: Config.InitialOptions['verbose'] = await getVerbose();\n          return {displayName: 'ts-async-function-config', verbose};\n        };\n        `,\n      'package.json': '{}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-async-function-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('with object config exported from CTS file', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.cts': `\n        import type {Config} from '@jest/types';\n        const config: Config.InitialOptions = {displayName: 'ts-object-config', verbose: true};\n        export default config;\n      `,\n      'package.json': '{}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-object-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('with function config exported from CTS file', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.cts': `\n        import type {Config} from '@jest/types';\n        async function getVerbose() {return true;}\n        export default async (): Promise<Config.InitialOptions> => {\n          const verbose: Config.InitialOptions['verbose'] = await getVerbose();\n          return {displayName: 'ts-async-function-config', verbose};\n        };\n        `,\n      'package.json': '{}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-async-function-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('throws if type errors are encountered', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.ts': `\n        import type {Config} from '@jest/types';\n        const config: Config.InitialOptions = {testTimeout: '10000'};\n        export default config;\n        `,\n      'package.json': '{}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.ts(2,40): error TS2322: Type 'string' is not assignable to type 'number'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test('throws if syntax errors are encountered', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.ts': `\n        import type {Config} from '@jest/types';\n        const config: Config.InitialOptions = {verbose: true};\n        export default get config;\n        `,\n      'package.json': '{}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.ts(3,16): error TS2304: Cannot find name 'get'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test('throws if type errors are encountered with CTS config', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.cts': `\n        import type {Config} from '@jest/types';\n        const config: Config.InitialOptions = {testTimeout: '10000'};\n        export default config;\n        `,\n      'package.json': '{}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.cts(2,40): error TS2322: Type 'string' is not assignable to type 'number'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test('throws if syntax errors are encountered with CTS config', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.cts': `\n        import type {Config} from '@jest/types';\n        const config: Config.InitialOptions = {verbose: true};\n        export default get config;\n        `,\n      'package.json': '{}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.cts(3,16): error TS2304: Cannot find name 'get'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test('works with object config exported from TS file when package.json#type=module', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(12).toBe(12));\",\n      'jest.config.ts': `\n          import type {Config} from '@jest/types';\n          const config: Config.InitialOptions = {displayName: 'ts-esm-object-config', verbose: true};\n          export default config;\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-esm-object-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('works with function config exported from TS file when package.json#type=module', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(12).toBe(12));\",\n      'jest.config.ts': `\n      import type {Config} from '@jest/types';\n      async function getVerbose() {return true;}\n      export default async (): Promise<Config.InitialOptions> => {\n        const verbose: Config.InitialOptions['verbose'] = await getVerbose();\n        return {displayName: 'ts-esm-async-function-config', verbose};\n      };\n      `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-esm-async-function-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('works with object config exported from CTS file when package.json#type=module', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(12).toBe(12));\",\n      'jest.config.cts': `\n          import type {Config} from '@jest/types';\n          const config: Config.InitialOptions = {displayName: 'ts-esm-object-config', verbose: true};\n          export default config;\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-esm-object-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('works with function config exported from CTS file when package.json#type=module', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(12).toBe(12));\",\n      'jest.config.cts': `\n          import type {Config} from '@jest/types';\n          async function getVerbose() {return true;}\n          export default async (): Promise<Config.InitialOptions> => {\n            const verbose: Config.InitialOptions['verbose'] = await getVerbose();\n            return {displayName: 'ts-esm-async-function-config', verbose};\n          };\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-esm-async-function-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('throws if type errors are encountered when package.json#type=module', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(12).toBe(12));\",\n      'jest.config.ts': `\n          import type {Config} from '@jest/types';\n          const config: Config.InitialOptions = {testTimeout: '10000'};\n          export default config;\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.ts(2,40): error TS2322: Type 'string' is not assignable to type 'number'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test('throws if syntax errors are encountered when package.json#type=module', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.ts': `\n          import type {Config} from '@jest/types';\n          const config: Config.InitialOptions = {verbose: true};\n          export default get config;\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.ts(3,16): error TS2304: Cannot find name 'get'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test('throws if type errors are encountered when package.json#type=module with CTS config', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(12).toBe(12));\",\n      'jest.config.cts': `\n          import type {Config} from '@jest/types';\n          const config: Config.InitialOptions = {testTimeout: '10000'};\n          export default config;\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.cts(2,40): error TS2322: Type 'string' is not assignable to type 'number'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test('throws if syntax errors are encountered when package.json#type=module with CTS config', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.cts': `\n          import type {Config} from '@jest/types';\n          const config: Config.InitialOptions = {verbose: true};\n          export default get config;\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.cts(3,16): error TS2304: Cannot find name 'get'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n});\n\ndescribe('when `Config` type is imported from \"jest\"', () => {\n  test('with object config exported from TS file', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.ts': `\n        import type {Config} from 'jest';\n        const config: Config = {displayName: 'ts-object-config', verbose: true};\n        export default config;\n        `,\n      'package.json': '{}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-object-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('with function config exported from TS file', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.ts': `\n        import type {Config} from 'jest';\n        async function getVerbose() {return true;}\n        export default async (): Promise<Config> => {\n          const verbose: Config['verbose'] = await getVerbose();\n          return {displayName: 'ts-async-function-config', verbose};\n        };\n        `,\n      'package.json': '{}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-async-function-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('with object config exported from CTS file', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.cts': `\n        import type {Config} from 'jest';\n        const config: Config = {displayName: 'ts-object-config', verbose: true};\n        export default config;\n        `,\n      'package.json': '{}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-object-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('with function config exported from CTS file', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.cts': `\n        import type {Config} from 'jest';\n        async function getVerbose() {return true;}\n        export default async (): Promise<Config> => {\n          const verbose: Config['verbose'] = await getVerbose();\n          return {displayName: 'ts-async-function-config', verbose};\n        };\n        `,\n      'package.json': '{}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-async-function-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('throws if type errors are encountered', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.ts': `\n        import type {Config} from 'jest';\n        const config: Config = {testTimeout: '10000'};\n        export default config;\n        `,\n      'package.json': '{}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.ts(2,25): error TS2322: Type 'string' is not assignable to type 'number'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test('throws if syntax errors are encountered', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.ts': `\n        import type {Config} from 'jest';\n        const config: Config = {verbose: true};\n        export default get config;\n        `,\n      'package.json': '{}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.ts(3,16): error TS2304: Cannot find name 'get'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test('throws if type errors are encountered with CTS config', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.cts': `\n        import type {Config} from 'jest';\n        const config: Config = {testTimeout: '10000'};\n        export default config;\n        `,\n      'package.json': '{}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.cts(2,25): error TS2322: Type 'string' is not assignable to type 'number'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test('throws if syntax errors are encountered with CTS config', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.cts': `\n        import type {Config} from 'jest';\n        const config: Config = {verbose: true};\n        export default get config;\n        `,\n      'package.json': '{}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.cts(3,16): error TS2304: Cannot find name 'get'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test('works with object config exported from TS file when package.json#type=module', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(12).toBe(12));\",\n      'jest.config.ts': `\n          import type {Config} from 'jest';\n          const config: Config = {displayName: 'ts-esm-object-config', verbose: true};\n          export default config;\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-esm-object-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('works with function config exported from TS file when package.json#type=module', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(12).toBe(12));\",\n      'jest.config.ts': `\n          import type {Config} from 'jest';\n          async function getVerbose() {return true;}\n          export default async (): Promise<Config> => {\n            const verbose: Config['verbose'] = await getVerbose();\n            return {displayName: 'ts-esm-async-function-config', verbose};\n          };\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-esm-async-function-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('works with object config exported from CTS file when package.json#type=module', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(12).toBe(12));\",\n      'jest.config.cts': `\n          import type {Config} from 'jest';\n          const config: Config = {displayName: 'ts-esm-object-config', verbose: true};\n          export default config;\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-esm-object-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('works with function config exported from CTS file when package.json#type=module', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(12).toBe(12));\",\n      'jest.config.cts': `\n          import type {Config} from 'jest';\n          async function getVerbose() {return true;}\n          export default async (): Promise<Config> => {\n            const verbose: Config['verbose'] = await getVerbose();\n            return {displayName: 'ts-esm-async-function-config', verbose};\n          };\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {configs, globalConfig} = getConfig(path.join(DIR));\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName?.name).toBe('ts-esm-async-function-config');\n    expect(globalConfig.verbose).toBe(true);\n  });\n\n  test('throws if type errors are encountered when package.json#type=module', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(12).toBe(12));\",\n      'jest.config.ts': `\n          import type {Config} from 'jest';\n          const config: Config = {testTimeout: '10000'};\n          export default config;\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.ts(2,25): error TS2322: Type 'string' is not assignable to type 'number'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test('throws if syntax errors are encountered when package.json#type=module', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.ts': `\n          import type {Config} from 'jest';\n          const config: Config = {verbose: true};\n          export default get config;\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.ts(3,16): error TS2304: Cannot find name 'get'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test('throws if type errors are encountered when package.json#type=module with CTS config', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(12).toBe(12));\",\n      'jest.config.cts': `\n          import type {Config} from 'jest';\n          const config: Config = {testTimeout: '10000'};\n          export default config;\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.cts(2,25): error TS2322: Type 'string' is not assignable to type 'number'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n\n  test('throws if syntax errors are encountered when package.json#type=module with CTS config', () => {\n    writeFiles(DIR, {\n      '__tests__/dummy.test.js': \"test('dummy', () => expect(123).toBe(123));\",\n      'jest.config.cts': `\n          import type {Config} from 'jest';\n          const config: Config = {verbose: true};\n          export default get config;\n          `,\n      'package.json': '{\"type\": \"module\"}',\n    });\n\n    const {stderr, exitCode} = runJest(DIR);\n\n    expect(stderr).toMatch(\n      \"jest.config.cts(3,16): error TS2304: Cannot find name 'get'.\",\n    );\n    expect(exitCode).toBe(1);\n  });\n});"}
{"prompt":"eslint-disable-next-line @typescript-eslint/no-empty-object-type","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {color} from '../entry';\nimport type {Color} from '../types';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\njest.mock('some-module', () => ({}) as Partial<{}>, {virtual: true});\n\njest.mock('../entry', () => {\n  const color: Color = 'blue';\n  return {color};\n});\n\ndescribe('babel-plugin-jest-hoist', () => {\n  it('works even with type imports', () => {\n    expect(color).toBe('blue');\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport * as semver from 'semver';\nimport {onNodeVersions} from '@jest/test-utils';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest, {getConfig} from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'typescript-config-file');\nconst useNativeTypeScript = semver.satisfies(process.versions.node, '>=23.6.0');\nconst importFileExtension = useNativeTypeScript ? '.ts' : '';\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ntest('works with single typescript config that imports something', () => {\n  writeFiles(DIR, {\n    '__tests__/mytest.alpha.js': \"test('alpha', () => expect(1).toBe(1));\",\n    '__tests__/mytest.common.js': \"test('common', () => expect(1).toBe(1));\",\n    'alpha.config.ts': `\n    import commonRegex from './common${importFileExtension}';\n    export default {\n      testRegex: [ commonRegex, '__tests__/mytest.alpha.js' ]\n    };`,\n    'common.ts': \"export default '__tests__/mytest.common.js$';\",\n  });\n\n  const {stdout, stderr, exitCode} = runJest(\n    DIR,\n    ['--projects', 'alpha.config.ts'],\n    {\n      skipPkgJsonCheck: true,\n    },\n  );\n\n  expect(stderr).toContain('PASS __tests__/mytest.alpha.js');\n  expect(stderr).toContain('PASS __tests__/mytest.common.js');\n  expect(stderr).toContain('Test Suites: 2 passed, 2 total');\n  expect(exitCode).toBe(0);\n  expect(stdout).toBe('');\n});\n\ntest('works with multiple typescript configs', () => {\n  writeFiles(DIR, {\n    '__tests__/mytest.alpha.js': \"test('alpha', () => expect(1).toBe(1));\",\n    '__tests__/mytest.beta.js': \"test('beta', () => expect(1).toBe(1));\",\n    'alpha.config.ts': `\n    export default {\n      testRegex: '__tests__/mytest.alpha.js'\n    };`,\n    'beta.config.ts': `\n    export default {\n      testRegex: '__tests__/mytest.beta.js'\n    };`,\n  });\n\n  const {stdout, stderr, exitCode} = runJest(\n    DIR,\n    ['--projects', 'alpha.config.ts', 'beta.config.ts'],\n    {\n      skipPkgJsonCheck: true,\n    },\n  );\n\n  expect(stderr).toContain('PASS __tests__/mytest.alpha.js');\n  expect(stderr).toContain('PASS __tests__/mytest.beta.js');\n  expect(stderr).toContain('Test Suites: 2 passed, 2 total');\n  expect(exitCode).toBe(0);\n  expect(stdout).toBe('');\n});\n\ntest('works with multiple typescript configs that import something', () => {\n  writeFiles(DIR, {\n    '__tests__/mytest.alpha.js': \"test('alpha', () => expect(1).toBe(1));\",\n    '__tests__/mytest.beta.js': \"test('beta', () => expect(1).toBe(1));\",\n    '__tests__/mytest.common.js': \"test('common', () => expect(1).toBe(1));\",\n    'alpha.config.ts': `\n    import commonRegex from './common${importFileExtension}';\n    export default {\n      testRegex: [ commonRegex, '__tests__/mytest.alpha.js' ]\n    };`,\n    'beta.config.ts': `\n    import commonRegex from './common${importFileExtension}';\n    export default {\n      testRegex: [ commonRegex, '__tests__/mytest.beta.js' ]\n    };`,\n    'common.ts': \"export default '__tests__/mytest.common.js$';\",\n  });\n\n  const {stdout, stderr, exitCode} = runJest(\n    DIR,\n    ['--projects', 'alpha.config.ts', 'beta.config.ts'],\n    {\n      skipPkgJsonCheck: true,\n    },\n  );\n\n  expect(stderr).toContain('PASS __tests__/mytest.alpha.js');\n  expect(stderr).toContain('PASS __tests__/mytest.beta.js');\n  expect(stderr).toContain('PASS __tests__/mytest.common.js');\n  expect(stderr.replace('PASS __tests__/mytest.common.js', '')).toContain(\n    'PASS __tests__/mytest.common.js',\n  );\n  expect(stderr).toContain('Test Suites: 4 passed, 4 total');\n  expect(exitCode).toBe(0);\n  expect(stdout).toBe('');\n});\n\nonNodeVersions('<23.6', () => {\n  test(\"works with single typescript config that does not import anything with project's moduleResolution set to Node16\", () => {\n    const {configs} = getConfig(\n      'typescript-config/modern-module-resolution',\n      [],\n      {\n        skipPkgJsonCheck: true,\n      },\n    );\n\n    expect(configs).toHaveLength(1);\n    expect(configs[0].displayName).toEqual({\n      color: 'white',\n      name: 'Config from modern ts file',\n    });\n  });\n});"}
{"prompt":"instruments and collects coverage for typescript files,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path';\nimport {runYarnInstall} from '../Utils';\nimport runJest from '../runJest';\n\nit('instruments and collects coverage for typescript files', () => {\n  const dir = path.resolve(__dirname, '../typescript-coverage');\n  runYarnInstall(dir);\n  const {stdout} = runJest(dir, ['--coverage', '--no-cache'], {\n    stripAnsi: true,\n  });\n  expect(stdout).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`instruments and collects coverage for typescript files 1`] = `\n\"------------|---------|----------|---------|---------|-------------------\nFile        | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n------------|---------|----------|---------|---------|-------------------\nAll files   |     100 |      100 |     100 |     100 |                   \n covered.ts |     100 |      100 |     100 |     100 |                   \n------------|---------|----------|---------|---------|-------------------\"\n`;"}
{"prompt":"should surface pnp errors,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nit('should surface pnp errors', () => {\n  expect(() => {\n    require('undeclared');\n  }).toThrow(expect.objectContaining({code: 'MODULE_NOT_FOUND'}));\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'unexpected-token');\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ntest('triggers unexpected token error message for non-JS assets', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '{}',\n    'asset.css': '.style {}',\n    'package.json': JSON.stringify({jest: {testEnvironment: 'node'}}),\n  });\n\n  writeFiles(DIR, {\n    '__tests__/asset.test.js':\n      \"require('../asset.css'); test('asset', () => {});\",\n  });\n\n  const {stdout, stderr} = runJest(DIR, ['']);\n\n  expect(stdout).toBe('');\n  expect(stderr).toMatch(/Jest encountered an unexpected token/);\n  expect(stderr).toMatch(/.style {}/);\n  expect(stderr).toMatch(/Unexpected token ./);\n});\n\ntest('triggers unexpected token error message for untranspiled node_modules', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '{}',\n    'node_modules/untranspiled-module': 'import {module} from \"some-module\"',\n    'package.json': JSON.stringify({jest: {testEnvironment: 'node'}}),\n  });\n\n  writeFiles(DIR, {\n    '__tests__/untranspiledModule.test.js':\n      \"require('untranspiled-module'); test('untranspiled', () => {});\",\n  });\n\n  const {stdout, stderr} = runJest(DIR, ['']);\n\n  expect(stdout).toBe('');\n  expect(stderr).toMatch(/Jest encountered an unexpected token/);\n  expect(stderr).toMatch(/import {module}/);\n  expect(stderr).toMatch(\n    /SyntaxError: Cannot use import statement outside a module/,\n  );\n});\n\ntest('does not trigger unexpected token error message for regular syntax errors', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '{}',\n    'faulty.js': 'import {module from \"some-module\"',\n    'faulty2.js': 'const name = {first: \"Name\" second: \"Second\"}',\n    'package.json': JSON.stringify({jest: {testEnvironment: 'node'}}),\n  });\n\n  writeFiles(DIR, {\n    '__tests__/faulty.test.js':\n      \"require('../faulty'); test('faulty', () => {});\",\n    '__tests__/faulty2.test.js':\n      \"require('../faulty2'); test('faulty2', () => {});\",\n  });\n\n  const {stdout, stderr} = runJest(DIR, ['']);\n\n  expect(stdout).toBe('');\n  expect(stderr).not.toMatch(/Jest encountered an unexpected token/);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nconst {promisify} = require('util');\n\nafterAll(async () => {\n  Promise.reject(new Error('REJECTED'));\n\n  await promisify(setTimeout)(0);\n});\n\ntest('foo', () => {});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nconst {promisify} = require('util');\n\nafterEach(async () => {\n  Promise.reject(new Error('REJECTED'));\n\n  await promisify(setTimeout)(0);\n});\n\ntest('foo #1', () => {});\n\ntest('foo #2', () => {});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nconst {promisify} = require('util');\n\nbeforeAll(async () => {\n  Promise.reject(new Error('REJECTED'));\n\n  await promisify(setTimeout)(0);\n});\n\ntest('foo', () => {});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nconst {promisify} = require('util');\n\nbeforeEach(async () => {\n  Promise.reject(new Error('REJECTED'));\n\n  await promisify(setTimeout)(0);\n});\n\ntest('foo #1', () => {});\n\ntest('foo #2', () => {});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\nconst {promisify} = require('util');\n\ntest('w/o event loop turn after rejection', () => {\n  Promise.reject(new Error('REJECTED'));\n});\n\ntest('w/ event loop turn after rejection in async function', async () => {\n  Promise.reject(new Error('REJECTED'));\n\n  await promisify(setTimeout)(0);\n});\n\ntest('w/ event loop turn after rejection in sync function', done => {\n  Promise.reject(new Error('REJECTED'));\n\n  setTimeout(done, 0);\n});\n\ntest('combined w/ another failure _after_ promise rejection', async () => {\n  Promise.reject(new Error('REJECTED'));\n\n  await promisify(setTimeout)(0);\n\n  expect(true).toBe(false);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntest('something', () => {\n  const timeout = setTimeout(() => {}, 30_000);\n  timeout.unref();\n  expect(true).toBe(true);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\ntest('fake timers', () => {\n  jest.useFakeTimers({\n    legacyFakeTimers: true,\n  });\n\n  expect(() => jest.setSystemTime(0)).toThrow(\n    '`jest.setSystemTime()` is not available when using legacy fake timers.',\n  );\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\nimport user from '../models/user';\n\ntest('if original user model', () => {\n  expect(user.getAuthenticated()).toEqual({age: 26, name: 'Real name'});\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\njest.useRealTimers();\n\ntest('bar', () => {\n  jest.runAllTimers();\n});"}
{"prompt":"Copyright c Meta Platforms, Inc. and affiliates.. All Rights Reserved.","test":"// Copyright (c) Meta Platforms, Inc. and affiliates.. All Rights Reserved.\n\nimport user from '../models/user';\n\njest.mock('../models/user');\n\ntest('if user model is mocked', () => {\n  expect(user.getAuthenticated()).toEqual({age: 622, name: 'Mock name'});\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'use-stderr-test');\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\n\ntest('no tests found message is redirected to stderr', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    'file1.js': 'module.exports = {}',\n    'package.json': JSON.stringify({jest: {testEnvironment: 'node'}}),\n  });\n  let stderr;\n  let stdout;\n\n  ({stdout, stderr} = runJest(DIR, ['--useStderr']));\n  expect(stdout).toBe('');\n  expect(stderr).toMatch('No tests found');\n\n  writeFiles(DIR, {\n    '__tests__/test.test.js': \"require('../file1'); test('file1', () => {});\",\n  });\n\n  ({stdout, stderr} = runJest(DIR, ['--useStderr']));\n  expect(stdout).toBe('');\n  expect(stderr).toMatch(/PASS.*test\\.test\\.js/);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nmodule.exports = 'isModuleEncodedInUTF8WithBOM';"}
{"prompt":"Test generated from existing file","test":"{\"isJSONModuleEncodedInUTF8WithBOM\": true}"}
{"prompt":"isLocalhost should detect localhost environment,  => {","test":"import {isLocalhost} from '../utils';\n\nafterEach(() => {\n  jest.restoreAllMocks();\n});\n\nit('isLocalhost should detect localhost environment', () => {\n  jest.replaceProperty(process, 'env', {HOSTNAME: 'localhost'});\n\n  expect(isLocalhost()).toBe(true);\n});\n\nit('isLocalhost should detect non-localhost environment', () => {\n  jest.replaceProperty(process, 'env', {HOSTNAME: 'example.com'});\n\n  expect(isLocalhost()).toBe(false);\n});"}
{"prompt":"eslint-disable-next-line no-eval","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\njest.mock('graceful-fs', () => ({\n  ...jest.createMockFromModule<typeof import('fs')>('fs'),\n  existsSync: jest.fn().mockReturnValue(true),\n}));\n\nimport * as path from 'path';\nimport chalk = require('chalk');\nimport * as fs from 'graceful-fs';\nimport {\n  SNAPSHOT_GUIDE_LINK,\n  SNAPSHOT_VERSION,\n  SNAPSHOT_VERSION_WARNING,\n  getSnapshotData,\n  keyToTestName,\n  saveSnapshotFile,\n  testNameToKey,\n} from '../utils';\n\ntest('keyToTestName()', () => {\n  expect(keyToTestName('abc cde 12')).toBe('abc cde');\n  expect(keyToTestName('abc cde   12')).toBe('abc cde  ');\n  expect(() => keyToTestName('abc cde')).toThrow(\n    'Snapshot keys must end with a number.',\n  );\n});\n\ntest('testNameToKey', () => {\n  expect(testNameToKey('abc cde', 1)).toBe('abc cde 1');\n  expect(testNameToKey('abc cde ', 12)).toBe('abc cde  12');\n});\n\ntest('saveSnapshotFile() works with \\r\\n', () => {\n  const filename = path.join(__dirname, 'remove-newlines.snap');\n  const data = {\n    myKey: '<div>\\r\\n</div>',\n  };\n\n  saveSnapshotFile(data, filename);\n  expect(fs.writeFileSync).toHaveBeenCalledWith(\n    filename,\n    `// Jest Snapshot v1, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n      'exports[`myKey`] = `<div>\\n</div>`;\\n',\n  );\n});\n\ntest('saveSnapshotFile() works with \\r', () => {\n  const filename = path.join(__dirname, 'remove-newlines.snap');\n  const data = {\n    myKey: '<div>\\r</div>',\n  };\n\n  saveSnapshotFile(data, filename);\n  expect(fs.writeFileSync).toHaveBeenCalledWith(\n    filename,\n    `// Jest Snapshot v1, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n      'exports[`myKey`] = `<div>\\n</div>`;\\n',\n  );\n});\n\ntest('getSnapshotData() throws when no snapshot version', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue('exports[`myKey`] = `<div>\\n</div>`;\\n');\n  const update = 'none';\n\n  expect(() => getSnapshotData(filename, update)).toThrow(\n    chalk.red(\n      `${chalk.bold('Outdated snapshot')}: No snapshot header found. ` +\n        'Jest 19 introduced versioned snapshots to ensure all developers on ' +\n        'a project are using the same version of Jest. ' +\n        'Please update all snapshots during this upgrade of Jest.\\n\\n',\n    ) + SNAPSHOT_VERSION_WARNING,\n  );\n});\n\ntest('getSnapshotData() throws for older snapshot version', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue(\n      `// Jest Snapshot v0.99, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n        'exports[`myKey`] = `<div>\\n</div>`;\\n',\n    );\n  const update = 'none';\n\n  expect(() => getSnapshotData(filename, update)).toThrow(\n    `${chalk.red(\n      `${chalk.red.bold('Outdated snapshot')}: The version of the snapshot ` +\n        'file associated with this test is outdated. The snapshot file ' +\n        'version ensures that all developers on a project are using ' +\n        'the same version of Jest. ' +\n        'Please update all snapshots during this upgrade of Jest.',\n    )}\\n\\nExpected: v${SNAPSHOT_VERSION}\\n` +\n      `Received: v0.99\\n\\n${SNAPSHOT_VERSION_WARNING}`,\n  );\n});\n\ntest('getSnapshotData() throws for newer snapshot version', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue(\n      `// Jest Snapshot v2, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n        'exports[`myKey`] = `<div>\\n</div>`;\\n',\n    );\n  const update = 'none';\n\n  expect(() => getSnapshotData(filename, update)).toThrow(\n    `${chalk.red(\n      `${chalk.red.bold('Outdated Jest version')}: The version of this ` +\n        'snapshot file indicates that this project is meant to be used ' +\n        'with a newer version of Jest. ' +\n        'The snapshot file version ensures that all developers on a project ' +\n        'are using the same version of Jest. ' +\n        'Please update your version of Jest and re-run the tests.',\n    )}\\n\\nExpected: v${SNAPSHOT_VERSION}\\nReceived: v2`,\n  );\n});\n\ntest('getSnapshotData() does not throw for when updating', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue('exports[`myKey`] = `<div>\\n</div>`;\\n');\n  const update = 'all';\n\n  expect(() => getSnapshotData(filename, update)).not.toThrow();\n});\n\ntest('getSnapshotData() marks invalid snapshot dirty when updating', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue('exports[`myKey`] = `<div>\\n</div>`;\\n');\n  const update = 'all';\n\n  expect(getSnapshotData(filename, update)).toMatchObject({dirty: true});\n});\n\ntest('getSnapshotData() marks valid snapshot not dirty when updating', () => {\n  const filename = path.join(__dirname, 'old-snapshot.snap');\n  jest\n    .mocked(fs.readFileSync)\n    .mockReturnValue(\n      `// Jest Snapshot v${SNAPSHOT_VERSION}, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n        'exports[`myKey`] = `<div>\\n</div>`;\\n',\n    );\n  const update = 'all';\n\n  expect(getSnapshotData(filename, update)).toMatchObject({dirty: false});\n});\n\ntest('escaping', () => {\n  const filename = path.join(__dirname, 'escaping.snap');\n  const data = '\"\\'\\\\';\n  const writeFileSync = jest.mocked(fs.writeFileSync);\n\n  writeFileSync.mockReset();\n  saveSnapshotFile({key: data}, filename);\n  const writtenData = writeFileSync.mock.calls[0][1];\n  expect(writtenData).toBe(\n    `// Jest Snapshot v1, ${SNAPSHOT_GUIDE_LINK}\\n\\n` +\n      'exports[`key`] = `\"\\'\\\\\\\\`;\\n',\n  );\n\n  // eslint-disable-next-line no-eval\n  const readData = eval(`var exports = {}; ${writtenData} exports`);\n  expect(readData).toEqual({key: data});\n  const snapshotData = readData.key;\n  expect(data).toEqual(snapshotData);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`printDisplayName should correctly print the displayName when color and name are valid values 1`] = `\"</><inverse><green> hello </color></inverse></>\"`;\n\nexports[`printDisplayName should default displayName color to white when color is not a valid value 1`] = `\"</><inverse><white> hello </color></inverse></>\"`;\n\nexports[`printDisplayName should default displayName color to white when displayName is a string 1`] = `\"</><inverse><white> hello </color></inverse></>\"`;\n\nexports[`trimAndFormatPath() does not trim anything 1`] = `\"<dim>1234567890/1234567890/</intensity><bold>1234.js</intensity>\"`;\n\nexports[`trimAndFormatPath() split at the path.sep index 1`] = `\"<dim>.../</intensity><bold>1234.js</intensity>\"`;\n\nexports[`trimAndFormatPath() trims dirname (longer line width) 1`] = `\"<dim>...890/1234567890/</intensity><bold>1234.js</intensity>\"`;\n\nexports[`trimAndFormatPath() trims dirname 1`] = `\"<dim>...234567890/</intensity><bold>1234.js</intensity>\"`;\n\nexports[`trimAndFormatPath() trims dirname and basename 1`] = `\"<bold>...1234.js</intensity>\"`;\n\nexports[`wrapAnsiString() returns the string unaltered if given a terminal width of zero 1`] = `\"This string shouldn't cause you any trouble\"`;\n\nexports[`wrapAnsiString() returns the string unaltered if given a terminal width of zero 2`] = `\"This string shouldn't cause you any trouble\"`;\n\nexports[`wrapAnsiString() wraps a long string containing ansi chars 1`] = `\n\"abcde <red><bold>red-\nbold</intensity></color> 12344\n56<dim>bcd</intensity> 123t\ntttttththt\nhththththt\nhththththt\nhththththt\nhthththtet\netetetette\ntetetetete\ntetete<underline><bold>stnh\nsnthsnth</intensity></underline>ss\not\"\n`;\n\nexports[`wrapAnsiString() wraps a long string containing ansi chars 2`] = `\n\"abcde red-\nbold 12344\n56bcd 123t\ntttttththt\nhththththt\nhththththt\nhththththt\nhthththtet\netetetette\ntetetetete\ntetetestnh\nsnthsnthss\not\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {multipleValidOptions} from '../condition';\nimport jestValidateDefaultConfig from '../defaultConfig';\nimport jestValidateExampleConfig from '../exampleConfig';\nimport validate from '../validate';\nimport {\n  defaultConfig,\n  deprecatedConfig,\n  validConfig,\n} from './__fixtures__/jestConfig';\n\nconst spyConsoleWarn = jest.spyOn(console, 'warn');\n\nbeforeEach(() => {\n  spyConsoleWarn.mockImplementation(() => {});\n});\n\nafterEach(() => {\n  spyConsoleWarn.mockReset();\n});\n\ntest('recursively validates default Jest config', () => {\n  expect(\n    validate(defaultConfig, {\n      exampleConfig: validConfig,\n    }),\n  ).toEqual({\n    hasDeprecationWarnings: false,\n    isValid: true,\n  });\n});\n\ntest('recursively validates default jest-validate config', () => {\n  expect(\n    validate(jestValidateDefaultConfig, {\n      exampleConfig: jestValidateExampleConfig,\n    }),\n  ).toEqual({\n    hasDeprecationWarnings: false,\n    isValid: true,\n  });\n});\n\ntest.each([\n  ['Boolean', {automock: []}],\n  ['Array', {coverageReporters: {}}],\n  ['String', {preset: 1337}],\n  ['Object', {haste: 42}],\n])('pretty prints valid config for %s', (_type, config) => {\n  expect(() =>\n    validate(config, {\n      exampleConfig: validConfig,\n    }),\n  ).toThrowErrorMatchingSnapshot();\n});\n\ntest('pretty prints valid config for Function', () => {\n  const config = {fn: 'test'};\n  const validConfig = {\n    fn: (_config: unknown, _option: unknown, _deprecatedOptions: unknown) =>\n      true,\n  };\n  expect(() =>\n    validate(config, {\n      exampleConfig: validConfig,\n    }),\n  ).toThrowErrorMatchingSnapshot();\n});\n\ntest('omits null and undefined config values', () => {\n  const config = {\n    haste: undefined,\n    preset: null,\n  };\n  expect(validate(config, {exampleConfig: validConfig})).toEqual({\n    hasDeprecationWarnings: false,\n    isValid: true,\n  });\n});\n\ntest('recursively omits null and undefined config values', () => {\n  const config = {\n    coverageThreshold: {\n      global: null,\n    },\n  };\n  expect(\n    validate(config, {exampleConfig: validConfig, recursive: true}),\n  ).toEqual({\n    hasDeprecationWarnings: false,\n    isValid: true,\n  });\n});\n\ntest.each([\n  [function () {}, function () {}],\n  [async function () {}, function () {}],\n  [function () {}, async function () {}],\n  [async function () {}, async function () {}],\n])(\n  'treat async and non-async functions as equivalent',\n  (value, exampleValue) => {\n    expect(\n      validate({name: value}, {exampleConfig: {name: exampleValue}}),\n    ).toEqual({hasDeprecationWarnings: false, isValid: true});\n  },\n);\n\ntest('respects recursiveDenylist', () => {\n  const config = {\n    something: {\n      nested: {\n        some_random_key: 'value',\n        some_random_key2: 'value2',\n      },\n    },\n  };\n  const exampleConfig = {\n    something: {\n      nested: {\n        test: true,\n      },\n    },\n  };\n\n  validate(config, {exampleConfig});\n\n  expect(spyConsoleWarn).toHaveBeenCalled();\n\n  spyConsoleWarn.mockReset();\n\n  validate(config, {\n    exampleConfig,\n    recursiveDenylist: ['something.nested'],\n  });\n\n  expect(spyConsoleWarn).not.toHaveBeenCalled();\n});\n\ntest('displays warning for unknown config options', () => {\n  const config = {unkwon: {}};\n  const validConfig = {unknown: 'string'};\n\n  validate(config, {exampleConfig: validConfig});\n\n  expect(spyConsoleWarn.mock.calls[0][0]).toMatchSnapshot();\n});\n\ntest('displays warning for deprecated config options', () => {\n  const config = {scriptPreprocessor: 'test'};\n\n  expect(\n    validate(config, {\n      deprecatedConfig,\n      exampleConfig: validConfig,\n    }),\n  ).toEqual({\n    hasDeprecationWarnings: true,\n    isValid: true,\n  });\n\n  expect(spyConsoleWarn.mock.calls[0][0]).toMatchSnapshot();\n});\n\ntest('works with custom warnings', () => {\n  const config = {unknown: 'string'};\n  const validConfig = {test: [1, 2]};\n  const options = {\n    comment: 'My custom comment',\n    deprecatedConfig,\n    exampleConfig: validConfig,\n    title: {\n      warning: 'My Custom Warning',\n    },\n  };\n\n  validate(config, options);\n\n  expect(spyConsoleWarn.mock.calls[0][0]).toMatchSnapshot();\n});\n\ntest('works with custom errors', () => {\n  const config = {test: 'string'};\n  const validConfig = {test: [1, 2]};\n  const options = {\n    comment: 'My custom comment',\n    deprecatedConfig,\n    exampleConfig: validConfig,\n    title: {\n      error: 'My Custom Error',\n    },\n  };\n\n  expect(() => validate(config, options)).toThrowErrorMatchingSnapshot();\n});\n\ntest('works with custom deprecations', () => {\n  const config = {scriptPreprocessor: 'test'};\n  const options = {\n    comment: 'My custom comment',\n    deprecatedConfig,\n    exampleConfig: validConfig,\n    title: {\n      deprecation: 'My Custom Deprecation Warning',\n    },\n  };\n\n  validate(config, options);\n\n  expect(spyConsoleWarn.mock.calls[0][0]).toMatchSnapshot();\n});\n\ntest('works with multiple valid types', () => {\n  const exampleConfig = {\n    foo: multipleValidOptions('text', ['text']),\n  };\n\n  expect(\n    validate(\n      {foo: 'foo'},\n      {\n        exampleConfig,\n      },\n    ),\n  ).toEqual({\n    hasDeprecationWarnings: false,\n    isValid: true,\n  });\n  expect(\n    validate(\n      {foo: ['foo']},\n      {\n        exampleConfig,\n      },\n    ),\n  ).toEqual({\n    hasDeprecationWarnings: false,\n    isValid: true,\n  });\n});\n\ntest('reports errors nicely when failing with multiple valid options', () => {\n  const exampleConfig = {\n    foo: multipleValidOptions('text', ['text']),\n  };\n\n  expect(() =>\n    validate(\n      {foo: 2},\n      {\n        exampleConfig,\n      },\n    ),\n  ).toThrowErrorMatchingSnapshot();\n});\n\ntest('Repeated types within multiple valid examples are coalesced in error report', () => {\n  const exampleConfig = {\n    foo: multipleValidOptions('foo', 'bar', 2),\n  };\n\n  expect(() =>\n    validate(\n      {foo: false},\n      {\n        exampleConfig,\n      },\n    ),\n  ).toThrowErrorMatchingSnapshot();\n});\n\ntest('Comments in config JSON using \"//\" key are not warned', () => {\n  const config = {'//': 'a comment'};\n\n  validate(config, {\n    exampleConfig: validConfig,\n  });\n  expect(spyConsoleWarn).not.toHaveBeenCalled();\n\n  spyConsoleWarn.mockReset();\n\n  validate(config, {\n    exampleConfig: validConfig,\n    recursiveDenylist: ['myCustomKey' as \"don't validate this\"],\n  });\n  expect(spyConsoleWarn).not.toHaveBeenCalled();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Repeated types within multiple valid examples are coalesced in error report 1`] = `\n\"<red><bold><bold>●</intensity><bold> Validation Error</intensity>:</color>\n<red></color>\n<red>  Option <bold>\"foo\"</intensity> must be of type:</color>\n<red>    <bold><green>string</color><red></intensity> or <bold><green>number</color><red></intensity></color>\n<red>  but instead received:</color>\n<red>    <bold><red>boolean</color><red></intensity></color>\n<red></color>\n<red>  Example:</color>\n<red>  {</color>\n<red>    <bold>\"foo\"</intensity>: <bold>\"foo\"</intensity></color>\n<red>  }</color>\n<red></color>\n<red>  or</color>\n<red></color>\n<red>  {</color>\n<red>    <bold>\"foo\"</intensity>: <bold>\"bar\"</intensity></color>\n<red>  }</color>\n<red></color>\n<red>  or</color>\n<red></color>\n<red>  {</color>\n<red>    <bold>\"foo\"</intensity>: <bold>2</intensity></color>\n<red>  }</color>\n<red></color>\"\n`;\n\nexports[`displays warning for deprecated config options 1`] = `\n\"<yellow><bold><bold>●</intensity><bold> Deprecation Warning</intensity>:</color>\n<yellow></color>\n<yellow>  Option <bold>scriptPreprocessor</intensity> was replaced by <bold>transform</intensity>, which support multiple preprocessors.</color>\n<yellow></color>\n<yellow>  Jest now treats your current configuration as:</color>\n<yellow>  {</color>\n<yellow>    <bold>\"transform\"</intensity>: <bold>{\".*\": \"test\"}</intensity></color>\n<yellow>  }</color>\n<yellow></color>\n<yellow>  Please update your configuration.</color>\n<yellow></color>\"\n`;\n\nexports[`displays warning for unknown config options 1`] = `\n\"<yellow><bold><bold>●</intensity><bold> Validation Warning</intensity>:</color>\n<yellow></color>\n<yellow>  Unknown option <bold>\"unkwon\"</intensity> with value <bold>{}</intensity> was found. Did you mean <bold>\"unknown\"</intensity>?</color>\n<yellow>  This is probably a typing mistake. Fixing it will remove this message.</color>\n<yellow></color>\"\n`;\n\nexports[`pretty prints valid config for Array 1`] = `\n\"<red><bold><bold>●</intensity><bold> Validation Error</intensity>:</color>\n<red></color>\n<red>  Option <bold>\"coverageReporters\"</intensity> must be of type:</color>\n<red>    <bold><green>array</color><red></intensity></color>\n<red>  but instead received:</color>\n<red>    <bold><red>object</color><red></intensity></color>\n<red></color>\n<red>  Example:</color>\n<red>  {</color>\n<red>    <bold>\"coverageReporters\"</intensity>: <bold>[</intensity></color>\n<red><bold>      \"json\",</intensity></color>\n<red><bold>      \"text\",</intensity></color>\n<red><bold>      \"lcov\",</intensity></color>\n<red><bold>      \"clover\"</intensity></color>\n<red><bold>    ]</intensity></color>\n<red>  }</color>\n<red></color>\"\n`;\n\nexports[`pretty prints valid config for Boolean 1`] = `\n\"<red><bold><bold>●</intensity><bold> Validation Error</intensity>:</color>\n<red></color>\n<red>  Option <bold>\"automock\"</intensity> must be of type:</color>\n<red>    <bold><green>boolean</color><red></intensity></color>\n<red>  but instead received:</color>\n<red>    <bold><red>array</color><red></intensity></color>\n<red></color>\n<red>  Example:</color>\n<red>  {</color>\n<red>    <bold>\"automock\"</intensity>: <bold>false</intensity></color>\n<red>  }</color>\n<red></color>\"\n`;\n\nexports[`pretty prints valid config for Function 1`] = `\n\"<red><bold><bold>●</intensity><bold> Validation Error</intensity>:</color>\n<red></color>\n<red>  Option <bold>\"fn\"</intensity> must be of type:</color>\n<red>    <bold><green>function</color><red></intensity></color>\n<red>  but instead received:</color>\n<red>    <bold><red>string</color><red></intensity></color>\n<red></color>\n<red>  Example:</color>\n<red>  {</color>\n<red>    <bold>\"fn\"</intensity>: <bold>(_config, _option, _deprecatedOptions) => true</intensity></color>\n<red>  }</color>\n<red></color>\"\n`;\n\nexports[`pretty prints valid config for Object 1`] = `\n\"<red><bold><bold>●</intensity><bold> Validation Error</intensity>:</color>\n<red></color>\n<red>  Option <bold>\"haste\"</intensity> must be of type:</color>\n<red>    <bold><green>object</color><red></intensity></color>\n<red>  but instead received:</color>\n<red>    <bold><red>number</color><red></intensity></color>\n<red></color>\n<red>  Example:</color>\n<red>  {</color>\n<red>    <bold>\"haste\"</intensity>: <bold>{}</intensity></color>\n<red>  }</color>\n<red></color>\"\n`;\n\nexports[`pretty prints valid config for String 1`] = `\n\"<red><bold><bold>●</intensity><bold> Validation Error</intensity>:</color>\n<red></color>\n<red>  Option <bold>\"preset\"</intensity> must be of type:</color>\n<red>    <bold><green>string</color><red></intensity></color>\n<red>  but instead received:</color>\n<red>    <bold><red>number</color><red></intensity></color>\n<red></color>\n<red>  Example:</color>\n<red>  {</color>\n<red>    <bold>\"preset\"</intensity>: <bold>\"react-native\"</intensity></color>\n<red>  }</color>\n<red></color>\"\n`;\n\nexports[`reports errors nicely when failing with multiple valid options 1`] = `\n\"<red><bold><bold>●</intensity><bold> Validation Error</intensity>:</color>\n<red></color>\n<red>  Option <bold>\"foo\"</intensity> must be of type:</color>\n<red>    <bold><green>string</color><red></intensity> or <bold><green>array</color><red></intensity></color>\n<red>  but instead received:</color>\n<red>    <bold><red>number</color><red></intensity></color>\n<red></color>\n<red>  Example:</color>\n<red>  {</color>\n<red>    <bold>\"foo\"</intensity>: <bold>\"text\"</intensity></color>\n<red>  }</color>\n<red></color>\n<red>  or</color>\n<red></color>\n<red>  {</color>\n<red>    <bold>\"foo\"</intensity>: <bold>[</intensity></color>\n<red><bold>      \"text\"</intensity></color>\n<red><bold>    ]</intensity></color>\n<red>  }</color>\n<red></color>\"\n`;\n\nexports[`works with custom deprecations 1`] = `\n\"<yellow><bold>My Custom Deprecation Warning</intensity>:</color>\n<yellow></color>\n<yellow>  Option <bold>scriptPreprocessor</intensity> was replaced by <bold>transform</intensity>, which support multiple preprocessors.</color>\n<yellow></color>\n<yellow>  Jest now treats your current configuration as:</color>\n<yellow>  {</color>\n<yellow>    <bold>\"transform\"</intensity>: <bold>{\".*\": \"test\"}</intensity></color>\n<yellow>  }</color>\n<yellow></color>\n<yellow>  Please update your configuration.</color>\n<yellow></color>\n<yellow>My custom comment</color>\"\n`;\n\nexports[`works with custom errors 1`] = `\n\"<red><bold>My Custom Error</intensity>:</color>\n<red></color>\n<red>  Option <bold>\"test\"</intensity> must be of type:</color>\n<red>    <bold><green>array</color><red></intensity></color>\n<red>  but instead received:</color>\n<red>    <bold><red>string</color><red></intensity></color>\n<red></color>\n<red>  Example:</color>\n<red>  {</color>\n<red>    <bold>\"test\"</intensity>: <bold>[</intensity></color>\n<red><bold>      1,</intensity></color>\n<red><bold>      2</intensity></color>\n<red><bold>    ]</intensity></color>\n<red>  }</color>\n<red></color>\n<red>My custom comment</color>\"\n`;\n\nexports[`works with custom warnings 1`] = `\n\"<yellow><bold>My Custom Warning</intensity>:</color>\n<yellow></color>\n<yellow>  Unknown option <bold>\"unknown\"</intensity> with value <bold>\"string\"</intensity> was found.</color>\n<yellow>  This is probably a typing mistake. Fixing it will remove this message.</color>\n<yellow></color>\n<yellow>My custom comment</color>\"\n`;"}
{"prompt":"handles deprecated CLI options,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport type {DeprecatedOptions} from '../types';\nimport validateCLIOptions from '../validateCLIOptions';\n\ntest('validates yargs special options', () => {\n  const argv = {\n    $0: 'foo',\n    _: ['bar'],\n    h: false,\n    help: false,\n  };\n\n  expect(validateCLIOptions(argv)).toBe(true);\n});\n\ntest('fails for unknown option', () => {\n  const argv = {\n    $0: 'foo',\n    _: ['bar'],\n    unknown: 'unknown',\n  };\n\n  expect(() => validateCLIOptions(argv)).toThrowErrorMatchingSnapshot();\n});\n\ntest('fails for multiple unknown options', () => {\n  const argv = {\n    $0: 'foo',\n    _: ['bar'],\n    jest: 'cool',\n    test: 'unknown',\n  };\n\n  expect(() => validateCLIOptions(argv)).toThrowErrorMatchingSnapshot();\n});\n\ntest('does not show suggestion when unrecognized cli param length <= 1', () => {\n  const argv = {\n    $0: 'foo',\n    _: ['bar'],\n    l: true,\n  };\n\n  expect(() => validateCLIOptions(argv)).toThrowErrorMatchingSnapshot();\n});\n\ntest('shows suggestion when unrecognized cli param length > 1', () => {\n  const argv = {\n    $0: 'foo',\n    _: ['bar'],\n    hell: true,\n  };\n\n  expect(() => validateCLIOptions(argv)).toThrowErrorMatchingSnapshot();\n});\n\ndescribe('handles deprecated CLI options', () => {\n  beforeEach(() => {\n    jest.spyOn(console, 'warn');\n  });\n\n  afterEach(() => {\n    jest.mocked(console.warn).mockRestore();\n  });\n\n  test('print warning for deprecated options that are listed in config', () => {\n    const optionName = 'foo';\n    const argv = {\n      $0: 'foo',\n      _: ['bar'],\n      [optionName]: true,\n    };\n\n    validateCLIOptions(argv, {\n      deprecationEntries: {\n        [optionName]: () => 'Deprecation message',\n      } as DeprecatedOptions,\n      [optionName]: {},\n    });\n\n    expect(jest.mocked(console.warn).mock.calls[0][0]).toMatchSnapshot();\n  });\n\n  test('throw an error for deprecated options that are not listed in config', () => {\n    const optionName = 'foo';\n\n    const argv = {\n      $0: 'foo',\n      _: ['bar'],\n      [optionName]: true,\n    };\n\n    expect(() =>\n      validateCLIOptions(argv, {\n        deprecationEntries: {\n          [optionName]: () => 'Deprecation message',\n        } as DeprecatedOptions,\n      }),\n    ).toThrowErrorMatchingSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`does not show suggestion when unrecognized cli param length <= 1 1`] = `\n\"<red><bold><bold>●</intensity><bold> Unrecognized CLI Parameter</intensity>:</color>\n<red></color>\n<red>  Unrecognized option <bold>\"l\"</intensity>.</color>\n<red></color>\n<red>  <bold>CLI Options Documentation</intensity>:</color>\n<red>  https://jestjs.io/docs/cli</color>\n<red></color>\"\n`;\n\nexports[`fails for multiple unknown options 1`] = `\n\"<red><bold><bold>●</intensity><bold> Unrecognized CLI Parameters</intensity>:</color>\n<red></color>\n<red>  Following options were not recognized:</color>\n<red>  <bold>[\"jest\", \"test\"]</intensity></color>\n<red></color>\n<red>  <bold>CLI Options Documentation</intensity>:</color>\n<red>  https://jestjs.io/docs/cli</color>\n<red></color>\"\n`;\n\nexports[`fails for unknown option 1`] = `\n\"<red><bold><bold>●</intensity><bold> Unrecognized CLI Parameter</intensity>:</color>\n<red></color>\n<red>  Unrecognized option <bold>\"unknown\"</intensity>.</color>\n<red></color>\n<red>  <bold>CLI Options Documentation</intensity>:</color>\n<red>  https://jestjs.io/docs/cli</color>\n<red></color>\"\n`;\n\nexports[`handles deprecated CLI options print warning for deprecated options that are listed in config 1`] = `\n\"<yellow><bold>foo</intensity>:</color>\n<yellow></color>\n<yellow>Deprecation message</color>\n<yellow></color>\n<yellow>  <bold>CLI Options Documentation:</intensity></color>\n<yellow>  https://jestjs.io/docs/cli</color>\n<yellow></color>\"\n`;\n\nexports[`handles deprecated CLI options throw an error for deprecated options that are not listed in config 1`] = `\n\"<red><bold>foo</intensity>:</color>\n<red></color>\n<red>Deprecation message</color>\n<red></color>\n<red>  <bold>CLI Options Documentation:</intensity></color>\n<red>  https://jestjs.io/docs/cli</color>\n<red></color>\"\n`;\n\nexports[`shows suggestion when unrecognized cli param length > 1 1`] = `\n\"<red><bold><bold>●</intensity><bold> Unrecognized CLI Parameter</intensity>:</color>\n<red></color>\n<red>  Unrecognized option <bold>\"hell\"</intensity>. Did you mean <bold>\"help\"</intensity>?</color>\n<red></color>\n<red>  <bold>CLI Options Documentation</intensity>:</color>\n<red>  https://jestjs.io/docs/cli</color>\n<red></color>\"\n`;"}
{"prompt":"Verbose,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\ntest('works just fine', () => {\n  expect(1).toBe(1);\n});\n\ntest('does not work', () => {\n  expect(1).toBe(2);\n});\n\ndescribe('Verbose', () => {\n  it('works', () => {\n    expect('apple').toBe('apple');\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport runJest from '../runJest';\n\ntest('Verbose Reporter', () => {\n  const {exitCode, stderr} = runJest('verbose-reporter');\n\n  expect(exitCode).toBe(1);\n  expect(stderr).toMatch('works just fine');\n  expect(stderr).toMatch('does not work');\n  expect(stderr).toMatch(/Verbose\\n.*?works/);\n});"}
{"prompt":"groupTestsBySuites,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nconst wrap = obj => ({suites: obj, tests: [], title: ''});\n\nlet groupTestsBySuites;\n\nbeforeEach(() => {\n  const VerboseReporter = require('../VerboseReporter').default;\n  groupTestsBySuites = VerboseReporter.groupTestsBySuites;\n});\n\ndescribe('groupTestsBySuites', () => {\n  it('should handle empty results', () => {\n    expect(groupTestsBySuites([])).toEqual(wrap([]));\n  });\n\n  it('should group A1 in A', () => {\n    expect(\n      groupTestsBySuites([\n        {\n          ancestorTitles: ['A'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'A1',\n        },\n      ]),\n    ).toEqual(\n      wrap([\n        {\n          suites: [],\n          tests: [\n            {\n              ancestorTitles: ['A'],\n              failureMessages: [],\n              numPassingAsserts: 1,\n              title: 'A1',\n            },\n          ],\n          title: 'A',\n        },\n      ]),\n    );\n  });\n\n  it('should group A1 in A; B1 in B', () => {\n    expect(\n      groupTestsBySuites([\n        {\n          ancestorTitles: ['A'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'A1',\n        },\n        {\n          ancestorTitles: ['B'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'B1',\n        },\n      ]),\n    ).toEqual(\n      wrap([\n        {\n          suites: [],\n          tests: [\n            {\n              ancestorTitles: ['A'],\n              failureMessages: [],\n              numPassingAsserts: 1,\n              title: 'A1',\n            },\n          ],\n          title: 'A',\n        },\n        {\n          suites: [],\n          tests: [\n            {\n              ancestorTitles: ['B'],\n              failureMessages: [],\n              numPassingAsserts: 1,\n              title: 'B1',\n            },\n          ],\n          title: 'B',\n        },\n      ]),\n    );\n  });\n\n  it('should group A1, A2 in A', () => {\n    expect(\n      groupTestsBySuites([\n        {\n          ancestorTitles: ['A'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'A1',\n        },\n        {\n          ancestorTitles: ['A'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'A2',\n        },\n      ]),\n    ).toEqual(\n      wrap([\n        {\n          suites: [],\n          tests: [\n            {\n              ancestorTitles: ['A'],\n              failureMessages: [],\n              numPassingAsserts: 1,\n              title: 'A1',\n            },\n            {\n              ancestorTitles: ['A'],\n              failureMessages: [],\n              numPassingAsserts: 1,\n              title: 'A2',\n            },\n          ],\n          title: 'A',\n        },\n      ]),\n    );\n  });\n\n  it('should group A1, A2 in A; B1, B2 in B', () => {\n    expect(\n      groupTestsBySuites([\n        {\n          ancestorTitles: ['A'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'A1',\n        },\n        {\n          ancestorTitles: ['A'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'A2',\n        },\n        {\n          ancestorTitles: ['B'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'B1',\n        },\n        {\n          ancestorTitles: ['B'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'B2',\n        },\n      ]),\n    ).toEqual(\n      wrap([\n        {\n          suites: [],\n          tests: [\n            {\n              ancestorTitles: ['A'],\n              failureMessages: [],\n              numPassingAsserts: 1,\n              title: 'A1',\n            },\n            {\n              ancestorTitles: ['A'],\n              failureMessages: [],\n              numPassingAsserts: 1,\n              title: 'A2',\n            },\n          ],\n          title: 'A',\n        },\n        {\n          suites: [],\n          tests: [\n            {\n              ancestorTitles: ['B'],\n              failureMessages: [],\n              numPassingAsserts: 1,\n              title: 'B1',\n            },\n            {\n              ancestorTitles: ['B'],\n              failureMessages: [],\n              numPassingAsserts: 1,\n              title: 'B2',\n            },\n          ],\n          title: 'B',\n        },\n      ]),\n    );\n  });\n\n  it('should group AB1 in AB', () => {\n    expect(\n      groupTestsBySuites([\n        {\n          ancestorTitles: ['A', 'B'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'AB1',\n        },\n      ]),\n    ).toEqual(\n      wrap([\n        {\n          suites: [\n            {\n              suites: [],\n              tests: [\n                {\n                  ancestorTitles: ['A', 'B'],\n                  failureMessages: [],\n                  numPassingAsserts: 1,\n                  title: 'AB1',\n                },\n              ],\n              title: 'B',\n            },\n          ],\n          tests: [],\n          title: 'A',\n        },\n      ]),\n    );\n  });\n\n  it('should group AB1, AB2 in AB', () => {\n    expect(\n      groupTestsBySuites([\n        {\n          ancestorTitles: ['A', 'B'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'AB1',\n        },\n        {\n          ancestorTitles: ['A', 'B'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'AB2',\n        },\n      ]),\n    ).toEqual(\n      wrap([\n        {\n          suites: [\n            {\n              suites: [],\n              tests: [\n                {\n                  ancestorTitles: ['A', 'B'],\n                  failureMessages: [],\n                  numPassingAsserts: 1,\n                  title: 'AB1',\n                },\n                {\n                  ancestorTitles: ['A', 'B'],\n                  failureMessages: [],\n                  numPassingAsserts: 1,\n                  title: 'AB2',\n                },\n              ],\n              title: 'B',\n            },\n          ],\n          tests: [],\n          title: 'A',\n        },\n      ]),\n    );\n  });\n\n  it('should group A1 in A; AB1 in AB', () => {\n    expect(\n      groupTestsBySuites([\n        {\n          ancestorTitles: ['A'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'A1',\n        },\n        {\n          ancestorTitles: ['A', 'B'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'AB1',\n        },\n      ]),\n    ).toEqual(\n      wrap([\n        {\n          suites: [\n            {\n              suites: [],\n              tests: [\n                {\n                  ancestorTitles: ['A', 'B'],\n                  failureMessages: [],\n                  numPassingAsserts: 1,\n                  title: 'AB1',\n                },\n              ],\n              title: 'B',\n            },\n          ],\n          tests: [\n            {\n              ancestorTitles: ['A'],\n              failureMessages: [],\n              numPassingAsserts: 1,\n              title: 'A1',\n            },\n          ],\n          title: 'A',\n        },\n      ]),\n    );\n  });\n\n  it('should group AB1 in AB; A1 in A', () => {\n    expect(\n      groupTestsBySuites([\n        {\n          ancestorTitles: ['A', 'B'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'AB1',\n        },\n        {\n          ancestorTitles: ['A'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'A1',\n        },\n      ]),\n    ).toEqual(\n      wrap([\n        {\n          suites: [\n            {\n              suites: [],\n              tests: [\n                {\n                  ancestorTitles: ['A', 'B'],\n                  failureMessages: [],\n                  numPassingAsserts: 1,\n                  title: 'AB1',\n                },\n              ],\n              title: 'B',\n            },\n          ],\n          tests: [\n            {\n              ancestorTitles: ['A'],\n              failureMessages: [],\n              numPassingAsserts: 1,\n              title: 'A1',\n            },\n          ],\n          title: 'A',\n        },\n      ]),\n    );\n  });\n\n  it('should group AB1 in AB; CD1 in CD', () => {\n    expect(\n      groupTestsBySuites([\n        {\n          ancestorTitles: ['A', 'B'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'AB1',\n        },\n        {\n          ancestorTitles: ['C', 'D'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'CD1',\n        },\n      ]),\n    ).toEqual(\n      wrap([\n        {\n          suites: [\n            {\n              suites: [],\n              tests: [\n                {\n                  ancestorTitles: ['A', 'B'],\n                  failureMessages: [],\n                  numPassingAsserts: 1,\n                  title: 'AB1',\n                },\n              ],\n              title: 'B',\n            },\n          ],\n          tests: [],\n          title: 'A',\n        },\n        {\n          suites: [\n            {\n              suites: [],\n              tests: [\n                {\n                  ancestorTitles: ['C', 'D'],\n                  failureMessages: [],\n                  numPassingAsserts: 1,\n                  title: 'CD1',\n                },\n              ],\n              title: 'D',\n            },\n          ],\n          tests: [],\n          title: 'C',\n        },\n      ]),\n    );\n  });\n\n  it('should group ABC1 in ABC; BC1 in BC; D1 in D; A1 in A', () => {\n    expect(\n      groupTestsBySuites([\n        {\n          ancestorTitles: ['A', 'B', 'C'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'ABC1',\n        },\n        {\n          ancestorTitles: ['B', 'C'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'BC1',\n        },\n        {\n          ancestorTitles: ['D'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'D1',\n        },\n        {\n          ancestorTitles: ['A'],\n          failureMessages: [],\n          numPassingAsserts: 1,\n          title: 'A1',\n        },\n      ]),\n    ).toEqual(\n      wrap([\n        {\n          suites: [\n            {\n              suites: [\n                {\n                  suites: [],\n                  tests: [\n                    {\n                      ancestorTitles: ['A', 'B', 'C'],\n                      failureMessages: [],\n                      numPassingAsserts: 1,\n                      title: 'ABC1',\n                    },\n                  ],\n                  title: 'C',\n                },\n              ],\n              tests: [],\n              title: 'B',\n            },\n          ],\n          tests: [\n            {\n              ancestorTitles: ['A'],\n              failureMessages: [],\n              numPassingAsserts: 1,\n              title: 'A1',\n            },\n          ],\n          title: 'A',\n        },\n        {\n          suites: [\n            {\n              suites: [],\n              tests: [\n                {\n                  ancestorTitles: ['B', 'C'],\n                  failureMessages: [],\n                  numPassingAsserts: 1,\n                  title: 'BC1',\n                },\n              ],\n              title: 'C',\n            },\n          ],\n          tests: [],\n          title: 'B',\n        },\n        {\n          suites: [],\n          tests: [\n            {\n              ancestorTitles: ['D'],\n              failureMessages: [],\n              numPassingAsserts: 1,\n              title: 'D1',\n            },\n          ],\n          title: 'D',\n        },\n      ]),\n    );\n  });\n});"}
{"prompt":"Only version gets printed and nothing else","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'version-test');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\ntest('works with jest.config.js', () => {\n  writeFiles(DIR, {\n    '.watchmanconfig': '',\n    'package.json': '{}',\n  });\n\n  const {exitCode, stdout, stderr} = runJest(DIR, ['--version']);\n  expect(stdout).toMatch(/\\d{2}(?:\\.\\d{1,2}){2}\\S*-dev$/);\n  // Only version gets printed and nothing else\n  expect(stdout.split(/\\n/)).toHaveLength(1);\n  expect(stderr).toBe('');\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"retryTimes set,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nlet i = 0;\nconst startTimeInSeconds = Date.now();\njest.retryTimes(3, {logErrorsBeforeRetry: true, waitBeforeRetry: 100});\nit('retryTimes set', () => {\n  i++;\n  if (i === 3) {\n    expect(Date.now() - startTimeInSeconds).toBeGreaterThan(200);\n  } else {\n    expect(true).toBeFalsy();\n  }\n});"}
{"prompt":"retryTimes set with fake timers,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nlet i = 0;\nconst startTimeInSeconds = Date.now();\njest.retryTimes(3, {logErrorsBeforeRetry: true, waitBeforeRetry: 100});\nit('retryTimes set with fake timers', () => {\n  jest.useFakeTimers();\n  i++;\n  if (i === 3) {\n    expect(Date.now() - startTimeInSeconds).toBeGreaterThan(200);\n  } else {\n    expect(true).toBeFalsy();\n    jest.runAllTimers();\n  }\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport {runContinuous} from '../runJest';\n\nconst testCompletedRE = /Ran all test suites./g;\nconst numberOfTestRuns = (stderr: string): number => {\n  const matches = stderr.match(testCompletedRE);\n  return matches ? matches.length : 0;\n};\n\ntest.each(['js', 'cjs'])('supports %s watch plugins', async watchPluginDir => {\n  const testRun = runContinuous(`watch-plugins/${watchPluginDir}`, [\n    '--watchAll',\n    '--no-watchman',\n  ]);\n\n  await testRun.waitUntil(({stderr}) => numberOfTestRuns(stderr) === 1);\n\n  expect(testRun.getCurrentOutput().stdout.trim()).toBe('getUsageInfo');\n\n  await testRun.end();\n});\n\ntest.each(['mjs', 'js-type-module'])(\n  'supports %s watch plugins',\n  async watchPluginDir => {\n    const testRun = runContinuous(`watch-plugins/${watchPluginDir}`, [\n      '--watchAll',\n      '--no-watchman',\n    ]);\n\n    await testRun.waitUntil(({stderr}) => numberOfTestRuns(stderr) === 1);\n\n    expect(testRun.getCurrentOutput().stdout.trim()).toBe('getUsageInfo');\n\n    await testRun.end();\n  },\n);"}
{"prompt":"Call the callback","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport chalk from 'chalk';\nimport {TestPathPatterns} from '@jest/pattern';\nimport {JestHook, KEYS, TestWatcher} from 'jest-watcher';\n\nconst runJestMock = jest.fn();\nconst watchPluginPath = `${__dirname}/__fixtures__/watchPlugin`;\nconst watchPlugin2Path = `${__dirname}/__fixtures__/watchPlugin2`;\nlet results;\n\njest.mock(\n  '../SearchSource',\n  () =>\n    class {\n      constructor(context) {\n        this._context = context;\n      }\n\n      findMatchingTests(pattern) {\n        const paths = [\n          './path/to/file1-test.js',\n          './path/to/file2-test.js',\n        ].filter(path => path.match(pattern));\n\n        return {\n          tests: paths.map(path => ({\n            context: this._context,\n            duration: null,\n            path,\n          })),\n        };\n      }\n    },\n);\n\njest.doMock('chalk', () => new chalk.Instance({level: 0}));\njest.doMock(\n  '../runJest',\n  () =>\n    function () {\n      const args = [...arguments];\n      const [{onComplete}] = args;\n      runJestMock.apply(null, args);\n\n      // Call the callback\n      onComplete(results);\n\n      return Promise.resolve();\n    },\n);\n\njest.doMock(\n  watchPluginPath,\n  () =>\n    class WatchPlugin1 {\n      getUsageInfo() {\n        return {\n          key: 's',\n          prompt: 'do nothing',\n        };\n      }\n    },\n  {virtual: true},\n);\n\njest.doMock(\n  watchPlugin2Path,\n  () =>\n    class WatchPlugin2 {\n      getUsageInfo() {\n        return {\n          key: 'r',\n          prompt: 'do something else',\n        };\n      }\n    },\n  {virtual: true},\n);\n\nconst regularUpdateGlobalConfig = require('../lib/updateGlobalConfig').default;\nconst updateGlobalConfig = jest.fn(regularUpdateGlobalConfig);\njest.doMock('../lib/updateGlobalConfig', () => updateGlobalConfig);\n\nconst nextTick = () => new Promise(resolve => process.nextTick(resolve));\n\nbeforeAll(() => {\n  jest.spyOn(process, 'on').mockImplementation(() => {});\n});\n\nafterAll(() => {\n  jest.restoreAllMocks();\n});\n\nafterEach(runJestMock.mockReset);\n\ndescribe('Watch mode flows', () => {\n  let watch;\n  let isInteractive;\n  let pipe;\n  let hasteMapInstances;\n  let globalConfig;\n  let contexts;\n  let stdin;\n\n  beforeEach(() => {\n    isInteractive = true;\n    jest.doMock('jest-util', () => {\n      const original = jest.requireActual('jest-util');\n\n      return {\n        ...original,\n        isInteractive,\n        // this imports internally, so we need to check `isInteractive` manually\n        preRunMessage: {\n          print: function mockedPrint(stream) {\n            if (isInteractive) {\n              stream.write('Determining test suites to run...');\n            }\n          },\n          remove: function mockedRemove(stream) {\n            if (isInteractive) {\n              original.clearLine(stream);\n            }\n          },\n        },\n      };\n    });\n    watch = require('../watch').default;\n    const config = {\n      rootDir: __dirname,\n      roots: [],\n      testPathIgnorePatterns: [],\n      testRegex: [],\n    };\n    pipe = {write: jest.fn()};\n    globalConfig = {\n      rootDir: '',\n      testPathPatterns: new TestPathPatterns([]),\n      watch: true,\n    };\n    hasteMapInstances = [{on: () => {}}];\n    contexts = [{config}];\n    stdin = new MockStdin();\n    results = {snapshot: {}};\n  });\n\n  afterEach(() => {\n    jest.resetModules();\n  });\n\n  it('Correctly passing test path pattern', async () => {\n    globalConfig.testPathPatterns = new TestPathPatterns(['test-*']);\n\n    await watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n\n    expect(runJestMock.mock.calls[0][0]).toMatchObject({\n      contexts,\n      globalConfig,\n      onComplete: expect.any(Function),\n      outputStream: pipe,\n      testWatcher: JSON.parse(\n        JSON.stringify(new TestWatcher({isWatchMode: true})),\n      ),\n    });\n  });\n\n  it('Correctly passing test name pattern', async () => {\n    globalConfig.testNamePattern = 'test-*';\n\n    await watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n\n    expect(runJestMock.mock.calls[0][0]).toMatchObject({\n      contexts,\n      globalConfig,\n      onComplete: expect.any(Function),\n      outputStream: pipe,\n      testWatcher: JSON.parse(\n        JSON.stringify(new TestWatcher({isWatchMode: true})),\n      ),\n    });\n  });\n\n  it('Runs Jest once by default and shows usage', async () => {\n    await watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n    expect(runJestMock.mock.calls[0][0]).toMatchObject({\n      contexts,\n      globalConfig,\n      onComplete: expect.any(Function),\n      outputStream: pipe,\n      testWatcher: JSON.parse(\n        JSON.stringify(new TestWatcher({isWatchMode: true})),\n      ),\n    });\n    expect(pipe.write.mock.calls.reverse()[0]).toMatchSnapshot();\n  });\n\n  it('Runs Jest in a non-interactive environment not showing usage', async () => {\n    jest.resetModules();\n    isInteractive = false;\n\n    watch = require('../watch').default;\n    await watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n    expect(runJestMock.mock.calls[0][0]).toMatchObject({\n      contexts,\n      globalConfig,\n      onComplete: expect.any(Function),\n      outputStream: pipe,\n      testWatcher: JSON.parse(\n        JSON.stringify(new TestWatcher({isWatchMode: true})),\n      ),\n    });\n    expect(pipe.write.mock.calls.reverse()[0]).toMatchSnapshot();\n  });\n\n  it('resolves relative to the package root', async () => {\n    await expect(\n      watch(\n        {\n          ...globalConfig,\n          rootDir: __dirname,\n          watchPlugins: [{config: {}, path: watchPluginPath}],\n        },\n        contexts,\n        pipe,\n        hasteMapInstances,\n        stdin,\n      ),\n    ).resolves.toBeUndefined();\n  });\n\n  it('shows prompts for WatchPlugins in alphabetical order', async () => {\n    await watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [\n          {config: {}, path: watchPluginPath},\n          {config: {}, path: watchPlugin2Path},\n        ],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    const pipeMockCalls = pipe.write.mock.calls;\n\n    const determiningTestsToRun = pipeMockCalls.findIndex(\n      ([c]) => c === 'Determining test suites to run...',\n    );\n\n    expect(pipeMockCalls.slice(determiningTestsToRun + 1)).toMatchSnapshot();\n  });\n\n  it('shows update snapshot prompt (without interactive)', async () => {\n    results = {snapshot: {failure: true}};\n\n    await watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    const pipeMockCalls = pipe.write.mock.calls;\n\n    const determiningTestsToRun = pipeMockCalls.findIndex(\n      ([c]) => c === 'Determining test suites to run...',\n    );\n\n    expect(pipeMockCalls.slice(determiningTestsToRun + 1)).toMatchSnapshot();\n  });\n\n  it('shows update snapshot prompt (with interactive)', async () => {\n    results = {\n      numFailedTests: 1,\n      snapshot: {\n        failure: true,\n      },\n      testPath: 'test.js',\n      testResults: [\n        {\n          snapshot: {\n            unmatched: true,\n          },\n          testResults: [\n            {\n              status: 'failed',\n              title: 'test a',\n            },\n          ],\n        },\n      ],\n    };\n\n    await watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    const pipeMockCalls = pipe.write.mock.calls;\n\n    const determiningTestsToRun = pipeMockCalls.findIndex(\n      ([c]) => c === 'Determining test suites to run...',\n    );\n\n    expect(pipeMockCalls.slice(determiningTestsToRun + 1)).toMatchSnapshot();\n  });\n\n  it('allows WatchPlugins to hook into JestHook', async () => {\n    const apply = jest.fn();\n    const pluginPath = `${__dirname}/__fixtures__/plugin_path_register`;\n    jest.doMock(\n      pluginPath,\n      () =>\n        class WatchPlugin {\n          constructor() {\n            this.apply = apply;\n          }\n        },\n      {virtual: true},\n    );\n\n    await watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [{config: {}, path: pluginPath}],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    await nextTick();\n\n    expect(apply).toHaveBeenCalled();\n  });\n\n  it('allows WatchPlugins to override eligible internal plugins', async () => {\n    const run = jest.fn(() => Promise.resolve());\n    const pluginPath = `${__dirname}/__fixtures__/plugin_path_override`;\n    jest.doMock(\n      pluginPath,\n      () =>\n        class WatchPlugin {\n          constructor() {\n            this.run = run;\n          }\n          getUsageInfo() {\n            return {\n              key: 'p',\n              prompt: 'custom \"P\" plugin',\n            };\n          }\n        },\n      {virtual: true},\n    );\n\n    await watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [{config: {}, path: pluginPath}],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    await nextTick();\n\n    expect(pipe.write.mock.calls.reverse()[0]).toMatchSnapshot();\n\n    stdin.emit('p');\n    await nextTick();\n\n    expect(run).toHaveBeenCalled();\n  });\n\n  describe('when dealing with potential watch plugin key conflicts', () => {\n    it.each`\n      key    | plugin\n      ${'q'} | ${'Quit'}\n      ${'u'} | ${'UpdateSnapshots'}\n      ${'i'} | ${'UpdateSnapshotsInteractive'}\n    `(\n      'forbids WatchPlugins overriding reserved internal plugins',\n      async ({key}) => {\n        const run = jest.fn(() => Promise.resolve());\n        const pluginPath = `${__dirname}/__fixtures__/plugin_bad_override_${key}`;\n        jest.doMock(\n          pluginPath,\n          () =>\n            class OffendingWatchPlugin {\n              constructor() {\n                this.run = run;\n              }\n              getUsageInfo() {\n                return {\n                  key,\n                  prompt: `custom \"${key.toUpperCase()}\" plugin`,\n                };\n              }\n            },\n          {virtual: true},\n        );\n\n        await expect(\n          watch(\n            {\n              ...globalConfig,\n              rootDir: __dirname,\n              watchPlugins: [{config: {}, path: pluginPath}],\n            },\n            contexts,\n            pipe,\n            hasteMapInstances,\n            stdin,\n          ),\n        ).rejects.toThrow(\n          new RegExp(\n            `Watch plugin OffendingWatchPlugin attempted to register key <${key}>,\\\\s+that is reserved internally for .+\\\\.\\\\s+Please change the configuration key for this plugin\\\\.`,\n            'm',\n          ),\n        );\n      },\n    );\n\n    // The jury's still out on 'a', 'c', 'f', 'o', 'w' and '?'…\n    // See https://github.com/jestjs/jest/issues/6693\n    it.each`\n      key    | plugin\n      ${'t'} | ${'TestNamePattern'}\n      ${'p'} | ${'TestPathPattern'}\n    `(\n      'allows WatchPlugins to override non-reserved internal plugins',\n      async ({key}) => {\n        const run = jest.fn(() => Promise.resolve());\n        const pluginPath = `${__dirname}/__fixtures__/plugin_valid_override_${key}`;\n        jest.doMock(\n          pluginPath,\n          () =>\n            class ValidWatchPlugin {\n              constructor() {\n                this.run = run;\n              }\n              getUsageInfo() {\n                return {\n                  key,\n                  prompt: `custom \"${key.toUpperCase()}\" plugin`,\n                };\n              }\n            },\n          {virtual: true},\n        );\n\n        await expect(\n          watch(\n            {\n              ...globalConfig,\n              rootDir: __dirname,\n              watchPlugins: [{config: {}, path: pluginPath}],\n            },\n            contexts,\n            pipe,\n            hasteMapInstances,\n            stdin,\n          ),\n        ).resolves.toBeUndefined();\n      },\n    );\n\n    it('forbids third-party WatchPlugins overriding each other', async () => {\n      const pluginPaths = ['Foo', 'Bar'].map(ident => {\n        const run = jest.fn(() => Promise.resolve());\n        const pluginPath = `${__dirname}/__fixtures__/plugin_bad_override_${ident.toLowerCase()}`;\n        jest.doMock(\n          pluginPath,\n          () => {\n            class OffendingThirdPartyWatchPlugin {\n              constructor() {\n                this.run = run;\n              }\n              getUsageInfo() {\n                return {\n                  key: '!',\n                  prompt: `custom \"!\" plugin ${ident}`,\n                };\n              }\n            }\n            OffendingThirdPartyWatchPlugin.displayName = `Offending${ident}ThirdPartyWatchPlugin`;\n            return OffendingThirdPartyWatchPlugin;\n          },\n          {virtual: true},\n        );\n        return pluginPath;\n      });\n\n      await expect(\n        watch(\n          {\n            ...globalConfig,\n            rootDir: __dirname,\n            watchPlugins: pluginPaths.map(path => ({config: {}, path})),\n          },\n          contexts,\n          pipe,\n          hasteMapInstances,\n          stdin,\n        ),\n      ).rejects.toThrow(\n        /Watch plugins OffendingFooThirdPartyWatchPlugin and OffendingBarThirdPartyWatchPlugin both attempted to register key <!>\\.\\s+Please change the key configuration for one of the conflicting plugins to avoid overlap\\./m,\n      );\n    });\n  });\n\n  it('allows WatchPlugins to be configured', async () => {\n    const pluginPath = `${__dirname}/__fixtures__/plugin_path_with_config`;\n    jest.doMock(\n      pluginPath,\n      () =>\n        class WatchPlugin {\n          constructor({config}) {\n            this._key = config.key;\n            this._prompt = config.prompt;\n          }\n          onKey() {}\n          run() {}\n          getUsageInfo() {\n            return {\n              key: this._key || 'z',\n              prompt: this._prompt || 'default prompt',\n            };\n          }\n        },\n      {virtual: true},\n    );\n\n    await watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [\n          {\n            config: {key: 'k', prompt: 'filter with a custom prompt'},\n            path: pluginPath,\n          },\n        ],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    expect(pipe.write.mock.calls.reverse()[0]).toMatchSnapshot();\n  });\n\n  it('allows WatchPlugins to hook into file system changes', async () => {\n    const onFileChange = jest.fn();\n    const pluginPath = `${__dirname}/__fixtures__/plugin_path_fs_change`;\n    jest.doMock(\n      pluginPath,\n      () =>\n        class WatchPlugin {\n          apply(jestHooks) {\n            jestHooks.onFileChange(onFileChange);\n          }\n        },\n      {virtual: true},\n    );\n\n    await watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [{config: {}, path: pluginPath}],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    expect(onFileChange).toHaveBeenCalledWith({\n      projects: [\n        {\n          config: contexts[0].config,\n          testPaths: ['./path/to/file1-test.js', './path/to/file2-test.js'],\n        },\n      ],\n    });\n  });\n\n  it('makes watch plugin initialization errors look nice', async () => {\n    const pluginPath = `${__dirname}/__fixtures__/watchPluginThrows`;\n\n    await expect(\n      watch(\n        {\n          ...globalConfig,\n          rootDir: __dirname,\n          watchPlugins: [{config: {}, path: pluginPath}],\n        },\n        contexts,\n        pipe,\n        hasteMapInstances,\n        stdin,\n      ),\n    ).rejects.toMatchSnapshot();\n  });\n\n  it.each`\n    ok       | option\n    ${'✔︎'} | ${'bail'}\n    ${'✖︎'} | ${'changedFilesWithAncestor'}\n    ${'✔︎'} | ${'changedSince'}\n    ${'✔︎'} | ${'collectCoverage'}\n    ${'✔︎'} | ${'collectCoverageFrom'}\n    ${'✔︎'} | ${'coverageDirectory'}\n    ${'✔︎'} | ${'coverageReporters'}\n    ${'✖︎'} | ${'coverageThreshold'}\n    ${'✖︎'} | ${'detectLeaks'}\n    ${'✖︎'} | ${'detectOpenHandles'}\n    ${'✖︎'} | ${'errorOnDeprecated'}\n    ${'✖︎'} | ${'expand'}\n    ${'✖︎'} | ${'filter'}\n    ${'✔︎'} | ${'findRelatedTests'}\n    ${'✖︎'} | ${'forceExit'}\n    ${'✖︎'} | ${'globalSetup'}\n    ${'✖︎'} | ${'globalTeardown'}\n    ${'✖︎'} | ${'json'}\n    ${'✖︎'} | ${'lastCommit'}\n    ${'✖︎'} | ${'listTests'}\n    ${'✖︎'} | ${'logHeapUsage'}\n    ${'✖︎'} | ${'maxWorkers'}\n    ${'✔︎'} | ${'nonFlagArgs'}\n    ${'✖︎'} | ${'noSCM'}\n    ${'✖︎'} | ${'noStackTrace'}\n    ${'✔︎'} | ${'notify'}\n    ${'✔︎'} | ${'notifyMode'}\n    ${'✖︎'} | ${'onlyChanged'}\n    ${'✔︎'} | ${'onlyFailures'}\n    ${'✖︎'} | ${'outputFile'}\n    ${'✖︎'} | ${'passWithNoTests'}\n    ${'✖︎'} | ${'projects'}\n    ${'✖︎'} | ${'replname'}\n    ${'✔︎'} | ${'reporters'}\n    ${'✖︎'} | ${'rootDir'}\n    ${'✖︎'} | ${'runTestsByPath'}\n    ${'✖︎'} | ${'silent'}\n    ${'✖︎'} | ${'skipFilter'}\n    ${'✖︎'} | ${'testFailureExitCode'}\n    ${'✔︎'} | ${'testNamePattern'}\n    ${'✔︎'} | ${'testPathPatterns'}\n    ${'✖︎'} | ${'testResultsProcessor'}\n    ${'✔︎'} | ${'updateSnapshot'}\n    ${'✖︎'} | ${'useStderr'}\n    ${'✔︎'} | ${'verbose'}\n    ${'✖︎'} | ${'watch'}\n    ${'✖︎'} | ${'watchAll'}\n    ${'✖︎'} | ${'watchman'}\n    ${'✖︎'} | ${'watchPlugins'}\n  `(\n    'allows WatchPlugins to modify only white-listed global config keys',\n    async ({ok, option}) => {\n      ok = ok === '✔︎';\n      const pluginPath = `${__dirname}/__fixtures__/plugin_path_config_updater_${option}`;\n\n      const newVal = (() => {\n        if (option === 'testPathPatterns') {\n          return new TestPathPatterns(['a/b', 'c']);\n        }\n\n        return '__JUST_TRYING__';\n      })();\n\n      jest.doMock(\n        pluginPath,\n        () =>\n          class WatchPlugin {\n            getUsageInfo() {\n              return {key: 'x', prompt: 'test option white-listing'};\n            }\n\n            run(globalConfig, updateConfigAndRun) {\n              updateConfigAndRun({[option]: newVal});\n              return Promise.resolve();\n            }\n          },\n        {virtual: true},\n      );\n\n      const config = {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [{config: {}, path: pluginPath}],\n      };\n\n      await watch(config, contexts, pipe, hasteMapInstances, stdin);\n      await nextTick();\n\n      stdin.emit('x');\n      await nextTick();\n\n      // We need the penultimate call as Jest forces a final call to restore\n      // updateSnapshot because it's not sticky after a run…?\n      const lastCall = updateGlobalConfig.mock.calls.at(-2);\n      // eslint-disable-next-line jest/valid-expect\n      let expector = expect(lastCall[1]);\n      if (!ok) {\n        expector = expector.not;\n      }\n      expector.toHaveProperty(option, newVal);\n    },\n  );\n\n  it('triggers enter on a WatchPlugin when its key is pressed', async () => {\n    const run = jest.fn(() => Promise.resolve());\n    const pluginPath = `${__dirname}/__fixtures__/plugin_path`;\n    jest.doMock(\n      pluginPath,\n      () =>\n        class WatchPlugin1 {\n          constructor() {\n            this.run = run;\n          }\n          getUsageInfo() {\n            return {\n              key: 's',\n              prompt: 'do nothing',\n            };\n          }\n        },\n      {virtual: true},\n    );\n\n    await watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [{config: {}, path: pluginPath}],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    stdin.emit('s');\n\n    await nextTick();\n\n    expect(run).toHaveBeenCalled();\n  });\n\n  it('prevents Jest from handling keys when active and returns control when end is called', async () => {\n    let resolveShowPrompt;\n    const run = jest.fn(\n      () => new Promise(resolve => (resolveShowPrompt = resolve)),\n    );\n    const pluginPath = `${__dirname}/__fixtures__/plugin_path_1`;\n    jest.doMock(\n      pluginPath,\n      () =>\n        class WatchPlugin1 {\n          constructor() {\n            this.run = run;\n          }\n          onKey() {}\n          getUsageInfo() {\n            return {\n              key: 's',\n              prompt: 'do nothing',\n            };\n          }\n        },\n      {virtual: true},\n    );\n\n    const showPrompt2 = jest.fn(() => Promise.resolve());\n    const pluginPath2 = `${__dirname}/__fixtures__/plugin_path_2`;\n    jest.doMock(\n      pluginPath2,\n      () =>\n        class WatchPlugin1 {\n          constructor() {\n            this.run = showPrompt2;\n          }\n          onKey() {}\n          getUsageInfo() {\n            return {\n              key: 'z',\n              prompt: 'also do nothing',\n            };\n          }\n        },\n      {virtual: true},\n    );\n\n    await watch(\n      {\n        ...globalConfig,\n        rootDir: __dirname,\n        watchPlugins: [\n          {config: {}, path: pluginPath},\n          {config: {}, path: pluginPath2},\n        ],\n      },\n      contexts,\n      pipe,\n      hasteMapInstances,\n      stdin,\n    );\n\n    stdin.emit('s');\n    await nextTick();\n    expect(run).toHaveBeenCalled();\n    stdin.emit('z');\n    await nextTick();\n    expect(showPrompt2).not.toHaveBeenCalled();\n    await resolveShowPrompt();\n    stdin.emit('z');\n    expect(showPrompt2).toHaveBeenCalled();\n  });\n\n  it('Pressing \"o\" runs test in \"only changed files\" mode', async () => {\n    await watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n    runJestMock.mockReset();\n\n    stdin.emit('o');\n\n    expect(runJestMock).toHaveBeenCalled();\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchObject({\n      onlyChanged: true,\n      watch: true,\n      watchAll: false,\n    });\n  });\n\n  it('Pressing \"a\" runs test in \"watch all\" mode', async () => {\n    await watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n    runJestMock.mockReset();\n\n    stdin.emit('a');\n\n    expect(runJestMock).toHaveBeenCalled();\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchObject({\n      onlyChanged: false,\n      watch: false,\n      watchAll: true,\n    });\n  });\n\n  it('Pressing \"ENTER\" reruns the tests', async () => {\n    await watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n    expect(runJestMock).toHaveBeenCalledTimes(1);\n    stdin.emit(KEYS.ENTER);\n    expect(runJestMock).toHaveBeenCalledTimes(2);\n  });\n\n  it('Pressing \"t\" reruns the tests in \"test name pattern\" mode', async () => {\n    const hooks = new JestHook();\n\n    await watch(globalConfig, contexts, pipe, hasteMapInstances, stdin, hooks);\n    runJestMock.mockReset();\n\n    stdin.emit('t');\n    for (const key of ['t', 'e', 's', 't']) stdin.emit(key);\n    stdin.emit(KEYS.ENTER);\n    await nextTick();\n\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchObject({\n      testNamePattern: 'test',\n      watch: true,\n      watchAll: false,\n    });\n  });\n\n  it('Pressing \"p\" reruns the tests in \"filename pattern\" mode', async () => {\n    const hooks = new JestHook();\n\n    await watch(globalConfig, contexts, pipe, hasteMapInstances, stdin, hooks);\n    runJestMock.mockReset();\n\n    stdin.emit('p');\n    for (const key of ['f', 'i', 'l', 'e']) stdin.emit(key);\n    stdin.emit(KEYS.ENTER);\n    await nextTick();\n\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchObject({\n      testPathPatterns: {patterns: ['file']},\n      watch: true,\n      watchAll: false,\n    });\n  });\n\n  it('Can combine \"p\" and \"t\" filters', async () => {\n    const hooks = new JestHook();\n\n    await watch(globalConfig, contexts, pipe, hasteMapInstances, stdin, hooks);\n    runJestMock.mockReset();\n\n    stdin.emit('p');\n    for (const key of ['f', 'i', 'l', 'e']) stdin.emit(key);\n    stdin.emit(KEYS.ENTER);\n    await nextTick();\n\n    stdin.emit('t');\n    for (const key of ['t', 'e', 's', 't']) stdin.emit(key);\n    stdin.emit(KEYS.ENTER);\n    await nextTick();\n\n    expect(runJestMock.mock.calls[1][0].globalConfig).toMatchObject({\n      testNamePattern: 'test',\n      testPathPatterns: {patterns: ['file']},\n      watch: true,\n      watchAll: false,\n    });\n  });\n\n  it('Pressing \"u\" reruns the tests in \"update snapshot\" mode', async () => {\n    const hooks = new JestHook();\n\n    globalConfig.updateSnapshot = 'new';\n\n    await watch(globalConfig, contexts, pipe, hasteMapInstances, stdin, hooks);\n    runJestMock.mockReset();\n\n    hooks.getEmitter().onTestRunComplete({snapshot: {failure: true}});\n\n    stdin.emit('u');\n    await nextTick();\n\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchObject({\n      updateSnapshot: 'all',\n      watch: true,\n      watchAll: false,\n    });\n\n    stdin.emit('a');\n\n    await nextTick();\n    // updateSnapshot is not sticky after a run.\n    expect(runJestMock.mock.calls[1][0].globalConfig).toMatchObject({\n      updateSnapshot: 'new',\n      watch: false,\n      watchAll: true,\n    });\n\n    results = {snapshot: {failure: true}};\n\n    stdin.emit('a');\n    await nextTick();\n\n    runJestMock.mockReset();\n    stdin.emit('u');\n    await nextTick();\n\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchObject({\n      updateSnapshot: 'all',\n      watch: false,\n      watchAll: true,\n    });\n  });\n\n  it('passWithNoTest should be set to true in watch mode', async () => {\n    globalConfig.passWithNoTests = false;\n    await watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n    globalConfig.passWithNoTests = true;\n    expect(runJestMock.mock.calls[0][0]).toMatchObject({\n      globalConfig,\n    });\n  });\n\n  it('shows the correct usage for the f key in \"only failed tests\" mode', async () => {\n    await watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n\n    stdin.emit('f');\n    stdin.emit('w');\n\n    const lastWatchDisplay = pipe.write.mock.calls.reverse()[0][0];\n    expect(lastWatchDisplay).toMatch('Press a to run all tests.');\n    expect(lastWatchDisplay).toMatch(\n      'Press f to quit \"only failed tests\" mode',\n    );\n  });\n});\n\nclass MockStdin {\n  constructor() {\n    this._callbacks = [];\n  }\n\n  setRawMode() {}\n\n  resume() {}\n\n  setEncoding() {}\n\n  on(evt, callback) {\n    this._callbacks.push(callback);\n  }\n\n  emit(key) {\n    for (const cb of this._callbacks) cb(key);\n  }\n}"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Watch mode flows Runs Jest in a non-interactive environment not showing usage 1`] = `\nArray [\n  \"\n\",\n]\n`;\n\nexports[`Watch mode flows Runs Jest once by default and shows usage 1`] = `\nArray [\n  \"\nWatch Usage\n › Press a to run all tests.\n › Press f to run only failed tests.\n › Press p to filter by a filename regex pattern.\n › Press t to filter by a test name regex pattern.\n › Press q to quit watch mode.\n › Press Enter to trigger a test run.\n\",\n]\n`;\n\nexports[`Watch mode flows allows WatchPlugins to be configured 1`] = `\nArray [\n  \"\nWatch Usage\n › Press a to run all tests.\n › Press f to run only failed tests.\n › Press p to filter by a filename regex pattern.\n › Press t to filter by a test name regex pattern.\n › Press q to quit watch mode.\n › Press k to filter with a custom prompt.\n › Press Enter to trigger a test run.\n\",\n]\n`;\n\nexports[`Watch mode flows allows WatchPlugins to override eligible internal plugins 1`] = `\nArray [\n  \"\nWatch Usage\n › Press a to run all tests.\n › Press f to run only failed tests.\n › Press t to filter by a test name regex pattern.\n › Press q to quit watch mode.\n › Press p to custom \"P\" plugin.\n › Press Enter to trigger a test run.\n\",\n]\n`;\n\nexports[`Watch mode flows makes watch plugin initialization errors look nice 1`] = `\n[Error: Failed to initialize watch plugin \"packages/jest-core/src/__tests__/__fixtures__/watchPluginThrows\":\n\n  ● Test suite failed to run\n\n    initialization error\n\n      at Object.<anonymous> (__fixtures__/watchPluginThrows.js:8:7)\n]\n`;\n\nexports[`Watch mode flows shows prompts for WatchPlugins in alphabetical order 1`] = `\nArray [\n  Array [\n    \"\nWatch Usage\n › Press a to run all tests.\n › Press f to run only failed tests.\n › Press p to filter by a filename regex pattern.\n › Press t to filter by a test name regex pattern.\n › Press q to quit watch mode.\n › Press r to do something else.\n › Press s to do nothing.\n › Press Enter to trigger a test run.\n\",\n  ],\n]\n`;\n\nexports[`Watch mode flows shows update snapshot prompt (with interactive) 1`] = `\nArray [\n  Array [\n    \"\nWatch Usage\n › Press a to run all tests.\n › Press f to run only failed tests.\n › Press p to filter by a filename regex pattern.\n › Press t to filter by a test name regex pattern.\n › Press u to update failing snapshots.\n › Press i to update failing snapshots interactively.\n › Press q to quit watch mode.\n › Press Enter to trigger a test run.\n\",\n  ],\n]\n`;\n\nexports[`Watch mode flows shows update snapshot prompt (without interactive) 1`] = `\nArray [\n  Array [\n    \"\nWatch Usage\n › Press a to run all tests.\n › Press f to run only failed tests.\n › Press p to filter by a filename regex pattern.\n › Press t to filter by a test name regex pattern.\n › Press u to update failing snapshots.\n › Press q to quit watch mode.\n › Press Enter to trigger a test run.\n\",\n  ],\n]\n`;"}
{"prompt":"Watch mode flows with changed files,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport type {WriteStream} from 'tty';\nimport * as fs from 'graceful-fs';\nimport type {AggregatedResult} from '@jest/test-result';\nimport {normalize} from 'jest-config';\nimport type {IHasteMap} from 'jest-haste-map';\nimport Runtime from 'jest-runtime';\nimport {interopRequireDefault} from 'jest-util';\nimport {JestHook} from 'jest-watcher';\n\ndescribe('Watch mode flows with changed files', () => {\n  jest.resetModules();\n\n  let watch: typeof import('../watch').default;\n  let pipe: WriteStream;\n  let stdin: MockStdin;\n  const testDirectory = path.resolve(tmpdir(), 'jest-tmp');\n  const fileTargetPath = path.resolve(testDirectory, 'lost-file.js');\n  const fileTargetPath2 = path.resolve(\n    testDirectory,\n    'watch-test-fake.test.js',\n  );\n  const cacheDirectory = path.resolve(tmpdir(), `tmp${Math.random()}`);\n  let hasteMapInstance: IHasteMap;\n\n  beforeEach(() => {\n    watch = interopRequireDefault(require('../watch')).default;\n    pipe = {write: jest.fn()} as unknown;\n    stdin = new MockStdin();\n    fs.rmSync(cacheDirectory, {force: true, recursive: true});\n    fs.rmSync(testDirectory, {force: true, recursive: true});\n    fs.mkdirSync(testDirectory);\n    fs.mkdirSync(cacheDirectory);\n  });\n\n  afterEach(() => {\n    jest.resetModules();\n    if (hasteMapInstance) {\n      hasteMapInstance.end();\n    }\n    fs.rmSync(cacheDirectory, {force: true, recursive: true});\n    fs.rmSync(testDirectory, {force: true, recursive: true});\n  });\n\n  it('should correct require new files without legacy cache', async () => {\n    fs.writeFileSync(\n      fileTargetPath2,\n      `\n        require('./lost-file.js');\n        describe('Fake test', () => {\n            it('Hey', () => {\n\n            });\n        });\n      `,\n    );\n\n    const config = (\n      await normalize(\n        {\n          cache: false,\n          cacheDirectory,\n          coverageReporters: [],\n          maxConcurrency: 1,\n          maxWorkers: 1,\n          moduleDirectories: ['node_modules'],\n          onlyChanged: false,\n          reporters: [],\n          rootDir: testDirectory,\n          silent: true,\n          testRegex: ['watch-test-fake\\\\.test\\\\.js$'],\n          watch: false,\n          watchman: false,\n        },\n        {} as unknown,\n      )\n    ).options;\n\n    hasteMapInstance = await Runtime.createHasteMap(config, {\n      maxWorkers: 1,\n      resetCache: true,\n      watch: true,\n      watchman: false,\n    });\n\n    const realContext = await hasteMapInstance.build().then(hasteMap => ({\n      config,\n      hasteFS: hasteMap.hasteFS,\n      moduleMap: hasteMap.moduleMap,\n      resolver: Runtime.createResolver(config, hasteMap.moduleMap),\n    }));\n\n    const hook = new JestHook();\n    const firstErrorPromise = new Promise(resolve => {\n      hook.getSubscriber().onTestRunComplete(resolve);\n    });\n    await watch(\n      {\n        ...config,\n        watchPlugins: [],\n      },\n      [realContext],\n      pipe,\n      [hasteMapInstance],\n      stdin,\n      hook,\n    );\n\n    await firstErrorPromise;\n\n    const successPromise = new Promise<AggregatedResult>(resolve => {\n      hook.getSubscriber().onTestRunComplete(resolve);\n    });\n\n    // Create lost file\n    fs.writeFileSync(\n      fileTargetPath,\n      `\n        describe('Fake group', () => {\n            it('Fake 1', () => {});\n            it('Fake 2', () => {});\n            it('Fake 3', () => {});\n        });\n      `,\n    );\n\n    const resultSuccessReport = await successPromise;\n\n    expect(resultSuccessReport).toMatchObject({\n      numFailedTestSuites: 0,\n      numFailedTests: 0,\n      numPassedTests: 4,\n      numRuntimeErrorTestSuites: 0,\n      success: true,\n      wasInterrupted: false,\n    });\n    expect(resultSuccessReport.testResults[0]).toMatchObject({\n      failureMessage: null,\n    });\n\n    const errorPromise = new Promise<AggregatedResult>(resolve => {\n      hook.getSubscriber().onTestRunComplete(resolve);\n    });\n\n    // Remove again to ensure about no legacy cache\n    fs.unlinkSync(fileTargetPath);\n\n    const resultErrorReport = await errorPromise;\n\n    // After remove file we have to fail tests\n    expect(resultErrorReport).toMatchObject({\n      numFailedTestSuites: 1,\n      numPassedTests: 0,\n      numRuntimeErrorTestSuites: 1,\n      success: false,\n      wasInterrupted: false,\n    });\n  });\n});\n\nclass MockStdin {\n  private readonly _callbacks: Array<unknown>;\n\n  constructor() {\n    this._callbacks = [];\n  }\n\n  resume() {}\n\n  setEncoding() {}\n\n  on(_: unknown, callback: unknown) {\n    this._callbacks.push(callback);\n  }\n\n  emit(key: string) {\n    for (const cb of this._callbacks) cb(key);\n  }\n}"}
{"prompt":"Call the callback","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport chalk from 'chalk';\nimport {TestPathPatterns} from '@jest/pattern';\nimport {KEYS} from 'jest-watcher';\n\nconst runJestMock = jest.fn();\n\njest.mock(\n  '../SearchSource',\n  () =>\n    class {\n      constructor(context) {\n        this._context = context;\n      }\n\n      findMatchingTests(pattern) {\n        const paths = [\n          './path/to/file1-test.js',\n          './path/to/file2-test.js',\n          './path/to/file3-test.js',\n          './path/to/file4-test.js',\n          './path/to/file5-test.js',\n          './path/to/file6-test.js',\n          './path/to/file7-test.js',\n          './path/to/file8-test.js',\n          './path/to/file9-test.js',\n          './path/to/file10-test.js',\n          './path/to/file11-test.js',\n        ].filter(path => path.match(pattern));\n\n        return {\n          tests: paths.map(path => ({\n            context: this._context,\n            duration: null,\n            path,\n          })),\n        };\n      }\n    },\n);\n\njest.doMock('chalk', () => new chalk.Instance({level: 0}));\n\njest.doMock('strip-ansi');\nrequire('strip-ansi').mockImplementation(str => str);\n\njest.doMock(\n  '../runJest',\n  () =>\n    function () {\n      const args = [...arguments];\n      const [{onComplete}] = args;\n      runJestMock.apply(null, args);\n\n      // Call the callback\n      onComplete({snapshot: {}});\n\n      return Promise.resolve();\n    },\n);\n\nconst watch = require('../watch').default;\n\nconst nextTick = () => new Promise(resolve => process.nextTick(resolve));\n\nconst globalConfig = {\n  rootDir: '',\n  testPathPatterns: new TestPathPatterns([]),\n  watch: true,\n};\n\nafterEach(runJestMock.mockReset);\n\ndescribe('Watch mode flows', () => {\n  let pipe;\n  let hasteMapInstances;\n  let contexts;\n  let stdin;\n\n  beforeEach(() => {\n    pipe = {write: jest.fn()};\n    hasteMapInstances = [{on: () => {}}];\n    contexts = [{config: {}}];\n    stdin = new MockStdin();\n  });\n\n  it('Pressing \"P\" enters pattern mode', () => {\n    contexts[0].config = {rootDir: ''};\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n\n    // Write a enter pattern mode\n    stdin.emit('p');\n    expect(pipe.write).toHaveBeenCalledWith(' pattern › ');\n\n    const assertPattern = hex => {\n      pipe.write.mockReset();\n      stdin.emit(hex);\n      expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    };\n\n    // Write a pattern\n    for (const pattern of ['p', '.', '*', '1', '0']) assertPattern(pattern);\n\n    for (const pattern of [KEYS.BACKSPACE, KEYS.BACKSPACE])\n      assertPattern(pattern);\n\n    for (const pattern of ['3']) assertPattern(pattern);\n\n    // Runs Jest again\n    runJestMock.mockReset();\n    stdin.emit(KEYS.ENTER);\n    expect(runJestMock).toHaveBeenCalled();\n\n    // globalConfig is updated with the current pattern\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchSnapshot();\n  });\n\n  it('Pressing \"c\" clears the filters', async () => {\n    contexts[0].config = {rootDir: ''};\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n\n    stdin.emit('p');\n    await nextTick();\n\n    for (const key of ['p', '.', '*', '1', '0'].concat(KEYS.ENTER))\n      stdin.emit(key);\n\n    stdin.emit('t');\n    await nextTick();\n\n    for (const key of ['t', 'e', 's', 't'].concat(KEYS.ENTER)) stdin.emit(key);\n\n    await nextTick();\n\n    stdin.emit('c');\n    await nextTick();\n\n    pipe.write.mockReset();\n    stdin.emit('p');\n    await nextTick();\n\n    expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n  });\n});\n\nclass MockStdin {\n  constructor() {\n    this._callbacks = [];\n  }\n\n  setRawMode() {}\n\n  resume() {}\n\n  setEncoding() {}\n\n  on(evt, callback) {\n    this._callbacks.push(callback);\n  }\n\n  emit(key) {\n    for (const cb of this._callbacks) cb(key);\n  }\n}"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Watch mode flows Pressing \"P\" enters pattern mode 1`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › p\n<saveCursorPosition>\n<moveCursorToRow6Column13>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"P\" enters pattern mode 2`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › p.\n<saveCursorPosition>\n<moveCursorToRow6Column14>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"P\" enters pattern mode 3`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › p.*\n<saveCursorPosition>\n<moveCursorToRow6Column15>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"P\" enters pattern mode 4`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › p.*1\n<saveCursorPosition>\n<moveCursorToRow6Column16>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"P\" enters pattern mode 5`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › p.*10\n<saveCursorPosition>\n<moveCursorToRow6Column17>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"P\" enters pattern mode 6`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › p.*1\n<saveCursorPosition>\n<moveCursorToRow6Column16>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"P\" enters pattern mode 7`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › p.*\n<saveCursorPosition>\n<moveCursorToRow6Column15>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"P\" enters pattern mode 8`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › p.*3\n<saveCursorPosition>\n<moveCursorToRow6Column16>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"P\" enters pattern mode 9`] = `\nObject {\n  \"onlyChanged\": false,\n  \"passWithNoTests\": true,\n  \"rootDir\": \"\",\n  \"testPathPatterns\": Object {\n    \"patterns\": Array [\n      \"p.*3\",\n    ],\n    \"type\": \"TestPathPatterns\",\n  },\n  \"watch\": true,\n  \"watchAll\": false,\n}\n`;\n\nexports[`Watch mode flows Pressing \"c\" clears the filters 1`] = `\n\"<hideCursor>\n<clearTerminal>\n\n<bold>Pattern Mode Usage</intensity>\n <dim>› Press</intensity> Esc <dim>to exit pattern mode.</intensity>\n <dim>› Press</intensity> Enter <dim>to filter by a filenames regex pattern.</intensity>\n\n\n<showCursor>\n<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › \n<saveCursorPosition>\n<moveCursorToRow6Column12>\n<restoreCursorPosition>\n\"\n`;"}
{"prompt":"watchman watch,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nconst path = require('path');\n\njest.mock('fb-watchman', () => {\n  const normalizePathSep = require('../../lib/normalizePathSep').default;\n  const Client = jest.fn();\n  Client.prototype.capabilityCheck = jest.fn((args, callback) =>\n    setImmediate(() => {\n      callback(null, {\n        capabilities: {'suffix-set': true},\n        version: '2021.06.07.00',\n      });\n    }),\n  );\n  Client.prototype.command = jest.fn((args, callback) =>\n    setImmediate(() => {\n      const path = args[1] ? normalizePathSep(args[1]) : undefined;\n      const response = mockResponse[args[0]][path];\n      callback(null, response.next ? response.next().value : response);\n    }),\n  );\n  Client.prototype.on = jest.fn();\n  Client.prototype.end = jest.fn();\n  return {Client};\n});\n\nconst forcePOSIXPaths = path => path.replaceAll('\\\\', '/');\nconst pearMatcher = path => /pear/.test(path);\n\nlet watchman;\nlet watchmanCrawl;\nlet mockResponse;\nlet mockFiles;\n\nconst ROOT_MOCK = path.sep === '/' ? '/root-mock' : 'M:\\\\root-mock';\nconst FRUITS_RELATIVE = 'fruits';\nconst VEGETABLES_RELATIVE = 'vegetables';\nconst FRUITS = path.resolve(ROOT_MOCK, FRUITS_RELATIVE);\nconst VEGETABLES = path.resolve(ROOT_MOCK, VEGETABLES_RELATIVE);\nconst ROOTS = [FRUITS, VEGETABLES];\nconst BANANA_RELATIVE = path.join(FRUITS_RELATIVE, 'banana.js');\nconst STRAWBERRY_RELATIVE = path.join(FRUITS_RELATIVE, 'strawberry.js');\nconst KIWI_RELATIVE = path.join(FRUITS_RELATIVE, 'kiwi.js');\nconst TOMATO_RELATIVE = path.join(FRUITS_RELATIVE, 'tomato.js');\nconst MELON_RELATIVE = path.join(VEGETABLES_RELATIVE, 'melon.json');\n\nconst WATCH_PROJECT_MOCK = {\n  [FRUITS]: {\n    relative_path: 'fruits',\n    watch: forcePOSIXPaths(ROOT_MOCK),\n  },\n  [VEGETABLES]: {\n    relative_path: 'vegetables',\n    watch: forcePOSIXPaths(ROOT_MOCK),\n  },\n};\n\nconst createMap = obj => new Map(Object.keys(obj).map(key => [key, obj[key]]));\n\ndescribe('watchman watch', () => {\n  beforeEach(() => {\n    watchmanCrawl = require('../watchman').watchmanCrawl;\n\n    watchman = require('fb-watchman');\n\n    mockResponse = {\n      'list-capabilities': {\n        [undefined]: {\n          capabilities: ['field-content.sha1hex'],\n        },\n      },\n      query: {\n        [ROOT_MOCK]: {\n          clock: 'c:fake-clock:1',\n          files: [\n            {\n              exists: true,\n              mtime_ms: {toNumber: () => 30},\n              name: 'fruits/strawberry.js',\n              size: 40,\n            },\n            {\n              exists: true,\n              mtime_ms: {toNumber: () => 31},\n              name: 'fruits/tomato.js',\n              size: 41,\n            },\n            {\n              exists: true,\n              mtime_ms: {toNumber: () => 32},\n              name: 'fruits/pear.js',\n              size: 42,\n            },\n            {\n              exists: true,\n              mtime_ms: {toNumber: () => 33},\n              name: 'vegetables/melon.json',\n              size: 43,\n            },\n          ],\n          is_fresh_instance: true,\n          version: '4.5.0',\n        },\n      },\n      'watch-project': WATCH_PROJECT_MOCK,\n    };\n\n    mockFiles = createMap({\n      [MELON_RELATIVE]: ['', 33, 43, 0, '', null],\n      [STRAWBERRY_RELATIVE]: ['', 30, 40, 0, '', null],\n      [TOMATO_RELATIVE]: ['', 31, 41, 0, '', null],\n    });\n  });\n\n  afterEach(() => {\n    watchman.Client.mock.instances[0].command.mockClear();\n  });\n\n  test('returns a list of all files when there are no clocks', async () => {\n    const {changedFiles, hasteMap, removedFiles} = await watchmanCrawl({\n      data: {\n        clocks: new Map(),\n        files: new Map(),\n      },\n      extensions: ['js', 'json'],\n      ignore: pearMatcher,\n      rootDir: ROOT_MOCK,\n      roots: ROOTS,\n    });\n    const client = watchman.Client.mock.instances[0];\n    const calls = client.command.mock.calls;\n\n    expect(client.on).toHaveBeenCalled();\n    expect(client.on).toHaveBeenCalledWith('error', expect.any(Function));\n\n    // Call 0 and 1 are for ['watch-project']\n    expect(calls[0][0][0]).toBe('watch-project');\n    expect(calls[1][0][0]).toBe('watch-project');\n\n    // Call 2 is the query\n    const query = calls[2][0];\n    expect(query[0]).toBe('query');\n\n    expect(query[2].expression).toEqual([\n      'allof',\n      ['type', 'f'],\n      ['suffix', ['js', 'json']],\n      ['anyof', ['dirname', 'fruits'], ['dirname', 'vegetables']],\n    ]);\n\n    expect(query[2].fields).toEqual(['name', 'exists', 'mtime_ms', 'size']);\n\n    expect(query[2].glob).toEqual([\n      'fruits/**/*.js',\n      'fruits/**/*.json',\n      'vegetables/**/*.js',\n      'vegetables/**/*.json',\n    ]);\n\n    expect(hasteMap.clocks).toEqual(\n      createMap({\n        '': 'c:fake-clock:1',\n      }),\n    );\n\n    expect(changedFiles).toBeUndefined();\n\n    expect(hasteMap.files).toEqual(mockFiles);\n\n    expect(removedFiles).toEqual(new Map());\n\n    expect(client.end).toHaveBeenCalled();\n  });\n\n  test('updates file map and removedFiles when the clock is given', async () => {\n    mockResponse = {\n      'list-capabilities': {\n        [undefined]: {\n          capabilities: ['field-content.sha1hex'],\n        },\n      },\n      query: {\n        [ROOT_MOCK]: {\n          clock: 'c:fake-clock:2',\n          files: [\n            {\n              exists: true,\n              mtime_ms: {toNumber: () => 42},\n              name: 'fruits/kiwi.js',\n              size: 40,\n            },\n            {\n              exists: false,\n              mtime_ms: null,\n              name: 'fruits/tomato.js',\n              size: 0,\n            },\n          ],\n          is_fresh_instance: false,\n          version: '4.5.0',\n        },\n      },\n      'watch-project': WATCH_PROJECT_MOCK,\n    };\n\n    const clocks = createMap({\n      '': 'c:fake-clock:1',\n    });\n\n    const {changedFiles, hasteMap, removedFiles} = await watchmanCrawl({\n      data: {\n        clocks,\n        files: mockFiles,\n      },\n      extensions: ['js', 'json'],\n      ignore: pearMatcher,\n      rootDir: ROOT_MOCK,\n      roots: ROOTS,\n    });\n\n    // The object was reused.\n    expect(hasteMap.files).toBe(mockFiles);\n\n    expect(hasteMap.clocks).toEqual(\n      createMap({\n        '': 'c:fake-clock:2',\n      }),\n    );\n\n    expect(changedFiles).toEqual(\n      createMap({\n        [KIWI_RELATIVE]: ['', 42, 40, 0, '', null],\n      }),\n    );\n\n    expect(hasteMap.files).toEqual(\n      createMap({\n        [KIWI_RELATIVE]: ['', 42, 40, 0, '', null],\n        [MELON_RELATIVE]: ['', 33, 43, 0, '', null],\n        [STRAWBERRY_RELATIVE]: ['', 30, 40, 0, '', null],\n      }),\n    );\n\n    expect(removedFiles).toEqual(\n      createMap({\n        [TOMATO_RELATIVE]: ['', 31, 41, 0, '', null],\n      }),\n    );\n  });\n\n  test('resets the file map and tracks removedFiles when watchman is fresh', async () => {\n    const mockTomatoSha1 = '321f6b7e8bf7f29aab89c5e41a555b1b0baa41a9';\n\n    mockResponse = {\n      'list-capabilities': {\n        [undefined]: {\n          capabilities: ['field-content.sha1hex'],\n        },\n      },\n      query: {\n        [ROOT_MOCK]: {\n          clock: 'c:fake-clock:3',\n          files: [\n            {\n              exists: true,\n              mtime_ms: {toNumber: () => 42},\n              name: 'fruits/kiwi.js',\n              size: 52,\n            },\n            {\n              exists: true,\n              mtime_ms: {toNumber: () => 41},\n              name: 'fruits/banana.js',\n              size: 51,\n            },\n            {\n              'content.sha1hex': mockTomatoSha1,\n              exists: true,\n              mtime_ms: {toNumber: () => 76},\n              name: 'fruits/tomato.js',\n              size: 41,\n            },\n          ],\n          is_fresh_instance: true,\n          version: '4.5.0',\n        },\n      },\n      'watch-project': WATCH_PROJECT_MOCK,\n    };\n\n    const mockBananaMetadata = ['Banana', 41, 51, 1, ['Raspberry'], null];\n    mockFiles.set(BANANA_RELATIVE, mockBananaMetadata);\n    const mockTomatoMetadata = ['Tomato', 31, 41, 1, [], mockTomatoSha1];\n    mockFiles.set(TOMATO_RELATIVE, mockTomatoMetadata);\n\n    const clocks = createMap({\n      '': 'c:fake-clock:1',\n    });\n\n    const {changedFiles, hasteMap, removedFiles} = await watchmanCrawl({\n      data: {\n        clocks,\n        files: mockFiles,\n      },\n      extensions: ['js', 'json'],\n      ignore: pearMatcher,\n      rootDir: ROOT_MOCK,\n      roots: ROOTS,\n    });\n\n    // The file object was *not* reused.\n    expect(hasteMap.files).not.toBe(mockFiles);\n\n    expect(hasteMap.clocks).toEqual(\n      createMap({\n        '': 'c:fake-clock:3',\n      }),\n    );\n\n    expect(changedFiles).toBeUndefined();\n\n    // strawberry and melon removed from the file list.\n    expect(hasteMap.files).toEqual(\n      createMap({\n        [BANANA_RELATIVE]: mockBananaMetadata,\n        [KIWI_RELATIVE]: ['', 42, 52, 0, '', null],\n        [TOMATO_RELATIVE]: ['Tomato', 76, 41, 1, [], mockTomatoSha1],\n      }),\n    );\n\n    // Even though the file list was reset, old file objects are still reused\n    // if no changes have been made\n    expect(hasteMap.files.get(BANANA_RELATIVE)).toBe(mockBananaMetadata);\n\n    // Old file objects are not reused if they have a different mtime\n    expect(hasteMap.files.get(TOMATO_RELATIVE)).not.toBe(mockTomatoMetadata);\n\n    expect(removedFiles).toEqual(\n      createMap({\n        [MELON_RELATIVE]: ['', 33, 43, 0, '', null],\n        [STRAWBERRY_RELATIVE]: ['', 30, 40, 0, '', null],\n      }),\n    );\n  });\n\n  test('properly resets the file map when only one watcher is reset', async () => {\n    mockResponse = {\n      'list-capabilities': {\n        [undefined]: {\n          capabilities: ['field-content.sha1hex'],\n        },\n      },\n      query: {\n        [FRUITS]: {\n          clock: 'c:fake-clock:3',\n          files: [\n            {\n              exists: true,\n              mtime_ms: {toNumber: () => 42},\n              name: 'kiwi.js',\n              size: 52,\n            },\n          ],\n          is_fresh_instance: false,\n          version: '4.5.0',\n        },\n        [VEGETABLES]: {\n          clock: 'c:fake-clock:4',\n          files: [\n            {\n              exists: true,\n              mtime_ms: {toNumber: () => 33},\n              name: 'melon.json',\n              size: 43,\n            },\n          ],\n          is_fresh_instance: true,\n          version: '4.5.0',\n        },\n      },\n      'watch-project': {\n        [FRUITS]: {\n          watch: forcePOSIXPaths(FRUITS),\n        },\n        [VEGETABLES]: {\n          watch: forcePOSIXPaths(VEGETABLES),\n        },\n      },\n    };\n\n    const clocks = createMap({\n      [FRUITS_RELATIVE]: 'c:fake-clock:1',\n      [VEGETABLES_RELATIVE]: 'c:fake-clock:2',\n    });\n\n    const {changedFiles, hasteMap, removedFiles} = await watchmanCrawl({\n      data: {\n        clocks,\n        files: mockFiles,\n      },\n      extensions: ['js', 'json'],\n      ignore: pearMatcher,\n      rootDir: ROOT_MOCK,\n      roots: ROOTS,\n    });\n\n    expect(hasteMap.clocks).toEqual(\n      createMap({\n        [FRUITS_RELATIVE]: 'c:fake-clock:3',\n        [VEGETABLES_RELATIVE]: 'c:fake-clock:4',\n      }),\n    );\n\n    expect(changedFiles).toBeUndefined();\n\n    expect(hasteMap.files).toEqual(\n      createMap({\n        [KIWI_RELATIVE]: ['', 42, 52, 0, '', null],\n        [MELON_RELATIVE]: ['', 33, 43, 0, '', null],\n      }),\n    );\n\n    expect(removedFiles).toEqual(\n      createMap({\n        [STRAWBERRY_RELATIVE]: ['', 30, 40, 0, '', null],\n        [TOMATO_RELATIVE]: ['', 31, 41, 0, '', null],\n      }),\n    );\n  });\n\n  test('does not add directory filters to query when watching a ROOT', async () => {\n    mockResponse = {\n      'list-capabilities': {\n        [undefined]: {\n          capabilities: ['field-content.sha1hex'],\n        },\n      },\n      query: {\n        [ROOT_MOCK]: {\n          clock: 'c:fake-clock:1',\n          files: [],\n          is_fresh_instance: false,\n          version: '4.5.0',\n        },\n      },\n      'watch-project': {\n        [FRUITS]: {\n          relative_path: 'fruits',\n          watch: forcePOSIXPaths(ROOT_MOCK),\n        },\n        [ROOT_MOCK]: {\n          watch: forcePOSIXPaths(ROOT_MOCK),\n        },\n        [VEGETABLES]: {\n          relative_path: 'vegetables',\n          watch: forcePOSIXPaths(ROOT_MOCK),\n        },\n      },\n    };\n\n    const {changedFiles, hasteMap, removedFiles} = await watchmanCrawl({\n      data: {\n        clocks: new Map(),\n        files: new Map(),\n      },\n      extensions: ['js', 'json'],\n      ignore: pearMatcher,\n      rootDir: ROOT_MOCK,\n      roots: [...ROOTS, ROOT_MOCK],\n    });\n\n    const client = watchman.Client.mock.instances[0];\n    const calls = client.command.mock.calls;\n\n    expect(client.on).toHaveBeenCalled();\n    expect(client.on).toHaveBeenCalledWith('error', expect.any(Function));\n\n    // First 3 calls are for ['watch-project']\n    expect(calls[0][0][0]).toBe('watch-project');\n    expect(calls[1][0][0]).toBe('watch-project');\n    expect(calls[2][0][0]).toBe('watch-project');\n\n    // Call 4 is the query\n    const query = calls[3][0];\n    expect(query[0]).toBe('query');\n\n    expect(query[2].expression).toEqual([\n      'allof',\n      ['type', 'f'],\n      ['suffix', ['js', 'json']],\n    ]);\n\n    expect(query[2].fields).toEqual(['name', 'exists', 'mtime_ms', 'size']);\n\n    expect(query[2].glob).toEqual(['**/*.js', '**/*.json']);\n\n    expect(hasteMap.clocks).toEqual(\n      createMap({\n        '': 'c:fake-clock:1',\n      }),\n    );\n\n    expect(changedFiles).toEqual(new Map());\n\n    expect(hasteMap.files).toEqual(new Map());\n\n    expect(removedFiles).toEqual(new Map());\n\n    expect(client.end).toHaveBeenCalled();\n  });\n\n  test('SHA-1 requested and available', async () => {\n    mockResponse = {\n      'list-capabilities': {\n        [undefined]: {\n          capabilities: ['field-content.sha1hex'],\n        },\n      },\n      query: {\n        [ROOT_MOCK]: {\n          clock: 'c:fake-clock:1',\n          files: [],\n          is_fresh_instance: false,\n          version: '4.5.0',\n        },\n      },\n      'watch-project': {\n        [ROOT_MOCK]: {\n          watch: forcePOSIXPaths(ROOT_MOCK),\n        },\n      },\n    };\n\n    await watchmanCrawl({\n      computeSha1: true,\n      data: {\n        clocks: new Map(),\n        files: new Map(),\n      },\n      extensions: ['js', 'json'],\n      rootDir: ROOT_MOCK,\n      roots: [ROOT_MOCK],\n    });\n\n    const client = watchman.Client.mock.instances[0];\n    const calls = client.command.mock.calls;\n\n    expect(calls[0][0]).toEqual(['list-capabilities']);\n    expect(calls[2][0][2].fields).toContain('content.sha1hex');\n  });\n\n  test('SHA-1 requested and NOT available', async () => {\n    mockResponse = {\n      'list-capabilities': {\n        [undefined]: {\n          capabilities: [],\n        },\n      },\n      query: {\n        [ROOT_MOCK]: {\n          clock: 'c:fake-clock:1',\n          files: [],\n          is_fresh_instance: false,\n          version: '4.5.0',\n        },\n      },\n      'watch-project': {\n        [ROOT_MOCK]: {\n          watch: forcePOSIXPaths(ROOT_MOCK),\n        },\n      },\n    };\n\n    await watchmanCrawl({\n      computeSha1: true,\n      data: {\n        clocks: new Map(),\n        files: new Map(),\n      },\n      extensions: ['js', 'json'],\n      rootDir: ROOT_MOCK,\n      roots: [ROOT_MOCK],\n    });\n\n    const client = watchman.Client.mock.instances[0];\n    const calls = client.command.mock.calls;\n\n    expect(calls[0][0]).toEqual(['list-capabilities']);\n    expect(calls[2][0][2].fields).not.toContain('content.sha1hex');\n  });\n\n  test('source control query', async () => {\n    mockResponse = {\n      'list-capabilities': {\n        [undefined]: {\n          capabilities: ['field-content.sha1hex'],\n        },\n      },\n      query: {\n        [ROOT_MOCK]: {\n          clock: {\n            clock: 'c:1608612057:79675:1:139410',\n            scm: {\n              mergebase: 'master',\n              'mergebase-with': 'master',\n            },\n          },\n          files: [\n            {\n              exists: true,\n              mtime_ms: {toNumber: () => 42},\n              name: 'fruits/kiwi.js',\n              size: 40,\n            },\n            {\n              exists: false,\n              mtime_ms: null,\n              name: 'fruits/tomato.js',\n              size: 0,\n            },\n          ],\n          // Watchman is going to tell us that we have a fresh instance.\n          is_fresh_instance: true,\n          version: '4.5.0',\n        },\n      },\n      'watch-project': WATCH_PROJECT_MOCK,\n    };\n\n    // Start with a source-control clock.\n    const clocks = createMap({\n      '': {scm: {'mergebase-with': 'master'}},\n    });\n\n    const {changedFiles, hasteMap, removedFiles} = await watchmanCrawl({\n      data: {\n        clocks,\n        files: mockFiles,\n      },\n      extensions: ['js', 'json'],\n      ignore: pearMatcher,\n      rootDir: ROOT_MOCK,\n      roots: ROOTS,\n    });\n\n    // The object was reused.\n    expect(hasteMap.files).toBe(mockFiles);\n\n    // Transformed into a normal clock.\n    expect(hasteMap.clocks).toEqual(\n      createMap({\n        '': 'c:1608612057:79675:1:139410',\n      }),\n    );\n\n    expect(changedFiles).toEqual(\n      createMap({\n        [KIWI_RELATIVE]: ['', 42, 40, 0, '', null],\n      }),\n    );\n\n    expect(hasteMap.files).toEqual(\n      createMap({\n        [KIWI_RELATIVE]: ['', 42, 40, 0, '', null],\n        [MELON_RELATIVE]: ['', 33, 43, 0, '', null],\n        [STRAWBERRY_RELATIVE]: ['', 30, 40, 0, '', null],\n      }),\n    );\n\n    expect(removedFiles).toEqual(\n      createMap({\n        [TOMATO_RELATIVE]: ['', 31, 41, 0, '', null],\n      }),\n    );\n  });\n});"}
{"prompt":"First run","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport * as os from 'os';\nimport * as path from 'path';\nimport * as fs from 'graceful-fs';\nimport {cleanup, writeFiles} from '../Utils';\nimport {runContinuous} from '../runJest';\n\nconst DIR = path.resolve(os.tmpdir(), 'watch_mode_no_access');\n\nconst sleep = (time: number) =>\n  new Promise(resolve => setTimeout(resolve, time));\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\nconst setupFiles = () => {\n  writeFiles(DIR, {\n    '__tests__/foo.test.js': `\n      const foo = require('../foo');\n      test('foo', () => { expect(typeof foo).toBe('number'); });\n    `,\n    'foo.js': `\n      module.exports = 0;\n    `,\n    'package.json': JSON.stringify({\n      jest: {},\n    }),\n  });\n};\n\nlet testRun: ReturnType<typeof runContinuous>;\n\nafterEach(async () => {\n  if (testRun) {\n    await testRun.end();\n  }\n});\n\nconst getOneSecondAfterMs = (ms: number) => ms / 1000 + 1;\n\ntest('does not re-run tests when only access time is modified', async () => {\n  setupFiles();\n\n  testRun = runContinuous(DIR, ['--watchAll', '--no-watchman']);\n\n  const testCompletedRE = /Ran all test suites./g;\n  const numberOfTestRuns = (stderr: string): number => {\n    const matches = stderr.match(testCompletedRE);\n    return matches ? matches.length : 0;\n  };\n\n  // First run\n  await testRun.waitUntil(({stderr}) => numberOfTestRuns(stderr) === 1);\n\n  // Should re-run the test\n  const modulePath = path.join(DIR, 'foo.js');\n  const stat = fs.lstatSync(modulePath);\n  fs.utimesSync(\n    modulePath,\n    getOneSecondAfterMs(stat.atimeMs),\n    getOneSecondAfterMs(stat.mtimeMs),\n  );\n\n  await testRun.waitUntil(({stderr}) => numberOfTestRuns(stderr) === 2);\n\n  // Should NOT re-run the test\n  const fakeATime = 1_541_723_621;\n  fs.utimesSync(\n    modulePath,\n    getOneSecondAfterMs(fakeATime),\n    getOneSecondAfterMs(stat.mtimeMs),\n  );\n  await sleep(3000);\n  expect(numberOfTestRuns(testRun.getCurrentOutput().stderr)).toBe(2);\n\n  // Should re-run the test\n  fs.writeFileSync(modulePath, 'module.exports = 1;', 'utf8');\n  await testRun.waitUntil(({stderr}) => numberOfTestRuns(stderr) === 3);\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, extractSummaries, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'watch-mode-only-failed');\nconst pluginPath = path.resolve(__dirname, '../MockStdinWatchPlugin');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\nconst setupFiles = (input: Array<{keys: Array<string>}>) => {\n  writeFiles(DIR, {\n    '__tests__/bar.spec.js': `\n      test('bar 1', () => { expect('bar').toBe('foo'); });\n    `,\n    '__tests__/foo.spec.js': `\n      test('foo 1', () => { expect('foo').toBe('foo'); });\n    `,\n    'package.json': JSON.stringify({\n      jest: {\n        testEnvironment: 'node',\n        watchPlugins: [[pluginPath, {input}]],\n      },\n    }),\n  });\n};\n\ntest('can press \"f\" to run only failed tests', () => {\n  const input = [{keys: ['f']}, {keys: ['q']}];\n  setupFiles(input);\n\n  const {exitCode, stderr} = runJest(DIR, ['--no-watchman', '--watchAll']);\n  const results = extractSummaries(stderr);\n\n  expect(results).toHaveLength(2);\n  for (const {rest, summary} of results) {\n    expect(rest).toMatchSnapshot('test results');\n    expect(summary).toMatchSnapshot('test summary');\n  }\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`can press \"f\" to run only failed tests: test results 1`] = `\n\"FAIL __tests__/bar.spec.js\n  ● bar 1\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: \"foo\"\n    Received: \"bar\"\n\n    > 1 | test('bar 1', () => { expect('bar').toBe('foo'); });\n        |                                     ^\n\n      at Object.toBe (__tests__/bar.spec.js:1:37)\n\nPASS __tests__/foo.spec.js\"\n`;\n\nexports[`can press \"f\" to run only failed tests: test results 2`] = `\n\"FAIL __tests__/bar.spec.js\n  ✕ bar 1\n\n  ● bar 1\n\n    expect(received).toBe(expected) // Object.is equality\n\n    Expected: \"foo\"\n    Received: \"bar\"\n\n    > 1 | test('bar 1', () => { expect('bar').toBe('foo'); });\n        |                                     ^\n\n      at Object.toBe (__tests__/bar.spec.js:1:37)\"\n`;\n\nexports[`can press \"f\" to run only failed tests: test summary 1`] = `\n\"Test Suites: 1 failed, 1 passed, 2 total\nTests:       1 failed, 1 passed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`can press \"f\" to run only failed tests: test summary 2`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       1 failed, 1 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, extractSummaries, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'watch-mode-patterns');\nconst pluginPath = path.resolve(__dirname, '../MockStdinWatchPlugin');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\nconst setupFiles = (input: Array<{keys: Array<string>}>) => {\n  writeFiles(DIR, {\n    '__tests__/bar.spec.js': `\n      test('bar 1', () => { expect('bar').toBe('bar'); });\n      test('bar 2', () => { expect('bar').toBe('bar'); });\n    `,\n    '__tests__/foo.spec.js': `\n      test('foo 1', () => { expect('foo').toBe('foo'); });\n      test('foo 2', () => { expect('foo').toBe('foo'); });\n    `,\n    'package.json': JSON.stringify({\n      jest: {\n        testEnvironment: 'node',\n        watchPlugins: [[pluginPath, {input}]],\n      },\n    }),\n  });\n};\n\ntest('can press \"p\" to filter by file name', () => {\n  const input = [{keys: ['p', 'b', 'a', 'r', '\\r']}, {keys: ['q']}];\n  setupFiles(input);\n\n  const {exitCode, stdout, stderr} = runJest(DIR, [\n    '--no-watchman',\n    '--watchAll',\n  ]);\n  const results = extractSummaries(stderr);\n\n  expect(stdout).toMatchSnapshot();\n  expect(results).toHaveLength(2);\n  for (const {rest, summary} of results) {\n    expect(rest).toMatchSnapshot('test results');\n    expect(summary).toMatchSnapshot('test summary');\n  }\n  expect(exitCode).toBe(0);\n});\n\ntest('can press \"t\" to filter by test name', () => {\n  const input = [{keys: ['t', '2', '\\r']}, {keys: ['q']}];\n  setupFiles(input);\n\n  const {exitCode, stdout, stderr} = runJest(DIR, [\n    '--no-watchman',\n    '--watchAll',\n  ]);\n  const results = extractSummaries(stderr);\n\n  expect(stdout).toMatchSnapshot();\n  expect(results).toHaveLength(2);\n  for (const {rest, summary} of results) {\n    expect(rest).toMatchSnapshot('test results');\n    expect(summary).toMatchSnapshot('test summary');\n  }\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`can press \"p\" to filter by file name 1`] = `\n\"<hideCursor>\n<clearTerminal>\nPattern Mode Usage\n › Press Esc to exit pattern mode.\n › Press Enter to filter by a filenames regex pattern.\n\n<showCursor>\n<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › \n<saveCursorPosition>\n<moveCursorToRow6Column12>\n<restoreCursorPosition>\n<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › b\n<saveCursorPosition>\n<moveCursorToRow6Column13>\n<restoreCursorPosition>\n<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › ba\n<saveCursorPosition>\n<moveCursorToRow6Column14>\n<restoreCursorPosition>\n<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › bar\n<saveCursorPosition>\n<moveCursorToRow6Column15>\n<restoreCursorPosition>\n\n<moveCursorDownBy1Row>\n<eraseScreenDown>\n\"\n`;\n\nexports[`can press \"p\" to filter by file name: test results 1`] = `\n\"PASS __tests__/bar.spec.js\nPASS __tests__/foo.spec.js\"\n`;\n\nexports[`can press \"p\" to filter by file name: test results 2`] = `\n\"PASS __tests__/bar.spec.js\n  ✓ bar 1\n  ✓ bar 2\"\n`;\n\nexports[`can press \"p\" to filter by file name: test summary 1`] = `\n\"Test Suites: 2 passed, 2 total\nTests:       4 passed, 4 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`can press \"p\" to filter by file name: test summary 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites matching bar.\"\n`;\n\nexports[`can press \"t\" to filter by test name 1`] = `\n\"<hideCursor>\n<clearTerminal>\nPattern Mode Usage\n › Press Esc to exit pattern mode.\n › Press Enter to filter by a tests regex pattern.\n\n<showCursor>\n<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › \n<saveCursorPosition>\n<moveCursorToRow6Column12>\n<restoreCursorPosition>\n<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › 2\n<saveCursorPosition>\n<moveCursorToRow6Column13>\n<restoreCursorPosition>\n\n<moveCursorDownBy1Row>\n<eraseScreenDown>\n\"\n`;\n\nexports[`can press \"t\" to filter by test name: test results 1`] = `\n\"PASS __tests__/bar.spec.js\nPASS __tests__/foo.spec.js\"\n`;\n\nexports[`can press \"t\" to filter by test name: test results 2`] = `\n\"PASS __tests__/bar.spec.js\nPASS __tests__/foo.spec.js\"\n`;\n\nexports[`can press \"t\" to filter by test name: test summary 1`] = `\n\"Test Suites: 2 passed, 2 total\nTests:       4 passed, 4 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`can press \"t\" to filter by test name: test summary 2`] = `\n\"Test Suites: 2 passed, 2 total\nTests:       2 skipped, 2 passed, 4 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites with tests matching \"2\".\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport * as path from 'path';\nimport {cleanup, extractSummaries, writeFiles} from '../Utils';\nimport runJest from '../runJest';\n\nconst DIR = path.resolve(tmpdir(), 'watch-mode-update-snapshot');\nconst pluginPath = path.resolve(__dirname, '../MockStdinWatchPlugin');\n\nbeforeEach(() => cleanup(DIR));\nafterAll(() => cleanup(DIR));\n\nexpect.addSnapshotSerializer({\n  print: val => (val as string).replaceAll('[s\u001b[u', '\\n'),\n  test: val => typeof val === 'string' && val.includes('[s\u001b[u'),\n});\n\nconst setupFiles = (input: Array<{keys: Array<string>}>) => {\n  writeFiles(DIR, {\n    '__tests__/__snapshots__/bar.spec.js.snap': `// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[\\`bar 1\\`] = \\`\"foo\"\\`;\n    `,\n    '__tests__/bar.spec.js': `\n      test('bar', () => { expect('bar').toMatchSnapshot(); });\n    `,\n    'package.json': JSON.stringify({\n      jest: {\n        testEnvironment: 'node',\n        watchPlugins: [[pluginPath, {input}]],\n      },\n    }),\n  });\n};\n\ntest('can press \"u\" to update snapshots', () => {\n  const input = [{keys: ['u']}, {keys: ['q']}];\n  setupFiles(input);\n\n  const {exitCode, stderr} = runJest(DIR, ['--no-watchman', '--watchAll']);\n  const results = extractSummaries(stderr);\n  expect(results).toHaveLength(2);\n  for (const {rest, summary} of results) {\n    expect(rest).toMatchSnapshot('test results');\n    expect(summary).toMatchSnapshot('test summary');\n  }\n  expect(exitCode).toBe(0);\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`can press \"u\" to update snapshots: test results 1`] = `\n\"FAIL __tests__/bar.spec.js\n  ✕ bar\n\n  ● bar\n\n    expect(received).toMatchSnapshot()\n\n    Snapshot name: \\`bar 1\\`\n\n    Snapshot: \"foo\"\n    Received: \"bar\"\n\n    > 1 | test('bar', () => { expect('bar').toMatchSnapshot(); });\n        |                                   ^\n\n      at Object.toMatchSnapshot (__tests__/bar.spec.js:1:35)\n\n › 1 snapshot failed.\nSnapshot Summary\n › 1 snapshot failed from 1 test suite. Inspect your code changes or press \\`u\\` to update them.\"\n`;\n\nexports[`can press \"u\" to update snapshots: test results 2`] = `\n\"PASS __tests__/bar.spec.js\n  ✓ bar\n\n › 1 snapshot updated.\nSnapshot Summary\n › 1 snapshot updated from 1 test suite.\"\n`;\n\nexports[`can press \"u\" to update snapshots: test summary 1`] = `\n\"Test Suites: 1 failed, 1 total\nTests:       1 failed, 1 total\nSnapshots:   1 failed, 1 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;\n\nexports[`can press \"u\" to update snapshots: test summary 2`] = `\n\"Test Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   1 updated, 1 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nthrow new Error('initialization error');"}
{"prompt":"Call the callback","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport chalk from 'chalk';\nimport {TestPathPatterns} from '@jest/pattern';\nimport {KEYS} from 'jest-watcher';\n\nconst runJestMock = jest.fn();\n\njest.mock(\n  '../SearchSource',\n  () =>\n    class {\n      findMatchingTests(pattern) {\n        return {paths: []};\n      }\n    },\n);\n\njest.doMock('chalk', () => new chalk.Instance({level: 0}));\n\njest.doMock('strip-ansi');\nrequire('strip-ansi').mockImplementation(str => str);\n\njest.doMock(\n  '../runJest',\n  () =>\n    function () {\n      const args = [...arguments];\n      const [{onComplete}] = args;\n      runJestMock.apply(null, args);\n\n      // Call the callback\n      onComplete({\n        snapshot: {},\n        testResults: [\n          {\n            testResults: [{title: 'should return the correct index when'}],\n          },\n          {\n            testResults: [{title: 'should allow test siblings to modify'}],\n          },\n          {\n            testResults: [{title: 'might get confusing'}],\n          },\n          {\n            testResults: [\n              {title: 'should handle length properties that cannot'},\n            ],\n          },\n          {\n            testResults: [{title: 'should recognize various types'}],\n          },\n          {\n            testResults: [{title: 'should recognize null and undefined'}],\n          },\n          {\n            testResults: [{title: 'should not output colors to pipe'}],\n          },\n          {\n            testResults: [{title: 'should convert string to a RegExp'}],\n          },\n          {\n            testResults: [\n              {title: 'should escape and convert string to a RegExp'},\n            ],\n          },\n          {\n            testResults: [{title: 'should convert grep string to a RegExp'}],\n          },\n        ],\n      });\n\n      return Promise.resolve();\n    },\n);\n\nconst watch = require('../watch').default;\n\nconst globalConfig = {\n  rootDir: '',\n  testPathPatterns: new TestPathPatterns([]),\n  watch: true,\n};\n\nafterEach(runJestMock.mockReset);\n\ndescribe('Watch mode flows', () => {\n  let pipe;\n  let hasteMapInstances;\n  let contexts;\n  let stdin;\n\n  beforeEach(() => {\n    pipe = {write: jest.fn()};\n    hasteMapInstances = [{on: () => {}}];\n    contexts = [{config: {}}];\n    stdin = new MockStdin();\n  });\n\n  it('Pressing \"T\" enters pattern mode', () => {\n    contexts[0].config = {rootDir: ''};\n    watch(globalConfig, contexts, pipe, hasteMapInstances, stdin);\n\n    // Write a enter pattern mode\n    stdin.emit('t');\n    expect(pipe.write).toHaveBeenCalledWith(' pattern › ');\n\n    const assertPattern = hex => {\n      pipe.write.mockReset();\n      stdin.emit(hex);\n      expect(pipe.write.mock.calls.join('\\n')).toMatchSnapshot();\n    };\n\n    // Write a pattern\n    for (const pattern of ['c', 'o', 'n', ' ', '1', '2'])\n      assertPattern(pattern);\n\n    for (const pattern of [KEYS.BACKSPACE, KEYS.BACKSPACE])\n      assertPattern(pattern);\n\n    for (const pattern of ['*']) assertPattern(pattern);\n\n    // Runs Jest again\n    runJestMock.mockReset();\n    stdin.emit(KEYS.ENTER);\n    expect(runJestMock).toHaveBeenCalled();\n\n    // globalConfig is updated with the current pattern\n    expect(runJestMock.mock.calls[0][0].globalConfig).toMatchObject({\n      onlyChanged: false,\n      testNamePattern: 'con *',\n      watch: true,\n      watchAll: false,\n    });\n  });\n});\n\nclass MockStdin {\n  constructor() {\n    this._callbacks = [];\n  }\n\n  setRawMode() {}\n\n  resume() {}\n\n  setEncoding() {}\n\n  on(evt, callback) {\n    this._callbacks.push(callback);\n  }\n\n  emit(key) {\n    for (const cb of this._callbacks) cb(key);\n  }\n}"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Watch mode flows Pressing \"T\" enters pattern mode 1`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › c\n<saveCursorPosition>\n<moveCursorToRow6Column13>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"T\" enters pattern mode 2`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › co\n<saveCursorPosition>\n<moveCursorToRow6Column14>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"T\" enters pattern mode 3`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › con\n<saveCursorPosition>\n<moveCursorToRow6Column15>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"T\" enters pattern mode 4`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › con \n<saveCursorPosition>\n<moveCursorToRow6Column16>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"T\" enters pattern mode 5`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › con 1\n<saveCursorPosition>\n<moveCursorToRow6Column17>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"T\" enters pattern mode 6`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › con 12\n<saveCursorPosition>\n<moveCursorToRow6Column18>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"T\" enters pattern mode 7`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › con 1\n<saveCursorPosition>\n<moveCursorToRow6Column17>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"T\" enters pattern mode 8`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › con \n<saveCursorPosition>\n<moveCursorToRow6Column16>\n<restoreCursorPosition>\n\"\n`;\n\nexports[`Watch mode flows Pressing \"T\" enters pattern mode 9`] = `\n\"<eraseLine>\n<moveCursorToColumn1>\n<eraseScreenDown>\n pattern › con *\n<saveCursorPosition>\n<moveCursorToRow6Column17>\n<restoreCursorPosition>\n\"\n`;"}
{"prompt":"/ <reference lib=dom />","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @jest-environment jsdom\n */\n\n/// <reference lib=\"dom\" />\n\nfunction exampleDispatch() {\n  globalThis.dispatchEvent(new CustomEvent('event', {}));\n}\n\ndescribe('spy on `dispatchEvent`', () => {\n  const dispatchEventSpy = jest.spyOn(globalThis, 'dispatchEvent');\n\n  it('should be called', () => {\n    exampleDispatch();\n\n    expect(dispatchEventSpy).toHaveBeenCalled();\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst {Worker} = require('worker_threads');\n\ntest('something', () => {\n  const worker = new Worker(require.resolve('../interval-code'), {\n    stderr: true,\n    stdout: true,\n  });\n  worker.unref();\n  expect(true).toBe(true);\n});"}
{"prompt":"Strawberry!","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n'use strict';\n\nimport * as path from 'path';\nimport fs from 'graceful-fs';\nimport H from '../constants';\nimport {getSha1, worker} from '../worker';\n\njest.mock('graceful-fs', () => {\n  const path = require('path');\n  const mockFs = {\n    [path.join('/project', 'fruits', 'Banana.js')]: `\n        const Strawberry = require(\"Strawberry\");\n      `,\n    [path.join('/project', 'fruits', 'Pear.js')]: `\n        const Banana = require(\"Banana\");\n        const Strawberry = require('Strawberry');\n        const Lime = loadModule('Lime');\n      `,\n    [path.join('/project', 'fruits', 'Strawberry.js')]: `\n        // Strawberry!\n      `,\n    [path.join('/project', 'fruits', 'apple.png')]: Buffer.from([\n      137, 80, 78, 71, 13, 10, 26, 10,\n    ]),\n    [path.join('/project', 'package.json')]: `\n        {\n          \"name\": \"haste-package\",\n          \"main\": \"foo.js\"\n        }\n      `,\n  };\n\n  return {\n    ...jest.createMockFromModule('graceful-fs'),\n    readFileSync: jest.fn((path, options) => {\n      if (mockFs[path]) {\n        return options === 'utf8' ? mockFs[path] : Buffer.from(mockFs[path]);\n      }\n\n      throw new Error(`Cannot read path '${path}'.`);\n    }),\n  };\n});\n\nconst rootDir = '/project';\n\ndescribe('worker', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('parses JavaScript files and extracts module information', async () => {\n    expect(\n      await worker({\n        computeDependencies: true,\n        filePath: path.join('/project', 'fruits', 'Pear.js'),\n        rootDir,\n      }),\n    ).toEqual({\n      dependencies: ['Banana', 'Strawberry'],\n    });\n\n    expect(\n      await worker({\n        computeDependencies: true,\n        filePath: path.join('/project', 'fruits', 'Strawberry.js'),\n        rootDir,\n      }),\n    ).toEqual({\n      dependencies: [],\n    });\n  });\n\n  it('accepts a custom dependency extractor', async () => {\n    expect(\n      await worker({\n        computeDependencies: true,\n        dependencyExtractor: path.join(__dirname, 'dependencyExtractor.js'),\n        filePath: path.join('/project', 'fruits', 'Pear.js'),\n        rootDir,\n      }),\n    ).toEqual({\n      dependencies: ['Banana', 'Strawberry', 'Lime'],\n    });\n  });\n\n  it('delegates to hasteImplModulePath for getting the id', async () => {\n    expect(\n      await worker({\n        computeDependencies: true,\n        filePath: path.join('/project', 'fruits', 'Pear.js'),\n        hasteImplModulePath: require.resolve('./haste_impl.js'),\n        rootDir,\n      }),\n    ).toEqual({\n      dependencies: ['Banana', 'Strawberry'],\n      id: 'Pear',\n      module: [path.join('fruits', 'Pear.js'), H.MODULE],\n    });\n\n    expect(\n      await worker({\n        computeDependencies: true,\n        filePath: path.join('/project', 'fruits', 'Strawberry.js'),\n        rootDir,\n      }),\n    ).toEqual({\n      dependencies: [],\n      id: 'Strawberry',\n      module: [path.join('fruits', 'Strawberry.js'), H.MODULE],\n    });\n  });\n\n  it('parses package.json files as haste packages', async () => {\n    expect(\n      await worker({\n        computeDependencies: true,\n        filePath: path.join('/project', 'package.json'),\n        rootDir,\n      }),\n    ).toEqual({\n      dependencies: undefined,\n      id: 'haste-package',\n      module: ['package.json', H.PACKAGE],\n    });\n  });\n\n  it('returns an error when a file cannot be accessed', async () => {\n    let error = null;\n\n    try {\n      await worker({computeDependencies: true, filePath: '/kiwi.js', rootDir});\n    } catch (thrownError) {\n      error = thrownError;\n    }\n\n    expect(error.message).toBe(\"Cannot read path '/kiwi.js'.\");\n  });\n\n  it('simply computes SHA-1s when requested (works well with binary data)', async () => {\n    expect(\n      await getSha1({\n        computeSha1: true,\n        filePath: path.join('/project', 'fruits', 'apple.png'),\n        rootDir,\n      }),\n    ).toEqual({sha1: '4caece539b039b16e16206ea2478f8c5ffb2ca05'});\n\n    expect(\n      await getSha1({\n        computeSha1: false,\n        filePath: path.join('/project', 'fruits', 'Banana.js'),\n        rootDir,\n      }),\n    ).toEqual({sha1: null});\n\n    expect(\n      await getSha1({\n        computeSha1: true,\n        filePath: path.join('/project', 'fruits', 'Banana.js'),\n        rootDir,\n      }),\n    ).toEqual({sha1: '7772b628e422e8cf59c526be4bb9f44c0898e3d1'});\n\n    expect(\n      await getSha1({\n        computeSha1: true,\n        filePath: path.join('/project', 'fruits', 'Pear.js'),\n        rootDir,\n      }),\n    ).toEqual({sha1: 'c7a7a68a1c8aaf452669dd2ca52ac4a434d25552'});\n\n    await expect(\n      getSha1({computeSha1: true, filePath: '/i/dont/exist.js', rootDir}),\n    ).rejects.toThrow(\"Cannot read path '/i/dont/exist.js'.\");\n  });\n\n  it('avoids computing dependencies if not requested and Haste does not need it', async () => {\n    expect(\n      await worker({\n        computeDependencies: false,\n        filePath: path.join('/project', 'fruits', 'Pear.js'),\n        hasteImplModulePath: path.resolve(__dirname, 'haste_impl.js'),\n        rootDir,\n      }),\n    ).toEqual({\n      dependencies: undefined,\n      id: 'Pear',\n      module: [path.join('fruits', 'Pear.js'), H.MODULE],\n      sha1: undefined,\n    });\n\n    // Ensure not disk access happened.\n    expect(fs.readFileSync).not.toHaveBeenCalled();\n    expect(fs.readFile).not.toHaveBeenCalled();\n  });\n});"}
{"prompt":"https://ghub.com/nodejs/node/issues/51766","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {access, mkdir, rm, writeFile} from 'fs/promises';\nimport {dirname, join} from 'path';\nimport {transformFileAsync} from '@babel/core';\nimport {\n  CHILD_MESSAGE_CALL,\n  WorkerEvents,\n  type WorkerOptions,\n  WorkerStates,\n} from '../../types';\nimport ChildProcessWorker, {SIGKILL_DELAY} from '../ChildProcessWorker';\nimport ThreadsWorker from '../NodeThreadsWorker';\n\njest.setTimeout(10_000);\n\nconst root = join('../../');\nconst filesToBuild = [\n  'workers/processChild',\n  'workers/threadChild',\n  'workers/safeMessageTransferring',\n  'workers/isDataCloneError',\n  'types',\n];\nconst writeDestination = join(__dirname, '__temp__');\nconst processChildWorkerPath = join(\n  writeDestination,\n  'workers/processChild.js',\n);\nconst threadChildWorkerPath = join(writeDestination, 'workers/threadChild.js');\n\n// https://github.com/nodejs/node/issues/51766\nif (\n  process.platform === 'win32' &&\n  (process.version.startsWith('v21.') ||\n    process.version.startsWith('v22.') ||\n    process.version.startsWith('v23.'))\n) {\n  // eslint-disable-next-line jest/no-focused-tests\n  test.only('skipping test on broken platform', () => {\n    console.warn('Skipping test on broken platform');\n  });\n}\n\nbeforeAll(async () => {\n  await mkdir(writeDestination, {recursive: true});\n\n  for (const file of filesToBuild) {\n    const sourcePath = join(__dirname, root, `${file}.ts`);\n    const writePath = join(writeDestination, `${file}.js`);\n\n    await mkdir(dirname(writePath), {recursive: true});\n\n    const result = await transformFileAsync(sourcePath);\n\n    await writeFile(writePath, result!.code!, 'utf8');\n  }\n});\n\nafterAll(async () => {\n  await rm(writeDestination, {force: true, recursive: true});\n});\n\ntest.each(filesToBuild)('%s.js should exist', file => {\n  const path = join(writeDestination, `${file}.js`);\n\n  expect(async () => access(path)).not.toThrow();\n});\n\nasync function closeWorkerAfter(\n  worker: ChildProcessWorker | ThreadsWorker,\n  testBody: (worker: ChildProcessWorker | ThreadsWorker) => Promise<void>,\n) {\n  try {\n    await testBody(worker);\n  } finally {\n    worker.forceExit();\n    await worker.waitForExit();\n  }\n}\n\ndescribe.each([\n  {\n    name: 'ProcessWorker',\n    workerClass: ChildProcessWorker,\n    workerPath: processChildWorkerPath,\n  },\n  {\n    name: 'ThreadWorker',\n    workerClass: ThreadsWorker,\n    workerPath: threadChildWorkerPath,\n  },\n])('$name', ({workerClass, workerPath}) => {\n  let int: NodeJS.Timeout;\n\n  afterEach(async () => {\n    clearInterval(int);\n  });\n\n  function waitForChange(fn: () => unknown) {\n    const initial = fn();\n\n    return new Promise((resolve, reject) => {\n      let count = 0;\n\n      int = setInterval(() => {\n        const updated = fn();\n\n        if (initial !== updated) {\n          resolve(updated);\n          clearInterval(int);\n        }\n\n        if (count > 100_000) {\n          reject(new Error('Timeout waiting for change'));\n        }\n\n        count++;\n      }, 1);\n    });\n  }\n\n  test('should get memory usage', async () => {\n    await closeWorkerAfter(\n      new workerClass({\n        childWorkerPath: workerPath,\n        maxRetries: 0,\n        workerPath: join(__dirname, '__fixtures__', 'EdgeCasesWorker'),\n      } as WorkerOptions),\n      async (worker: ChildProcessWorker | ThreadsWorker) => {\n        const memoryUsagePromise = worker.getMemoryUsage();\n        expect(memoryUsagePromise).toBeInstanceOf(Promise);\n\n        expect(await memoryUsagePromise).toBeGreaterThan(0);\n      },\n    );\n  });\n\n  test('should recycle on idle limit breach', async () => {\n    await closeWorkerAfter(\n      new workerClass({\n        childWorkerPath: workerPath,\n        // There is no way this is fitting into 1000 bytes, so it should restart\n        // after requesting a memory usage update\n        idleMemoryLimit: 1000,\n        maxRetries: 0,\n        workerPath: join(__dirname, '__fixtures__', 'EdgeCasesWorker'),\n      } as WorkerOptions),\n      async (worker: ChildProcessWorker | ThreadsWorker) => {\n        const startSystemId = worker.getWorkerSystemId();\n        expect(startSystemId).toBeGreaterThanOrEqual(0);\n\n        worker.checkMemoryUsage();\n\n        await waitForChange(() => worker.getWorkerSystemId());\n\n        const systemId = worker.getWorkerSystemId();\n        expect(systemId).toBeGreaterThanOrEqual(0);\n        expect(systemId).not.toEqual(startSystemId);\n\n        await new Promise(resolve => {\n          setTimeout(resolve, SIGKILL_DELAY + 100);\n        });\n\n        expect(worker.isWorkerRunning()).toBeTruthy();\n      },\n    );\n  });\n\n  describe('should automatically recycle on idle limit breach', () => {\n    let startPid: number;\n    let worker: ChildProcessWorker | ThreadsWorker;\n    const orderOfEvents: Array<WorkerStates> = [];\n\n    beforeAll(() => {\n      worker = new workerClass({\n        childWorkerPath: workerPath,\n        // There is no way this is fitting into 1000 bytes, so it should restart\n        // after requesting a memory usage update\n        idleMemoryLimit: 1000,\n        maxRetries: 0,\n        on: {\n          [WorkerEvents.STATE_CHANGE]: (state: WorkerStates) => {\n            orderOfEvents.push(state);\n          },\n        },\n        silent: true,\n        workerPath: join(__dirname, '__fixtures__', 'EdgeCasesWorker'),\n      } as unknown as WorkerOptions);\n    });\n\n    afterAll(async () => {\n      if (worker) {\n        worker.forceExit();\n        await worker.waitForExit();\n      }\n    });\n\n    test('initial state', async () => {\n      startPid = worker.getWorkerSystemId();\n      expect(startPid).toBeGreaterThanOrEqual(0);\n      expect(worker.state).toEqual(WorkerStates.OK);\n\n      expect(orderOfEvents).toEqual(['ok']);\n    });\n\n    test('new worker starts', async () => {\n      const onStart = jest.fn();\n      const onEnd = jest.fn();\n      const onCustom = jest.fn();\n\n      worker.send(\n        [CHILD_MESSAGE_CALL, true, 'safeFunction', []],\n        onStart,\n        onEnd,\n        onCustom,\n      );\n\n      await waitForChange(() => worker.getWorkerSystemId());\n\n      const endPid = worker.getWorkerSystemId();\n      expect(endPid).toBeGreaterThanOrEqual(0);\n      expect(endPid).not.toEqual(startPid);\n      expect(worker.isWorkerRunning()).toBeTruthy();\n      expect(worker.state).toEqual(WorkerStates.OK);\n    });\n\n    test(\n      'worker continues to run after kill delay',\n      async () => {\n        await new Promise(resolve => {\n          setTimeout(resolve, SIGKILL_DELAY + 100);\n        });\n\n        expect(worker.state).toEqual(WorkerStates.OK);\n        expect(worker.isWorkerRunning()).toBeTruthy();\n      },\n      SIGKILL_DELAY * 3,\n    );\n\n    test('expected state order', () => {\n      expect(orderOfEvents).toEqual(['ok', 'restarting', 'starting', 'ok']);\n    });\n  });\n\n  describe('should cleanly exit on out of memory crash', () => {\n    const workerHeapLimit = 50;\n\n    let worker: ChildProcessWorker | ThreadsWorker;\n    let orderOfEvents: Array<WorkerStates> = [];\n\n    beforeAll(() => {\n      orderOfEvents = [];\n\n      const options = {\n        childWorkerPath: workerPath,\n        maxRetries: 0,\n        on: {\n          [WorkerEvents.STATE_CHANGE]: (state: WorkerStates) => {\n            orderOfEvents.push(state);\n          },\n        },\n        silent: true,\n        workerPath: join(__dirname, '__fixtures__', 'EdgeCasesWorker'),\n      } as unknown as WorkerOptions;\n\n      if (workerClass === ThreadsWorker) {\n        options.resourceLimits = {\n          codeRangeSizeMb: workerHeapLimit * 2,\n          maxOldGenerationSizeMb: workerHeapLimit,\n          maxYoungGenerationSizeMb: workerHeapLimit * 2,\n          stackSizeMb: workerHeapLimit * 2,\n        };\n      } else if (workerClass === ChildProcessWorker) {\n        options.forkOptions = {\n          // Forcibly set the heap limit so we can crash the process easily.\n          execArgv: [`--max-old-space-size=${workerHeapLimit}`],\n        };\n      }\n\n      worker = new workerClass(options);\n    });\n\n    afterAll(async () => {\n      await new Promise<void>(resolve => {\n        setTimeout(async () => {\n          if (worker) {\n            worker.forceExit();\n            await worker.waitForExit();\n          }\n\n          resolve();\n        }, 500);\n      });\n    });\n\n    test('starting state', async () => {\n      const startPid = worker.getWorkerSystemId();\n      expect(startPid).toBeGreaterThanOrEqual(0);\n    });\n\n    test('worker ready', async () => {\n      await worker.waitForWorkerReady();\n      expect(worker.state).toEqual(WorkerStates.OK);\n    });\n\n    test('worker crashes and exits', async () => {\n      const onStart = jest.fn();\n      const onEnd = jest.fn();\n      const onCustom = jest.fn();\n\n      worker.send(\n        [CHILD_MESSAGE_CALL, true, 'leakMemory', []],\n        onStart,\n        onEnd,\n        onCustom,\n      );\n\n      await worker.waitForExit();\n\n      expect(worker.state).not.toEqual(WorkerStates.OK);\n    });\n\n    test('worker stays dead', async () => {\n      await expect(async () => worker.waitForWorkerReady()).rejects.toThrow(\n        'Worker state means it will never be ready: shut-down',\n      );\n      expect(worker.isWorkerRunning()).toBeFalsy();\n    });\n\n    test('expected state order', () => {\n      expect(orderOfEvents).toEqual([\n        WorkerStates.OK,\n        WorkerStates.OUT_OF_MEMORY,\n        WorkerStates.SHUT_DOWN,\n      ]);\n    });\n  });\n\n  describe('should handle regular fatal crashes', () => {\n    let worker: ChildProcessWorker | ThreadsWorker;\n    let startedWorkers = 0;\n\n    beforeAll(() => {\n      worker = new workerClass({\n        childWorkerPath: workerPath,\n        maxRetries: 4,\n        on: {\n          [WorkerEvents.STATE_CHANGE]: (state: WorkerStates) => {\n            if (state === WorkerStates.OK) {\n              startedWorkers++;\n            }\n          },\n        },\n        workerPath: join(__dirname, '__fixtures__', 'EdgeCasesWorker'),\n      } as unknown as WorkerOptions);\n    });\n\n    afterAll(async () => {\n      if (worker) {\n        worker.forceExit();\n        await worker.waitForExit();\n      }\n    });\n\n    test('starting state', async () => {\n      const startPid = worker.getWorkerSystemId();\n      expect(startPid).toBeGreaterThanOrEqual(0);\n    });\n\n    test('processes restart', async () => {\n      const onStart = jest.fn();\n      const onEnd = jest.fn();\n      const onCustom = jest.fn();\n\n      worker.send(\n        [CHILD_MESSAGE_CALL, true, 'fatalExitCode', []],\n        onStart,\n        onEnd,\n        onCustom,\n      );\n\n      // Give it some time to restart some workers\n      await new Promise(resolve => setTimeout(resolve, 4000));\n\n      expect(startedWorkers).toBe(6);\n\n      expect(worker.isWorkerRunning()).toBeTruthy();\n      expect(worker.state).toEqual(WorkerStates.OK);\n    });\n\n    test('processes exits', async () => {\n      worker.forceExit();\n\n      await expect(() => worker.waitForWorkerReady()).rejects.toThrow(\n        'Worker state means it will never be ready: shutting-down',\n      );\n    });\n  });\n\n  describe('should not hang when worker is killed or unexpectedly terminated', () => {\n    let worker: ChildProcessWorker | ThreadsWorker;\n\n    beforeEach(() => {\n      const options = {\n        childWorkerPath: processChildWorkerPath,\n        maxRetries: 0,\n        silent: true,\n        workerPath: join(__dirname, '__fixtures__', 'SelfKillWorker'),\n      } as unknown as WorkerOptions;\n\n      worker = new ChildProcessWorker(options);\n    });\n\n    afterEach(async () => {\n      await new Promise<void>(resolve => {\n        setTimeout(async () => {\n          if (worker) {\n            worker.forceExit();\n            await worker.waitForExit();\n          }\n\n          resolve();\n        }, 500);\n      });\n    });\n\n    // Regression test for https://github.com/jestjs/jest/issues/13183\n    test('onEnd callback is called', async () => {\n      let onEndPromiseResolve: () => void;\n      let onEndPromiseReject: (err: Error) => void;\n      const onEndPromise = new Promise<void>((resolve, reject) => {\n        onEndPromiseResolve = resolve;\n        onEndPromiseReject = reject;\n      });\n\n      const onStart = jest.fn();\n      const onEnd = jest.fn((err: Error | null) => {\n        if (err) {\n          return onEndPromiseReject(err);\n        }\n        onEndPromiseResolve();\n      });\n      const onCustom = jest.fn();\n\n      await worker.waitForWorkerReady();\n\n      // The SelfKillWorker simulates an external process calling SIGTERM on it,\n      // but just SIGTERMs itself underneath the hood to make this test easier.\n      worker.send(\n        [CHILD_MESSAGE_CALL, true, 'selfKill', []],\n        onStart,\n        onEnd,\n        onCustom,\n      );\n\n      // The onEnd callback should be called when the child process exits.\n      await expect(onEndPromise).rejects.toBeInstanceOf(Error);\n      expect(onEnd).toHaveBeenCalled();\n    });\n  });\n});"}
{"prompt":"assuming -1 because of package.json, but +1 because of the individual test file","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {tmpdir} from 'os';\nimport {resolve} from 'path';\nimport findProcess = require('find-process');\nimport {\n  cleanup,\n  generateTestFilesToForceUsingWorkers,\n  writeFiles,\n} from '../Utils';\nimport runJest from '../runJest';\n\njest.retryTimes(3);\n\nconst DIR = resolve(tmpdir(), 'worker-force-exit');\n\nbeforeEach(() => cleanup(DIR));\nafterEach(() => cleanup(DIR));\nconst testFiles = {\n  ...generateTestFilesToForceUsingWorkers(),\n  'package.json': `{\n      \"testEnvironment\": \"node\"\n  }`,\n};\n\nconst verifyNumPassed = (stderr: string) => {\n  const numberOfTestsPassed = (stderr.match(/\\bPASS\\b/g) || []).length;\n  // assuming -1 because of package.json, but +1 because of the individual test file\n  expect(numberOfTestsPassed).toBe(Object.keys(testFiles).length);\n};\n\ntest('prints a warning if a worker is force exited', () => {\n  writeFiles(DIR, {\n    ...testFiles,\n    '__tests__/simple.test.js': `\n      test('t', () => {\n        require('http').createServer().listen(0);\n      });\n    `,\n  });\n  const {exitCode, stderr} = runJest(DIR, ['--maxWorkers=2']);\n\n  expect(exitCode).toBe(0);\n  verifyNumPassed(stderr);\n  expect(stderr).toContain('A worker process has failed to exit gracefully');\n});\n\ntest('force exits a worker that fails to exit gracefully', async () => {\n  writeFiles(DIR, {\n    ...testFiles,\n    '__tests__/timeoutKilled.test.js': `\n      test('t', () => {\n        require('http').createServer().listen(0);\n        console.error('pid: ' + process.pid);\n      });\n    `,\n  });\n  const {exitCode, stderr} = runJest(DIR, ['--maxWorkers=2']);\n\n  expect(exitCode).toBe(0);\n  verifyNumPassed(stderr);\n\n  const execRes = /pid: (\\d+)/.exec(stderr);\n\n  expect(execRes).toHaveLength(2);\n\n  const [, pid] = execRes!;\n\n  const pidNumber = Number(pid);\n\n  expect(pidNumber).not.toBeNaN();\n\n  expect(await findProcess('pid', pidNumber)).toHaveLength(0);\n}, 15_000);"}
{"prompt":"WorkerPool,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport WorkerPool from '../WorkerPool';\nimport type {ChildMessage, WorkerPoolOptions} from '../types';\nimport ChildProcessWorker from '../workers/ChildProcessWorker';\nimport NodeThreadWorker from '../workers/NodeThreadsWorker';\n\njest.mock('../workers/ChildProcessWorker', () => {\n  const fakeClass = jest.fn(() => ({\n    getStderr: jest.fn(),\n    getStdout: jest.fn(),\n    send: jest.fn(),\n  }));\n\n  return {\n    __esModule: true,\n    default: fakeClass,\n  };\n});\n\njest.mock('../workers/NodeThreadsWorker', () => {\n  const fakeClass = jest.fn(() => ({\n    getStderr: jest.fn(),\n    getStdout: jest.fn(),\n    send: jest.fn(),\n  }));\n\n  return {\n    __esModule: true,\n    default: fakeClass,\n  };\n});\n\ndescribe('WorkerPool', () => {\n  beforeEach(() => {\n    jest.mocked(ChildProcessWorker).mockClear();\n    jest.mocked(NodeThreadWorker).mockClear();\n  });\n\n  it('should create a ChildProcessWorker and send to it', () => {\n    jest.mock('worker_threads', () => {\n      throw new Error('Undefined');\n    });\n    const workerPool = new WorkerPool('/path', {\n      forkOptions: {},\n      maxRetries: 1,\n      numWorkers: 1,\n    } as WorkerPoolOptions);\n\n    const request = {foo: 'bar'} as unknown as ChildMessage;\n    const onStart = () => {};\n    const onEnd = () => {};\n    const onCustomMessage = () => {};\n\n    workerPool.send(0, request, onStart, onEnd, onCustomMessage);\n\n    expect(ChildProcessWorker).toHaveBeenCalledWith({\n      forkOptions: {},\n      maxRetries: 1,\n      workerId: 0,\n      workerPath: '/path',\n    });\n    expect(NodeThreadWorker).not.toHaveBeenCalled();\n    // @ts-expect-error: Testing internal method\n    expect(workerPool._workers[0].send).toHaveBeenCalledWith(\n      request,\n      onStart,\n      onEnd,\n      onCustomMessage,\n    );\n  });\n\n  it('should create a NodeThreadWorker and send to it', () => {\n    jest.mock('worker_threads', () => 'Defined');\n    const workerPool = new WorkerPool('/path', {\n      enableWorkerThreads: true,\n      forkOptions: {},\n      maxRetries: 1,\n      numWorkers: 1,\n    } as WorkerPoolOptions);\n\n    const request = {foo: 'bar'} as unknown as ChildMessage;\n    const onStart = () => {};\n    const onEnd = () => {};\n    const onCustomMessage = () => {};\n\n    workerPool.send(0, request, onStart, onEnd, onCustomMessage);\n\n    expect(NodeThreadWorker).toHaveBeenCalledWith({\n      forkOptions: {},\n      maxRetries: 1,\n      workerId: 0,\n      workerPath: '/path',\n    });\n    expect(ChildProcessWorker).not.toHaveBeenCalled();\n    // @ts-expect-error: Testing internal method\n    expect(workerPool._workers[0].send).toHaveBeenCalledWith(\n      request,\n      onStart,\n      onEnd,\n      onCustomMessage,\n    );\n  });\n\n  it('should avoid NodeThreadWorker if not passed enableWorkerThreads', () => {\n    jest.mock('worker_threads', () => 'Defined');\n    const workerPool = new WorkerPool('/path', {\n      forkOptions: {},\n      maxRetries: 1,\n      numWorkers: 1,\n    } as WorkerPoolOptions);\n\n    const request = {foo: 'bar'} as unknown as ChildMessage;\n    const onStart = () => {};\n    const onEnd = () => {};\n    const onCustomMessage = () => {};\n\n    workerPool.send(0, request, onStart, onEnd, onCustomMessage);\n\n    expect(ChildProcessWorker).toHaveBeenCalledWith({\n      forkOptions: {},\n      maxRetries: 1,\n      workerId: 0,\n      workerPath: '/path',\n    });\n    expect(NodeThreadWorker).not.toHaveBeenCalled();\n    // @ts-expect-error: Testing internal method\n    expect(workerPool._workers[0].send).toHaveBeenCalledWith(\n      request,\n      onStart,\n      onEnd,\n      onCustomMessage,\n    );\n  });\n});"}
{"prompt":"all 3 test files should complete,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nit('all 3 test files should complete', () => {\n  const result = runJest('worker-restart-before-send');\n  const {summary} = extractSummary(result.stderr);\n  expect(summary).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`all 3 test files should complete 1`] = `\n\"Test Suites: 1 failed, 2 passed, 3 total\nTests:       2 passed, 2 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"all 3 test files should complete,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nit('all 3 test files should complete', () => {\n  const result = runJest('worker-restarting');\n  expect(result.exitCode).toBe(0);\n  const {summary} = extractSummary(result.stderr);\n  expect(summary).toMatchSnapshot();\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`all 3 test files should complete 1`] = `\n\"Test Suites: 3 passed, 3 total\nTests:       3 passed, 3 total\nSnapshots:   0 total\nTime:        <<REPLACED>>\nRan all test suites.\"\n`;"}
{"prompt":"snapshot,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n'use strict';\n\ndescribe('snapshot', () => {\n  it('some snapshots exists and are fine', () => {\n    expect('normal').toMatchSnapshot();\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`snapshot some snapshots exists and are fine 1`] = `\"normal\"`;"}
{"prompt":"block with concurrent,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('block with concurrent', () => {\n  it('test should fail', () => {\n    expect(10).toBe(101);\n  });\n\n  it.concurrent.failing('.failing() should fail', () => {\n    expect(10).toBe(10);\n  });\n\n  it.concurrent.failing('.failing() should pass', () => {\n    expect(10).toBe(101);\n  });\n\n  test.concurrent.failing.each([\n    {a: 1, b: 1, expected: 2},\n    {a: 1, b: 2, expected: 3},\n    {a: 2, b: 1, expected: 3},\n  ])('.add($a, $b) .failing.each() should fail', ({a, b, expected}) => {\n    expect(a + b).toBe(expected);\n  });\n\n  test.concurrent.failing.each([\n    {a: 1, b: 1, expected: 2},\n    {a: 1, b: 2, expected: 3},\n    {a: 2, b: 1, expected: 3},\n  ])('.add($a, $b) .failing.each() should pass', ({a, b, expected}) => {\n    expect(a + b).toBe(expected + 10);\n  });\n\n  it.concurrent.skip.failing('skipped failing fails', () => {\n    expect(10).toBe(101);\n  });\n});"}
{"prompt":"block with concurrent,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('block with concurrent', () => {\n  it('skipped failing test', () => {\n    expect(10).toBe(101);\n  });\n\n  it.concurrent.only.failing('.only.failing() should fail', () => {\n    expect(10).toBe(10);\n  });\n\n  it.concurrent.only.failing('.only.failing() should pass', () => {\n    expect(10).toBe(101);\n  });\n\n  test.concurrent.only.failing.each([\n    {a: 1, b: 1, expected: 2},\n    {a: 1, b: 2, expected: 3},\n    {a: 2, b: 1, expected: 3},\n  ])('.add($a, $b) .only.failing.each() should fail', ({a, b, expected}) => {\n    expect(a + b).toBe(expected);\n  });\n\n  test.concurrent.only.failing.each([\n    {a: 1, b: 1, expected: 2},\n    {a: 1, b: 2, expected: 3},\n    {a: 2, b: 1, expected: 3},\n  ])('.add($a, $b) .only.failing.each() should pass', ({a, b, expected}) => {\n    expect(a + b).toBe(expected + 10);\n  });\n\n  test.concurrent.failing.each([\n    {a: 1, b: 1, expected: 2},\n    {a: 1, b: 2, expected: 3},\n    {a: 2, b: 1, expected: 3},\n  ])('.add($a, $b) skipped each', ({a, b, expected}) => {\n    expect(a + b).toBe(expected + 10);\n  });\n\n  it.concurrent.failing('skipped failing fails', () => {\n    expect(10).toBe(101);\n  });\n});"}
{"prompt":"block with only, should pass,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/* eslint-disable jest/no-focused-tests */\n\ndescribe('block with only, should pass', () => {\n  it.only.failing('failing fails = passes, should pass', () => {\n    expect(10).toBe(101);\n  });\n\n  it.only.failing.each([\n    {a: 1, b: 1, expected: 2},\n    {a: 1, b: 2, expected: 3},\n    {a: 2, b: 1, expected: 3},\n  ])('.add($a, $b)', ({a, b, expected}) => {\n    expect(a + b).toBe(expected);\n  });\n\n  it('failing test but skipped', () => {\n    expect(10).toBe(101);\n  });\n\n  it('passing test but skipped', () => {\n    expect(10).toBe(10);\n  });\n});\n\ndescribe('block with only, should fail', () => {\n  it.only.failing('failing passes = fails, should fail', () => {\n    expect(10).toBe(10);\n  });\n\n  it('failing test but skipped', () => {\n    expect(10).toBe(101);\n  });\n\n  it('passing test but skipped', () => {\n    expect(10).toBe(10);\n  });\n});\n\ndescribe('block with only in other it, should skip', () => {\n  it.failing('failing passes = fails, should fail but skipped', () => {\n    expect(10).toBe(10);\n  });\n\n  it.only('failing test', () => {\n    expect(10).toBe(101);\n  });\n\n  it('passing test but skipped', () => {\n    expect(10).toBe(10);\n  });\n});\n\ndescribe('block with only with different syntax, should fail', () => {\n  fit.failing('failing passes = fails, should fail 1', () => {\n    expect(10).toBe(10);\n  });\n\n  test.only.failing('failing passes = fails, should fail 2', () => {\n    expect(10).toBe(10);\n  });\n\n  it('failing test but skipped', () => {\n    expect(10).toBe(101);\n  });\n\n  it('passing test but skipped', () => {\n    expect(10).toBe(10);\n  });\n});"}
{"prompt":"block with only, should pass,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ndescribe('block with only, should pass', () => {\n  it.skip.failing('skipped failing fails = passes, should pass', () => {\n    expect(10).toBe(101);\n  });\n\n  it.skip.failing.each([\n    {a: 1, b: 1, expected: 2},\n    {a: 1, b: 2, expected: 3},\n    {a: 2, b: 1, expected: 3},\n  ])('.add($a, $b)', ({a, b, expected}) => {\n    expect(a + b).toBe(expected);\n  });\n\n  it('failing test', () => {\n    expect(10).toBe(101);\n  });\n\n  it.skip('passing test', () => {\n    expect(10).toBe(10);\n  });\n\n  it.failing('failing fails = passes', () => {\n    expect(10).toBe(101);\n  });\n});\n\ndescribe('block with only, should fail', () => {\n  it.skip.failing('failing passes = fails, should fail', () => {\n    expect(10).toBe(10);\n  });\n\n  it.skip('failing test', () => {\n    expect(10).toBe(101);\n  });\n\n  it('passing test', () => {\n    expect(10).toBe(10);\n  });\n\n  it.failing('failing passes = fails', () => {\n    expect(10).toBe(101);\n  });\n});"}
{"prompt":"Wrong globals for environment,  => {","test":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {onNodeVersions} from '@jest/test-utils';\nimport {extractSummary} from '../Utils';\nimport runJest from '../runJest';\n\nfunction assertFailuresAndSnapshot(args: Array<string>) {\n  const result = runJest('wrong-env', args);\n  expect(result.exitCode).toBe(1);\n  expect(extractSummary(result.stderr).rest).toMatchSnapshot();\n}\n\ndescribe('Wrong globals for environment', () => {\n  it('print useful error for window', () => {\n    assertFailuresAndSnapshot(['node', '-t=window']);\n  });\n\n  it('print useful error for document', () => {\n    assertFailuresAndSnapshot(['node', '-t=document']);\n  });\n\n  // Node.js 18 is the last LTS version, which is missing the global 'navigator'\n  onNodeVersions('<=18', () => {\n    it('print useful error for navigator', () => {\n      assertFailuresAndSnapshot(['node', '-t=navigator']);\n    });\n  });\n\n  it('print useful error for unref', () => {\n    assertFailuresAndSnapshot(['jsdom', '-t=unref']);\n  });\n\n  it('print useful error when it explodes during evaluation', () => {\n    assertFailuresAndSnapshot(['beforeTest']);\n  });\n});"}
{"prompt":"Jest Snapshot v1, https://goo.gl/fbAQLP","test":"// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`Wrong globals for environment on node <=18 print useful error for navigator 1`] = `\n\"FAIL __tests__/node.js\n  ✕ use navigator\n  ○ skipped use document\n  ○ skipped use window\n\n  ● use navigator\n\n    The error below may be caused by using the wrong test environment, see https://jestjs.io/docs/configuration#testenvironment-string.\n    Consider using the \"jsdom\" test environment.\n\n    ReferenceError: navigator is not defined\n\n      31 |\n      32 | test('use navigator', () => {\n    > 33 |   const userAgent = navigator.userAgent;\n         |                     ^\n      34 |\n      35 |   console.log(userAgent);\n      36 |\n\n      at Object.navigator (__tests__/node.js:33:21)\"\n`;\n\nexports[`Wrong globals for environment print useful error for document 1`] = `\n\"FAIL __tests__/node.js\n  ✕ use document\n  ○ skipped use window\n  ○ skipped use navigator\n\n  ● use document\n\n    The error below may be caused by using the wrong test environment, see https://jestjs.io/docs/configuration#testenvironment-string.\n    Consider using the \"jsdom\" test environment.\n\n    ReferenceError: document is not defined\n\n      14 |\n      15 | test('use document', () => {\n    > 16 |   const div = document.createElement('div');\n         |               ^\n      17 |\n      18 |   console.log(div);\n      19 |\n\n      at Object.document (__tests__/node.js:16:15)\"\n`;\n\nexports[`Wrong globals for environment print useful error for unref 1`] = `\n\"FAIL __tests__/jsdom.js\n  ✕ use unref\n\n  ● use unref\n\n    The error below may be caused by using the wrong test environment, see https://jestjs.io/docs/configuration#testenvironment-string.\n    Consider using the \"node\" test environment.\n\n    TypeError: setTimeout(...).unref is not a function\n\n      11 |\n      12 | test('use unref', () => {\n    > 13 |   setTimeout(() => {}, 0).unref();\n         |                           ^\n      14 |\n      15 |   expect(1).toBe(1);\n      16 | });\n\n      at Object.unref (__tests__/jsdom.js:13:27)\"\n`;\n\nexports[`Wrong globals for environment print useful error for window 1`] = `\n\"FAIL __tests__/node.js\n  ✕ use window\n  ○ skipped use document\n  ○ skipped use navigator\n\n  ● use window\n\n    The error below may be caused by using the wrong test environment, see https://jestjs.io/docs/configuration#testenvironment-string.\n    Consider using the \"jsdom\" test environment.\n\n    ReferenceError: window is not defined\n\n      23 | test('use window', () => {\n      24 |   // eslint-disable-next-line unicorn/prefer-global-this\n    > 25 |   const location = window.location;\n         |                    ^\n      26 |\n      27 |   console.log(location);\n      28 |\n\n      at Object.window (__tests__/node.js:25:20)\"\n`;\n\nexports[`Wrong globals for environment print useful error when it explodes during evaluation 1`] = `\n\"FAIL __tests__/beforeTest.js\n  ● Test suite failed to run\n\n    The error below may be caused by using the wrong test environment, see https://jestjs.io/docs/configuration#testenvironment-string.\n    Consider using the \"jsdom\" test environment.\n\n    ReferenceError: document is not defined\n\n      11 | /* global document */\n      12 |\n    > 13 | const div = document.createElement('div');\n         |             ^\n      14 |\n      15 | console.log(div);\n      16 |\n\n      at Object.document (__tests__/beforeTest.js:13:13)\"\n`;"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nglobal.required = global.required || [];\nglobal.required.push('a.js');"}
{"prompt":"Test generated from existing file","test":"export function add(a, b) {\n  return a + b;\n}"}
{"prompt":"Test generated from existing file","test":"export function add(a, b) {\n  return a + b;\n}"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\ndescribe('spec 1', function () {\n  afterEach(function (done) {\n    console.log('after');\n    process.nextTick(function () {\n      throw new Error('after each hook error');\n    });\n  });\n  it('should be called because error is in after each hook', function () {\n    console.log('test 1');\n  });\n  it('should not be called', function () {\n    console.log('test 2');\n  });\n});\ndescribe('spec 2', function () {\n  it('should be called, because hook error was in a sibling suite', function () {\n    console.log('test 3');\n  });\n});"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\ndescribe('spec 1', function () {\n  afterEach(function () {\n    console.log('after');\n    throw new Error('after each hook error');\n  });\n  it('should be called because error is in after each hook', function () {\n    console.log('test 1');\n  });\n  it('should not be called', function () {\n    console.log('test 2');\n  });\n});\ndescribe('spec 2', function () {\n  it('should be called, because hook error was in a sibling suite', function () {\n    console.log('test 3');\n  });\n});"}
{"prompt":"fail the test from the after each hook, function {","test":"describe('fail the test from the \"after each\" hook', function() {\n  it('should fail', function() {\n    // but not here\n  });\n\n  afterEach(function() {\n    this.test.error(new Error('failing from after each'));\n  });\n});"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\ndescribe('spec 1', function () {\n  after(function (done) {\n    console.log('after');\n    process.nextTick(function () {\n      throw new Error('after hook error');\n    });\n  });\n  it('should be called because error is in after hook', function () {\n    console.log('test 1');\n  });\n  it('should be called because error is in after hook', function () {\n    console.log('test 2');\n  });\n});\ndescribe('spec 2', function () {\n  it('should be called, because hook error was in a sibling suite', function () {\n    console.log('test 3');\n  });\n});"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\ndescribe('spec 1', function () {\n  it('should pass', function () { });\n  describe('spec 2 nested - this title should be used', function () {\n    after(function() {\n      throw new Error('after hook nested error');\n    });\n    describe('spec 3 nested', function () {\n        it('it nested - this title should not be used', function () { });\n    });\n  });\n});"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\ndescribe('spec 1', function () {\n  after(function () {\n    console.log('after');\n    throw new Error('after hook error');\n  });\n  it('should be called because error is in after hook', function () {\n    console.log('test 1');\n  });\n  it('should be called because error is in after hook', function () {\n    console.log('test 2');\n  });\n});\ndescribe('spec 2', function () {\n  it('should be called, because hook error was in a sibling suite', function () {\n    console.log('test 3');\n  });\n});"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\ndescribe('spec 1', function () {\n  it('should pass', function () { });\n  describe('spec nested', function () {\n    after(function() {\n      throw new Error('after hook nested error');\n    });\n    it('it nested - this title should be used', function () { });\n  });\n  describe('spec 2 nested', function () {\n    it('it nested - not this title', function () { });\n  });\n});"}
{"prompt":"Uncaught exception after runners end,  => {","test":"'use strict';\n\ndescribe(\"Uncaught exception after runner's end\", () => {\n  it('test', () => {\n    setTimeout(() => {\n      throw new Error('Unexpected crash');\n    }, 100);\n  });\n});"}
{"prompt":"--allow-uncaught, function  {","test":"'use strict';\n\nvar path = require('node:path').posix;\nvar helpers = require('../helpers');\nvar runMocha = helpers.runMocha;\nvar runMochaJSON = helpers.runMochaJSON;\n\ndescribe('--allow-uncaught', function () {\n  var args = ['--allow-uncaught'];\n\n  it('should throw an uncaught error and exit process', function (done) {\n    var fixture = path.join('options', 'allow-uncaught', 'propagate');\n    runMocha(\n      fixture,\n      args,\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n\n        expect(res.code, 'to be greater than', 0);\n        expect(res.output, 'to contain', 'Error: Uncaught error after test1');\n        expect(res.passing, 'to be', 0);\n        expect(res.failing, 'to be', 0);\n        done();\n      },\n      {stdio: 'pipe'}\n    );\n  });\n\n  it('should run with conditional `this.skip()`', function (done) {\n    var fixture = path.join('options', 'allow-uncaught', 'this-skip-it');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have passed')\n        .and('to have passed test count', 2)\n        .and('to have pending test count', 3)\n        .and('to have passed test', 'test1', 'test4')\n        .and('to have pending test order', 'test2', 'test3', 'test5');\n      done();\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nconst {version} = require('../package.json');\nconst escapeRe = require('escape-string-regexp');\n\nmodule.exports = {\n  name: 'unexpected-mocha-internal',\n  version,\n  installInto(expect) {\n    expect\n      .addType({\n        name: 'RawResult',\n        base: 'object',\n        identify(v) {\n          return (\n            this.baseType.identify(v) &&\n            typeof v.output === 'string' &&\n            'code' in v && // may be null\n            Array.isArray(v.args) &&\n            typeof v.command === 'string'\n          );\n        }\n      })\n      .addType({\n        name: 'JSONResult',\n        base: 'RawResult',\n        identify(v) {\n          return (\n            this.baseType.identify(v) &&\n            typeof v.stats === 'object' &&\n            Array.isArray(v.failures) &&\n            Array.isArray(v.passes) &&\n            Array.isArray(v.tests) &&\n            Array.isArray(v.pending)\n          );\n        }\n      })\n      .addType({\n        name: 'SummarizedResult',\n        base: 'RawResult',\n        identify(v) {\n          return (\n            this.baseType.identify(v) &&\n            typeof v.passing === 'number' &&\n            typeof v.failing === 'number' &&\n            typeof v.pending === 'number'\n          );\n        }\n      })\n      .addAssertion(\n        '<JSONResult> [not] to have (passed|succeeded)',\n        (expect, result) => {\n          expect(result, 'to satisfy', {\n            code: expect.it('[not] to be', 0),\n            stats: {\n              failures: expect.it('[not] to be', 0)\n            },\n            failures: expect.it('[not] to be empty')\n          });\n        }\n      )\n      .addAssertion(\n        '<SummarizedResult|RawResult> [not] to have (passed|succeeded)',\n        (expect, result) => {\n          expect(result, '[not] to have property', 'code', 0);\n        }\n      )\n      .addAssertion(\n        '<SummarizedResult|JSONResult> [not] to have completed with [exit] code <number>',\n        (expect, result, code) => {\n          expect(result.code, '[not] to be', code);\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have passed (with|having) count <number>',\n        (expect, result, count) => {\n          expect(result, '[not] to pass').and('[not] to satisfy', {\n            stats: {passes: expect.it('to be', count)}\n          });\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have failed (with|having) count <number>',\n        (expect, result, count) => {\n          expect(result, '[not] to have failed').and('[not] to satisfy', {\n            stats: {failures: expect.it('to be', count)}\n          });\n        }\n      )\n      .addAssertion('<JSONResult> [not] to have failed', (expect, result) => {\n        expect(result, '[not] to satisfy', {\n          code: expect.it('to be greater than', 0),\n          stats: {\n            failures: expect.it('to be greater than', 0)\n          },\n          failures: expect.it('to be non-empty')\n        });\n      })\n      .addAssertion(\n        '<SummarizedResult|RawResult> [not] to have failed',\n        (expect, result) => {\n          expect(result, '[not] to satisfy', {\n            code: expect.it('to be greater than', 0)\n          });\n        }\n      )\n      .addAssertion(\n        '<SummarizedResult|RawResult> [not] to have failed (with|having) output <any>',\n        (expect, result, output) => {\n          expect(result, '[not] to satisfy', {\n            code: expect.it('to be greater than', 0),\n            output\n          });\n        }\n      )\n      .addAssertion(\n        '<SummarizedResult|RawResult> [not] to have passed (with|having) output <any>',\n        (expect, result, output) => {\n          expect(result, '[not] to satisfy', {\n            code: 0,\n            output\n          });\n        }\n      )\n      .addAssertion(\n        '<SummarizedResult> [not] to have failed [test] count <number>',\n        (expect, result, count) => {\n          expect(result.failing, '[not] to be', count);\n        }\n      )\n      .addAssertion(\n        '<SummarizedResult> [not] to have passed [test] count <number>',\n        (expect, result, count) => {\n          expect(result.passing, '[not] to be', count);\n        }\n      )\n      .addAssertion(\n        '<SummarizedResult> [not] to have pending [test] count <number>',\n        (expect, result, count) => {\n          expect(result.pending, '[not] to be', count);\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have test count <number>',\n        (expect, result, count) => {\n          expect(result.stats.tests, '[not] to be', count);\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have failed [test] count <number>',\n        (expect, result, count) => {\n          expect(result.stats.failures, '[not] to be', count);\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have passed [test] count <number>',\n        (expect, result, count) => {\n          expect(result.stats.passes, '[not] to be', count);\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have pending [test] count <number>',\n        (expect, result, count) => {\n          expect(result.stats.pending, '[not] to be', count);\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have run (test|tests) <string+>',\n        (expect, result, ...titles) => {\n          titles.forEach(title => {\n            expect(\n              result,\n              '[not] to have a value satisfying',\n              expect.it(\n                'to have an item satisfying',\n                expect\n                  .it('to have property', 'title', title)\n                  .or('to have property', 'fullTitle', title)\n              )\n            );\n          });\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have failed (test|tests) <string+>',\n        (expect, result, ...titles) => {\n          titles.forEach(title => {\n            expect(\n              result.failures,\n              '[not] to have an item satisfying',\n              expect\n                .it('to have property', 'title', title)\n                .or('to have property', 'fullTitle', title)\n            );\n          });\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have (error|errors) <any+>',\n        (expect, result, ...errors) => {\n          errors.forEach(error => {\n            expect(result, '[not] to satisfy', {\n              failures: expect.it('to have an item satisfying', {\n                err: expect\n                  .it('to satisfy', error)\n                  .or('to satisfy', {message: error})\n              })\n            });\n          });\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have passed (test|tests) <string+>',\n        (expect, result, ...titles) => {\n          titles.forEach(title => {\n            expect(result.passes, '[not] to have an item satisfying', {\n              title\n            });\n          });\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have test order <string> <array>',\n        (expect, result, state, titles) => {\n          expect(\n            result[state].slice(0, titles.length),\n            '[not] to satisfy',\n            titles.map(title => {\n              return typeof title === 'string' ? {title} : title;\n            })\n          );\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have passed test order <array>',\n        (expect, result, titles) => {\n          expect(result, '[not] to have test order', 'passes', titles);\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have passed test order <string+>',\n        (expect, result, ...titles) => {\n          expect(result, '[not] to have test order', 'passes', titles);\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have failed test order <array>',\n        (expect, result, titles) => {\n          expect(result, '[not] to have test order', 'failures', titles);\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have failed test order <string+>',\n        (expect, result, ...titles) => {\n          expect(result, '[not] to have test order', 'failures', titles);\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have pending test order <array>',\n        (expect, result, titles) => {\n          expect(result, '[not] to have test order', 'pending', titles);\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have pending test order <string+>',\n        (expect, result, ...titles) => {\n          expect(result, '[not] to have test order', 'pending', titles);\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have pending tests',\n        (expect, result) => {\n          expect(result.stats.pending, '[not] to be greater than', 0);\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have passed tests',\n        (expect, result) => {\n          expect(result.stats.passes, '[not] to be greater than', 0);\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have failed tests',\n        (expect, result) => {\n          expect(result.stats.failed, '[not] to be greater than', 0);\n        }\n      )\n      .addAssertion('<JSONResult> [not] to have tests', (expect, result) => {\n        expect(result.stats.tests, '[not] to be greater than', 0);\n      })\n      .addAssertion(\n        '<JSONResult> [not] to have retried test <string>',\n        (expect, result, title) => {\n          expect(result.tests, '[not] to have an item satisfying', {\n            title,\n            currentRetry: expect.it('to be positive')\n          });\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have retried test <string> <number>',\n        (expect, result, title, count) => {\n          expect(result.tests, '[not] to have an item satisfying', {\n            title,\n            currentRetry: count\n          });\n        }\n      )\n      .addAssertion(\n        '<JSONResult> [not] to have failed with (error|errors) <any+>',\n        function (expect, result, ...errors) {\n          errors.forEach(error => {\n            expect(result, '[not] to have failed').and('[not] to satisfy', {\n              failures: expect.it('to have an item satisfying', {\n                err: expect\n                  .it('to satisfy', error)\n                  .or('to satisfy', {message: error})\n              })\n            });\n          });\n        }\n      )\n      .addAssertion(\n        '<RawResult|SummarizedResult> [not] to contain [output] <any>',\n        (expect, result, output) => {\n          expect(result.output, '[not] to satisfy', output);\n        }\n      )\n      .addAssertion(\n        '<RawResult|SummarizedResult> to contain [output] once <any>',\n        (expect, result, output) => {\n          if (typeof output === 'string') {\n            output = escapeRe(output);\n          } else if (!(output instanceof RegExp)) {\n            throw new TypeError('expected a string or regexp');\n          }\n          output = new RegExp(output, 'g');\n          expect(result.output.match(output), 'to have length', 1);\n        }\n      )\n      .addAssertion(\n        '<RawResult|SummarizedResult|JSONResult> to have [exit] code <number>',\n        (expect, result, code) => {\n          expect(result.code, 'to be', code);\n        }\n      );\n  }\n};"}
{"prompt":"should pass, function done {","test":"'use strict';\n\nit('should pass', function (done) {\n  done();\n});"}
{"prompt":"throws an error, function  {};","test":"'use strict';\n\nit('throws an error', function () {});"}
{"prompt":"retries, function  {","test":"'use strict';\n\ndescribe('retries', function () {\n  var times = 0;\n  before(function () {\n    console.log('before');\n  });\n\n  after(function () {\n    console.log('after');\n  });\n\n  beforeEach(function () {\n    console.log('before each', times);\n  });\n\n  afterEach(function () {\n    console.log('after each', times);\n  });\n\n  it('should allow override and run appropriate hooks', function (done) {\n    this.timeout(100);\n    this.retries(2);\n    console.log('TEST', times);\n    if (++times < 3) {\n      return setTimeout(done, 300);\n    }\n    setTimeout(done, 50);\n  });\n});"}
{"prompt":"--async-only, function  {","test":"'use strict';\n\nvar path = require('node:path').posix;\nvar helpers = require('../helpers');\nvar runMochaJSON = helpers.runMochaJSON;\n\ndescribe('--async-only', function () {\n  var args = [];\n\n  before(function () {\n    args = ['--async-only'];\n  });\n\n  it('should fail synchronous specs', function (done) {\n    var fixture = path.join('options', 'async-only-sync');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have failed');\n      done();\n    });\n  });\n\n  it('should allow asynchronous specs', function (done) {\n    var fixture = path.join('options', 'async-only-async');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have passed');\n      done();\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"global.required ?= []\nglobal.required.push 'b.coffee'"}
{"prompt":"Test generated from existing file","test":"throw new Error('this module is wonky');"}
{"prompt":"Test generated from existing file","test":"require('fake');"}
{"prompt":"suite1, function  {","test":"'use strict';\n\ndescribe('suite1', function () {\n  it('should display this spec', function () {});\n\n  it('should only display this error', function (done) {\n    throw new Error('this should be displayed');\n  });\n\n  it('should not display this error', function (done) {\n    throw new Error('this should not be displayed');\n  });\n});\n\ndescribe('suite2', function () {\n  before(function (done) {\n    throw new Error('this hook should not be displayed');\n  });\n\n  it('should not display this error', function (done) {\n    throw new Error('this should not be displayed');\n  });\n});"}
{"prompt":"suite1, function  {","test":"'use strict';\nvar assert = require('assert');\n\ndescribe('suite1', function () {\n  var runOrder = [];\n  before('before suite1', function () {\n    runOrder.push('before suite1');\n  });\n  beforeEach('beforeEach suite1', function () {\n    runOrder.push('beforeEach suite1');\n  });\n  it('test suite1', function () {\n    runOrder.push('test suite1');\n  });\n\n  describe('suite1A', function () {\n    before('before suite1A', function () {\n      runOrder.push('before suite1A');\n    });\n    beforeEach('beforeEach suite1A', function () {\n      runOrder.push('beforeEach suite1A');\n    }); \n    it('test suite1A', function () {\n      runOrder.push('test suite1A');\n    });\n    afterEach('afterEach suite1A', function () {\n      runOrder.push('afterEach suite1A');\n    });\n    after('after suite1A', function () {\n      runOrder.push('after suite1A');\n      throw new Error('after suite1A error');\n    });\n  });\n\n  afterEach('afterEach suite1', function () {\n    runOrder.push('afterEach suite1');\n  });\n  after('after suite1', function () {\n    runOrder.push('after suite1');\n    assert.deepStrictEqual(runOrder, [\n      'before suite1', 'beforeEach suite1', 'test suite1',\n      'afterEach suite1', 'before suite1A', 'beforeEach suite1',\n      'beforeEach suite1A', 'test suite1A', 'afterEach suite1A',\n      'afterEach suite1', 'after suite1A', 'after suite1'\n    ]);\n  });\n});\n\ndescribe('suite2', function () {\n  before('before suite2', function () {});\n  beforeEach('beforeEach suite2', function () {});\n  it('test suite2', function () {\n    console.log('test suite2 - should not run');\n  });\n  afterEach('afterEach suite2', function () {});\n  after('after suite2', function () {});\n});"}
{"prompt":"suite1, function  {","test":"'use strict';\nvar assert = require('assert');\n\ndescribe('suite1', function () {\n  var runOrder = [];\n  before('before suite1', function () {\n    runOrder.push('before suite1');\n  });\n  beforeEach('beforeEach suite1', function () {\n    runOrder.push('beforeEach suite1');\n  });\n  it('test suite1', function () {\n    runOrder.push('test suite1');\n  });\n\n  describe('suite1A', function () {\n    before('before suite1A', function () {\n      runOrder.push('before suite1A');\n    });\n    beforeEach('beforeEach suite1A', function () {\n      runOrder.push('beforeEach suite1A');\n    }); \n    it('test suite1A', function () {\n      runOrder.push('test suite1A');\n    });\n    afterEach('afterEach suite1A', function () {\n      runOrder.push('afterEach suite1A');\n      throw new Error('afterEach suite1A error');\n    });\n    after('after suite1A', function () {\n      runOrder.push('after suite1A');\n    });\n  });\n\n  afterEach('afterEach suite1', function () {\n    runOrder.push('afterEach suite1');\n  });\n  after('after suite1', function () {\n    runOrder.push('after suite1');\n    assert.deepStrictEqual(runOrder, [\n      'before suite1', 'beforeEach suite1', 'test suite1',\n      'afterEach suite1', 'before suite1A', 'beforeEach suite1',\n      'beforeEach suite1A', 'test suite1A', 'afterEach suite1A',\n      'afterEach suite1', 'after suite1A', 'after suite1'\n    ]);\n  });\n});\n\ndescribe('suite2', function () {\n  before('before suite2', function () {});\n  beforeEach('beforeEach suite2', function () {});\n  it('test suite2', function () {\n    runOrder.push('test suite2 - should not run');\n  });\n  afterEach('afterEach suite2', function () {});\n  after('after suite2', function () {});\n});"}
{"prompt":"suite1, function  {","test":"'use strict';\nvar assert = require('assert');\n\ndescribe('suite1', function () {\n  var runOrder = [];\n  before('before suite1', function () {\n    runOrder.push('before suite1');\n    throw new Error('before suite1 error');\n  });\n  beforeEach('beforeEach suite1', function () {\n    runOrder.push('beforeEach suite1 - should not run');\n  });\n  it('test suite1', function () {\n    runOrder.push('test suite1 - should not run');\n  });\n\n  describe('suite1A', function () {\n    before('before suite1A', function () {});\n    beforeEach('beforeEach suite1A', function () {}); \n    it('test suite1A', function () {\n      runOrder.push('test suite1A - should not run');\n    });\n    afterEach('afterEach suite1A', function () {});\n    after('after suite1A', function () {});\n  });\n\n  afterEach('afterEach suite1', function () {\n    runOrder.push('afterEach suite1 - should not run');\n  });\n  after('after suite1', function () {\n    runOrder.push('after suite1');\n    assert.deepStrictEqual(runOrder, ['before suite1', 'after suite1']);\n  });\n});\n\ndescribe('suite2', function () {\n  before('before suite2', function () {});\n  beforeEach('beforeEach suite2', function () {});\n  it('test suite2', function () {\n    console.log('test suite2 - should not run');\n  });\n  afterEach('afterEach suite2', function () {});\n  after('after suite2', function () {});\n});"}
{"prompt":"suite1, function  {","test":"'use strict';\nvar assert = require('assert');\n\ndescribe('suite1', function () {\n  var runOrder = [];\n  before('before suite1', function () {\n    runOrder.push('before suite1');\n  });\n  beforeEach('beforeEach suite1', function () {\n    runOrder.push('beforeEach suite1');\n    throw new Error('beforeEach suite1 error');\n  });\n  it('test suite1', function () {\n    runOrder.push('test suite1 - should not run');\n  });\n\n  describe('suite1A', function () {\n    before('before suite1A', function () {});\n    beforeEach('beforeEach suite1A', function () {}); \n    it('test suite1A', function () {\n      runOrder.push('test suite1A - should not run');\n    });\n    afterEach('afterEach suite1A', function () {});\n    after('after suite1A', function () {});\n  });\n\n  afterEach('afterEach suite1', function () {\n    runOrder.push('afterEach suite1');\n  });\n  after('after suite1', function () {\n    runOrder.push('after suite1');\n    assert.deepStrictEqual(runOrder, [\n      'before suite1', 'beforeEach suite1', 'afterEach suite1', 'after suite1'\n    ]);\n  });\n});\n\ndescribe('suite2', function () {\n  before('before suite2', function () {});\n  beforeEach('beforeEach suite2', function () {});\n  it('test suite2', function () {\n    runOrder.push('test suite2 - should not run');\n  });\n  afterEach('afterEach suite2', function () {});\n  after('after suite2', function () {});\n});"}
{"prompt":"suite1, function  {","test":"'use strict';\nvar assert = require('assert');\n\ndescribe('suite1', function () {\n  var runOrder = [];\n  before('before suite1', function () {\n    runOrder.push('before suite1');\n  });\n  beforeEach('beforeEach suite1', function () {\n    runOrder.push('beforeEach suite1');\n  });\n  it('test suite1', function () {\n    runOrder.push('test suite1');\n    throw new Error('test suite1 error');\n  });\n\n  describe('suite1A', function () {\n    before('before suite1A', function () {});\n    beforeEach('beforeEach suite1A', function () {}); \n    it('test suite1A', function () {\n      runOrder.push('test suite1A - should not run');\n    });\n    afterEach('afterEach suite1A', function () {});\n    after('after suite1A', function () {});\n  });\n\n  afterEach('afterEach suite1', function () {\n    runOrder.push('afterEach suite1');\n  });\n  after('after suite1', function () {\n    runOrder.push('after suite1');\n    assert.deepStrictEqual(runOrder, [\n      'before suite1', 'beforeEach suite1', 'test suite1',\n      'afterEach suite1', 'after suite1'\n    ]);\n  });\n});\n\ndescribe('suite2', function () {\n  before('before suite2', function () {});\n  beforeEach('beforeEach suite2', function () {});\n  it('test suite2', function () {\n    runOrder.push('test suite2 - should not run');\n  });\n  afterEach('afterEach suite2', function () {});\n  after('after suite2', function () {});\n});"}
{"prompt":"some suite, function {","test":"describe('some suite', function() {\n  this.bail(true);\n  \n  it('should bail', function() {\n    throw new Error();\n  });\n\n  it('will not get run', function() {});\n});"}
{"prompt":"--bail, function  {","test":"'use strict';\n\nvar path = require('node:path').posix;\nvar helpers = require('../helpers');\nvar runMochaJSON = helpers.runMochaJSON;\n\ndescribe('--bail', function () {\n  var args = [];\n\n  before(function () {\n    args = ['--bail'];\n  });\n\n  it('should stop after the first error', function (done) {\n    var fixture = path.join('options', 'bail');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have failed')\n        .and('to have passed test', 'should display this spec')\n        .and('to have failed test', 'should only display this error')\n        .and('to have passed test count', 1)\n        .and('to have failed test count', 1);\n      done();\n    });\n  });\n\n  it('should stop after the first error - async', function (done) {\n    var fixture = path.join('options', 'bail-async');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have failed')\n        .and('to have passed test', 'should display this spec')\n        .and('to have failed test', 'should only display this error')\n        .and('to have passed test count', 1)\n        .and('to have failed test count', 1);\n      done();\n    });\n  });\n\n  it('should stop all tests after failing \"before\" hook', function (done) {\n    var fixture = path.join('options', 'bail-with-before');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have failed')\n        .and('to have failed test count', 1)\n        .and(\n          'to have failed test',\n          '\"before all\" hook: before suite1 for \"test suite1\"'\n        )\n        .and('to have passed test count', 0);\n      done();\n    });\n  });\n\n  it('should stop all tests after failing \"beforeEach\" hook', function (done) {\n    var fixture = path.join('options', 'bail-with-beforeEach');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have failed')\n        .and('to have failed test count', 1)\n        .and(\n          'to have failed test',\n          '\"before each\" hook: beforeEach suite1 for \"test suite1\"'\n        )\n        .and('to have passed test count', 0);\n      done();\n    });\n  });\n\n  it('should stop all tests after failing test', function (done) {\n    var fixture = path.join('options', 'bail-with-test');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have failed')\n        .and('to have failed test count', 1)\n        .and('to have failed test', 'test suite1')\n        .and('to have passed test count', 0);\n      done();\n    });\n  });\n\n  it('should stop all tests after failing \"after\" hook', function (done) {\n    var fixture = path.join('options', 'bail-with-after');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have failed')\n        .and('to have failed test count', 1)\n        .and(\n          'to have failed test',\n          '\"after all\" hook: after suite1A for \"test suite1A\"'\n        )\n        .and('to have passed test count', 2)\n        .and('to have passed test order', 'test suite1', 'test suite1A');\n      done();\n    });\n  });\n\n  it('should stop all tests after failing \"afterEach\" hook', function (done) {\n    var fixture = path.join('options', 'bail-with-afterEach');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have failed')\n        .and('to have failed test count', 1)\n        .and(\n          'to have failed test',\n          '\"after each\" hook: afterEach suite1A for \"test suite1A\"'\n        )\n        .and('to have passed test count', 2)\n        .and('to have passed test order', 'test suite1', 'test suite1A');\n      done();\n    });\n  });\n});"}
{"prompt":"Base reporter, function  {","test":"'use strict';\n\nvar assert = require('node:assert');\nvar chai = require('chai');\nvar sinon = require('sinon');\nvar helpers = require('./helpers');\nvar reporters = require('../../').reporters;\nvar AssertionError = assert.AssertionError;\nvar Base = reporters.Base;\nvar chaiExpect = chai.expect;\nvar createElements = helpers.createElements;\nvar makeTest = helpers.makeTest;\nvar Mocha = require('../../');\nvar Suite = Mocha.Suite;\nvar Runner = Mocha.Runner;\n\ndescribe('Base reporter', function () {\n  var stdout;\n\n  function list(tests) {\n    try {\n      Base.list(tests);\n    } finally {\n      sinon.restore();\n    }\n  }\n\n  function generateDiff(actual, expected) {\n    var diffStr;\n\n    try {\n      diffStr = Base.generateDiff(actual, expected);\n    } finally {\n      sinon.restore();\n    }\n\n    return diffStr;\n  }\n\n  var gather = function (chunk, encoding, cb) {\n    stdout.push(chunk);\n  };\n\n  beforeEach(function () {\n    sinon.stub(Base, 'useColors').value(false);\n    sinon.stub(process.stdout, 'write').callsFake(gather);\n    stdout = [];\n  });\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('showDiff', function () {\n    var err;\n\n    beforeEach(function () {\n      err = new AssertionError({actual: 'foo', expected: 'bar'});\n    });\n\n    it('should show diffs by default', function () {\n      var test = makeTest(err);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n');\n      expect(errOut, 'to match', /- actual/);\n      expect(errOut, 'to match', /\\+ expected/);\n    });\n\n    it(\"should show diffs if 'err.showDiff' is true\", function () {\n      err.showDiff = true;\n      var test = makeTest(err);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n');\n      expect(errOut, 'to match', /- actual/);\n      expect(errOut, 'to match', /\\+ expected/);\n    });\n\n    it(\"should not show diffs if 'err.showDiff' is false\", function () {\n      err.showDiff = false;\n      var test = makeTest(err);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n');\n      expect(errOut, 'not to match', /- actual/);\n      expect(errOut, 'not to match', /\\+ expected/);\n    });\n\n    it(\"should not show diffs if 'expected' is not defined\", function () {\n      var _err = new Error('ouch');\n      var test = makeTest(_err);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n');\n      expect(errOut, 'not to match', /- actual/);\n      expect(errOut, 'not to match', /\\+ expected/);\n    });\n\n    it(\"should not show diffs if 'hideDiff' is true\", function () {\n      var test = makeTest(err);\n\n      sinon.stub(Base, 'hideDiff').value(true);\n      list([test]);\n\n      var errOut = stdout.join('\\n');\n      expect(errOut, 'not to match', /- actual/);\n      expect(errOut, 'not to match', /\\+ expected/);\n    });\n  });\n\n  describe('getting two strings', function () {\n    // Fix regression V1.2.1(see: issue #1241)\n    it('should show strings diff as is', function () {\n      var err = new Error('test');\n      err.actual = 'foo\\nbar';\n      err.expected = 'foo\\nbaz';\n      err.showDiff = true;\n      var test = makeTest(err);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n');\n      expect(errOut, 'not to match', /\"foo\\\\nbar\"/);\n      expect(errOut, 'to match', /foo/).and('to match', /bar/);\n      expect(errOut, 'to match', /test/);\n      expect(errOut, 'to match', /actual/);\n      expect(errOut, 'to match', /expected/);\n    });\n  });\n\n  describe('diff generation', function () {\n    var inlineDiffsStub;\n\n    beforeEach(function () {\n      inlineDiffsStub = sinon.stub(Base, 'inlineDiffs').value(false);\n    });\n\n    it(\"should generate unified diffs if 'inlineDiffs' is false\", function () {\n      var actual = 'a foo unified diff';\n      var expected = 'a bar unified diff';\n\n      var output = generateDiff(actual, expected);\n\n      expect(\n        output,\n        'to be',\n        '\\n      + expected - actual\\n\\n      -a foo unified diff\\n      +a bar unified diff\\n      '\n      );\n    });\n\n    it(\"should generate inline diffs if 'inlineDiffs' is true\", function () {\n      var actual = 'a foo inline diff';\n      var expected = 'a bar inline diff';\n\n      inlineDiffsStub.value(true);\n      var output = generateDiff(actual, expected);\n\n      expect(\n        output,\n        'to be',\n        '      \\n      actual expected\\n      \\n      a foobar inline diff\\n      '\n      );\n    });\n\n    it(\"should truncate overly long 'actual' \", function () {\n      var actual = '';\n      var i = 0;\n      while (i++ < 500) {\n        actual += 'a foo unified diff ';\n      }\n      var expected = 'a bar unified diff';\n\n      var output = generateDiff(actual, expected);\n\n      expect(output, 'to match', /output truncated/);\n    });\n\n    it(\"should truncate overly long 'expected' \", function () {\n      var actual = 'a foo unified diff';\n      var expected = '';\n      var i = 0;\n      while (i++ < 500) {\n        expected += 'a bar unified diff ';\n      }\n\n      var output = generateDiff(actual, expected);\n\n      expect(output, 'to match', /output truncated/);\n    });\n\n    it(\"should not truncate overly long 'actual' if maxDiffSize=0\", function () {\n      var actual = '';\n      var i = 0;\n      while (i++ < 120) {\n        actual += 'a bar unified diff ';\n      }\n      var expected = 'b foo unified diff';\n\n      sinon.stub(Base, 'maxDiffSize').value(0);\n      var output = generateDiff(actual, expected);\n\n      expect(output, 'not to match', /output truncated/);\n    });\n\n    it(\"should not truncate overly long 'expected' if maxDiffSize=0\", function () {\n      var actual = 'a foo unified diff';\n      var expected = '';\n      var i = 0;\n      while (i++ < 120) {\n        expected += 'a bar unified diff ';\n      }\n\n      sinon.stub(Base, 'maxDiffSize').value(0);\n      var output = generateDiff(actual, expected);\n\n      expect(output, 'not to match', /output truncated/);\n    });\n  });\n\n  describe('inline strings diff', function () {\n    beforeEach(function () {\n      sinon.stub(Base, 'inlineDiffs').value(true);\n    });\n\n    it(\"should show single line diff if 'inlineDiffs' is true\", function () {\n      var err = new Error('test');\n      err.actual = 'a foo inline diff';\n      err.expected = 'a bar inline diff';\n      err.showDiff = true;\n      var test = makeTest(err);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n');\n      expect(errOut, 'to match', /a foobar inline diff/);\n      expect(errOut, 'to match', /test/);\n      expect(errOut, 'to match', /actual/);\n      expect(errOut, 'to match', /expected/);\n    });\n\n    it('should split lines if string has more than 4 line breaks', function () {\n      var err = new Error('test');\n      err.actual = 'a\\nfoo\\ninline\\ndiff\\nwith\\nmultiple lines';\n      err.expected = 'a\\nbar\\ninline\\ndiff\\nwith\\nmultiple lines';\n      err.showDiff = true;\n      var test = makeTest(err);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n');\n      expect(errOut, 'to match', /1 \\| a/);\n      expect(errOut, 'to match', /2 \\| foobar/);\n      expect(errOut, 'to match', /3 \\| inline/);\n      expect(errOut, 'to match', /4 \\| diff/);\n      expect(errOut, 'to match', /5 \\| with/);\n      expect(errOut, 'to match', /6 \\| multiple lines/);\n      expect(errOut, 'to match', /test/);\n      expect(errOut, 'to match', /actual/);\n      expect(errOut, 'to match', /expected/);\n    });\n  });\n\n  describe('unified diff', function () {\n    beforeEach(function () {\n      sinon.stub(Base, 'inlineDiffs').value(false);\n    });\n\n    it('should separate diff hunks by two dashes', function () {\n      var err = new Error('test');\n      err.actual = createElements({from: 2, to: 11});\n      err.expected = createElements({from: 1, to: 10});\n      err.showDiff = true;\n      var test = makeTest(err);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n');\n\n      var regexesToMatch = [\n        /\\[/,\n        /\\+ {2}\"element 1\"/,\n        /\"element 2\"/,\n        /\"element 3\"/,\n        /\"element 4\"/,\n        /\"element 5\"/,\n        /--/,\n        /\"element 7\"/,\n        /\"element 8\"/,\n        /\"element 9\"/,\n        /\"element 10\"/,\n        /- {2}\"element 11\"/,\n        /]/,\n        /test/,\n        /expected/,\n        /actual/\n      ];\n\n      regexesToMatch.forEach(function (aRegex) {\n        expect(errOut, 'to match', aRegex);\n      });\n    });\n  });\n\n  describe(\"when 'reporterOption.maxDiffSize' is provided\", function () {\n    var origSize;\n\n    beforeEach(function () {\n      sinon.restore();\n      origSize = Base.maxDiffSize;\n    });\n\n    afterEach(function () {\n      Base.maxDiffSize = origSize;\n    });\n\n    it(\"should set 'Base.maxDiffSize' used for truncating diffs\", function () {\n      var options = {\n        reporterOption: {\n          maxDiffSize: 4\n        }\n      };\n      var suite = new Suite('Dummy suite', 'root');\n      var runner = new Runner(suite);\n      // eslint-disable-next-line no-unused-vars\n      var base = new Base(runner, options);\n      expect(Base.maxDiffSize, 'to be', 4);\n    });\n  });\n\n  it('should stringify objects', function () {\n    var err = new Error('test');\n    err.actual = {key: 'a1'};\n    err.expected = {key: 'e1'};\n    err.showDiff = true;\n    var test = makeTest(err);\n\n    list([test]);\n\n    var errOut = stdout.join('\\n');\n    expect(errOut, 'to match', /\"key\"/);\n    expect(errOut, 'to match', /test/);\n    expect(errOut, 'to match', /- actual/);\n    expect(errOut, 'to match', /\\+ expected/);\n  });\n\n  it('should stringify Object.create(null)', function () {\n    var err = new Error('test');\n\n    err.actual = Object.create(null);\n    err.actual.hasOwnProperty = 1;\n    err.expected = Object.create(null);\n    err.expected.hasOwnProperty = 2;\n    err.showDiff = true;\n    var test = makeTest(err);\n\n    list([test]);\n\n    var errOut = stdout.join('\\n');\n    expect(errOut, 'to match', /\"hasOwnProperty\"/);\n    expect(errOut, 'to match', /test/);\n    expect(errOut, 'to match', /- actual/);\n    expect(errOut, 'to match', /\\+ expected/);\n  });\n\n  it('should handle error messages that are not strings', function () {\n    try {\n      assert(false, true);\n    } catch (err) {\n      err.actual = false;\n      err.expected = true;\n      err.showDiff = true;\n      var test = makeTest(err);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n');\n      expect(errOut, 'to match', /\\+true/);\n      expect(errOut, 'to match', /-false/);\n      expect(errOut, 'to match', /- actual/);\n      expect(errOut, 'to match', /\\+ expected/);\n    }\n  });\n\n  it(\"should interpret 'chai' module custom error messages\", function () {\n    var actual = 43;\n    var expected = 42;\n\n    try {\n      chaiExpect(actual, 'custom error message').to.equal(expected);\n    } catch (err) {\n      err.actual = actual;\n      err.expected = expected;\n      err.showDiff = true;\n      var test = makeTest(err);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n');\n      expect(errOut, 'to match', /custom error message\\n/)\n        .and('to match', /\\+42/)\n        .and('to match', /-43/)\n        .and('to match', /- actual/)\n        .and('to match', /\\+ expected/);\n    }\n  });\n\n  it(\"should interpret 'assert' module custom error messages\", function () {\n    var actual = 43;\n    var expected = 42;\n\n    try {\n      assert.strictEqual(actual, expected, 'custom error message');\n      // AssertionError: custom error message: expected 43 to equal 42.\n      // assert.equal(43, 42, 'custom error message: expected 43 to equal 42.');\n    } catch (err) {\n      err.actual = actual;\n      err.expected = expected;\n      err.showDiff = true;\n      var test = makeTest(err);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n');\n      expect(errOut, 'to match', /custom error message\\n/);\n      expect(errOut, 'to match', /\\+42/);\n      expect(errOut, 'to match', /-43/);\n      expect(errOut, 'to match', /- actual/);\n      expect(errOut, 'to match', /\\+ expected/);\n    }\n  });\n\n  it('should remove message from stack', function () {\n    var err = {\n      message: 'Error',\n      stack: 'Error\\nfoo\\nbar',\n      showDiff: false\n    };\n    var test = makeTest(err);\n\n    list([test]);\n\n    var errOut = stdout.join('\\n').trim();\n    expect(errOut, 'to be', '1) test title:\\n     Error\\n  foo\\n  bar');\n  });\n\n  it(\"should use 'inspect' if 'inspect' and 'message' are set\", function () {\n    var err = new Error('test');\n    err.showDiff = false;\n    err.message = 'error message';\n    err.inspect = function () {\n      return 'Inspect Error';\n    };\n\n    var test = makeTest(err);\n\n    list([test]);\n\n    var errOut = stdout.join('\\n').trim();\n\n    expect(errOut, 'to contain', 'Inspect Error');\n  });\n\n  it(\"should set an empty message if neither 'inspect' nor 'message' is set\", function () {\n    var err = {\n      showDiff: false\n    };\n    var test = makeTest(err);\n\n    list([test]);\n\n    var errOut = stdout.join('\\n').trim();\n    expect(errOut, 'to be', '1) test title:');\n  });\n\n  it('should not modify stack if it does not contain message', function () {\n    var err = {\n      message: 'Error',\n      stack: 'foo\\nbar',\n      showDiff: false\n    };\n    var test = makeTest(err);\n\n    list([test]);\n\n    var errOut = stdout.join('\\n').trim();\n    expect(errOut, 'to be', '1) test title:\\n     Error\\n  foo\\n  bar');\n  });\n\n  describe('error causes', function () {\n    it('should append any error cause trail to stack traces', function () {\n      var err = {\n        message: 'Error',\n        stack: 'Error\\nfoo\\nbar',\n        showDiff: false,\n        cause: {\n          message: 'Cause1',\n          stack: 'Cause1\\nbar\\nfoo',\n          showDiff: false,\n          cause: {\n            message: 'Cause2',\n            stack: 'Cause2\\nabc\\nxyz',\n            showDiff: false\n          }\n        }\n      };\n      var test = makeTest(err);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n').trim();\n      expect(\n        errOut,\n        'to be',\n        '1) test title:\\n     Error\\n  foo\\n  bar\\n     Caused by: Cause1\\n  bar\\n  foo\\n     Caused by: Cause2\\n  abc\\n  xyz'\n      );\n    });\n\n    it('should not get stuck in a hypothetical circular error cause trail', function () {\n      var err1 = {\n        message: 'Error',\n        stack: 'Error\\nfoo\\nbar',\n        showDiff: false,\n      };\n      var err2 = {\n        message: 'Cause1',\n        stack: 'Cause1\\nbar\\nfoo',\n        showDiff: false,\n        cause: err1\n      }\n      err1.cause = err2;\n\n      var test = makeTest(err1);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n').trim();\n      expect(\n        errOut,\n        'to be',\n        '1) test title:\\n     Error\\n  foo\\n  bar\\n     Caused by: Cause1\\n  bar\\n  foo\\n     Caused by: <circular>'\n      );\n    });\n\n    it(\"should set an empty cause if neither 'inspect' nor 'message' is set\", function () {\n      var err = {\n        message: 'Error',\n        stack: 'Error\\nfoo\\nbar',\n        showDiff: false,\n        cause: {\n          showDiff: false,\n        }\n      };\n\n      var test = makeTest(err);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n').trim();\n      expect(\n        errOut,\n        'to be',\n        '1) test title:\\n     Error\\n  foo\\n  bar\\n     Caused by:'\n      );\n    });\n\n    it('should not add cause trail if error does not contain message', function () {\n      var err = {\n        message: 'Error',\n        stack: 'foo\\nbar',\n        showDiff: false,\n        cause: {\n          message: 'Cause1',\n          stack: 'Cause1\\nbar\\nfoo',\n          showDiff: false,\n          cause: {\n            message: 'Cause2',\n            stack: 'Cause2\\nabc\\nxyz',\n            showDiff: false\n          }\n        }\n      };\n      var test = makeTest(err);\n\n      list([test]);\n\n      var errOut = stdout.join('\\n').trim();\n      expect(errOut, 'to be', '1) test title:\\n     Error\\n  foo\\n  bar');\n    });\n  });\n\n  it('should list multiple Errors per test', function () {\n    var err = new Error('First Error');\n    err.multiple = [new Error('Second Error - same test')];\n    var test = makeTest(err);\n\n    list([test, test]);\n\n    var errOut = stdout.join('\\n').trim();\n    expect(\n      errOut,\n      'to contain',\n      'Error: First Error',\n      'Error: Second Error - same test'\n    );\n  });\n\n  describe('when reporter output immune to user test changes', function () {\n    var baseConsoleLog;\n\n    beforeEach(function () {\n      sinon.restore();\n      sinon.stub(console, 'log');\n      baseConsoleLog = sinon.stub(Base, 'consoleLog');\n    });\n\n    it('should let you stub out console.log without effecting reporters output', function () {\n      Base.list([]);\n      baseConsoleLog.restore();\n\n      expect(baseConsoleLog, 'was called');\n      expect(console.log, 'was not called');\n    });\n  });\n});"}
{"prompt":"it.only via requiremocha, function  {","test":"'use strict';\n\nvar mocha = require('../../lib/mocha');\n\nvar beforeEach = mocha.beforeEach;\nvar it = mocha.it;\nvar describe = mocha.describe;\n\ndescribe('it.only via require(\"mocha\")', function () {\n  beforeEach(function () {\n    this.didRunBeforeEach = true;\n  });\n  describe('nested within a describe/context', function () {\n    it.only('should run all enclosing beforeEach hooks', function () {\n      require('node:assert').strictEqual(this.didRunBeforeEach, true);\n    });\n  });\n});"}
{"prompt":".onlyshould run this suite, function  {","test":"'use strict';\n\ndescribe.only('should run this suite', function () {\n  it('should run this test', function () {});\n\n  it('should run this test', function () {});\n\n  it('should run this test', function () {});\n});\n\ndescribe('should not run this suite', function () {\n  it('should not run this test', function () {\n    (true).should.equal(false);\n  });\n\n  it('should not run this test', function () {\n    (true).should.equal(false);\n  });\n\n  it('should not run this test', function () {\n    (true).should.equal(false);\n  });\n});\n\ndescribe.only('should run this suite too', function () {\n  describe('should run this nested suite', function () {\n    it('should run this test', function () {});\n\n    it('should run this test', function () {});\n\n    it('should run this test', function () {});\n  });\n});\n\ndescribe.only('should run this suite, even', function () {\n  describe('should run this nested suite, even', function () {\n    describe('should run this doubly-nested suite!', function () {\n      it('should run this test', function () {});\n\n      it('should run this test', function () {});\n\n      it('should run this test', function () {});\n    });\n  });\n});\n\ndescribe('should run this suite with an exclusive test', function () {\n  it.only('should run this test', function () {});\n\n  describe('should not run this nested suite', function () {\n    describe.only('should not run this doubly-nested suite', function () {\n      it('should not run this test', function () {});\n\n      it('should not run this test', function () {});\n\n      it('should not run this test', function () {});\n    });\n  });\n});\n\ndescribe('should run this suite with an exclusive test (reverse order)', function () {\n  describe('should not run this nested suite', function () {\n    describe.only('should not run this doubly-nested suite', function () {\n      it('should not run this test', function () {});\n\n      it('should not run this test', function () {});\n\n      it('should not run this test', function () {});\n    });\n  });\n  it.only('should run this test', function () {});\n});"}
{"prompt":"Root-only test cases","test":"'use strict';\n\n// Root-only test cases\nit.only('#Root-Suite, should run this bdd test-case #1', function () {\n  expect(true, 'to be', true);\n});\n\nit('#Root-Suite, should not run this bdd test-case #2', function () {\n  expect(false, 'to be', true);\n});\n\nit('#Root-Suite, should not run this bdd test-case #3', function () {\n  expect(false, 'to be', true);\n});"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\ndescribe('spec 1', function () {\n  beforeEach(function (done) {\n    console.log('before');\n    process.nextTick(function () {\n      throw new Error('before each hook error');\n    });\n  });\n  it('should not be called because of error in before each hook', function () {\n    console.log('test 1');\n  });\n  it('should not be called because of error in before each hook', function () {\n    console.log('test 2');\n  });\n});\ndescribe('spec 2', function () {\n  it('should be called, because hook error was in a sibling suite', function () {\n    console.log('test 3');\n  });\n});"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\ndescribe('spec 1', function () {\n  beforeEach(function () {\n    console.log('before');\n    throw new Error('before each hook error');\n  });\n  it('should not be called because of error in before each hook', function () {\n    console.log('test 1');\n  });\n  it('should not be called because of error in before each hook', function () {\n    console.log('test 2');\n  });\n});\ndescribe('spec 2', function () {\n  it('should be called, because hook error was in a sibling suite', function () {\n    console.log('test 3');\n  });\n});"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\ndescribe('spec 1', function () {\n  it('should not blame me', function () { });\n});\ndescribe('spec 2', function () {\n  before(function (done) {\n    process.nextTick(function () {\n      throw new Error('before hook error');\n    });\n  });\n  it('skipped');\n});"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\ndescribe('spec 1', function () {\n  before(function (done) {\n    console.log('before');\n    process.nextTick(function () {\n      throw new Error('before hook error');\n    });\n  });\n  it('should not be called because of error in before hook', function () {\n    console.log('test 1');\n  });\n  it('should not be called because of error in before hook', function () {\n    console.log('test 2');\n  });\n});\ndescribe('spec 2', function () {\n  it('should be called, because hook error was in a sibling suite', function () {\n    console.log('test 3');\n  });\n});"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\ndescribe('spec 1', function () {\n  it('should pass', function () { });\n  describe('spec 2 nested - this title should be used', function () {\n    before(function() {\n      throw new Error('before hook nested error');\n    });\n    describe('spec 3 nested', function () { \n      it('it nested - this title should not be used', function () { });\n    });\n  });\n});"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\ndescribe('spec 1', function () {\n  it('should not blame me', function () { });\n});\ndescribe('spec 2', function () {\n  before(function () {\n    throw new Error('before hook error');\n  });\n  it('skipped');\n});"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\ndescribe('spec 1', function () {\n  before(function () {\n    console.log('before');\n    throw new Error('before hook error');\n  });\n  it('should not be called because of error in before hook', function () {\n    console.log('test 1');\n  });\n  it('should not be called because of error in before hook', function () {\n    console.log('test 2');\n  });\n});\ndescribe('spec 2', function () {\n  it('should be called, because hook error was in a sibling suite', function () {\n    console.log('test 3');\n  });\n});"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\ndescribe('spec 1', function () {\n  it('should pass', function () { });\n  describe('spec nested', function () {\n    before(function() {\n      throw new Error('before hook nested error');\n    });\n    it('it nested - this title should be used', function () { });\n  });\n});"}
{"prompt":"spec 1, function  {","test":"'use strict';\n\nbefore(function() {\n  throw new Error('before hook root error');\n});\n\ndescribe('spec 1', function () {\n  it('should not be called', function () { });\n});"}
{"prompt":"forbid pending - before calls skip, function {","test":"'use strict';\n\ndescribe('forbid pending - before calls `skip()`', function() {\n  it('test', function() {});\n  before(function() {\n    this.skip();\n  });\n});"}
{"prompt":"forbid pending - beforeEach calls skip, function {","test":"'use strict';\n\ndescribe('forbid pending - beforeEach calls `skip()`', function() {\n  it('test', function() {});\n  beforeEach(function() {\n    this.skip();\n  });\n});"}
{"prompt":"class BufferedWorkerPool, function  {","test":"'use strict';\n\nconst rewiremock = require('rewiremock/node');\nconst sinon = require('sinon');\n\ndescribe('class BufferedWorkerPool', function () {\n  let BufferedWorkerPool;\n  let pool;\n  let stats;\n  let serializeJavascript;\n  let serializer;\n  let result;\n\n  beforeEach(function () {\n    stats = {totalWorkers: 10, busyWorkers: 8, idleWorkers: 2, pendingTasks: 3};\n    result = {failures: 0, events: []};\n    pool = {\n      terminate: sinon.stub().resolves(),\n      exec: sinon.stub().resolves(result),\n      stats: sinon.stub().returns(stats)\n    };\n    serializer = {\n      deserialize: sinon.stub()\n    };\n\n    serializeJavascript = sinon.spy(require('serialize-javascript'));\n    BufferedWorkerPool = rewiremock.proxy(\n      require.resolve('../../lib/nodejs/buffered-worker-pool'),\n      {\n        workerpool: {\n          pool: sinon.stub().returns(pool),\n          cpus: 8\n        },\n        '../../lib/nodejs/serializer': serializer,\n        'serialize-javascript': serializeJavascript\n      }\n    ).BufferedWorkerPool;\n\n    // reset cache\n    BufferedWorkerPool.resetOptionsCache();\n  });\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('static method', function () {\n    describe('create()', function () {\n      it('should return a BufferedWorkerPool instance', function () {\n        expect(\n          BufferedWorkerPool.create({foo: 'bar'}),\n          'to be a',\n          BufferedWorkerPool\n        );\n      });\n\n      describe('when passed no arguments', function () {\n        it('should not throw', function () {\n          expect(BufferedWorkerPool.create, 'not to throw');\n        });\n      });\n    });\n\n    describe('serializeOptions()', function () {\n      describe('when passed no arguments', function () {\n        it('should not throw', function () {\n          expect(BufferedWorkerPool.serializeOptions, 'not to throw');\n        });\n      });\n\n      it('should return a serialized string', function () {\n        expect(\n          BufferedWorkerPool.serializeOptions({foo: 'bar'}),\n          'to be a',\n          'string'\n        );\n      });\n\n      describe('when called multiple times with the same object', function () {\n        it('should not perform serialization twice', function () {\n          const obj = {foo: 'bar'};\n          BufferedWorkerPool.serializeOptions(obj);\n          BufferedWorkerPool.serializeOptions(obj);\n          expect(serializeJavascript, 'was called once');\n        });\n\n        it('should return the same value', function () {\n          const obj = {foo: 'bar'};\n          expect(\n            BufferedWorkerPool.serializeOptions(obj),\n            'to be',\n            BufferedWorkerPool.serializeOptions(obj)\n          );\n        });\n      });\n    });\n  });\n\n  describe('constructor', function () {\n    it('should apply defaults', function () {\n      expect(new BufferedWorkerPool(), 'to satisfy', {\n        options: {\n          workerType: 'process',\n          forkOpts: {execArgv: process.execArgv},\n          maxWorkers: expect.it('to be greater than or equal to', 1)\n        }\n      });\n    });\n  });\n\n  describe('instance method', function () {\n    let workerPool;\n\n    beforeEach(function () {\n      workerPool = BufferedWorkerPool.create();\n    });\n\n    describe('stats()', function () {\n      it('should return the object returned by `workerpool.Pool#stats`', function () {\n        expect(workerPool.stats(), 'to be', stats);\n      });\n    });\n\n    describe('run()', function () {\n      describe('when passed no arguments', function () {\n        it('should reject', async function () {\n          return expect(workerPool.run(), 'to be rejected with', {\n            code: 'ERR_MOCHA_INVALID_ARG_TYPE'\n          });\n        });\n      });\n\n      describe('when passed a non-string filepath', function () {\n        it('should reject', async function () {\n          return expect(workerPool.run(123), 'to be rejected with', {\n            code: 'ERR_MOCHA_INVALID_ARG_TYPE'\n          });\n        });\n      });\n\n      it('should serialize the options object', async function () {\n        await workerPool.run('file.js', {foo: 'bar'});\n\n        expect(pool.exec, 'to have a call satisfying', [\n          'run',\n          ['file.js', '{\"foo\":\"bar\"}']\n        ]).and('was called once');\n      });\n\n      it('should deserialize the result', async function () {\n        await workerPool.run('file.js', {foo: 'bar'});\n        expect(serializer.deserialize, 'to have a call satisfying', [\n          result\n        ]).and('was called once');\n      });\n    });\n\n    describe('terminate()', function () {\n      describe('when called with `force`', function () {\n        beforeEach(async function () {\n          await workerPool.terminate(true);\n        });\n\n        it('should delegate to the underlying pool w/ \"force\" behavior', async function () {\n          expect(pool.terminate, 'to have a call satisfying', [true]).and(\n            'was called once'\n          );\n        });\n      });\n\n      describe('when called without `force`', function () {\n        beforeEach(async function () {\n          await workerPool.terminate();\n        });\n\n        it('should delegate to the underlying pool w/o \"force\" behavior', async function () {\n          expect(pool.terminate, 'to have a call satisfying', [false]).and(\n            'was called once'\n          );\n        });\n      });\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nglobal.required = global.required || [];\nglobal.required.push('c.js');"}
{"prompt":"one, function  {","test":"'use strict';\n\ndescribe('one', function () {\n  before(function () {\n    console.log('before one');\n  });\n\n  after(function () {\n    console.log('after one');\n  });\n\n  beforeEach(function () {\n    console.log('  before each one');\n  });\n\n  afterEach(function () {\n    console.log('  after each one');\n  });\n\n  describe('two', function () {\n    before(function () {\n      console.log('  before two');\n    });\n\n    after(function () {\n      console.log('  after two');\n    });\n\n    beforeEach(function () {\n      console.log('    before each two');\n    });\n\n    afterEach(function () {\n      console.log('    after each two');\n    });\n\n    describe('three', function () {\n      before(function () {\n        console.log('    before three');\n      });\n\n      after(function () {\n        console.log('    after three');\n      });\n\n      beforeEach(function () {\n        console.log('    before each three');\n      });\n\n      afterEach(function () {\n        console.log('    after each three');\n      });\n\n      it('should three', function () {\n        console.log('      TEST three');\n      });\n    });\n  });\n});"}
{"prompt":"test1,  => {","test":"import {describe,it} from \"../../../../index.js\";\n\ndescribe('test1', () => {\n  it('test', () => {\n    const error = new Error('Foo');\n    error.foo = { props: [] };\n    error.foo.props.push(error.foo);\n    throw error;\n  });\n});"}
{"prompt":"test1,  => {","test":"import {describe,it} from \"../../../../index.js\";\n\ndescribe('test1', () => {\n  it('test', () => {\n    const errorA = {};\n    const objectB = {toA: errorA};\n    errorA.toB = objectB;\n\n    const error = new Error(\"Oh no!\");\n    error.error = errorA;\n    error.values = [errorA];\n\n    throw error;\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\nconst Mocha = require('../../../../lib/mocha');\n\nconst mocha = new Mocha({ reporter: 'json' });\nmocha.cleanReferencesAfterRun(true);\nrequire('./run-thrice-helper')(mocha);"}
{"prompt":"mjs, function  {","test":"var obj = {foo: 'bar'};\n\ndescribe('mjs', function () {\n  it('should work', function () {\n    expect(obj, 'to equal', {foo: 'bar'});\n  });\n});"}
{"prompt":"mocha binary, function  {","test":"'use strict';\n\nvar childProcess = require('node:child_process');\nvar path = require('node:path');\n\ndescribe('mocha binary', function () {\n  it('should not output colors to pipe', function (done) {\n    var command = [path.join('bin', 'mocha'), '--grep', 'missing-test'];\n    childProcess.execFile(process.execPath, command, function (err, stdout) {\n      if (err) return done(err);\n\n      expect(stdout, 'not to contain', '[90m');\n\n      done();\n    });\n  });\n});"}
{"prompt":",","test":"const { afterEach,\n  after,\n  beforeEach,\n  before,\n  describe,\n  xdescribe,\n  it,\n  xit,\n  setup,\n  suiteSetup,\n  suiteTeardown,\n  suite,\n  teardown,\n  test,\n  run } = require('../../..');\n\n\nsuite('root suite', () => {\n  setup(() => {\n    console.log('running setup');\n  })\n  before(() => {\n    console.log('running before');\n  });\n  beforeEach(() => {\n    console.log('running beforeEach');\n  });\n  afterEach(() => {\n    console.log('running afterEach');\n  });\n  after(() => {\n    console.log('running after');\n  });\n  teardown(() => {\n    console.log('running teardown');\n  });\n  suiteSetup(() => {\n    console.log('running suiteSetup');\n  });\n  suiteTeardown(() => {\n    console.log('running suiteTeardown');\n  });\n\n  describe.only('describe only', () => {\n    it('it', () => {\n      console.log('running it');\n    }).timeout(1000);\n    xit('it', () => {\n      console.log('running xit');\n    });\n    it.only('it.only', () => {\n      console.log('running it.only');\n    }).retries(2);\n    it.skip('it.skip', () => {\n      console.log('running it.skip');\n    });\n    test('test', () => {\n      console.log('running test');\n    });\n  });\n\n  describe('describe', () => {});\n\n  xdescribe('xdescribe', () => {});\n\n  describe.skip('describe.skip', () => {});\n\n  suite.only('suite only', () => {});\n\n  suite.skip('suite.skip', () => {});\n\n});\n\n// using `run` here makes it so this suite needs to be run with `--delay` mode.\n// adding it here to test that `run` is correctly exported from mocha.\nsetTimeout(run, 0);"}
{"prompt":"common js require,  => {","test":"'use strict';\n\nconst {runMochaAsync} = require('./helpers');\n\ndescribe('common js require', () => {\n  it('should be able to run a test where all mocha exports are used', async () => {\n    const result = await runMochaAsync('common-js-require.fixture.js', [\n      '--delay'\n    ]);\n    expect(result.output, 'to contain', 'running before');\n    expect(result.output, 'to contain', 'running suiteSetup');\n    expect(result.output, 'to contain', 'running setup');\n    expect(result.output, 'to contain', 'running beforeEach');\n    expect(result.output, 'to contain', 'running it');\n    expect(result.output, 'to contain', 'running afterEach');\n    expect(result.output, 'to contain', 'running teardown');\n    expect(result.output, 'to contain', 'running suiteTeardown');\n    expect(result.output, 'to contain', 'running after');\n  });\n});"}
{"prompt":"globbing like --compilers, function  {","test":"'use strict';\n\nvar exec = require('node:child_process').exec;\nvar path = require('node:path');\n\ndescribe('globbing like --compilers', function () {\n  it('should find a file of each type', function (done) {\n    exec(\n      '\"' +\n        process.execPath +\n        '\" \"' +\n        path.join('bin', 'mocha') +\n        '\" -R json --require coffeescript/register --require test/compiler-fixtures/foo.fixture \"test/compiler/*.@(coffee|foo)\"',\n      {cwd: path.join(__dirname, '..', '..')},\n      function (error, stdout) {\n        if (error && !stdout) {\n          return done(error);\n        }\n        var results = JSON.parse(stdout);\n        expect(results, 'to have property', 'tests');\n        var titles = [];\n        for (var index = 0; index < results.tests.length; index += 1) {\n          expect(results.tests[index], 'to have property', 'fullTitle');\n          titles.push(results.tests[index].fullTitle);\n        }\n        expect(\n          titles,\n          'to contain',\n          'coffeescript should work',\n          'custom compiler should work'\n        ).and('to have length', 2);\n        done();\n      }\n    );\n  });\n});"}
{"prompt":"--compilers, function  {","test":"'use strict';\n\nvar helpers = require('../helpers');\nvar invokeMocha = helpers.invokeMocha;\n\ndescribe('--compilers', function () {\n  it('should report deprecation', function (done) {\n    invokeMocha(\n      ['--compilers', 'coffee:coffeescript/register'],\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n\n        expect(res, 'to have failed with output', /compilers is deprecated/i);\n        done();\n      },\n      'pipe'\n    );\n  });\n});"}
{"prompt":"cli/config, function  {","test":"'use strict';\n\nconst sinon = require('sinon');\nconst rewiremock = require('rewiremock/node');\nconst {parsers} = require('../../../lib/cli/config');\n\ndescribe('cli/config', function () {\n  const phonyConfigObject = {ok: true};\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('loadConfig()', function () {\n    let parsers;\n    let loadConfig;\n\n    beforeEach(function () {\n      const config = rewiremock.proxy(\n        require.resolve('../../../lib/cli/config')\n      );\n      parsers = config.parsers;\n      loadConfig = config.loadConfig;\n    });\n\n    describe('when parsing succeeds', function () {\n      beforeEach(function () {\n        sinon.stub(parsers, 'yaml').returns(phonyConfigObject);\n        sinon.stub(parsers, 'json').returns(phonyConfigObject);\n        sinon.stub(parsers, 'js').returns(phonyConfigObject);\n      });\n\n      describe('when supplied a filepath with \".yaml\" extension', function () {\n        const filepath = 'foo.yaml';\n\n        it('should use the YAML parser', function () {\n          loadConfig(filepath);\n          expect(parsers.yaml, 'to have calls satisfying', [\n            {args: [filepath], returned: phonyConfigObject}\n          ]).and('was called once');\n        });\n      });\n\n      describe('when supplied a filepath with \".yml\" extension', function () {\n        const filepath = 'foo.yml';\n\n        it('should use the YAML parser', function () {\n          loadConfig(filepath);\n          expect(parsers.yaml, 'to have calls satisfying', [\n            {args: [filepath], returned: phonyConfigObject}\n          ]).and('was called once');\n        });\n      });\n\n      describe('when supplied a filepath with \".js\" extension', function () {\n        const filepath = 'foo.js';\n\n        it('should use the JS parser', function () {\n          loadConfig(filepath);\n          expect(parsers.js, 'to have calls satisfying', [\n            {args: [filepath], returned: phonyConfigObject}\n          ]).and('was called once');\n        });\n      });\n\n      describe('when supplied a filepath with \".cjs\" extension', function () {\n        const filepath = 'foo.cjs';\n\n        it('should use the JS parser', function () {\n          loadConfig(filepath);\n          expect(parsers.js, 'to have calls satisfying', [\n            {args: [filepath], returned: phonyConfigObject}\n          ]).and('was called once');\n        });\n      });\n\n      describe('when supplied a filepath with \".jsonc\" extension', function () {\n        const filepath = 'foo.jsonc';\n\n        it('should use the JSON parser', function () {\n          loadConfig('foo.jsonc');\n          expect(parsers.json, 'to have calls satisfying', [\n            {args: [filepath], returned: phonyConfigObject}\n          ]).and('was called once');\n        });\n      });\n\n      describe('when supplied a filepath with \".json\" extension', function () {\n        const filepath = 'foo.json';\n\n        it('should use the JSON parser', function () {\n          loadConfig('foo.json');\n          expect(parsers.json, 'to have calls satisfying', [\n            {args: [filepath], returned: phonyConfigObject}\n          ]).and('was called once');\n        });\n      });\n    });\n\n    describe('when supplied a filepath with unsupported extension', function () {\n      beforeEach(function () {\n        sinon.stub(parsers, 'json').returns(phonyConfigObject);\n      });\n\n      it('should use the JSON parser', function () {\n        loadConfig('foo.bar');\n        expect(parsers.json, 'was called');\n      });\n    });\n\n    describe('when config file parsing fails', function () {\n      beforeEach(function () {\n        sinon.stub(parsers, 'yaml').throws('goo.yaml is unparsable');\n      });\n\n      it('should throw', function () {\n        expect(\n          () => loadConfig('goo.yaml'),\n          'to throw',\n          'Unable to read/parse goo.yaml: goo.yaml is unparsable'\n        );\n      });\n    });\n  });\n\n  describe('findConfig()', function () {\n    let findup;\n    let findConfig;\n    let CONFIG_FILES;\n\n    beforeEach(function () {\n      findup = {sync: sinon.stub().returns('/some/path/.mocharc.js')};\n      const config = rewiremock.proxy(\n        require.resolve('../../../lib/cli/config'),\n        r => ({\n          'find-up': r.by(() => findup)\n        })\n      );\n      findConfig = config.findConfig;\n      CONFIG_FILES = config.CONFIG_FILES;\n    });\n\n    it('should look for one of the config files using findup-sync', function () {\n      findConfig();\n      expect(findup, 'to have a call satisfying', {\n        args: [CONFIG_FILES, {cwd: process.cwd()}],\n        returned: '/some/path/.mocharc.js'\n      });\n    });\n\n    it('should support an explicit `cwd`', function () {\n      findConfig('/some/path/');\n      expect(findup, 'to have a call satisfying', {\n        args: [CONFIG_FILES, {cwd: '/some/path/'}],\n        returned: '/some/path/.mocharc.js'\n      });\n    });\n  });\n\n  describe('parsers()', function () {\n    it('should print error message for faulty require', function () {\n      // Fixture exists, but fails loading.\n      // Prints correct error message without using fallback path.\n      expect(\n        () => parsers.js(require.resolve('./fixtures/bad-require.fixture.js')),\n        'to throw',\n        {message: /Cannot find module 'fake'/, code: 'MODULE_NOT_FOUND'}\n      );\n    });\n\n    it('should print error message for non-existing file', function () {\n      expect(() => parsers.js('not-existing.js'), 'to throw', {\n        message: /Cannot find module 'not-existing.js'/,\n        code: 'MODULE_NOT_FOUND'\n      });\n    });\n  });\n});"}
{"prompt":"Context, function  {","test":"'use strict';\n\ndescribe('Context', function () {\n  beforeEach(function () {\n    this.calls = ['before'];\n  });\n\n  describe('nested', function () {\n    beforeEach(function () {\n      this.calls.push('before two');\n    });\n\n    it('should work', function () {\n      expect(this.calls, 'to equal', ['before', 'before two']);\n      this.calls.push('test');\n    });\n\n    after(function () {\n      expect(this.calls, 'to equal', ['before', 'before two', 'test']);\n      this.calls.push('after two');\n    });\n  });\n\n  after(function () {\n    expect(this.calls, 'to equal', [\n      'before',\n      'before two',\n      'test',\n      'after two'\n    ]);\n  });\n});\n\ndescribe('Context Siblings', function () {\n  beforeEach(function () {\n    this.calls = ['before'];\n  });\n\n  describe('sequestered sibling', function () {\n    beforeEach(function () {\n      this.calls.push('before two');\n      this.hiddenFromSibling = 'This should be hidden';\n    });\n\n    it('should work', function () {\n      expect(this.hiddenFromSibling, 'to equal', 'This should be hidden');\n    });\n  });\n\n  describe('sibling verifiction', function () {\n    beforeEach(function () {\n      this.calls.push('before sibling');\n    });\n\n    it('should not have value set within a sibling describe', function () {\n      expect('This should be hidden', 'not to equal', this.hiddenFromSibling);\n      this.visibleFromTestSibling = 'Visible from test sibling';\n    });\n\n    it('should allow test siblings to modify shared context', function () {\n      expect(\n        'Visible from test sibling',\n        'to equal',\n        this.visibleFromTestSibling\n      );\n    });\n\n    it('should have reset this.calls before describe', function () {\n      expect(this.calls, 'to equal', ['before', 'before sibling']);\n    });\n  });\n\n  after(function () {\n    expect(this.calls, 'to equal', ['before', 'before sibling']);\n  });\n});\n\ndescribe('methods', function () {\n  describe('timeout()', function () {\n    it('should return the timeout', function () {\n      // set this explicitly because browser and node use diff settings\n      this.timeout(1000);\n      expect(this.timeout(), 'to be', 1000);\n    });\n  });\n\n  describe('slow()', function () {\n    it('should return the slow', function () {\n      expect(this.slow(), 'to be', 75);\n    });\n  });\n\n  describe('retries', function () {\n    it('should return the number of retries', function () {\n      expect(this.retries(), 'to be', -1);\n    });\n  });\n});"}
{"prompt":"suite A,  => {","test":"'use strict';\nvar assert = require('assert');\n\nfunction getTitle(ctx) {\n  return ctx.currentTest && ctx.currentTest.title;\n};\n\nbefore(function () {\n  assert.strictEqual(getTitle(this), undefined);\n});\n\ndescribe('suite A', () => {\n\n  before(function () {\n    assert.strictEqual(getTitle(this), undefined);\n  });\n\n  describe('suite B', () => {\n\n    it('test1 B', () => {});\n\n    describe('suite C', function () {\n      var lap = 0;\n\n      before(function () {\n        assert.strictEqual(getTitle(this), 'test1 C');\n      });\n      beforeEach(function () {\n        assert.strictEqual(getTitle(this), ++lap === 1 ? 'test1 C' : 'test2 C');\n      });\n\n      it('test1 C', function () {});\n      it('test2 C', function () {});\n\n      afterEach(function () {\n        assert.strictEqual(getTitle(this), lap === 1 ? 'test1 C' : 'test2 C');\n      });\n      after(function () {\n        assert.strictEqual(getTitle(this), 'test2 C');\n      });\n    });\n  });\n});\n\nafter(function () {\n  assert.strictEqual(getTitle(this), undefined);\n});"}
{"prompt":"Test generated from existing file","test":"global.required ?= []\nglobal.required.push 'd.coffee'"}
{"prompt":"test, function  {};","test":"'use strict';\n\nsetTimeout(function () {\n  throw new Error('oops');\n  /* eslint no-unreachable: off */\n  it('test', function () {});\n  run();\n}, 100);"}
{"prompt":"delayed execution should execute exclusive tests only, function  {","test":"'use strict';\n\nvar assert = require('assert');\nvar delay = 200;\n\nsetTimeout(function () {\n  describe('delayed execution should execute exclusive tests only', function () {\n    it('should not run this test', function () {\n      (true).should.equal(false);\n    });\n\n    it.only('should run this', function () {});\n\n    it('should not run this test, neither', function () {\n      (true).should.equal(false);\n    });\n\n    it.only('should run this, too', function () {});\n  });\n\n  run();\n}, delay);"}
{"prompt":"delayed execution, function  {","test":"'use strict';\n\nvar assert = require('assert');\nvar delay = 200;\n\nsetTimeout(function () {\n  describe('delayed execution', function () {\n    it('should have no effect if attempted twice in the same suite', function () {\n      assert(true);\n      run();\n      assert(true);\n    });\n  });\n\n  run();\n}, delay);"}
{"prompt":"--delay, function  {","test":"'use strict';\n\nvar path = require('node:path').posix;\nvar helpers = require('../helpers');\nvar runMochaJSON = helpers.runMochaJSON;\n\ndescribe('--delay', function () {\n  var args = [];\n\n  before(function () {\n    args = ['--delay'];\n  });\n\n  it('should run the generated test suite', function (done) {\n    var fixture = path.join('options', 'delay');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have passed').and('to have passed test count', 1);\n      done();\n    });\n  });\n\n  it('should execute exclusive tests only', function (done) {\n    var fixture = path.join('options', 'delay-only');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have passed')\n        .and('to have passed test count', 2)\n        .and(\n          'to have passed test order',\n          'should run this',\n          'should run this, too'\n        );\n      done();\n    });\n  });\n\n  it('should throw an error if the test suite failed to run', function (done) {\n    var fixture = path.join('options', 'delay-fail');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have failed').and(\n        'to have failed test',\n        'Uncaught error outside test suite'\n      );\n      done();\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"module.exports.testShouldFail = false;"}
{"prompt":"consolidates identical calls to deprecate, function {","test":"'use strict';\n\nvar errors = require(\"../../../lib/errors\");\n\nit('consolidates identical calls to deprecate', function() {\n  errors.deprecate(\"suite foo did a deprecated thing\");\n  errors.deprecate(\"suite foo did a deprecated thing\");\n  errors.deprecate(\"suite bar did a deprecated thing\");\n});"}
{"prompt":"utils.deprecate test, function  {","test":"'use strict';\n\nvar assert = require('node:assert');\nvar run = require('./helpers').runMocha;\nvar args = [];\n\ndescribe('utils.deprecate test', function () {\n  it('should print unique deprecation only once', function (done) {\n    run(\n      'deprecate.fixture.js',\n      args,\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n        var result = res.output.match(/deprecated thing/g) || [];\n        assert.strictEqual(result.length, 2);\n        done();\n      },\n      {stdio: 'pipe'}\n    );\n  });\n});"}
{"prompt":"Test generated from existing file","test":"body {\n  font: \"Helvetica Neue\", Helvetica, arial, sans-serif;\n  background: black;\n  color: white;\n}\n\na {\n  color: blue\n}"}
{"prompt":"Test generated from existing file","test":"body {\n  font: \"Helvetica Neue\", Helvetica, arial, sans-serif;\n  background: black;\n  color: #fff;\n}\n\na {\n  color: blue;\n}\n\nfoo {\n  bar: 'baz';\n}"}
{"prompt":"assert is used because unexpected doesnt use mochas diffs.","test":"'use strict';\n\n// assert is used because unexpected doesn't use mocha's diffs.\nvar assert = require('assert');\nvar fs = require('fs');\nvar cssin = fs.readFileSync('test/integration/fixtures/diffs/diffs.css.in', 'ascii');\nvar cssout = fs.readFileSync('test/integration/fixtures/diffs/diffs.css.out', 'ascii');\n\ndescribe('diffs', function () {\n  var actual, expected;\n\n  it('should display a diff for small strings', function () {\n    actual = 'foo rar baz';\n    expected = 'foo bar baz';\n    assert.strictEqual(actual, expected);\n  });\n\n  it('should display a diff of canonicalized objects', function () {\n    actual = { name: 'travis j', age: 23 };\n    expected = { age: 23, name: 'travis' };\n    assert.deepStrictEqual(actual, expected);\n  });\n\n  it('should display a diff for medium strings', function () {\n    actual = 'foo bar baz\\nfoo rar baz\\nfoo bar raz';\n    expected = 'foo bar baz\\nfoo bar baz\\nfoo bar baz';\n    assert.strictEqual(actual, expected);\n  });\n\n  it('should display a diff for entire object dumps', function () {\n    actual = {\n      name: 'joel',\n      age: 30,\n      address: {\n        city: 'new york',\n        country: 'usa'\n      }\n    };\n    expected = {\n      name: 'joe',\n      age: 30,\n      address: {\n        city: 'new york',\n        country: 'us'\n      }\n    };\n    assert.deepStrictEqual(actual, expected);\n  });\n\n  it('should display a diff for multi-line strings', function () {\n    actual = 'one two three\\nfour zzzz six\\nseven eight nine';\n    expected = 'one two three\\nfour five six\\nseven eight nine';\n    assert.strictEqual(actual, expected);\n  });\n\n  it('should display a diff for entire object dumps', function () {\n    actual = {\n      name: 'joel',\n      age: 30,\n      address: {\n        city: 'new york',\n        country: 'usa'\n      }\n    };\n    expected = {\n      name: 'joe',\n      age: 30,\n      address: {\n        city: 'new york',\n        country: 'us'\n      }\n    };\n    assert.deepStrictEqual(actual, expected);\n  });\n\n  it('should display a full-comparison with escaped special characters', function () {\n    actual = 'one\\ttab\\ntwo\\t\\t\\ttabs';\n    expected = 'one\\ttab\\ntwo\\t\\ttabs';\n    assert.strictEqual(actual, expected);\n  });\n\n  it('should display a word diff for large strings', function () {\n    assert.strictEqual(cssin, cssout);\n  });\n\n  it('should work with objects', function () {\n    actual = {\n      name: 'tobi',\n      species: 'ferret',\n      color: 'white',\n      age: 2\n    };\n\n    expected = {\n      name: 'loki',\n      species: 'ferret',\n      color: 'brown',\n      age: 2\n    };\n\n    assert.deepStrictEqual(actual, expected);\n  });\n\n  it('should show value diffs and not be affected by commas', function () {\n    actual = { a: 123 };\n    expected = { a: 123, b: 456 };\n    assert.deepStrictEqual(actual, expected);\n  });\n\n  it('should display diff by data and not like an objects', function () {\n    actual = Buffer.from([0x01]);\n    expected = Buffer.from([0x02]);\n    assert.deepStrictEqual(actual, expected);\n  });\n});"}
{"prompt":"New spec, e.g. 1 spec tle","test":"'use strict';\n\nvar helpers = require('./helpers');\nvar run = helpers.runMocha;\nvar fs = require('node:fs');\nvar path = require('node:path');\n\n/**\n * Returns an array of diffs corresponding to exceptions thrown from specs,\n * given the plaintext output (-C) of a mocha run.\n *\n * @param  {string}   output\n * returns {string[]}\n */\nfunction getDiffs(output) {\n  var diffs, i, inDiff, inStackTrace;\n\n  diffs = [];\n  output.split('\\n').forEach(function (line) {\n    if (line.match(/^\\s{2}\\d+\\)/)) {\n      // New spec, e.g. \"1) spec title\"\n      diffs.push([]);\n      i = diffs.length - 1;\n      inStackTrace = false;\n      inDiff = false;\n    } else if (!diffs.length || inStackTrace) {\n      // Haven't encountered a spec yet\n      // or we're in the middle of a stack trace\n    } else if (line.indexOf('+ expected - actual') !== -1) {\n      inDiff = true;\n    } else if (line.match(/at Context/)) {\n      // At the start of a stack trace\n      inStackTrace = true;\n      inDiff = false;\n    } else if (inDiff) {\n      diffs[i].push(line);\n    }\n  });\n\n  return diffs.map(function (diff) {\n    return diff\n      .filter(function (line) {\n        return line.trim().length;\n      })\n      .join('\\n');\n  });\n}\n\n/**\n * Returns content of test/integration/fixtures/diffs/output,\n * post-processed for consumption by tests.\n * @returns {string[]} Array of diff lines\n */\nfunction getExpectedOutput() {\n  var output = fs\n    .readFileSync(path.join(__dirname, 'fixtures', 'diffs', 'output'), 'UTF8')\n    .replace(/\\r\\n/g, '\\n');\n\n  // Diffs are delimited in file by \"// DIFF\"\n  return output\n    .split(/\\s*\\/\\/ DIFF/)\n    .slice(1)\n    .map(function (diff) {\n      return diff.split('\\n').filter(Boolean).join('\\n');\n    });\n}\n\ndescribe('diffs', function () {\n  var diffs, expected;\n\n  before(function (done) {\n    run('diffs/diffs.fixture.js', [], function (err, res) {\n      if (err) {\n        done(err);\n        return;\n      }\n      expected = getExpectedOutput();\n      diffs = getDiffs(res.output.replace(/\\r\\n/g, '\\n'));\n      done();\n    });\n  });\n\n  [\n    'should display a diff for small strings',\n    'should display a diff of canonicalized objects',\n    'should display a diff for medium strings',\n    'should display a diff for entire object dumps',\n    'should display a diff for multi-line strings',\n    'should display a diff for entire object dumps',\n    'should display a full-comparison with escaped special characters',\n    'should display a word diff for large strings',\n    'should work with objects',\n    'should show value diffs and not be affected by commas',\n    'should display diff by data and not like an objects'\n  ].forEach(function (title, i) {\n    it(title, function () {\n      expect(diffs[i], 'to be', expected[i]);\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\nconst Mocha = require('../../../../lib/mocha');\n\nconst mocha = new Mocha({ reporter: 'json' });\nmocha.dispose();\nrequire('./run-thrice-helper')(mocha);"}
{"prompt":"Doc reporter, function  {","test":"'use strict';\n\nvar events = require('../../').Runner.constants;\nvar helpers = require('./helpers');\nvar reporters = require('../../').reporters;\n\nvar Doc = reporters.Doc;\nvar createMockRunner = helpers.createMockRunner;\nvar makeRunReporter = helpers.createRunReporterFunction;\n\nvar EVENT_SUITE_BEGIN = events.EVENT_SUITE_BEGIN;\nvar EVENT_SUITE_END = events.EVENT_SUITE_END;\nvar EVENT_TEST_FAIL = events.EVENT_TEST_FAIL;\nvar EVENT_TEST_PASS = events.EVENT_TEST_PASS;\n\ndescribe('Doc reporter', function () {\n  var runner;\n  var options = {};\n  var runReporter = makeRunReporter(Doc);\n\n  afterEach(function () {\n    runner = null;\n  });\n\n  describe('event handlers', function () {\n    describe(\"on 'suite' event\", function () {\n      describe('when suite root does not exist', function () {\n        var expectedTitle = 'expectedTitle';\n        var unescapedTitle = '<div>' + expectedTitle + '</div>';\n        var suite = {\n          root: false,\n          title: expectedTitle\n        };\n\n        it('should log html with indents and expected title', function () {\n          runner = createMockRunner(\n            'suite',\n            EVENT_SUITE_BEGIN,\n            null,\n            null,\n            suite\n          );\n          var stdout = runReporter(this, runner, options);\n          var expectedArray = [\n            '    <section class=\"suite\">\\n',\n            '      <h1>' + expectedTitle + '</h1>\\n',\n            '      <dl>\\n'\n          ];\n          expect(stdout, 'to equal', expectedArray);\n        });\n\n        it('should escape title where necessary', function () {\n          var suite = {\n            root: false,\n            title: unescapedTitle\n          };\n          expectedTitle =\n            '&#x3C;div&#x3E;' + expectedTitle + '&#x3C;/div&#x3E;';\n\n          runner = createMockRunner(\n            'suite',\n            EVENT_SUITE_BEGIN,\n            null,\n            null,\n            suite\n          );\n          var stdout = runReporter(this, runner, options);\n          var expectedArray = [\n            '    <section class=\"suite\">\\n',\n            '      <h1>' + expectedTitle + '</h1>\\n',\n            '      <dl>\\n'\n          ];\n          expect(stdout, 'to equal', expectedArray);\n        });\n      });\n\n      describe('when suite root exists', function () {\n        var suite = {\n          root: true\n        };\n\n        it('should not log any html', function () {\n          runner = createMockRunner(\n            'suite',\n            EVENT_SUITE_BEGIN,\n            null,\n            null,\n            suite\n          );\n          var stdout = runReporter(this, runner, options);\n          expect(stdout, 'to be empty');\n        });\n      });\n    });\n\n    describe(\"on 'suite end' event\", function () {\n      describe('when suite root does not exist', function () {\n        var suite = {\n          root: false\n        };\n\n        it('should log expected html with indents', function () {\n          runner = createMockRunner(\n            'suite end',\n            EVENT_SUITE_END,\n            null,\n            null,\n            suite\n          );\n          var stdout = runReporter(this, runner, options);\n          var expectedArray = ['  </dl>\\n', '</section>\\n'];\n          expect(stdout, 'to equal', expectedArray);\n        });\n      });\n\n      describe('when suite root exists', function () {\n        var suite = {\n          root: true\n        };\n\n        it('should not log any html', function () {\n          runner = createMockRunner(\n            'suite end',\n            EVENT_SUITE_END,\n            null,\n            null,\n            suite\n          );\n          var stdout = runReporter(this, runner, options);\n          expect(stdout, 'to be empty');\n        });\n      });\n    });\n\n    describe(\"on 'pass' event\", function () {\n      var expectedTitle = 'some tite';\n      var expectedFile = 'testFile.spec.js';\n      var expectedBody = 'some body';\n      var test = {\n        title: expectedTitle,\n        file: expectedFile,\n        body: expectedBody,\n        slow: function () {\n          return '';\n        }\n      };\n\n      it('should log html with indents, expected title, and body', function () {\n        runner = createMockRunner('pass', EVENT_TEST_PASS, null, null, test);\n        var stdout = runReporter(this, runner, options);\n        var expectedArray = [\n          '    <dt>' + expectedTitle + '</dt>\\n',\n          '    <dt>' + expectedFile + '</dt>\\n',\n          '    <dd><pre><code>' + expectedBody + '</code></pre></dd>\\n'\n        ];\n        expect(stdout, 'to equal', expectedArray);\n      });\n\n      it('should escape title and body where necessary', function () {\n        var unescapedTitle = '<div>' + expectedTitle + '</div>';\n        var unescapedFile = '<div>' + expectedFile + '</div>';\n        var unescapedBody = '<div>' + expectedBody + '</div>';\n        test.title = unescapedTitle;\n        test.file = unescapedFile;\n        test.body = unescapedBody;\n\n        var expectedEscapedTitle =\n          '&#x3C;div&#x3E;' + expectedTitle + '&#x3C;/div&#x3E;';\n        var expectedEscapedFile =\n          '&#x3C;div&#x3E;' + expectedFile + '&#x3C;/div&#x3E;';\n        var expectedEscapedBody =\n          '&#x3C;div&#x3E;' + expectedBody + '&#x3C;/div&#x3E;';\n        runner = createMockRunner('pass', EVENT_TEST_PASS, null, null, test);\n        var stdout = runReporter(this, runner, options);\n        var expectedArray = [\n          '    <dt>' + expectedEscapedTitle + '</dt>\\n',\n          '    <dt>' + expectedEscapedFile + '</dt>\\n',\n          '    <dd><pre><code>' + expectedEscapedBody + '</code></pre></dd>\\n'\n        ];\n        expect(stdout, 'to equal', expectedArray);\n      });\n    });\n\n    describe(\"on 'fail' event\", function () {\n      var expectedTitle = 'some tite';\n      var expectedFile = 'testFile.spec.js';\n      var expectedBody = 'some body';\n      var expectedError = 'some error';\n      var test = {\n        title: expectedTitle,\n        file: expectedFile,\n        body: expectedBody,\n        slow: function () {\n          return '';\n        }\n      };\n\n      it('should log html with indents, expected title, body, and error', function () {\n        runner = createMockRunner(\n          'fail two args',\n          EVENT_TEST_FAIL,\n          null,\n          null,\n          test,\n          expectedError\n        );\n        var stdout = runReporter(this, runner, options);\n        var expectedArray = [\n          '    <dt class=\"error\">' + expectedTitle + '</dt>\\n',\n          '    <dt class=\"error\">' + expectedFile + '</dt>\\n',\n          '    <dd class=\"error\"><pre><code>' +\n            expectedBody +\n            '</code></pre></dd>\\n',\n          '    <dd class=\"error\">' + expectedError + '</dd>\\n'\n        ];\n        expect(stdout, 'to equal', expectedArray);\n      });\n\n      it('should escape title, body, and error where necessary', function () {\n        var unescapedTitle = '<div>' + expectedTitle + '</div>';\n        var unescapedFile = '<div>' + expectedFile + '</div>';\n        var unescapedBody = '<div>' + expectedBody + '</div>';\n        var unescapedError = '<div>' + expectedError + '</div>';\n        test.title = unescapedTitle;\n        test.file = unescapedFile;\n        test.body = unescapedBody;\n\n        var expectedEscapedTitle =\n          '&#x3C;div&#x3E;' + expectedTitle + '&#x3C;/div&#x3E;';\n        var expectedEscapedFile =\n          '&#x3C;div&#x3E;' + expectedFile + '&#x3C;/div&#x3E;';\n        var expectedEscapedBody =\n          '&#x3C;div&#x3E;' + expectedBody + '&#x3C;/div&#x3E;';\n        var expectedEscapedError =\n          '&#x3C;div&#x3E;' + expectedError + '&#x3C;/div&#x3E;';\n        runner = createMockRunner(\n          'fail two args',\n          EVENT_TEST_FAIL,\n          null,\n          null,\n          test,\n          unescapedError\n        );\n        var stdout = runReporter(this, runner, options);\n        var expectedArray = [\n          '    <dt class=\"error\">' + expectedEscapedTitle + '</dt>\\n',\n          '    <dt class=\"error\">' + expectedEscapedFile + '</dt>\\n',\n          '    <dd class=\"error\"><pre><code>' +\n            expectedEscapedBody +\n            '</code></pre></dd>\\n',\n          '    <dd class=\"error\">' + expectedEscapedError + '</dd>\\n'\n        ];\n        expect(stdout, 'to equal', expectedArray);\n      });\n    });\n  });\n});"}
{"prompt":"Dot reporter, function  {","test":"'use strict';\n\nvar sinon = require('sinon');\nvar events = require('../../').Runner.constants;\nvar helpers = require('./helpers');\nvar reporters = require('../../').reporters;\n\nvar Base = reporters.Base;\nvar Dot = reporters.Dot;\nvar createMockRunner = helpers.createMockRunner;\nvar makeRunReporter = helpers.createRunReporterFunction;\n\nvar EVENT_RUN_BEGIN = events.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = events.EVENT_RUN_END;\nvar EVENT_TEST_FAIL = events.EVENT_TEST_FAIL;\nvar EVENT_TEST_PASS = events.EVENT_TEST_PASS;\nvar EVENT_TEST_PENDING = events.EVENT_TEST_PENDING;\n\ndescribe('Dot reporter', function () {\n  var windowWidthStub;\n  var runReporter = makeRunReporter(Dot);\n  var noop = function () {};\n\n  beforeEach(function () {\n    windowWidthStub = sinon.stub(Base.window, 'width').value(0);\n    sinon.stub(Base, 'useColors').value(false);\n    sinon.stub(Base, 'color').callsFake(function (type, str) {\n      return type.replace(/ /g, '-') + '_' + str;\n    });\n  });\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('event handlers', function () {\n    describe(\"on 'start' event\", function () {\n      it('should write a newline', function () {\n        var runner = createMockRunner('start', EVENT_RUN_BEGIN);\n        var options = {};\n        var stdout = runReporter({epilogue: noop}, runner, options);\n        sinon.restore();\n\n        var expectedArray = ['\\n'];\n        expect(stdout, 'to equal', expectedArray);\n      });\n    });\n\n    describe(\"on 'pending' event\", function () {\n      describe('when window width is greater than 1', function () {\n        beforeEach(function () {\n          windowWidthStub.value(2);\n        });\n\n        it('should write a newline followed by a comma', function () {\n          var runner = createMockRunner('pending', EVENT_TEST_PENDING);\n          var options = {};\n          var stdout = runReporter({epilogue: noop}, runner, options);\n          sinon.restore();\n\n          var expectedArray = ['\\n  ', 'pending_' + Base.symbols.comma];\n          expect(stdout, 'to equal', expectedArray);\n        });\n      });\n\n      describe('when window width is less than or equal to 1', function () {\n        it('should write a comma', function () {\n          var runner = createMockRunner('pending', EVENT_TEST_PENDING);\n          var options = {};\n          var stdout = runReporter({epilogue: noop}, runner, options);\n          sinon.restore();\n\n          var expectedArray = ['pending_' + Base.symbols.comma];\n          expect(stdout, 'to equal', expectedArray);\n        });\n      });\n    });\n\n    describe(\"on 'pass' event\", function () {\n      var test = {\n        duration: 1,\n        slow: function () {\n          return 2;\n        }\n      };\n\n      describe('when window width is greater than 1', function () {\n        beforeEach(function () {\n          windowWidthStub.value(2);\n        });\n\n        describe('when test speed is fast', function () {\n          it('should write a newline followed by a dot', function () {\n            var runner = createMockRunner(\n              'pass',\n              EVENT_TEST_PASS,\n              null,\n              null,\n              test\n            );\n            var options = {};\n            var stdout = runReporter({epilogue: noop}, runner, options);\n            sinon.restore();\n\n            expect(test.speed, 'to equal', 'fast');\n            var expectedArray = ['\\n  ', 'fast_' + Base.symbols.dot];\n            expect(stdout, 'to equal', expectedArray);\n          });\n        });\n      });\n\n      describe('when window width is less than or equal to 1', function () {\n        describe('when test speed is fast', function () {\n          it('should write a grey dot', function () {\n            var runner = createMockRunner(\n              'pass',\n              EVENT_TEST_PASS,\n              null,\n              null,\n              test\n            );\n            var options = {};\n            var stdout = runReporter({epilogue: noop}, runner, options);\n            sinon.restore();\n\n            expect(test.speed, 'to equal', 'fast');\n            var expectedArray = ['fast_' + Base.symbols.dot];\n            expect(stdout, 'to equal', expectedArray);\n          });\n        });\n\n        describe('when test speed is medium', function () {\n          it('should write a yellow dot', function () {\n            test.duration = 2;\n            var runner = createMockRunner(\n              'pass',\n              EVENT_TEST_PASS,\n              null,\n              null,\n              test\n            );\n            var options = {};\n            var stdout = runReporter({epilogue: noop}, runner, options);\n            sinon.restore();\n\n            expect(test.speed, 'to equal', 'medium');\n            var expectedArray = ['medium_' + Base.symbols.dot];\n            expect(stdout, 'to equal', expectedArray);\n          });\n        });\n\n        describe('when test speed is slow', function () {\n          it('should write a bright yellow dot', function () {\n            test.duration = 3;\n            var runner = createMockRunner(\n              'pass',\n              EVENT_TEST_PASS,\n              null,\n              null,\n              test\n            );\n            var options = {};\n            var stdout = runReporter({epilogue: noop}, runner, options);\n            sinon.restore();\n\n            expect(test.speed, 'to equal', 'slow');\n            var expectedArray = ['bright-yellow_' + Base.symbols.dot];\n            expect(stdout, 'to equal', expectedArray);\n          });\n        });\n      });\n    });\n\n    describe(\"on 'fail' event\", function () {\n      var test = {\n        test: {\n          err: 'some error'\n        }\n      };\n\n      describe('when window width is greater than 1', function () {\n        beforeEach(function () {\n          windowWidthStub.value(2);\n        });\n\n        it('should write a newline followed by an exclamation mark', function () {\n          var runner = createMockRunner(\n            'fail',\n            EVENT_TEST_FAIL,\n            null,\n            null,\n            test\n          );\n          var options = {};\n          var stdout = runReporter({epilogue: noop}, runner, options);\n          sinon.restore();\n\n          var expectedArray = ['\\n  ', 'fail_' + Base.symbols.bang];\n          expect(stdout, 'to equal', expectedArray);\n        });\n      });\n\n      describe('when window width is less than or equal to 1', function () {\n        it('should write an exclamation mark', function () {\n          var runner = createMockRunner(\n            'fail',\n            EVENT_TEST_FAIL,\n            null,\n            null,\n            test\n          );\n          var options = {};\n          var stdout = runReporter({epilogue: noop}, runner, options);\n          sinon.restore();\n\n          var expectedArray = ['fail_' + Base.symbols.bang];\n          expect(stdout, 'to equal', expectedArray);\n        });\n      });\n    });\n\n    describe(\"on 'end' event\", function () {\n      it('should call epilogue', function () {\n        var runner = createMockRunner('end', EVENT_RUN_END);\n        var fakeThis = {\n          epilogue: sinon.stub()\n        };\n        var options = {};\n        runReporter(fakeThis, runner, options);\n        sinon.restore();\n\n        expect(fakeThis.epilogue.called, 'to be true');\n      });\n    });\n  });\n});"}
{"prompt":"fails exactly once when a global error is thrown first, function done {","test":"'use strict';\n\n/**\n * This file should only generate one failure per spec despite the fact that\n * Mocha is capable of detecting two distinct exceptions during test execution.\n */\n\nit('fails exactly once when a global error is thrown first', function (done) {\n  process.nextTick(function () {\n    throw new Error('global error');\n  });\n});\n\nit('fails exactly once when a global error is thrown second', function (done) {\n  process.nextTick(function () {\n    done(new Error('test error'));\n  });\n\n  process.nextTick(function () {\n    throw new Error('global error');\n  });\n});"}
{"prompt":".onlysuite1, function {","test":"'use strict';\n\ndescribe.only('suite1', function() {\n  it.skip('test1 - report as skipped', function() { });\n\n  it('test2 - report as passed', function() { });\n\n  it('test3 - report as passed', function() {\n    throw new Error('this test should not run');\n  });\n});\n\ndescribe('suite2', function () {\n  before(function() {\n    throw new Error('this hook should not run');\n  });\n  beforeEach(function() {\n    throw new Error('this hook should not run');\n  });\n\n  it.only('test4 - report as passed', function () {\n    throw new Error('this test should not run');\n  });\n\n  it('test5 - should be ignored', function () {\n    throw new Error('this test should not run');\n  });\n\n  afterEach(function() {\n    throw new Error('this hook should not run');\n  });\n  after(function() {\n    throw new Error('this hook should not run');\n  });\n});"}
{"prompt":"--dry-run, function  {","test":"'use strict';\n\nvar path = require('node:path').posix;\nvar helpers = require('../helpers');\nvar runMochaJSON = helpers.runMochaJSON;\n\ndescribe('--dry-run', function () {\n  var args = ['--dry-run'];\n\n  it('should only report, but not execute any test', function (done) {\n    var fixture = path.join('options/dry-run', 'dry-run');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have passed')\n        .and(\n          'to have passed tests',\n          'test2 - report as passed',\n          'test3 - report as passed',\n          'test4 - report as passed'\n        )\n        .and('to have passed test count', 3)\n        .and('to have pending test count', 1)\n        .and('to have failed test count', 0);\n      done();\n    });\n  });\n\n  it('should pass without \"RangeError: maximum call stack size exceeded\"', function (done) {\n    var fixture = path.join('options/dry-run', 'stack-size');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have passed test count', 400);\n      done();\n    });\n  });\n});"}
{"prompt":"when non-array argument is provided multiple times, function  {","test":"'use strict';\n\nvar runMochaJSON = require('./helpers').runMochaJSON;\n\ndescribe('when non-array argument is provided multiple times', function () {\n  describe('when the same argument name is used', function () {\n    it('should prefer the last value', function (done) {\n      runMochaJSON(\n        'passing-sync',\n        ['--no-async-only', '--async-only', '--no-async-only'],\n        function (err, result) {\n          if (err) {\n            return done(err);\n          }\n          expect(result, 'to have passed');\n          done();\n        }\n      );\n    });\n  });\n\n  describe('when a different argument name is used', function () {\n    it('should prefer the last value', function (done) {\n      runMochaJSON(\n        'passing-async',\n        ['--timeout', '100', '-t', '10'],\n        function (err, result) {\n          if (err) {\n            return done(err);\n          }\n          expect(result, 'to have failed');\n          done();\n        }\n      );\n    });\n  });\n});"}
{"prompt":"durations, function  {","test":"'use strict';\n\ndescribe('durations', function () {\n  describe('when slow', function () {\n    it('should highlight in red', function (done) {\n      setTimeout(function () {\n        done();\n      }, 100);\n    });\n  });\n\n  describe('when reasonable', function () {\n    it('should highlight in yellow', function (done) {\n      setTimeout(function () {\n        done();\n      }, 50);\n    });\n  });\n\n  describe('when fast', function () {\n    it('should not highlight', function (done) {\n      setTimeout(function () {\n        done();\n      }, 10);\n    });\n  });\n});"}
{"prompt":"retries, function  {","test":"'use strict';\nconst assert = require('assert');\n\ndescribe('retries', function () {\n  this.retries(1);\n  var times = 0;\n  var self = this;\n\n  it('should pass after 1 retry', function () {\n    times++;\n    if (times !== 2) {\n      throw new Error('retry error ' + times);\n    }\n  });\n  \n  it('check for updated `suite.tests`', function() {\n    assert.strictEqual(self.tests[0]._currentRetry, 1);\n    assert.ok(self.tests[0]._retriedTest);\n    assert.strictEqual(self.tests[0].state, 'passed');\n  })\n});"}
{"prompt":"Errors, function  {","test":"'use strict';\n\nvar errors = require('../../lib/errors');\nconst sinon = require('sinon');\nconst {createNoFilesMatchPatternError} = require('../../lib/errors');\n\ndescribe('Errors', function () {\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  var message = 'some message';\n\n  describe('createInvalidReporterError()', function () {\n    it('should include expected code in thrown reporter errors', function () {\n      expect(\n        errors.createInvalidReporterError(message, 'badReporter'),\n        'to satisfy',\n        {\n          message,\n          code: 'ERR_MOCHA_INVALID_REPORTER',\n          reporter: 'badReporter'\n        }\n      );\n    });\n  });\n\n  describe('createInvalidInterfaceError()', function () {\n    it('should include expected code in thrown interface errors', function () {\n      expect(\n        errors.createInvalidInterfaceError(message, 'badUi'),\n        'to satisfy',\n        {\n          message,\n          code: 'ERR_MOCHA_INVALID_INTERFACE',\n          interface: 'badUi'\n        }\n      );\n    });\n  });\n\n  describe('createForbiddenExclusivityError()', function () {\n    describe('when Mocha instance is running in a worker process', function () {\n      it('should output a message regarding incompatibility', function () {\n        var mocha = {isWorker: true};\n        expect(\n          errors.createForbiddenExclusivityError(mocha, {}),\n          'to satisfy',\n          {\n            message: /parallel/,\n            code: errors.constants.FORBIDDEN_EXCLUSIVITY\n          }\n        );\n      });\n    });\n\n    describe('when Mocha instance is not running in a worker process', function () {\n      it('should output a message regarding --forbid-only', function () {\n        var mocha = {};\n        expect(\n          errors.createForbiddenExclusivityError(mocha, {}),\n          'to satisfy',\n          {\n            message: /--forbid-only/,\n            code: errors.constants.FORBIDDEN_EXCLUSIVITY\n          }\n        );\n      });\n    });\n  });\n\n  describe('createUnparsableFileError()', function () {\n    it('should include expected code in thrown unparsable file errors', function () {\n      expect(\n        errors.createUnparsableFileError(message, 'badFilePath'),\n        'to satisfy',\n        {\n          message,\n          code: 'ERR_MOCHA_UNPARSABLE_FILE'\n        }\n      );\n    });\n  });\n\n  describe('deprecate()', function () {\n    var emitWarning;\n\n    beforeEach(function () {\n      if (process.emitWarning) {\n        emitWarning = process.emitWarning;\n        sinon.stub(process, 'emitWarning');\n      } else {\n        process.emitWarning = sinon.spy();\n      }\n      errors.deprecate.cache = {};\n    });\n\n    afterEach(function () {\n      // if this is not set, then we created it, so we should remove it.\n      if (!emitWarning) {\n        delete process.emitWarning;\n      }\n    });\n\n    it('should coerce its parameter to a string', function () {\n      errors.deprecate(1);\n      expect(process.emitWarning, 'to have a call satisfying', [\n        '1',\n        'DeprecationWarning'\n      ]);\n    });\n\n    it('should cache the message', function () {\n      errors.deprecate('foo');\n      errors.deprecate('foo');\n      expect(process.emitWarning, 'was called times', 1);\n    });\n\n    it('should ignore falsy messages', function () {\n      errors.deprecate('');\n      expect(process.emitWarning, 'was not called');\n    });\n  });\n\n  describe('warn()', function () {\n    var emitWarning;\n\n    beforeEach(function () {\n      if (process.emitWarning) {\n        emitWarning = process.emitWarning;\n        sinon.stub(process, 'emitWarning');\n      } else {\n        process.emitWarning = sinon.spy();\n      }\n    });\n\n    afterEach(function () {\n      // if this is not set, then we created it, so we should remove it.\n      if (!emitWarning) {\n        delete process.emitWarning;\n      }\n    });\n\n    it('should call process.emitWarning', function () {\n      errors.warn('foo');\n      expect(process.emitWarning, 'was called times', 1);\n    });\n\n    it('should not cache messages', function () {\n      errors.warn('foo');\n      errors.warn('foo');\n      expect(process.emitWarning, 'was called times', 2);\n    });\n\n    it('should ignore falsy messages', function () {\n      errors.warn('');\n      expect(process.emitWarning, 'was not called');\n    });\n  });\n\n  describe('isMochaError()', function () {\n    describe('when provided an Error object having a known Mocha error code', function () {\n      it('should return true', function () {\n        expect(\n          errors.isMochaError(createNoFilesMatchPatternError('derp')),\n          'to be true'\n        );\n      });\n    });\n\n    describe('when provided an Error object with a non-Mocha error code', function () {\n      it('should return false', function () {\n        const err = new Error();\n        err.code = 'ENOTEA';\n        expect(errors.isMochaError(err), 'to be false');\n      });\n    });\n\n    describe('when provided a non-error', function () {\n      it('should return false', function () {\n        expect(errors.isMochaError(), 'to be false');\n      });\n    });\n  });\n});"}
{"prompt":"should use a function from an esm, and fail,  => {","test":"import {add} from './add.mjs';\n\nit('should use a function from an esm, and fail', () => {\n  expect(add(3, 5), 'to be', 9);\n});"}
{"prompt":"should use a function from an esm module with a js extension,  => {","test":"import {add} from './add.js';\n\nit('should use a function from an esm module with a js extension', () => {\n  expect(add(3, 5), 'to be', 8);\n});"}
{"prompt":"should use a function from an esm,  => {","test":"import {add} from './add.mjs';\n\nit('should use a function from an esm', () => {\n  expect(add(3, 5), 'to be', 8);\n});"}
{"prompt":"This is intentionally a syntax error","test":"// This is intentionally a syntax error\nit('should never run because of a syntax error here', => {\n});"}
{"prompt":"esm-utils, function  {","test":"'use strict';\n\nconst esmUtils = require('../../lib/nodejs/esm-utils');\nconst sinon = require('sinon');\nconst url = require('node:url');\n\ndescribe('esm-utils', function () {\n  beforeEach(function () {\n    sinon.stub(esmUtils, 'doImport').resolves({});\n  });\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('loadFilesAsync()', function () {\n    it('should not decorate imported module if no decorator passed', async function () {\n      await esmUtils.loadFilesAsync(\n        ['/foo/bar.mjs'],\n        () => {},\n        () => {}\n      );\n\n      expect(\n        esmUtils.doImport.firstCall.args[0].toString(),\n        'to be',\n        url.pathToFileURL('/foo/bar.mjs').toString()\n      );\n    });\n\n    it('should decorate imported module with passed decorator', async function () {\n      await esmUtils.loadFilesAsync(\n        ['/foo/bar.mjs'],\n        () => {},\n        () => {},\n        x => `${x}?foo=bar`\n      );\n\n      expect(\n        esmUtils.doImport.firstCall.args[0].toString(),\n        'to be',\n        `${url.pathToFileURL('/foo/bar.mjs').toString()}?foo=bar`\n      );\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"/* eslint-disable-next-line import/no-absolute-path */\nimport '/base/mocha.js';\nwindow.MOCHA_IS_OK = true;"}
{"prompt":"esm, function  {","test":"'use strict';\nvar path = require('node:path');\nconst {runMochaJSON: run, runMochaAsync} = require('./helpers');\nvar args = [];\n\ndescribe('esm', function () {\n  it('should pass a passing esm test that uses esm', function (done) {\n    var fixture = 'esm/esm-success.fixture.mjs';\n    run(fixture, args, function (err, result) {\n      if (err) {\n        done(err);\n        return;\n      }\n\n      expect(result, 'to have passed test count', 1);\n      done();\n    });\n  });\n\n  it('should fail a failing esm test that uses esm', function (done) {\n    var fixture = 'esm/esm-failure.fixture.mjs';\n    run(fixture, args, function (err, result) {\n      if (err) {\n        done(err);\n        return;\n      }\n\n      expect(result, 'to have failed test count', 1).and(\n        'to have failed test',\n        'should use a function from an esm, and fail'\n      );\n      done();\n    });\n  });\n\n  it('should show file location when there is a syntax error in the test', async function () {\n    var fixture = 'esm/syntax-error/esm-syntax-error.fixture.mjs';\n    const err = await runMochaAsync(fixture, args, {stdio: 'pipe'}).catch(\n      err => err\n    );\n    expect(err.output, 'to contain', 'SyntaxError').and(\n      'to contain',\n      'esm-syntax-error.fixture.mjs'\n    );\n  });\n\n  it('should recognize esm files ending with .js due to package.json type flag', function (done) {\n    var fixture = 'esm/js-folder/esm-in-js.fixture.js';\n    run(fixture, args, function (err, result) {\n      if (err) {\n        done(err);\n        return;\n      }\n\n      expect(result, 'to have passed test count', 1);\n      done();\n    });\n  });\n\n  it('should enable requiring/loading a cjs module with \"dir\" as filename', async function () {\n    var fixture = 'esm/test-that-uses-dir-cjs-require.fixture.js';\n    const result = await runMochaAsync(\n      fixture,\n      ['--require', path.resolve(__dirname, './fixtures/esm/dir-cjs-require')],\n      {stdio: 'pipe'}\n    );\n\n    expect(result, 'to have passed test count', 1);\n  });\n\n  it('should throw an ERR_MODULE_NOT_FOUND and not ERR_REQUIRE_ESM if file imports a non-existing module', async function () {\n    const fixture =\n      'esm/type-module/test-that-imports-non-existing-module.fixture.js';\n\n    const err = await runMochaAsync(fixture, ['--unhandled-rejections=warn'], {\n      stdio: 'pipe'\n    }).catch(err => err);\n\n    expect(err.output, 'to contain', 'ERR_MODULE_NOT_FOUND').and(\n      'to contain',\n      'test-that-imports-non-existing-module'\n    );\n  });\n\n  it('should throw an ERR_MODULE_NOT_FOUND and not ERR_REQUIRE_ESM if file imports a non-existing module with a loader', async function () {\n    const fixture =\n      'esm/loader-with-module-not-found/test-that-imports-non-existing-module.fixture.ts';\n\n    const err = await runMochaAsync(\n      fixture,\n      [\n        '--unhandled-rejections=warn',\n        '--loader=./test/integration/fixtures/esm/loader-with-module-not-found/loader-that-recognizes-ts.mjs'\n      ],\n      {\n        stdio: 'pipe'\n      }\n    ).catch(err => err);\n\n    expect(err.output, 'to contain', 'ERR_MODULE_NOT_FOUND').and(\n      'to contain',\n      'non-existent-package'\n    );\n  });\n});"}
{"prompt":"should register a global if it did not fail, function  {","test":"import './fixtures/esm.fixture.mjs';\n\nit('should register a global if it did not fail', function () {\n  expect(window.MOCHA_IS_OK, 'to be ok');\n});\n\nit('should has global Mocha', function () {\n  expect(window.Mocha, 'not to be', undefined);\n});"}
{"prompt":"console.logem: ${event};","test":"'use strict';\nvar Runner = require('../../../../lib/runner.js');\nvar assert = require('assert');\nvar constants = Runner.constants;\nvar EVENT_HOOK_BEGIN = constants.EVENT_HOOK_BEGIN;\nvar EVENT_HOOK_END = constants.EVENT_HOOK_END;\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\nvar EVENT_SUITE_END = constants.EVENT_SUITE_END;\nvar EVENT_TEST_BEGIN = constants.EVENT_TEST_BEGIN;\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\nvar EVENT_TEST_RETRY = constants.EVENT_TEST_RETRY;\n\nvar emitOrder = [\n EVENT_RUN_BEGIN,\n  EVENT_SUITE_BEGIN,\n  EVENT_SUITE_BEGIN,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_BEGIN,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_RETRY,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_BEGIN,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_FAIL,\n  EVENT_TEST_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_SUITE_END,\n  EVENT_SUITE_END,\n  EVENT_RUN_END\n];\n\nvar realEmit = Runner.prototype.emit;\nRunner.prototype.emit = function(event, ...args) {\n  // console.log(`emit: ${event}`);\n  assert.strictEqual(event, emitOrder.shift());\n  return realEmit.call(this, event, ...args);\n};\n\ndescribe('suite A', function() {\n  before('before', function() {});\n  beforeEach('beforeEach', function() {});\n  it('test A', function() {\n    throw new Error('error test A');\n  });\n  afterEach('afterEach', function() {});\n  after('after', function() {});\n});"}
{"prompt":"suite A, function {","test":"'use strict';\nvar Runner = require('../../../../lib/runner.js');\nvar assert = require('assert');\nvar constants = Runner.constants;\nvar EVENT_HOOK_BEGIN = constants.EVENT_HOOK_BEGIN;\nvar EVENT_HOOK_END = constants.EVENT_HOOK_END;\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\nvar EVENT_SUITE_END = constants.EVENT_SUITE_END;\nvar EVENT_TEST_BEGIN = constants.EVENT_TEST_BEGIN;\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\n\nvar emitOrder = [\n  EVENT_RUN_BEGIN,\n  EVENT_SUITE_BEGIN,\n  EVENT_SUITE_BEGIN,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_BEGIN,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_FAIL,\n  EVENT_TEST_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_SUITE_END,\n  EVENT_SUITE_END,\n  EVENT_RUN_END\n];\n\nvar realEmit = Runner.prototype.emit;\nRunner.prototype.emit = function(event, ...args) {\n  assert.strictEqual(event, emitOrder.shift());\n  return realEmit.call(this, event, ...args);\n};\n\ndescribe('suite A', function() {\n  before('before', function() {});\n  beforeEach('beforeEach', function() {});\n  it('test A', function() {\n    throw new Error('error test A');\n  });\n  describe('suite B', function() {\n    it('test B', function() {});\n  });\n  afterEach('afterEach', function() {});\n  after('after', function() {});\n});"}
{"prompt":"suite A, function {","test":"'use strict';\nvar Runner = require('../../../../lib/runner.js');\nvar assert = require('assert');\nvar constants = Runner.constants;\nvar EVENT_DELAY_BEGIN = constants.EVENT_DELAY_BEGIN;\nvar EVENT_DELAY_END = constants.EVENT_DELAY_END;\nvar EVENT_HOOK_BEGIN = constants.EVENT_HOOK_BEGIN;\nvar EVENT_HOOK_END = constants.EVENT_HOOK_END;\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\nvar EVENT_SUITE_END = constants.EVENT_SUITE_END;\nvar EVENT_TEST_BEGIN = constants.EVENT_TEST_BEGIN;\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\nvar EVENT_TEST_RETRY = constants.EVENT_TEST_RETRY;\n\nvar emitOrder = [\n  EVENT_RUN_BEGIN,\n  EVENT_SUITE_BEGIN,\n  EVENT_SUITE_BEGIN,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_BEGIN,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_PASS,\n  EVENT_TEST_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_SUITE_BEGIN,\n  EVENT_TEST_BEGIN,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_PASS,\n  EVENT_TEST_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_SUITE_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_SUITE_END,\n  EVENT_SUITE_END,\n  EVENT_RUN_END\n];\n\nvar realEmit = Runner.prototype.emit;\nRunner.prototype.emit = function(event, ...args) {\n  assert.strictEqual(event, emitOrder.shift());\n  return realEmit.call(this, event, ...args);\n};\n\ndescribe('suite A', function() {\n  before('before', function() {});\n  beforeEach('beforeEach', function() {});\n  it('test A', function() {});\n  describe('suite B', function() {\n    it('test B', function() {});\n  });\n  afterEach('afterEach', function() {});\n  after('after', function() {});\n});"}
{"prompt":"suite A, function {","test":"'use strict';\nvar Runner = require('../../../../lib/runner.js');\nvar assert = require('assert');\nvar constants = Runner.constants;\nvar EVENT_DELAY_BEGIN = constants.EVENT_DELAY_BEGIN;\nvar EVENT_DELAY_END = constants.EVENT_DELAY_END;\nvar EVENT_HOOK_BEGIN = constants.EVENT_HOOK_BEGIN;\nvar EVENT_HOOK_END = constants.EVENT_HOOK_END;\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\nvar EVENT_SUITE_END = constants.EVENT_SUITE_END;\nvar EVENT_TEST_BEGIN = constants.EVENT_TEST_BEGIN;\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\nvar EVENT_TEST_PASS = constants.EVENT_TEST_PASS;\nvar EVENT_TEST_PENDING = constants.EVENT_TEST_PENDING;\nvar EVENT_TEST_RETRY = constants.EVENT_TEST_RETRY;\n\nvar emitOrder = [\n  EVENT_DELAY_BEGIN,\n  EVENT_DELAY_END,\n  EVENT_RUN_BEGIN,\n  EVENT_SUITE_BEGIN,\n  EVENT_SUITE_BEGIN,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_BEGIN,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_PASS,\n  EVENT_TEST_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_SUITE_BEGIN,\n  EVENT_TEST_BEGIN,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_PASS,\n  EVENT_TEST_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_SUITE_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_SUITE_END,\n  EVENT_SUITE_END,\n  EVENT_RUN_END\n];\n\nvar realEmit = Runner.prototype.emit;\nRunner.prototype.emit = function(event, ...args) {\n  assert.strictEqual(event, emitOrder.shift());\n  return realEmit.call(this, event, ...args);\n};\n\nsetTimeout(function() {\n\n  describe('suite A', function() {\n    before('before', function() {});\n    beforeEach('beforeEach', function() {});\n    it('test A', function() {});\n    describe('suite B', function() {\n      it('test B', function() {});\n    });\n    afterEach('afterEach', function() {});\n    after('after', function() {});\n  });\n\n  run();\n}, 100);"}
{"prompt":"suite A, function {","test":"'use strict';\nvar Runner = require('../../../../lib/runner.js');\nvar assert = require('assert');\nvar constants = Runner.constants;\nvar EVENT_HOOK_BEGIN = constants.EVENT_HOOK_BEGIN;\nvar EVENT_HOOK_END = constants.EVENT_HOOK_END;\nvar EVENT_RUN_BEGIN = constants.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = constants.EVENT_RUN_END;\nvar EVENT_SUITE_BEGIN = constants.EVENT_SUITE_BEGIN;\nvar EVENT_SUITE_END = constants.EVENT_SUITE_END;\nvar EVENT_TEST_BEGIN = constants.EVENT_TEST_BEGIN;\nvar EVENT_TEST_END = constants.EVENT_TEST_END;\nvar EVENT_TEST_FAIL = constants.EVENT_TEST_FAIL;\nvar EVENT_TEST_RETRY = constants.EVENT_TEST_RETRY;\n\nvar emitOrder = [\n  EVENT_RUN_BEGIN,\n  EVENT_SUITE_BEGIN,\n  EVENT_SUITE_BEGIN,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_BEGIN,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_RETRY,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_BEGIN,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_FAIL,\n  EVENT_TEST_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_SUITE_END,\n  EVENT_SUITE_END,\n  EVENT_RUN_END\n];\n\nvar realEmit = Runner.prototype.emit;\nRunner.prototype.emit = function(event, ...args) {\n  assert.strictEqual(event, emitOrder.shift());\n  return realEmit.call(this, event, ...args);\n};\n\ndescribe('suite A', function() {\n  before('before', function() {});\n  beforeEach('beforeEach', function() {});\n  it('test A', function() {\n    throw new Error('error test A');\n  });\n  afterEach('afterEach', function() {});\n  after('after', function() {});\n});"}
{"prompt":"event order, function  {","test":"'use strict';\n\nvar helpers = require('./helpers');\nvar runMochaJSON = helpers.runMochaJSON;\n\ndescribe('event order', function () {\n  describe('trivial test case', function () {\n    it('should assert trivial event order', function (done) {\n      runMochaJSON('runner/events-basic.fixture.js', [], function (err, res) {\n        if (err) {\n          done(err);\n          return;\n        }\n        expect(res, 'to have passed')\n          .and('to have passed test count', 2)\n          .and('to have passed test order', 'test A', 'test B')\n          .and('to have failed test count', 0);\n        done();\n      });\n    });\n  });\n\n  describe('--bail test case', function () {\n    it('should assert --bail event order', function (done) {\n      runMochaJSON(\n        'runner/events-bail.fixture.js',\n        ['--bail'],\n        function (err, res) {\n          if (err) {\n            done(err);\n            return;\n          }\n          expect(res, 'to have failed with error', 'error test A')\n            .and('to have failed test count', 1)\n            .and('to have passed test count', 0);\n          done();\n        }\n      );\n    });\n  });\n\n  describe('--retries test case', function () {\n    it('should assert --retries event order', function (done) {\n      runMochaJSON(\n        'runner/events-retries.fixture.js',\n        ['--retries', '1'],\n        function (err, res) {\n          if (err) {\n            done(err);\n            return;\n          }\n          expect(res, 'to have failed with error', 'error test A')\n            .and('to have failed test count', 1)\n            .and('to have passed test count', 0);\n          done();\n        }\n      );\n    });\n  });\n\n  describe('--delay test case', function () {\n    it('should assert --delay event order', function (done) {\n      runMochaJSON(\n        'runner/events-delay.fixture.js',\n        ['--delay'],\n        function (err, res) {\n          if (err) {\n            done(err);\n            return;\n          }\n          expect(res, 'to have passed')\n            .and('to have passed test count', 2)\n            .and('to have passed test order', 'test A', 'test B')\n            .and('to have failed test count', 0);\n          done();\n        }\n      );\n    });\n  });\n\n  describe('--retries and --bail test case', function () {\n    it('should assert --retries event order', function (done) {\n      runMochaJSON(\n        'runner/events-bail-retries.fixture.js',\n        ['--retries', '1', '--bail'],\n        function (err, res) {\n          if (err) {\n            done(err);\n            return;\n          }\n          expect(res, 'to have failed with error', 'error test A')\n            .and('to have failed test count', 1)\n            .and('to have passed test count', 0);\n          done();\n        }\n      );\n    });\n  });\n});"}
{"prompt":".onlyit should only run this, but it does not, function {","test":"describe.only('it should only run this, but it does not', function() {\n  it('should do a thing', function() {});\n});"}
{"prompt":"it should run this anyway, function {","test":"describe('it should run this anyway', function() {\n  it('should do a different thing', function() {});\n});"}
{"prompt":"should hang when --no-exit used, function done {","test":"'use strict';\n\nvar net = require('net');\n\nit('should hang when --no-exit used', function (done) {\n  var server = net.createServer();\n  server.listen(55554, done);\n});"}
{"prompt":"--exit, function  {","test":"'use strict';\n\nvar runMocha = require('../helpers').runMocha;\n\ndescribe('--exit', function () {\n  var behaviors = {\n    enabled: '--exit',\n    disabled: '--no-exit'\n  };\n\n  // subprocess\n  var mocha;\n\n  function killSubprocess() {\n    mocha.kill('SIGKILL');\n  }\n\n  // these two handlers deal with a ctrl-c on command-line\n  before(function () {\n    process.on('SIGINT', killSubprocess);\n  });\n\n  after(function () {\n    process.removeListener('SIGINT', killSubprocess);\n  });\n\n  /**\n   * Returns a test that executes Mocha in a subprocess with either\n   * `--exit`, `--no-exit`, or default behavior.\n   *\n   * @param {boolean} shouldExit - Expected result; `true` if Mocha should\n   *   have force-killed the process.\n   * @param {\"enabled\"|\"disabled\"} [behavior] - 'enabled' or 'disabled'; omit for default\n   * @returns {Function} async function implementing the test\n   */\n  var runExit = function (shouldExit, behavior) {\n    return function (done) {\n      var timeout = this.timeout();\n      this.timeout(0);\n      this.slow(Infinity);\n\n      var didExit = true;\n      var timeoutObj;\n      var fixture = 'exit.fixture.js';\n      var args = behaviors[behavior] ? [behaviors[behavior]] : [];\n      mocha = runMocha(fixture, args, function postmortem(err) {\n        clearTimeout(timeoutObj);\n        if (err) {\n          return done(err);\n        }\n        expect(didExit, 'to be', shouldExit);\n        done();\n      });\n\n      // If this callback happens, then Mocha didn't automatically exit.\n      timeoutObj = setTimeout(function () {\n        didExit = false;\n        killSubprocess();\n      }, timeout - 500);\n    };\n  };\n\n  describe('default behavior', function () {\n    it('should not force exit after root suite completion', runExit(false));\n  });\n\n  describe('when enabled', function () {\n    it(\n      'should force exit after root suite completion',\n      runExit(true, 'enabled')\n    );\n  });\n\n  describe('when disabled', function () {\n    it(\n      'should not force exit after root suite completion',\n      runExit(false, 'disabled')\n    );\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nvar calls = [];\n\nexports.Array = {\n  before: function () {\n    calls.push('before');\n  },\n\n  after: function () {\n    calls.push('after');\n    expect(calls, 'to equal', [\n      'before',\n      'before each',\n      'one',\n      'after each',\n      'before each',\n      'two',\n      'after each',\n      'after'\n    ]);\n  },\n\n  '#indexOf()': {\n    beforeEach: function () {\n      calls.push('before each');\n    },\n\n    afterEach: function () {\n      calls.push('after each');\n    },\n\n    'should return -1 when the value is not present': function () {\n      calls.push('one');\n      expect([1, 2, 3].indexOf(5), 'to be', -1);\n      expect([1, 2, 3].indexOf(0), 'to be', -1);\n    },\n\n    'should return the correct index when the value is present': function () {\n      calls.push('two');\n      expect([1, 2, 3].indexOf(1), 'to be', 0);\n      expect([1, 2, 3].indexOf(2), 'to be', 1);\n      expect([1, 2, 3].indexOf(3), 'to be', 2);\n    }\n  }\n};"}
{"prompt":"--extension, function  {","test":"'use strict';\n\nvar helpers = require('../helpers');\nvar invokeMocha = helpers.invokeMocha;\nvar toJSONResult = helpers.toJSONResult;\n\ndescribe('--extension', function () {\n  it('should allow comma-separated variables', function (done) {\n    var args = [\n      '--require',\n      'coffeescript/register',\n      '--require',\n      './test/setup',\n      '--reporter',\n      'json',\n      '--extension',\n      'js,coffee',\n      'test/integration/fixtures/options/extension'\n    ];\n    invokeMocha(args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n      expect(toJSONResult(res), 'to have passed').and(\n        'to have passed test count',\n        2\n      );\n      done();\n    });\n  });\n\n  it('should allow extensions beginning with a dot', function (done) {\n    var args = [\n      '--require',\n      'coffeescript/register',\n      '--require',\n      './test/setup',\n      '--reporter',\n      'json',\n      '--extension',\n      '.js',\n      'test/integration/fixtures/options/extension'\n    ];\n    invokeMocha(args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n      expect(toJSONResult(res), 'to have passed').and(\n        'to have passed test count',\n        1\n      );\n      done();\n    });\n  });\n});"}
{"prompt":"should fail if in a worker, function {","test":"'use strict';\n\nit('should fail if in a worker', function() {\n  if (!require('workerpool').isMainThread) {\n    throw new Error('in worker!');\n  }\n});"}
{"prompt":"ignore test nested fail, function  {","test":"'use strict';\n\ndescribe('ignore test nested fail', function () {\n  it('should not run this test', function () {\n    throw new Error('should not run');\n  });\n});"}
{"prompt":"a suite, function {","test":"'use strict';\n\nvar assert = require('assert');\n\ndescribe('a suite', function() {\n  it('should succeed', function() {\n    assert(false);\n  });\n});"}
{"prompt":"--fail-zero, function  {","test":"'use strict';\n\nvar helpers = require('../helpers');\nvar runMochaJSON = helpers.runMochaJSON;\n\ndescribe('--fail-zero', function () {\n  var args = ['--fail-zero', '--grep', 'yyyyyy'];\n\n  it('should fail since no tests are encountered', function (done) {\n    var fixture = '__default__.fixture.js';\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have passed test count', 0)\n        .and('to have test count', 0)\n        .and('to have exit code', 1);\n      done();\n    });\n  });\n});"}
{"prompt":"fatal uncaught exception, function  {","test":"'use strict';\n\ndescribe('fatal uncaught exception', function () {\n  describe('first suite', function () {\n    it('should bail if a successful test asynchronously fails', function (done) {\n      done();\n      process.nextTick(function () {\n        throw new Error('global error');\n      });\n    });\n\n    it('should not actually get run', function () {\n      throw new Error('should never throw - first suite');\n    });\n  });\n  \n  describe('second suite', function () {\n    it('should not actually get run', function () {\n      throw new Error('should never throw - second suite');\n    });\n  });\n});"}
{"prompt":"alpha, function  {","test":"'use strict';\n\ndescribe('alpha', function () {\n  it('should be executed first', function () {\n    if (global.beta !== undefined) {\n      throw new Error('alpha was not executed first');\n    }\n\n    if (global.theta !== undefined) {\n      throw new Error('alpha was not executed first');\n    }\n  });\n});"}
{"prompt":"beta, function  {","test":"'use strict';\n\ndescribe('beta', function () {\n  it('should be executed second', function () {\n    global.beta = 1;\n\n    if (global.theta !== undefined) {\n      throw new Error('beta was not executed second');\n    }\n  });\n});"}
{"prompt":"theta, function  {","test":"'use strict';\n\ndescribe('theta', function () {\n  it('should be executed third', function () {\n    global.theta = 1;\n  });\n});"}
{"prompt":"file utils, function  {","test":"'use strict';\n\nconst lookupFiles = require('../../lib/cli/lookup-files');\nconst {existsSync, symlinkSync, renameSync} = require('node:fs');\nconst path = require('node:path');\nconst {touchFile, createTempDir} = require('./helpers');\n\nconst SYMLINK_SUPPORT = process.platform !== 'win32';\n\ndescribe('file utils', function () {\n  let tmpDir;\n  let removeTempDir;\n  let tmpFile;\n\n  beforeEach(async function () {\n    const result = await createTempDir();\n    tmpDir = result.dirpath;\n    removeTempDir = result.removeTempDir;\n\n    tmpFile = filepath => path.join(tmpDir, filepath);\n\n    touchFile(tmpFile('mocha-utils.js'));\n    if (SYMLINK_SUPPORT) {\n      symlinkSync(tmpFile('mocha-utils.js'), tmpFile('mocha-utils-link.js'));\n    }\n  });\n\n  afterEach(async function () {\n    return removeTempDir();\n  });\n\n  describe('lookupFiles()', function () {\n    it('should not return broken symlink file path', function () {\n      if (!SYMLINK_SUPPORT) {\n        return this.skip();\n      }\n\n      expect(\n        lookupFiles(tmpDir, ['js'], false),\n        'to contain',\n        tmpFile('mocha-utils-link.js'),\n        tmpFile('mocha-utils.js')\n      ).and('to have length', 2);\n      expect(existsSync(tmpFile('mocha-utils-link.js')), 'to be', true);\n      renameSync(tmpFile('mocha-utils.js'), tmpFile('bob'));\n      expect(existsSync(tmpFile('mocha-utils-link.js')), 'to be', false);\n      expect(lookupFiles(tmpDir, ['js'], false), 'to equal', []);\n    });\n\n    it('should accept a glob \"path\" value', function () {\n      const res = lookupFiles(tmpFile('mocha-utils*'), ['js'], false).map(\n        foundFilepath => path.normalize(foundFilepath)\n      );\n\n      let expectedLength = 0;\n      let ex = expect(res, 'to contain', tmpFile('mocha-utils.js'));\n      expectedLength++;\n\n      if (SYMLINK_SUPPORT) {\n        ex = ex.and('to contain', tmpFile('mocha-utils-link.js'));\n        expectedLength++;\n      }\n\n      ex.and('to have length', expectedLength);\n    });\n\n    describe('when given `extension` option', function () {\n      describe('when provided a directory for the filepath', function () {\n        let filepath;\n\n        beforeEach(async function () {\n          filepath = tmpFile('mocha-utils-text.txt');\n          touchFile(filepath);\n        });\n\n        describe('when `extension` option has leading dot', function () {\n          it('should find the file w/ the extension', function () {\n            expect(lookupFiles(tmpDir, ['.txt']), 'to equal', [filepath]);\n          });\n        });\n\n        describe('when `extension` option has no leading dot', function () {\n          it('should find the file w/ the extension', function () {\n            expect(lookupFiles(tmpDir, ['txt']), 'to equal', [filepath]);\n          });\n        });\n\n        describe('when directory contains file without multipart extension', function () {\n          let filepath;\n\n          beforeEach(function () {\n            filepath = tmpFile('mocha-utils-test.js');\n            touchFile(filepath);\n          });\n\n          describe('when provided multipart `extension` option', function () {\n            describe('when `extension` option has no leading dot', function () {\n              it('should not match the filepath', function () {\n                expect(\n                  lookupFiles(tmpDir, ['test.js']).map(filepath =>\n                    path.normalize(filepath)\n                  ),\n                  'to equal',\n                  []\n                );\n              });\n            });\n\n            describe('when `extension` option has a leading dot', function () {\n              it('should not match the filepath', function () {\n                expect(\n                  lookupFiles(tmpDir, ['.test.js']).map(filepath =>\n                    path.normalize(filepath)\n                  ),\n                  'to equal',\n                  []\n                );\n              });\n            });\n          });\n        });\n\n        describe('when directory contains matching file having a multipart extension', function () {\n          let filepath;\n\n          beforeEach(function () {\n            filepath = tmpFile('mocha-utils.test.js');\n            touchFile(filepath);\n          });\n\n          describe('when provided multipart `extension` option', function () {\n            describe('when `extension` option has no leading dot', function () {\n              it('should find the matching file', function () {\n                expect(\n                  lookupFiles(tmpDir, ['test.js']).map(filepath =>\n                    path.normalize(filepath)\n                  ),\n                  'to equal',\n                  [filepath]\n                );\n              });\n            });\n\n            describe('when `extension` option has a leading dot', function () {\n              it('should find the matching file', function () {\n                expect(\n                  lookupFiles(tmpDir, ['.test.js']).map(filepath =>\n                    path.normalize(filepath)\n                  ),\n                  'to equal',\n                  [filepath]\n                );\n              });\n            });\n          });\n        });\n      });\n    });\n\n    describe('when provided a filepath with no extension', function () {\n      let filepath;\n\n      beforeEach(async function () {\n        filepath = tmpFile('mocha-utils.ts');\n        touchFile(filepath);\n      });\n\n      describe('when `extension` option has a leading dot', function () {\n        describe('when only provided a single extension', function () {\n          it('should append provided extensions and find only the matching file', function () {\n            expect(\n              lookupFiles(tmpFile('mocha-utils'), ['.js']).map(foundFilepath =>\n                path.normalize(foundFilepath)\n              ),\n              'to equal',\n              [tmpFile('mocha-utils.js')]\n            );\n          });\n        });\n\n        describe('when provided multiple extensions', function () {\n          it('should append provided extensions and find all matching files', function () {\n            expect(\n              lookupFiles(tmpFile('mocha-utils'), ['.js', '.ts']).map(\n                foundFilepath => path.normalize(foundFilepath)\n              ),\n              'to contain',\n              tmpFile('mocha-utils.js'),\n              filepath\n            ).and('to have length', 2);\n          });\n        });\n      });\n\n      describe('when `extension` option has no leading dot', function () {\n        describe('when only provided a single extension', function () {\n          it('should append provided extensions and find only the matching file', function () {\n            expect(\n              lookupFiles(tmpFile('mocha-utils'), ['js']).map(foundFilepath =>\n                path.normalize(foundFilepath)\n              ),\n              'to equal',\n              [tmpFile('mocha-utils.js')]\n            );\n          });\n        });\n\n        describe('when provided multiple extensions', function () {\n          it('should append provided extensions and find all matching files', function () {\n            expect(\n              lookupFiles(tmpFile('mocha-utils'), ['js', 'ts']).map(\n                foundFilepath => path.normalize(foundFilepath)\n              ),\n              'to contain',\n              tmpFile('mocha-utils.js'),\n              filepath\n            ).and('to have length', 2);\n          });\n        });\n      });\n\n      describe('when `extension` option is multipart', function () {\n        let filepath;\n\n        beforeEach(function () {\n          filepath = tmpFile('mocha-utils.test.js');\n          touchFile(filepath);\n        });\n\n        describe('when `extension` option has no leading dot', function () {\n          it('should append provided extension and find only the matching file', function () {\n            expect(\n              lookupFiles(tmpFile('mocha-utils'), ['test.js']).map(\n                foundFilepath => path.normalize(foundFilepath)\n              ),\n              'to equal',\n              [filepath]\n            );\n          });\n        });\n\n        describe('when `extension` option has leading dot', function () {\n          it('should append provided extension and find only the matching file', function () {\n            expect(\n              lookupFiles(tmpFile('mocha-utils'), ['.test.js']).map(\n                foundFilepath => path.normalize(foundFilepath)\n              ),\n              'to equal',\n              [filepath]\n            );\n          });\n        });\n      });\n    });\n\n    describe('when no files match', function () {\n      it('should throw an exception', function () {\n        expect(() => lookupFiles(tmpFile('mocha-utils')), 'to throw', {\n          name: 'Error',\n          code: 'ERR_MOCHA_NO_FILES_MATCH_PATTERN'\n        });\n      });\n    });\n\n    describe('when looking up a directory and no extensions provided', function () {\n      it('should throw', function () {\n        expect(() => lookupFiles(tmpDir), 'to throw', {\n          name: 'TypeError',\n          code: 'ERR_MOCHA_INVALID_ARG_TYPE',\n          argument: 'extensions'\n        });\n      });\n    });\n  });\n});"}
{"prompt":"--file, function  {","test":"'use strict';\n\nvar path = require('node:path').posix;\nconst {\n  runMochaJSON,\n  resolveFixturePath: resolvePath,\n  runMocha\n} = require('../helpers');\n\ndescribe('--file', function () {\n  var args = [];\n  var fixtures = {\n    alpha: path.join('options', 'file-alpha'),\n    beta: path.join('options', 'file-beta'),\n    theta: path.join('options', 'file-theta')\n  };\n\n  it('should run tests passed via file first', function (done) {\n    args = ['--file', resolvePath(fixtures.alpha)];\n\n    var fixture = fixtures.beta;\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n      expect(res, 'to have passed')\n        .and('to have passed test count', 2)\n        .and('to have passed test order', 'should be executed first');\n      done();\n    });\n  });\n\n  it('should run multiple tests passed via file first', function (done) {\n    args = [\n      '--file',\n      resolvePath(fixtures.alpha),\n      '--file',\n      resolvePath(fixtures.beta)\n    ];\n\n    var fixture = fixtures.theta;\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n      expect(res, 'to have passed')\n        .and('to have passed test count', 3)\n        .and(\n          'to have passed test order',\n          'should be executed first',\n          'should be executed second',\n          'should be executed third'\n        );\n      done();\n    });\n  });\n\n  it('should support having no other test files', function (done) {\n    args = ['--file', resolvePath(fixtures.alpha)];\n\n    runMochaJSON('filethatdoesnotexist.js', args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n      expect(res, 'to have passed').and('to have passed test count', 1);\n      done();\n    });\n  });\n\n  it('should run esm tests passed via file', function (done) {\n    const esmFile = 'collect-files.fixture.mjs';\n    const testArgs = ['--file', resolvePath(esmFile)];\n\n    runMochaJSON(esmFile, testArgs, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n      expect(res, 'to have passed');\n      done();\n    });\n  });\n\n  it('should log a warning if a nonexistent file with an unknown extension is specified', function (done) {\n    const nonexistentTestFileArg = 'nonexistent.test.ts';\n    runMocha(\n      nonexistentTestFileArg,\n      ['--file'],\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n\n        expect(\n          res.output,\n          'to contain',\n          `Warning: Cannot find any files matching pattern`\n        ).and('to contain', nonexistentTestFileArg);\n        done();\n      },\n      {stdio: 'pipe'}\n    );\n  });\n\n  it('should provide warning for nonexistent js file extensions', function (done) {\n    const nonexistentCjsArg = 'nonexistent.test.js';\n\n    runMocha(\n      nonexistentCjsArg,\n      ['--file'],\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n\n        expect(\n          res.output,\n          'to contain',\n          `Warning: Cannot find any files matching pattern`\n        ).and('to contain', nonexistentCjsArg);\n        done();\n      },\n      {stdio: 'pipe'}\n    );\n  });\n\n  it('should provide warning for nonexistent esm file extensions', function (done) {\n    const nonexistentEsmArg = 'nonexistent.test.mjs';\n\n    runMocha(\n      nonexistentEsmArg,\n      ['--file'],\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n\n        expect(\n          res.output,\n          'to contain',\n          `Warning: Cannot find any files matching pattern`\n        ).and('to contain', nonexistentEsmArg);\n        done();\n      },\n      {stdio: 'pipe'}\n    );\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nvar fs = require('fs');\n\nrequire.extensions['.foo'] = function (module, filename) {\n  var content;\n  content = fs.readFileSync(filename, 'utf8');\n  var test = 'describe(\"custom compiler\",function(){ it(\"should work\",function() { ' +\n    'expect(' + content + ', \"to be\", 1); }); });';\n  return module._compile(test, filename);\n};"}
{"prompt":"--forbid-only, function  {","test":"'use strict';\n\nvar path = require('node:path').posix;\nvar helpers = require('../helpers');\nvar runMocha = helpers.runMocha;\nvar runMochaJSON = helpers.runMochaJSON;\n\ndescribe('--forbid-only', function () {\n  var args = [];\n  var onlyErrorMessage = '`.only` forbidden';\n\n  beforeEach(function () {\n    args = ['--forbid-only'];\n  });\n\n  it('should succeed if there are only passed tests', function (done) {\n    var fixture = path.join('options', 'forbid-only', 'passed');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n      expect(res, 'to have passed');\n      done();\n    });\n  });\n\n  it('should fail if there are tests marked only', function (done) {\n    var fixture = path.join('options', 'forbid-only', 'only');\n    var spawnOpts = {stdio: 'pipe'};\n    runMocha(\n      fixture,\n      args,\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to have failed with output', new RegExp(onlyErrorMessage));\n        done();\n      },\n      spawnOpts\n    );\n  });\n\n  it('should fail if there are tests in suites marked only', function (done) {\n    var fixture = path.join('options', 'forbid-only', 'only-suite');\n    var spawnOpts = {stdio: 'pipe'};\n    runMocha(\n      fixture,\n      args,\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to have failed with output', new RegExp(onlyErrorMessage));\n        done();\n      },\n      spawnOpts\n    );\n  });\n\n  it('should fail if there is empty suite marked only', function (done) {\n    var fixture = path.join('options', 'forbid-only', 'only-empty-suite');\n    var spawnOpts = {stdio: 'pipe'};\n    runMocha(\n      fixture,\n      args,\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to have failed with output', new RegExp(onlyErrorMessage));\n        done();\n      },\n      spawnOpts\n    );\n  });\n\n  it('should fail if there is suite marked only which matches grep', function (done) {\n    var fixture = path.join('options', 'forbid-only', 'only-suite');\n    var spawnOpts = {stdio: 'pipe'};\n    runMocha(\n      fixture,\n      args.concat('--fgrep', 'suite marked with only'),\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to have failed with output', new RegExp(onlyErrorMessage));\n        done();\n      },\n      spawnOpts\n    );\n  });\n\n  it('should fail if suite marked only does not match grep', function (done) {\n    var fixture = path.join('options', 'forbid-only', 'only-suite');\n    var spawnOpts = {stdio: 'pipe'};\n    runMocha(\n      fixture,\n      args.concat('--fgrep', 'bumble bees'),\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to have failed with output', new RegExp(onlyErrorMessage));\n        done();\n      },\n      spawnOpts\n    );\n  });\n\n  it('should fail if suite marked only does not match inverted grep', function (done) {\n    var fixture = path.join('options', 'forbid-only', 'only-suite');\n    var spawnOpts = {stdio: 'pipe'};\n    runMocha(\n      fixture,\n      args.concat('--fgrep', 'suite marked with only', '--invert'),\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to have failed with output', new RegExp(onlyErrorMessage));\n        done();\n      },\n      spawnOpts\n    );\n  });\n\n  it('should fail even if before has \"skip\"', function (done) {\n    var fixture = path.join('options', 'forbid-only', 'only-before');\n    var spawnOpts = {stdio: 'pipe'};\n    runMocha(\n      fixture,\n      args,\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to have failed with output', new RegExp(onlyErrorMessage));\n        done();\n      },\n      spawnOpts\n    );\n  });\n\n  it('should fail even if beforeEach has \"skip\"', function (done) {\n    var fixture = path.join('options', 'forbid-only', 'only-before-each');\n    var spawnOpts = {stdio: 'pipe'};\n    runMocha(\n      fixture,\n      args,\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to have failed with output', new RegExp(onlyErrorMessage));\n        done();\n      },\n      spawnOpts\n    );\n  });\n});"}
{"prompt":"--forbid-pending, function  {","test":"'use strict';\n\nvar path = require('node:path').posix;\nvar helpers = require('../helpers');\nvar runMocha = helpers.runMocha;\nvar runMochaJSON = helpers.runMochaJSON;\n\ndescribe('--forbid-pending', function () {\n  var args = [];\n  var pendingErrorMessage = 'Pending test forbidden';\n\n  before(function () {\n    args = ['--forbid-pending'];\n  });\n\n  it('should succeed if there are only passed tests', function (done) {\n    var fixture = path.join('options', 'forbid-pending', 'passed');\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n      expect(res, 'to have passed');\n      done();\n    });\n  });\n\n  it('should fail if there are tests in suites marked skip', function (done) {\n    var fixture = path.join('options', 'forbid-pending', 'skip-suite');\n    var spawnOpts = {stdio: 'pipe'};\n    runMocha(\n      fixture,\n      args,\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to satisfy', {\n          code: 1,\n          output: new RegExp(pendingErrorMessage)\n        });\n        done();\n      },\n      spawnOpts\n    );\n  });\n\n  it('should fail if there is empty suite marked pending', function (done) {\n    var fixture = path.join('options', 'forbid-pending', 'skip-empty-suite');\n    var spawnOpts = {stdio: 'pipe'};\n    runMocha(\n      fixture,\n      args,\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to satisfy', {\n          code: 1,\n          output: new RegExp(pendingErrorMessage)\n        });\n        done();\n      },\n      spawnOpts\n    );\n  });\n\n  var forbidPendingFailureTests = {\n    'should fail if there are tests marked skip': 'skip',\n    'should fail if there are pending tests': 'pending',\n    'should fail if tests call `skip()`': 'this-skip',\n    'should fail if beforeEach calls `skip()`': 'beforeEach-this-skip',\n    'should fail if before calls `skip()`': 'before-this-skip'\n  };\n\n  Object.keys(forbidPendingFailureTests).forEach(function (title) {\n    it(title, function (done) {\n      var fixture = path.join(\n        'options',\n        'forbid-pending',\n        forbidPendingFailureTests[title]\n      );\n      runMochaJSON(fixture, args, function (err, res) {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to have failed with error', pendingErrorMessage);\n        done();\n      });\n    });\n  });\n});"}
{"prompt":"test1,  => {","test":"import {describe, it} from '../../../../index.js';\n\ndescribe('test1', () => {\n  it('test', async () => {\n    const error = new Error('Oh no!');\n\n    error.nested = {\n      get inner() {\n        return 'abc';\n      }\n    };\n\n    throw error;\n  });\n});"}
{"prompt":"globbing, function  {","test":"'use strict';\n\nvar exec = require('node:child_process').exec;\nvar path = require('node:path');\n\nvar node = '\"' + process.execPath + '\"';\n\ndescribe('globbing', function () {\n  describe('by the shell', function () {\n    it('should find the first level test', function (done) {\n      testGlob.shouldSucceed(\n        './*.js',\n        function (results) {\n          expect(\n            results.stdout,\n            'to contain',\n            '[\"end\",{\"suites\":1,\"tests\":1,\"passes\":1,\"pending\":0,\"failures\":0,'\n          );\n        },\n        done\n      );\n    });\n\n    it('should not find a non-matching pattern', function (done) {\n      testGlob.shouldFail(\n        './*-none.js',\n        function (results) {\n          expect(\n            results.stderr,\n            'to contain',\n            'Error: No test files found: \"./*-none.js\"'\n          );\n        },\n        done\n      );\n    });\n\n    it('should handle multiple non-matching patterns', function (done) {\n      testGlob.shouldFail(\n        './*-none.js ./*-none-twice.js',\n        function (results) {\n          expect(results.stderr, 'to contain', 'Error: No test files found');\n          expect(results.stderr, 'not to contain', '*-none');\n        },\n        done\n      );\n    });\n\n    it('should handle both matching and non-matching patterns in the same command', function (done) {\n      testGlob.shouldSucceed(\n        './*.js ./*-none.js',\n        function (results) {\n          expect(\n            results.stdout,\n            'to contain',\n            '[\"end\",{\"suites\":1,\"tests\":1,\"passes\":1,\"pending\":0,\"failures\":0,'\n          );\n          expect(\n            results.stderr,\n            'to contain',\n            'Warning: Cannot find any files matching pattern'\n          );\n        },\n        done\n      );\n    });\n  });\n\n  describe('by Mocha', function () {\n    it('should find the first level test', function (done) {\n      testGlob.shouldSucceed(\n        '\"./*.js\"',\n        function (results) {\n          expect(\n            results.stdout,\n            'to contain',\n            '[\"end\",{\"suites\":1,\"tests\":1,\"passes\":1,\"pending\":0,\"failures\":0,'\n          );\n        },\n        done\n      );\n    });\n\n    it('should not find a non-matching pattern', function (done) {\n      testGlob.shouldFail(\n        '\"./*-none.js\"',\n        function (results) {\n          expect(\n            results.stderr,\n            'to contain',\n            'Error: No test files found: \"./*-none.js\"'\n          );\n        },\n        done\n      );\n    });\n\n    it('should handle multiple non-matching patterns', function (done) {\n      testGlob.shouldFail(\n        '\"./*-none.js\" \"./*-none-twice.js\"',\n        function (results) {\n          expect(results.stderr, 'to contain', 'Error: No test files found');\n        },\n        done\n      );\n    });\n\n    it('should handle both matching and non-matching patterns in the same command', function (done) {\n      testGlob.shouldSucceed(\n        '\"./*.js\" \"./*-none.js\"',\n        function (results) {\n          expect(\n            results.stdout,\n            'to contain',\n            '[\"end\",{\"suites\":1,\"tests\":1,\"passes\":1,\"pending\":0,\"failures\":0,'\n          );\n          expect(\n            results.stderr,\n            'to contain',\n            'Warning: Cannot find any files matching pattern'\n          );\n        },\n        done\n      );\n    });\n\n    describe('double-starred', function () {\n      it('should find the tests on multiple levels', function (done) {\n        testGlob.shouldSucceed(\n          '\"./**/*.js\"',\n          function (results) {\n            expect(\n              results.stdout,\n              'to contain',\n              '[\"end\",{\"suites\":2,\"tests\":2,\"passes\":2,\"pending\":0,\"failures\":0,'\n            );\n          },\n          done\n        );\n      });\n\n      it('should not find a non-matching pattern', function (done) {\n        testGlob.shouldFail(\n          '\"./**/*-none.js\"',\n          function (results) {\n            expect(\n              results.stderr,\n              'to contain',\n              'Error: No test files found: \"./**/*-none.js\"'\n            );\n          },\n          done\n        );\n      });\n\n      it('should handle both matching and non-matching patterns in the same command', function (done) {\n        testGlob.shouldSucceed(\n          '\"./**/*.js\" \"./**/*-none.js\"',\n          function (results) {\n            expect(\n              results.stdout,\n              'to contain',\n              '[\"end\",{\"suites\":2,\"tests\":2,\"passes\":2,\"pending\":0,\"failures\":0,'\n            );\n            expect(\n              results.stderr,\n              'to contain',\n              'Warning: Cannot find any files matching pattern'\n            );\n          },\n          done\n        );\n      });\n    });\n  });\n});\n\nvar testGlob = {\n  shouldSucceed: execMochaWith(function shouldNotError(error) {\n    if (error) {\n      throw error;\n    }\n  }),\n\n  shouldFail: execMochaWith(function shouldFailWithStderr(error, stderr) {\n    expect(error && error.message, 'to contain', stderr);\n  })\n};\n\nfunction execMochaWith(validate) {\n  return function execMocha(glob, assertOn, done) {\n    exec(\n      node +\n        ' \"' +\n        path.join('..', '..', '..', '..', 'bin', 'mocha') +\n        '\" -R json-stream --no-config ' +\n        glob,\n      {cwd: path.join(__dirname, 'fixtures', 'glob')},\n      function (error, stdout, stderr) {\n        try {\n          validate(error, stderr);\n          assertOn({stdout, stderr});\n          done();\n        } catch (assertion) {\n          done(assertion);\n        }\n      }\n    );\n  };\n}"}
{"prompt":"global setup/teardown, function  {","test":"'use strict';\n\nconst path = require('node:path');\nconst {\n  touchFile,\n  runMochaAsync,\n  runMochaWatchAsync,\n  copyFixture,\n  DEFAULT_FIXTURE,\n  resolveFixturePath,\n  createTempDir\n} = require('../helpers');\n\ndescribe('global setup/teardown', function () {\n  describe('when mocha run in serial mode', function () {\n    it('should execute global setup and teardown', async function () {\n      return expect(\n        runMochaAsync(DEFAULT_FIXTURE, [\n          '--require',\n          resolveFixturePath('plugins/global-fixtures/global-setup-teardown')\n        ]),\n        'when fulfilled',\n        'to have passed'\n      );\n    });\n\n    describe('when only global teardown is supplied', function () {\n      it('should run global teardown', async function () {\n        return expect(\n          runMochaAsync(DEFAULT_FIXTURE, [\n            '--require',\n            resolveFixturePath('plugins/global-fixtures/global-teardown')\n          ]),\n          'when fulfilled',\n          'to contain once',\n          /teardown schmeardown/\n        );\n      });\n    });\n\n    describe('when only global setup is supplied', function () {\n      it('should run global setup', async function () {\n        return expect(\n          runMochaAsync(DEFAULT_FIXTURE, [\n            '--require',\n            resolveFixturePath('plugins/global-fixtures/global-setup')\n          ]),\n          'when fulfilled',\n          'to contain once',\n          /setup schmetup/\n        );\n      });\n    });\n\n    it('should share context', async function () {\n      return expect(\n        runMochaAsync(DEFAULT_FIXTURE, [\n          '--require',\n          resolveFixturePath('plugins/global-fixtures/global-setup-teardown')\n        ]),\n        'when fulfilled',\n        'to contain once',\n        /setup: this\\.foo = bar[\\s\\S]+teardown: this\\.foo = bar/\n      );\n    });\n\n    describe('when supplied multiple functions', function () {\n      it('should execute them sequentially', async function () {\n        return expect(\n          runMochaAsync(DEFAULT_FIXTURE, [\n            '--require',\n            resolveFixturePath(\n              'plugins/global-fixtures/global-setup-teardown-multiple'\n            )\n          ]),\n          'when fulfilled',\n          'to contain once',\n          /teardown: this.foo = 3/\n        );\n      });\n    });\n\n    describe('when run in watch mode', function () {\n      let tempDir;\n      let testFile;\n      let removeTempDir;\n\n      beforeEach(async function () {\n        const tempInfo = await createTempDir();\n        tempDir = tempInfo.dirpath;\n        removeTempDir = tempInfo.removeTempDir;\n        testFile = path.join(tempDir, 'test.js');\n        copyFixture(DEFAULT_FIXTURE, testFile);\n      });\n\n      afterEach(async function () {\n        if (removeTempDir) {\n          return removeTempDir();\n        }\n      });\n\n      it('should execute global setup and teardown', async function () {\n        return expect(\n          runMochaWatchAsync(\n            [\n              '--require',\n              resolveFixturePath(\n                'plugins/global-fixtures/global-setup-teardown'\n              ),\n              testFile\n            ],\n            tempDir,\n            () => {\n              touchFile(testFile);\n            }\n          ),\n          'when fulfilled',\n          'to have passed'\n        );\n      });\n\n      describe('when only global teardown is supplied', function () {\n        it('should run global teardown', async function () {\n          return expect(\n            runMochaWatchAsync(\n              [\n                '--require',\n                resolveFixturePath('plugins/global-fixtures/global-teardown'),\n                testFile\n              ],\n              tempDir,\n              () => {\n                touchFile(testFile);\n              }\n            ),\n            'when fulfilled',\n            'to contain once',\n            /teardown schmeardown/\n          );\n        });\n      });\n\n      describe('when only global setup is supplied', function () {\n        it('should run global setup', async function () {\n          return expect(\n            runMochaWatchAsync(\n              [\n                '--require',\n                resolveFixturePath('plugins/global-fixtures/global-setup'),\n                testFile\n              ],\n              tempDir,\n              () => {\n                touchFile(testFile);\n              }\n            ),\n            'when fulfilled',\n            'to contain once',\n            /setup schmetup/\n          );\n        });\n      });\n\n      it('should not re-execute the global fixtures', async function () {\n        return expect(\n          runMochaWatchAsync(\n            [\n              '--require',\n              resolveFixturePath(\n                'plugins/global-fixtures/global-setup-teardown-multiple'\n              ),\n              testFile\n            ],\n            tempDir,\n            () => {\n              touchFile(testFile);\n            }\n          ),\n          'when fulfilled',\n          'to contain once',\n          /teardown: this.foo = 3/\n        );\n      });\n    });\n  });\n\n  describe('when mocha run in parallel mode', function () {\n    it('should execute global setup and teardown', async function () {\n      return expect(\n        runMochaAsync(DEFAULT_FIXTURE, [\n          '--parallel',\n          '--require',\n          resolveFixturePath('plugins/global-fixtures/global-setup-teardown')\n        ]),\n        'when fulfilled',\n        'to have passed'\n      );\n    });\n\n    it('should share context', async function () {\n      return expect(\n        runMochaAsync(DEFAULT_FIXTURE, [\n          '--parallel',\n          '--require',\n          resolveFixturePath('plugins/global-fixtures/global-setup-teardown')\n        ]),\n        'when fulfilled',\n        'to contain once',\n        /setup: this.foo = bar/\n      ).and('when fulfilled', 'to contain once', /teardown: this.foo = bar/);\n    });\n\n    describe('when supplied multiple functions', function () {\n      it('should execute them sequentially', async function () {\n        return expect(\n          runMochaAsync(DEFAULT_FIXTURE, [\n            '--parallel',\n            '--require',\n            resolveFixturePath(\n              'plugins/global-fixtures/global-setup-teardown-multiple'\n            )\n          ]),\n          'when fulfilled',\n          'to contain once',\n          /teardown: this.foo = 3/\n        );\n      });\n    });\n\n    describe('when run in watch mode', function () {\n      let tempDir;\n      let testFile;\n      let removeTempDir;\n\n      beforeEach(async function () {\n        const tempInfo = await createTempDir();\n        tempDir = tempInfo.dirpath;\n        removeTempDir = tempInfo.removeTempDir;\n        testFile = path.join(tempDir, 'test.js');\n        copyFixture(DEFAULT_FIXTURE, testFile);\n      });\n\n      afterEach(async function () {\n        if (removeTempDir) {\n          return removeTempDir();\n        }\n      });\n\n      it('should execute global setup and teardown', async function () {\n        return expect(\n          runMochaWatchAsync(\n            [\n              '--parallel',\n              '--require',\n              resolveFixturePath(\n                'plugins/global-fixtures/global-setup-teardown'\n              ),\n              testFile\n            ],\n            tempDir,\n            () => {\n              touchFile(testFile);\n            }\n          ),\n          'when fulfilled',\n          'to have passed'\n        );\n      });\n\n      it('should not re-execute the global fixtures', async function () {\n        return expect(\n          runMochaWatchAsync(\n            [\n              '--parallel',\n              '--require',\n              resolveFixturePath(\n                'plugins/global-fixtures/global-setup-teardown-multiple'\n              ),\n              testFile\n            ],\n            tempDir,\n            () => {\n              touchFile(testFile);\n            }\n          ),\n          'when fulfilled',\n          'to contain once',\n          /teardown: this.foo = 3/\n        );\n      });\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nexports.mochaGlobalSetup = [\n  async function() {\n    this.foo = 0;\n  },\n  function() {\n    this.foo = this.foo + 1;\n  }\n];\n\nexports.mochaGlobalTeardown = [\n  async function() {\n    this.foo = this.foo + 1;\n  },\n  function() {\n    this.foo = this.foo + 1;\n    console.log(`teardown: this.foo = ${this.foo}`);\n  }\n];"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nexports.mochaGlobalSetup = async function() {\n  this.foo = 'bar';\n  console.log(`setup: this.foo = ${this.foo}`);\n};\n\nexports.mochaGlobalTeardown = async function() {\n  console.log(`teardown: this.foo = ${this.foo}`);\n};"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nexports.mochaGlobalSetup = async function() {\n  console.log(`setup schmetup`);\n};"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nexports.mochaGlobalTeardown = async function() {\n  console.log('teardown schmeardown');\n};"}
{"prompt":"global leaks, function  {","test":"'use strict';\n\ndescribe('global leaks', function () {\n  before(function () {\n    // uncomment to test\n    // foo = 'hey';\n    // bar = 'hey';\n  });\n\n  beforeEach(function () {\n    // uncomment to test\n    // foo = 'bar'\n  });\n\n  it('should cause tests to fail', function () {\n    // uncomment to test\n    // foo = 'bar';\n    // bar = 'baz';\n    // baz = 'raz';\n  });\n\n  it('should pass when accepted', function () {\n    global.okGlobalA = 1;\n    global.okGlobalB = 1;\n    global.okGlobalC = 1;\n  });\n\n  it('should pass with wildcard', function () {\n    global.callback123 = 'foo';\n    global.callback345 = 'bar';\n  });\n\n  it('should pass when prefixed \"mocha-\"', function () {\n    // Opera and IE do this for HTML element IDs anyway\n    // but to sure we can assert this in any browser, simulate it.\n    global['mocha-example'] = {nodeType: 1};\n  });\n\n  afterEach(function () {\n    // uncomment to test\n    // foo = 'bar'\n  });\n});"}
{"prompt":"grep, function  {","test":"'use strict';\n\ndescribe('grep', function () {\n  describe('Match', function () {\n    it('should run', function () {});\n    it('should also run', function () {});\n  });\n\n  describe('match', function () {\n    it('should run', function () {});\n    it('should also run', function () {});\n  });\n\n  describe('fail', function () {\n    it('should not be ran', function () {\n      throw new Error('Spec should not run');\n    });\n  });\n});"}
{"prompt":"Mocha, function  {","test":"'use strict';\n\nvar Mocha = require('../../lib/mocha');\n\ndescribe('Mocha', function () {\n  describe('\"grep\" option', function () {\n    it('should add a RegExp to the mocha.options object', function () {\n      var mocha = new Mocha({grep: /foo.*/});\n      expect(mocha.options.grep, 'to equal', /foo.*/);\n    });\n\n    it('should convert string to a RegExp', function () {\n      var mocha = new Mocha({grep: 'foo.*'});\n      expect(mocha.options.grep, 'to equal', /foo.*/);\n    });\n  });\n\n  describe('\"fgrep\" option', function () {\n    it('should escape and convert string to a RegExp', function () {\n      var mocha = new Mocha({fgrep: 'foo.*'});\n      expect(mocha.options.grep, 'to equal', /foo\\.\\*/);\n    });\n  });\n\n  describe('.grep()', function () {\n    // Test helper\n    function testGrep(mocha) {\n      return function testGrep(grep, expected) {\n        mocha.grep(grep);\n        expect(String(mocha.options.grep), 'to be', expected);\n      };\n    }\n\n    it('should add a RegExp to the mocha.options object', function () {\n      var test = testGrep(new Mocha());\n      test(/foo/, '/foo/');\n    });\n\n    it('should convert grep string to a RegExp', function () {\n      var test = testGrep(new Mocha());\n      test('foo', '/foo/');\n      test('^foo.*bar$', '/^foo.*bar$/');\n      test('^@.*(?=\\\\(\\\\)$)', '/^@.*(?=\\\\(\\\\)$)/');\n    });\n\n    it('should covert grep regex-like string to a RegExp', function () {\n      var test = testGrep(new Mocha());\n      test('/foo/', '/foo/');\n      // Keep the flags\n      test('/baz/i', '/baz/i');\n      test('/bar/g', '/bar/g');\n      test('/^foo(.*)bar/g', '/^foo(.*)bar/g');\n    });\n\n    it('should return its parent Mocha object for chainability', function () {\n      var mocha = new Mocha();\n      expect(mocha.grep(), 'to be', mocha);\n    });\n  });\n\n  describe('\"invert\" option', function () {\n    it('should add a Boolean to the mocha.options object', function () {\n      var mocha = new Mocha({invert: true});\n      expect(mocha.options.invert, 'to be', true);\n    });\n  });\n});"}
{"prompt":"Reassign stream in order to make a copy of all reporter output","test":"'use strict';\n\nvar sinon = require('sinon');\nvar errors = require('../../lib/errors');\nvar createStatsCollector = require('../../lib/stats-collector');\n\nvar createUnsupportedError = errors.createUnsupportedError;\n\n/**\n * Creates a mock runner object.\n *\n * @param {string} runStr - argument that defines the runnerEvent\n * @param {string} ifStr1 - runner event\n * @param {(string|null)} [ifStr2] - runner event\n * @param {(string|null)} [ifStr3] - runner event\n * @param {(*|null)} [arg1] - variable to be added to event handler's scope\n * @param {(*|null)} [arg2] - variable to be added to event handler's scope\n * @return {Object} mock runner instance\n */\nfunction createMockRunner(runStr, ifStr1, ifStr2, ifStr3, arg1, arg2) {\n  var runnerFunction = createRunnerFunction(\n    runStr,\n    ifStr1,\n    ifStr2,\n    ifStr3,\n    arg1,\n    arg2\n  );\n  var mockRunner = {\n    on: runnerFunction,\n    once: runnerFunction\n  };\n  createStatsCollector(mockRunner);\n  return mockRunner;\n}\n\n/**\n * Creates an event handler function to be used by the runner.\n *\n * @description\n * Arguments 'ifStr1', 'ifStr2', and 'ifStr3' should be `Runner.constants`.\n *\n * @param {string} runStr - argument that defines the runnerEvent\n * @param {string} ifStr1 - runner event\n * @param {(string|null)} [ifStr2] - runner event\n * @param {(string|null)} [ifStr3] - runner event\n * @param {(*|null)} [arg1] - variable to be added to event handler's scope\n * @param {(*|null)} [arg2] - variable to be added to event handler's scope\n * @return {Function} event handler for the requested runner events\n */\nfunction createRunnerFunction(runStr, ifStr1, ifStr2, ifStr3, arg1, arg2) {\n  var test = null;\n  switch (runStr) {\n    case 'start':\n    case 'pending':\n    case 'end':\n      return function (event, callback) {\n        if (event === ifStr1) {\n          callback();\n        }\n      };\n    case 'pending test':\n    case 'pass':\n    case 'fail':\n    case 'suite':\n    case 'suite end':\n    case 'test end':\n      test = arg1;\n      return function (event, callback) {\n        if (event === ifStr1) {\n          callback(test);\n        }\n      };\n    case 'fail two args':\n      test = arg1;\n      var expectedError = arg2;\n      return function (event, callback) {\n        if (event === ifStr1) {\n          callback(test, expectedError);\n        }\n      };\n    case 'start test':\n      test = arg1;\n      return function (event, callback) {\n        if (event === ifStr1) {\n          callback();\n        }\n        if (event === ifStr2) {\n          callback(test);\n        }\n      };\n    case 'suite suite end':\n      var expectedSuite = arg1;\n      return function (event, callback) {\n        if (event === ifStr1) {\n          callback(expectedSuite);\n        }\n        if (event === ifStr2) {\n          callback();\n        }\n        if (event === ifStr3) {\n          callback();\n        }\n      };\n    case 'pass end':\n      test = arg1;\n      return function (event, callback) {\n        if (event === ifStr1) {\n          callback(test);\n        }\n        if (event === ifStr2) {\n          callback();\n        }\n      };\n    case 'test end fail':\n      test = arg1;\n      var error = arg2;\n      return function (event, callback) {\n        if (event === ifStr1) {\n          callback();\n        }\n        if (event === ifStr2) {\n          callback(test, error);\n        }\n      };\n    case 'fail end pass':\n      return function (event, callback) {\n        test = arg1;\n        if (event === ifStr1) {\n          callback(test, {});\n        }\n        if (event === ifStr2) {\n          callback(test);\n        }\n        if (event === ifStr3) {\n          callback(test);\n        }\n      };\n    default:\n      throw createUnsupportedError(\n        'This function does not support the runner string specified.'\n      );\n  }\n}\n\nfunction makeTest(err) {\n  return {\n    err,\n    titlePath: function () {\n      return ['test title'];\n    }\n  };\n}\n\nfunction createElements(argObj) {\n  var res = [];\n  for (var i = argObj.from; i <= argObj.to; i++) {\n    res.push('element ' + i);\n  }\n  return res;\n}\n\nfunction makeExpectedTest(\n  expectedTitle,\n  expectedFullTitle,\n  expectedFile,\n  expectedDuration,\n  currentRetry,\n  expectedBody\n) {\n  return {\n    title: expectedTitle,\n    fullTitle: function () {\n      return expectedFullTitle;\n    },\n    file: expectedFile,\n    duration: expectedDuration,\n    currentRetry: function () {\n      return currentRetry;\n    },\n    slow: function () {}\n  };\n}\n\n/**\n * Creates closure with reference to the reporter class constructor.\n *\n * @param {Function} ctor - Reporter class constructor\n * @return {createRunReporterFunction~runReporter}\n */\nfunction createRunReporterFunction(ctor) {\n  /**\n   * Run reporter using stream reassignment to capture output.\n   *\n   * @param {Object} stubSelf - Reporter-like stub instance\n   * @param {Runner} runner - Mock instance\n   * @param {Object} [options] - Reporter configuration settings\n   * @param {boolean} [tee=false] - Whether to echo output to screen\n   * @return {string[]} Lines of output written to `stdout`\n   */\n  var runReporter = function (stubSelf, runner, options, tee) {\n    var origStdoutWrite = process.stdout.write;\n    var stdoutWriteStub = sinon.stub(process.stdout, 'write');\n    var stdout = [];\n\n    var gather = function (chunk, enc, callback) {\n      stdout.push(chunk);\n      if (tee) {\n        origStdoutWrite.call(process.stdout, chunk);\n      }\n    };\n\n    // Reassign stream in order to make a copy of all reporter output\n    stdoutWriteStub.callsFake(gather);\n\n    // Give `stubSelf` access to `ctor` prototype chain\n    Object.setPrototypeOf(stubSelf, ctor.prototype);\n\n    try {\n      // Invoke reporter\n      ctor.call(stubSelf, runner, options);\n    } finally {\n      // Revert stream reassignment here so reporter output\n      // can't be corrupted if any test assertions throw\n      stdoutWriteStub.restore();\n    }\n\n    return stdout;\n  };\n\n  return runReporter;\n}\n\nmodule.exports = {\n  createElements,\n  createMockRunner,\n  createRunReporterFunction,\n  makeExpectedTest,\n  makeTest\n};"}
{"prompt":"async, function  {","test":"'use strict';\n\ndescribe('async', function () {\n  var calls = [];\n\n  before(function () {\n    calls.push('root before all');\n  });\n\n  after(function () {\n    calls.push('root after all');\n    expect(calls, 'to equal', [\n      'root before all',\n      'before all',\n      'parent before',\n      'before',\n      'before test one',\n      'one',\n      'after',\n      'after test one passed',\n      'parent after',\n      'parent before',\n      'before',\n      'before test two',\n      'two',\n      'after',\n      'after test two passed',\n      'parent after',\n      'parent before',\n      'before',\n      'before test three',\n      'three',\n      'after',\n      'after test three passed',\n      'parent after',\n      'after all',\n      'root after all'\n    ]);\n  });\n\n  beforeEach(function () {\n    calls.push('parent before');\n  });\n\n  afterEach(function () {\n    calls.push('parent after');\n  });\n\n  describe('hooks', function () {\n    before(function () {\n      calls.push('before all');\n    });\n\n    after(function () {\n      calls.push('after all');\n    });\n\n    beforeEach(function (done) {\n      var ctx = this;\n      process.nextTick(function () {\n        calls.push('before');\n        if (ctx.currentTest) {\n          calls.push('before test ' + ctx.currentTest.title);\n        }\n        done();\n      });\n    });\n\n    it('one', function (done) {\n      expect(calls, 'to equal', [\n        'root before all',\n        'before all',\n        'parent before',\n        'before',\n        'before test one'\n      ]);\n      calls.push('one');\n      process.nextTick(done);\n    });\n\n    it('two', function () {\n      expect(calls, 'to equal', [\n        'root before all',\n        'before all',\n        'parent before',\n        'before',\n        'before test one',\n        'one',\n        'after',\n        'after test one passed',\n        'parent after',\n        'parent before',\n        'before',\n        'before test two'\n      ]);\n      calls.push('two');\n    });\n\n    it('three', function () {\n      expect(calls, 'to equal', [\n        'root before all',\n        'before all',\n        'parent before',\n        'before',\n        'before test one',\n        'one',\n        'after',\n        'after test one passed',\n        'parent after',\n        'parent before',\n        'before',\n        'before test two',\n        'two',\n        'after',\n        'after test two passed',\n        'parent after',\n        'parent before',\n        'before',\n        'before test three'\n      ]);\n      calls.push('three');\n    });\n\n    afterEach(function (done) {\n      var ctx = this;\n      process.nextTick(function () {\n        calls.push('after');\n        if (ctx.currentTest) {\n          calls.push(\n            'after test ' + ctx.currentTest.title + ' ' + ctx.currentTest.state\n          );\n        }\n        done();\n      });\n    });\n  });\n});"}
{"prompt":"hook error handling, function  {","test":"'use strict';\nconst {\n  runMocha,\n  runMochaJSON,\n  runMochaJSONAsync,\n  SPLIT_DOT_REPORTER_REGEXP\n} = require('./helpers');\nconst {bang} = require('../../lib/reporters/base').symbols;\n\ndescribe('hook error handling', function () {\n  let lines;\n\n  describe('before hook error', function () {\n    before(run('hooks/before-hook-error.fixture.js'));\n    it('should verify results', function () {\n      expect(lines, 'to equal', ['before', bang + 'test 3']);\n    });\n  });\n\n  describe('before hook error tip', function () {\n    before(run('hooks/before-hook-error-tip.fixture.js', onlyErrorTitle()));\n    it('should verify results', function () {\n      expect(lines, 'to equal', [\n        '1) spec 2',\n        '\"before all\" hook for \"skipped\":'\n      ]);\n    });\n  });\n\n  describe('before hook root error', function () {\n    it('should verify results', function (done) {\n      runMochaJSON('hooks/before-hook-root-error', [], (err, res) => {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to have failed with error', 'before hook root error')\n          .and('to have failed test', '\"before all\" hook in \"{root}\"')\n          .and('to have passed test count', 0);\n        done();\n      });\n    });\n  });\n\n  describe('before hook nested error', function () {\n    it('should verify results', function (done) {\n      runMochaJSON('hooks/before-hook-nested-error', [], (err, res) => {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to have failed with error', 'before hook nested error')\n          .and(\n            'to have failed test',\n            '\"before all\" hook for \"it nested - this title should be used\"'\n          )\n          .and('to have passed test count', 1)\n          .and('to have passed test', 'should pass');\n        done();\n      });\n    });\n  });\n\n  describe('before hook deepnested error', function () {\n    it('should verify results', function (done) {\n      runMochaJSON('hooks/before-hook-deepnested-error', [], (err, res) => {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to have failed with error', 'before hook nested error')\n          .and(\n            'to have failed test',\n            '\"before all\" hook in \"spec 2 nested - this title should be used\"'\n          )\n          .and('to have passed test count', 1)\n          .and('to have passed test', 'should pass');\n        done();\n      });\n    });\n  });\n\n  describe('before each hook error', function () {\n    before(run('hooks/before-each-hook-error.fixture.js'));\n    it('should verify results', function () {\n      expect(lines, 'to equal', ['before', bang + 'test 3']);\n    });\n  });\n\n  describe('after hook error', function () {\n    before(run('hooks/after-hook-error.fixture.js'));\n    it('should verify results', function () {\n      expect(lines, 'to equal', ['test 1', 'test 2', 'after', bang + 'test 3']);\n    });\n  });\n\n  describe('after hook nested error', function () {\n    it('should verify results', function (done) {\n      runMochaJSON('hooks/after-hook-nested-error', [], (err, res) => {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to have failed with error', 'after hook nested error')\n          .and(\n            'to have failed test',\n            '\"after all\" hook for \"it nested - this title should be used\"'\n          )\n          .and('to have passed test count', 3)\n          .and(\n            'to have passed test order',\n            'should pass',\n            'it nested - this title should be used',\n            'it nested - not this title'\n          );\n        done();\n      });\n    });\n  });\n\n  describe('after hook deepnested error', function () {\n    it('should verify results', function (done) {\n      runMochaJSON('hooks/after-hook-deepnested-error', [], (err, res) => {\n        if (err) {\n          return done(err);\n        }\n        expect(res, 'to have failed with error', 'after hook nested error')\n          .and(\n            'to have failed test',\n            '\"after all\" hook in \"spec 2 nested - this title should be used\"'\n          )\n          .and('to have passed test count', 2)\n          .and(\n            'to have passed test order',\n            'should pass',\n            'it nested - this title should not be used'\n          );\n        done();\n      });\n    });\n  });\n\n  describe('after each hook error', function () {\n    before(run('hooks/after-each-hook-error.fixture.js'));\n    it('should verify results', function () {\n      expect(lines, 'to equal', ['test 1', 'after', bang + 'test 3']);\n    });\n  });\n\n  describe('multiple hook errors', function () {\n    before(run('hooks/multiple-hook-error.fixture.js'));\n    it('should verify results', function () {\n      expect(lines, 'to equal', [\n        'root before',\n        '1-1 before',\n        'root before each',\n        '1 before each',\n        '1-1 before each',\n        bang + '1-1 after each',\n        '1 after each',\n        'root after each',\n        '1-1 after',\n        bang + '1-2 before',\n        'root before each',\n        '1 before each',\n        '1-2 before each',\n        '1-2 test 1',\n        '1-2 after each',\n        bang + '1 after each',\n        'root after each',\n        '1-2 after',\n        '1 after',\n        '2-1 before',\n        'root before each',\n        '2 before each',\n        bang + '2 after each',\n        bang + 'root after each',\n        '2-1 after',\n        '2 after',\n        'root after'\n      ]);\n    });\n  });\n\n  describe('async - before hook error', function () {\n    before(run('hooks/before-hook-async-error.fixture.js'));\n    it('should verify results', function () {\n      expect(lines, 'to equal', ['before', bang + 'test 3']);\n    });\n  });\n\n  describe('async - before hook error tip', function () {\n    before(\n      run('hooks/before-hook-async-error-tip.fixture.js', onlyErrorTitle())\n    );\n    it('should verify results', function () {\n      expect(lines, 'to equal', [\n        '1) spec 2',\n        '\"before all\" hook for \"skipped\":'\n      ]);\n    });\n  });\n\n  describe('async - before each hook error', function () {\n    before(run('hooks/before-each-hook-async-error.fixture.js'));\n    it('should verify results', function () {\n      expect(lines, 'to equal', ['before', bang + 'test 3']);\n    });\n  });\n\n  describe('async - after hook error', function () {\n    before(run('hooks/after-hook-async-error.fixture.js'));\n    it('should verify results', function () {\n      expect(lines, 'to equal', ['test 1', 'test 2', 'after', bang + 'test 3']);\n    });\n  });\n\n  describe('async - after each hook error', function () {\n    before(run('hooks/after-each-hook-async-error.fixture.js'));\n    it('should verify results', function () {\n      expect(lines, 'to equal', ['test 1', 'after', bang + 'test 3']);\n    });\n  });\n\n  describe('async - multiple hook errors', function () {\n    before(run('hooks/multiple-hook-async-error.fixture.js'));\n    it('should verify results', function () {\n      expect(lines, 'to equal', [\n        'root before',\n        '1-1 before',\n        'root before each',\n        '1 before each',\n        '1-1 before each',\n        bang + '1-1 after each',\n        '1 after each',\n        'root after each',\n        '1-1 after',\n        bang + '1-2 before',\n        'root before each',\n        '1 before each',\n        '1-2 before each',\n        '1-2 test 1',\n        '1-2 after each',\n        bang + '1 after each',\n        'root after each',\n        '1-2 after',\n        '1 after',\n        '2-1 before',\n        'root before each',\n        '2 before each',\n        bang + '2 after each',\n        bang + 'root after each',\n        '2-1 after',\n        '2 after',\n        'root after'\n      ]);\n    });\n  });\n\n  describe('\"this.test.error()-style failure', function () {\n    it('should fail the associated test', async function () {\n      return expect(\n        runMochaJSONAsync('hooks/after-each-this-test-error'),\n        'when fulfilled',\n        'to have failed'\n      ).and(\n        'when fulfilled',\n        'to have failed test',\n        'fail the test from the \"after each\" hook should fail'\n      );\n    });\n  });\n\n  function run(fnPath, outputFilter) {\n    return done =>\n      runMocha(fnPath, ['--reporter', 'dot'], (err, res) => {\n        expect(err, 'to be falsy');\n\n        lines = res.output\n          .split(SPLIT_DOT_REPORTER_REGEXP)\n          .map(line => line.trim())\n          .filter(outputFilter || onlyConsoleOutput());\n\n        done();\n      });\n  }\n});\n\nfunction onlyConsoleOutput() {\n  let foundSummary = false;\n  return line => {\n    if (!foundSummary) {\n      foundSummary = !!/\\(\\d+ms\\)/.exec(line);\n    }\n    return !foundSummary && line.length > 0;\n  };\n}\n\nfunction onlyErrorTitle(line) {\n  let foundErrorTitle = false;\n  let foundError = false;\n  return line => {\n    if (!foundErrorTitle) {\n      foundErrorTitle = !!/^1\\)/.exec(line);\n    }\n    if (!foundError) {\n      foundError = /Error:/.exec(line);\n    }\n    return foundErrorTitle && !foundError;\n  };\n}"}
{"prompt":"serial, function  {","test":"'use strict';\n\ndescribe('serial', function () {\n  describe('nested', function () {\n    var calls = [];\n\n    beforeEach(function () {\n      calls.push('parent before');\n      if (this.currentTest) {\n        calls.push('parent before test ' + this.currentTest.title);\n      }\n    });\n\n    afterEach(function () {\n      calls.push('parent after');\n      if (this.currentTest) {\n        calls.push(\n          'parent after test ' +\n            this.currentTest.title +\n            ' ' +\n            this.currentTest.state\n        );\n      }\n    });\n\n    it('foo', function () {\n      expect(calls, 'to equal', ['parent before', 'parent before test foo']);\n      calls.push('foo');\n    });\n\n    it('bar', function () {\n      expect(calls, 'to equal', [\n        'parent before',\n        'parent before test foo',\n        'foo',\n        'parent after',\n        'parent after test foo passed',\n        'parent before',\n        'parent before test bar'\n      ]);\n    });\n\n    describe('hooks', function () {\n      beforeEach(function () {\n        calls.push('before');\n        if (this.currentTest) {\n          calls.push('before test ' + this.currentTest.title);\n        }\n      });\n\n      it('one', function () {\n        expect(calls, 'to equal', [\n          'parent before',\n          'parent before test foo',\n          'foo',\n          'parent after',\n          'parent after test foo passed',\n          'parent before',\n          'parent before test bar',\n          'parent after',\n          'parent after test bar passed',\n          'parent before',\n          'parent before test one',\n          'before',\n          'before test one'\n        ]);\n        calls.push('one');\n      });\n\n      it('two', function () {\n        expect(calls, 'to equal', [\n          'parent before',\n          'parent before test foo',\n          'foo',\n          'parent after',\n          'parent after test foo passed',\n          'parent before',\n          'parent before test bar',\n          'parent after',\n          'parent after test bar passed',\n          'parent before',\n          'parent before test one',\n          'before',\n          'before test one',\n          'one',\n          'after',\n          'after test one passed',\n          'parent after',\n          'parent after test one passed',\n          'parent before',\n          'parent before test two',\n          'before',\n          'before test two'\n        ]);\n        calls.push('two');\n      });\n\n      afterEach(function () {\n        calls.push('after');\n        if (this.currentTest) {\n          calls.push(\n            'after test ' +\n              this.currentTest.title +\n              ' ' +\n              this.currentTest.state\n          );\n        }\n      });\n    });\n  });\n});"}
{"prompt":"serial, function  {","test":"'use strict';\n\ndescribe('serial', function () {\n  var calls = [];\n\n  beforeEach(function () {\n    calls.push('parent before');\n  });\n\n  afterEach(function () {\n    calls.push('parent after');\n  });\n\n  describe('hooks', function () {\n    beforeEach(function () {\n      calls.push('before');\n      if (this.currentTest) {\n        calls.push('before test ' + this.currentTest.title);\n      }\n    });\n\n    it('one', function () {\n      expect(calls, 'to equal', ['parent before', 'before', 'before test one']);\n      calls.push('one');\n    });\n\n    it('two', function () {\n      expect(calls, 'to equal', [\n        'parent before',\n        'before',\n        'before test one',\n        'one',\n        'after',\n        'after test one passed',\n        'parent after',\n        'parent before',\n        'before',\n        'before test two'\n      ]);\n      calls.push('two');\n    });\n\n    it('three', function () {\n      expect(calls, 'to equal', [\n        'parent before',\n        'before',\n        'before test one',\n        'one',\n        'after',\n        'after test one passed',\n        'parent after',\n        'parent before',\n        'before',\n        'before test two',\n        'two',\n        'after',\n        'after test two passed',\n        'parent after',\n        'parent before',\n        'before',\n        'before test three'\n      ]);\n      calls.push('three');\n    });\n\n    afterEach(function () {\n      calls.push('after');\n      if (this.currentTest) {\n        calls.push(\n          'after test ' + this.currentTest.title + ' ' + this.currentTest.state\n        );\n      }\n    });\n\n    after(function () {\n      expect(calls, 'to equal', [\n        'parent before',\n        'before',\n        'before test one',\n        'one',\n        'after',\n        'after test one passed',\n        'parent after',\n        'parent before',\n        'before',\n        'before test two',\n        'two',\n        'after',\n        'after test two passed',\n        'parent after',\n        'parent before',\n        'before',\n        'before test three',\n        'three',\n        'after',\n        'after test three passed',\n        'parent after'\n      ]);\n    });\n  });\n});"}
{"prompt":"hook timeout, function  {","test":"'use strict';\n\ndescribe('hook timeout', function () {\n  before(function (done) {\n    setTimeout(done, 100);\n  });\n\n  it('should work', function (done) {\n    done();\n  });\n});"}
{"prompt":"uncaught, function  {","test":"'use strict';\n\ndescribe('uncaught', function () {\n  beforeEach(function (done) {\n    process.nextTick(function () {\n      throw new Error('oh noes');\n    });\n  });\n\n  it('test', function (done) {\n    process.nextTick(function () {\n      throw new Error(\"I'm uncaught!\");\n    });\n  });\n});"}
{"prompt":"Hook, function  {","test":"'use strict';\nvar sinon = require('sinon');\nvar Mocha = require('../../lib/mocha');\nvar Hook = Mocha.Hook;\nvar Runnable = Mocha.Runnable;\n\ndescribe('Hook', function () {\n  var hook;\n\n  beforeEach(function () {\n    hook = new Hook('Some hook', function () {});\n  });\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('error', function () {\n    it('should set the hook._error', function () {\n      var expectedError = new Error('Expected error');\n      hook.error(expectedError);\n      expect(hook._error, 'to be', expectedError);\n    });\n    it('should get the hook._error when called without arguments', function () {\n      var expectedError = new Error('Expected error');\n      hook._error = expectedError;\n      expect(hook.error(), 'to be', expectedError);\n    });\n  });\n\n  describe('reset', function () {\n    it('should call Runnable.reset', function () {\n      var runnableResetStub = sinon.stub(Runnable.prototype, 'reset');\n      hook.reset();\n      expect(runnableResetStub, 'was called once');\n    });\n\n    it('should reset the error state', function () {\n      hook.error(new Error('Expected error for test'));\n      hook.reset();\n      expect(hook.error(), 'to be undefined');\n    });\n  });\n});"}
{"prompt":"retries, function  {","test":"'use strict';\n\ndescribe('retries', function () {\n  var times = 0;\n  before(function () {\n    console.log('before');\n  });\n\n  after(function () {\n    console.log('after');\n  });\n\n  beforeEach(function () {\n    console.log('before each', times);\n  });\n\n  afterEach(function () {\n    console.log('after each', times);\n  });\n\n  it('should allow override and run appropriate hooks', function () {\n    this.retries(4);\n    console.log('TEST', times);\n    times++;\n    throw new Error('retry error');\n  });\n});"}
{"prompt":"hooks, function  {","test":"'use strict';\n\nvar assert = require('node:assert');\nvar runMocha = require('./helpers').runMocha;\nvar runMochaJSON = require('./helpers').runMochaJSON;\nvar SPLIT_DOT_REPORTER_REGEXP = require('./helpers').SPLIT_DOT_REPORTER_REGEXP;\nvar args = ['--reporter', 'dot'];\n\ndescribe('hooks', function () {\n  it('are ran in correct order', function (done) {\n    runMocha('cascade.fixture.js', args, function (err, res) {\n      var lines, expected;\n\n      if (err) {\n        done(err);\n        return;\n      }\n\n      lines = res.output\n        .split(SPLIT_DOT_REPORTER_REGEXP)\n        .map(function (line) {\n          return line.trim();\n        })\n        .filter(function (line) {\n          return line.length;\n        })\n        .slice(0, -1);\n\n      expected = [\n        'before one',\n        'before two',\n        'before three',\n        'before each one',\n        'before each two',\n        'before each three',\n        'TEST three',\n        'after each three',\n        'after each two',\n        'after each one',\n        'after three',\n        'after two',\n        'after one'\n      ];\n\n      expected.forEach(function (line, i) {\n        assert.strictEqual(lines[i], line);\n      });\n\n      assert.strictEqual(res.code, 0);\n      done();\n    });\n  });\n\n  it('current test title of all hooks', function (done) {\n    runMochaJSON('current-test-title.fixture.js', [], function (err, res) {\n      if (err) {\n        return done(err);\n      }\n      expect(res, 'to have passed')\n        .and('to have passed test count', 3)\n        .and('to have passed test order', 'test1 B', 'test1 C', 'test2 C');\n      done();\n    });\n  });\n});"}
{"prompt":"--ignore, function  {","test":"'use strict';\n\nvar path = require('node:path').posix;\nvar helpers = require('../helpers');\nvar runMochaJSON = helpers.runMochaJSON;\nvar resolvePath = helpers.resolveFixturePath;\n\ndescribe('--ignore', function () {\n  /*\n   * Runs mocha in {path} with the given args.\n   * Calls handleResult with the result.\n   *\n   * @param {string} fixture\n   * @param {string[]} args\n   * @param {function} handleResult\n   * @param {function} done\n   */\n  function runMochaTest(fixture, args, handleResult, done) {\n    runMochaJSON(fixture, args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      handleResult(res);\n      done();\n    });\n  }\n\n  it('should ignore specific files', function (done) {\n    var fixtures = path.join('options', 'ignore', '*');\n    runMochaTest(\n      fixtures,\n      [\n        '--ignore',\n        resolvePath(path.join('options', 'ignore', 'fail')).replace(/\\\\/g, '/')\n      ],\n      function (res) {\n        expect(res, 'to have passed')\n          .and('to have run test', 'should find this test')\n          .and('not to have pending tests');\n      },\n      done\n    );\n  });\n\n  it('should ignore globbed files', function (done) {\n    var fixtures = path.join('options', 'ignore', '**', '*');\n    runMochaTest(\n      fixtures,\n      ['--ignore', '**/fail.fixture.js'],\n      function (res) {\n        expect(res, 'to have passed')\n          .and('not to have pending tests')\n          .and('to have passed test count', 2);\n      },\n      done\n    );\n  });\n\n  it('should ignore multiple patterns', function (done) {\n    var fixtures = path.join('options', 'ignore', '**', '*');\n    runMochaTest(\n      fixtures,\n      [\n        '--ignore',\n        resolvePath(path.join('options', 'ignore', 'fail')).replace(/\\\\/g, '/'),\n        '--ignore',\n        resolvePath(path.join('options', 'ignore', 'nested', 'fail')).replace(\n          /\\\\/g,\n          '/'\n        )\n      ],\n      function (res) {\n        expect(res, 'to have passed')\n          .and('not to have pending tests')\n          .and('to have passed test count', 2);\n      },\n      done\n    );\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nvar Mocha = require('../../');\n\nvar mocha = new Mocha({\n  ui: 'bdd',\n  globals: ['okGlobalA', 'okGlobalB', 'okGlobalC', 'callback*'],\n  growl: true\n});\n\nrequire('../setup');\n\nmocha.addFile('test/unit/suite.spec.js');\nmocha.addFile('test/unit/runner.spec.js');\nmocha.addFile('test/unit/runnable.spec.js');\nmocha.addFile('test/unit/hook-sync.spec.js');\nmocha.addFile('test/unit/hook-sync-nested.spec.js');\nmocha.addFile('test/unit/hook-async.spec.js');\nmocha.addFile('test/unit/duration.spec.js');\nmocha.addFile('test/unit/globals.spec.js');\nmocha.addFile('test/unit/timeout.spec.js');\n\nmocha.run(function () {\n  console.log('done');\n});"}
{"prompt":"init command, function  {","test":"'use strict';\n\nvar fs = require('node:fs');\nvar rimraf = require('rimraf');\nvar invokeMocha = require('./helpers').invokeMocha;\nvar path = require('node:path');\nvar os = require('node:os');\n\ndescribe('init command', function () {\n  var tmpdir;\n\n  beforeEach(function () {\n    tmpdir = path.join(os.tmpdir(), 'mocha-init');\n    try {\n      fs.mkdirSync(tmpdir);\n    } catch (ignored) {}\n    expect(fs.existsSync(tmpdir), 'to be true');\n  });\n\n  afterEach(function () {\n    try {\n      rimraf.sync(tmpdir);\n    } catch (ignored) {}\n  });\n\n  describe('when no path is supplied', function () {\n    it('should fail', function (done) {\n      invokeMocha(\n        ['init'],\n        function (err, result) {\n          if (err) {\n            return done(err);\n          }\n          expect(\n            result,\n            'to have failed with output',\n            /not enough non-option arguments/i\n          );\n          done();\n        },\n        {stdio: 'pipe'}\n      );\n    });\n    it('should not throw', function (done) {\n      invokeMocha(\n        ['init'],\n        function (err, result) {\n          if (err) {\n            return done(err);\n          }\n          expect(result, 'to have failed').and('not to satisfy', {\n            output: /throw/i\n          });\n          done();\n        },\n        {stdio: 'pipe'}\n      );\n    });\n  });\n\n  it('should create some files in the dest dir', function (done) {\n    invokeMocha(\n      ['init', tmpdir],\n      function (err, result) {\n        if (err) {\n          return done(err);\n        }\n        expect(result, 'to have succeeded');\n        expect(fs.existsSync(path.join(tmpdir, 'mocha.css')), 'to be true');\n        expect(fs.existsSync(path.join(tmpdir, 'mocha.js')), 'to be true');\n        expect(fs.existsSync(path.join(tmpdir, 'tests.spec.js')), 'to be true');\n        expect(fs.existsSync(path.join(tmpdir, 'index.html')), 'to be true');\n        done();\n      },\n      {stdio: 'pipe'}\n    );\n  });\n});"}
{"prompt":"invalid arguments, function  {","test":"'use strict';\n\nvar invokeMocha = require('./helpers').invokeMocha;\n\ndescribe('invalid arguments', function () {\n  describe('when argument is missing required value', function () {\n    it('should exit with failure', function (done) {\n      invokeMocha(\n        ['--ui'],\n        function (err, result) {\n          if (err) {\n            return done(err);\n          }\n          expect(result, 'to have failed');\n          expect(result.output, 'to match', /not enough arguments/i);\n          done();\n        },\n        {stdio: 'pipe'}\n      );\n    });\n  });\n});"}
{"prompt":"--invert, function  {","test":"'use strict';\n\nvar runMocha = require('../helpers').runMocha;\n\ndescribe('--invert', function () {\n  describe('when used without --fgrep or --grep', function () {\n    it('it should report an error', function (done) {\n      runMocha(\n        'options/grep',\n        ['--invert'],\n        function (err, res) {\n          if (err) {\n            return done(err);\n          }\n          expect(\n            res,\n            'to have failed with output',\n            /--invert.*--grep <regexp>/\n          );\n          done();\n        },\n        'pipe'\n      );\n    });\n  });\n});"}
{"prompt":"we cannot recover gracefully if a Runnable has already passed","test":"'use strict';\n\n// we cannot recover gracefully if a Runnable has already passed\n// then fails asynchronously\nit('test 1', function () {\n  process.nextTick(function () {\n    throw new Error('Too bad');\n  });\n});\n\nit('test 2', function () {\n  throw new Error('should not run - test 2');\n});\n\nit('test 3', function () {\n  throw new Error('should not run - test 3');\n});"}
{"prompt":"fails exactly once when a global error is thrown synchronously and done errors, function done {","test":"'use strict';\n\n/**\n * This file should generate only one failure per spec for the thrown error.\n * It should not report misleading 'multiple calls to done()'.\n */\n\nit('fails exactly once when a global error is thrown synchronously and done errors', function (done) {\n  setTimeout(function () {\n    done(new Error('test error'));\n  }, 1); // Not 0 - it will 'succeed', but won't test the breaking condition\n\n  throw new Error('sync error a');\n});\n\nit('fails exactly once when a global error is thrown synchronously and done completes', function (done) {\n  setTimeout(function () {\n    done();\n  }, 1); // Not 0 - it will 'succeed', but won't test the breaking condition\n\n  throw new Error('sync error b');\n});"}
{"prompt":"Memory Leak Suite # + i, function  {","test":"'use strict';\n\n/* eslint no-unused-vars: off */\n\nfunction MemoryLeak () {\n  this.myArr = [];\n  for (var i = 0; i < 1000000; i++) {\n    this.myArr.push(i);\n  }\n}\n\nvar numOfTests = 300;\nfor (var i = 0; i < numOfTests; i += 1) {\n  /*\n   * This Test suite will crash V8 due to:\n   * 'FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - process out of memory'\n   * if all the deferred functions references have not been cleared\n   */\n  describe('Memory Leak Suite #' + i, function () {\n    // The <closureVar> variable will be accessed by the test below.\n    // As long as those test's functions are\n    // referenced in memory, the closure variable may not be garbage collected\n    // as it is still referenced.\n    // * In a chrome heap snapshot it will appear under \"system / Context\" (a scope)\n    var closureVar;\n\n    before(function () {\n      var x = closureVar ? 1 : 2;\n    });\n\n    after(function () {\n      var x = closureVar[0];\n    });\n\n    beforeEach(function () {\n      var x = closureVar ? 1 : 2;\n    });\n\n    afterEach(function () {\n      var x = closureVar[0];\n    });\n\n    it('access a variable via a closure', function () {\n      // slow performance on older node.js versions\n      this.timeout(1000);\n      closureVar = new MemoryLeak();\n    });\n  });\n}"}
{"prompt":"issue-2315: cannot read property currentRetry of undefined, function  {","test":"'use strict';\n\ndescribe('issue-2315: cannot read property currentRetry of undefined', function () {\n  before(function () {\n    process.nextTick(function () {\n      throw new Error();\n    });\n  });\n\n  it('something', function () {});\n});"}
{"prompt":"outer describe, function  {","test":"'use strict';\n\ndescribe('outer describe', function () {\n  it('should not run this test', function () {});\n  describe('this suite should not run', function () {\n    it('should not run this test', function () {});\n  });\n  describe.only('this .only suite should run', function () {\n    describe('this suite should run', function () {\n      it('should run this test in a nested suite', function () {});\n    });\n    it('should run this test', function () {});\n  });\n  describe('this suite should not run', function () {\n    it('should not run this test', function () {});\n  });\n});"}
{"prompt":"outer describe, function  {","test":"'use strict';\n\ndescribe('outer describe', function () {\n  describe.only('outer describe.only', function () {\n    it.only('inner it.only', function () {\n      // should run and exit without error\n    });\n  });\n});"}
{"prompt":"--jobs, function  {","test":"'use strict';\n\nvar helpers = require('../helpers');\nvar runMochaAsync = helpers.runMochaAsync;\n\ndescribe('--jobs', function () {\n  describe('when set to a number less than 2', function () {\n    it('should run tests in serial', function () {\n      return expect(\n        runMochaAsync(\n          'options/jobs/fail-in-parallel',\n          ['--parallel', '--jobs', '1'],\n          'pipe'\n        ),\n        'when fulfilled',\n        'to have passed'\n      );\n    });\n  });\n\n  describe('when set to a number greater than 1', function () {\n    it('should run tests in parallel', function () {\n      return expect(\n        runMochaAsync(\n          'options/jobs/fail-in-parallel',\n          ['--parallel', '--jobs', '2'],\n          'pipe'\n        ),\n        'when fulfilled',\n        'to have failed'\n      );\n    });\n  });\n});"}
{"prompt":"JSON Stream reporter, function  {","test":"'use strict';\n\nvar events = require('../../').Runner.constants;\nvar helpers = require('./helpers');\nvar reporters = require('../../').reporters;\n\nvar JSONStream = reporters.JSONStream;\nvar createMockRunner = helpers.createMockRunner;\nvar makeExpectedTest = helpers.makeExpectedTest;\nvar makeRunReporter = helpers.createRunReporterFunction;\n\nvar EVENT_RUN_BEGIN = events.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = events.EVENT_RUN_END;\nvar EVENT_TEST_FAIL = events.EVENT_TEST_FAIL;\nvar EVENT_TEST_PASS = events.EVENT_TEST_PASS;\n\ndescribe('JSON Stream reporter', function () {\n  var runReporter = makeRunReporter(JSONStream);\n  var expectedTitle = 'some title';\n  var expectedFullTitle = 'full title';\n  var expectedFile = 'someTest.spec.js';\n  var expectedDuration = 1000;\n  var currentRetry = 1;\n  var expectedSpeed = 'fast';\n  var expectedTest = makeExpectedTest(\n    expectedTitle,\n    expectedFullTitle,\n    expectedFile,\n    expectedDuration,\n    currentRetry,\n    expectedSpeed\n  );\n  var expectedErrorMessage = 'error message';\n  var expectedErrorStack = 'error stack';\n  var expectedError = {\n    message: expectedErrorMessage\n  };\n\n  describe('event handlers', function () {\n    describe(\"on 'start' event\", function () {\n      it('should write stringified start with expected total', function () {\n        var runner = createMockRunner('start', EVENT_RUN_BEGIN);\n        var expectedTotal = 12;\n        runner.total = expectedTotal;\n        var options = {};\n        var stdout = runReporter({}, runner, options);\n\n        expect(\n          stdout[0],\n          'to equal',\n          '[\"start\",{\"total\":' + expectedTotal + '}]\\n'\n        );\n      });\n    });\n\n    describe(\"on 'pass' event\", function () {\n      it('should write stringified test data', function () {\n        var runner = createMockRunner(\n          'pass',\n          EVENT_TEST_PASS,\n          null,\n          null,\n          expectedTest\n        );\n        var options = {};\n        var stdout = runReporter({}, runner, options);\n\n        expect(\n          stdout[0],\n          'to equal',\n          '[\"pass\",{\"title\":' +\n            `\"${expectedTitle}\"` +\n            ',\"fullTitle\":' +\n            `\"${expectedFullTitle}\"` +\n            ',\"file\":' +\n            `\"${expectedFile}\"` +\n            ',\"duration\":' +\n            expectedDuration +\n            ',\"currentRetry\":' +\n            currentRetry +\n            ',\"speed\":' +\n            `\"${expectedSpeed}\"` +\n            '}]\\n'\n        );\n      });\n    });\n\n    describe(\"on 'fail' event\", function () {\n      describe('when error stack exists', function () {\n        it('should write stringified test data with error data', function () {\n          expectedError.stack = expectedErrorStack;\n          var runner = createMockRunner(\n            'fail two args',\n            EVENT_TEST_FAIL,\n            null,\n            null,\n            expectedTest,\n            expectedError\n          );\n          var options = {};\n          var stdout = runReporter({}, runner, options);\n\n          expect(\n            stdout[0],\n            'to equal',\n            '[\"fail\",{\"title\":' +\n              `\"${expectedTitle}\"` +\n              ',\"fullTitle\":' +\n              `\"${expectedFullTitle}\"` +\n              ',\"file\":' +\n              `\"${expectedFile}\"` +\n              ',\"duration\":' +\n              expectedDuration +\n              ',\"currentRetry\":' +\n              currentRetry +\n              ',\"speed\":' +\n              `\"${expectedSpeed}\"` +\n              ',\"err\":' +\n              `\"${expectedErrorMessage}\"` +\n              ',\"stack\":' +\n              `\"${expectedErrorStack}\"` +\n              '}]\\n'\n          );\n        });\n      });\n\n      describe('when error stack does not exist', function () {\n        it('should write stringified test data with error data', function () {\n          expectedError.stack = null;\n          var runner = createMockRunner(\n            'fail two args',\n            EVENT_TEST_FAIL,\n            null,\n            null,\n            expectedTest,\n            expectedError\n          );\n          var options = {};\n          var stdout = runReporter(this, runner, options);\n\n          expect(\n            stdout[0],\n            'to equal',\n            '[\"fail\",{\"title\":' +\n              `\"${expectedTitle}\"` +\n              ',\"fullTitle\":' +\n              `\"${expectedFullTitle}\"` +\n              ',\"file\":' +\n              `\"${expectedFile}\"` +\n              ',\"duration\":' +\n              expectedDuration +\n              ',\"currentRetry\":' +\n              currentRetry +\n              ',\"speed\":' +\n              `\"${expectedSpeed}\"` +\n              ',\"err\":' +\n              `\"${expectedErrorMessage}\"` +\n              ',\"stack\":null}]\\n'\n          );\n        });\n      });\n    });\n\n    describe(\"on 'end' event\", function () {\n      it('should write summary statistics', function () {\n        var runner = createMockRunner('end', EVENT_RUN_END);\n        var options = {};\n        var stdout = runReporter(this, runner, options);\n        expect(stdout[0], 'to match', /end/);\n      });\n    });\n  });\n});"}
{"prompt":"JSON reporter, function  {","test":"'use strict';\n\nvar fs = require('node:fs');\nvar sinon = require('sinon');\nvar JSONReporter = require('../../lib/reporters/json');\nvar utils = require('../../lib/utils');\nvar Mocha = require('../../');\nvar Suite = Mocha.Suite;\nvar Runner = Mocha.Runner;\nvar Test = Mocha.Test;\n\ndescribe('JSON reporter', function () {\n  var mocha;\n  var suite;\n  var runner;\n  var testTitle = 'json test 1';\n  var testFile = 'someTest.spec.js';\n  var noop = function () {};\n\n  beforeEach(function () {\n    mocha = new Mocha({\n      reporter: 'json'\n    });\n    suite = new Suite('JSON suite', 'root');\n    runner = new Runner(suite);\n  });\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('test results', function () {\n    beforeEach(function () {\n      var options = {};\n      /* eslint no-unused-vars: off */\n      var mochaReporter = new mocha._reporter(runner, options);\n    });\n\n    beforeEach(function () {\n      sinon.stub(process.stdout, 'write').callsFake(noop);\n    });\n\n    it('should have 1 test failure', function (done) {\n      var error = {message: 'oh shit'};\n\n      var test = new Test(testTitle, function (done) {\n        done(new Error(error.message));\n      });\n\n      test.file = testFile;\n      suite.addTest(test);\n\n      runner.run(function (failureCount) {\n        sinon.restore();\n        expect(runner, 'to satisfy', {\n          testResults: {\n            failures: [\n              {\n                title: testTitle,\n                file: testFile,\n                err: {\n                  message: error.message\n                }\n              }\n            ]\n          }\n        });\n        expect(failureCount, 'to be', 1);\n        done();\n      });\n    });\n\n    it('should have 1 test pending', function (done) {\n      var test = new Test(testTitle);\n      test.file = testFile;\n      suite.addTest(test);\n\n      runner.run(function (failureCount) {\n        sinon.restore();\n        expect(runner, 'to satisfy', {\n          testResults: {\n            pending: [\n              {\n                title: testTitle,\n                file: testFile\n              }\n            ]\n          }\n        });\n        expect(failureCount, 'to be', 0);\n        done();\n      });\n    });\n\n    it('should have 1 test pass', function (done) {\n      const test = new Test(testTitle, () => {});\n\n      test.file = testFile;\n      suite.addTest(test);\n\n      runner.run(function (failureCount) {\n        sinon.restore();\n        expect(runner, 'to satisfy', {\n          testResults: {\n            passes: [\n              {\n                title: testTitle,\n                file: testFile,\n                speed: /(slow|medium|fast)/\n              }\n            ]\n          }\n        });\n        expect(failureCount, 'to be', 0);\n        done();\n      });\n    });\n\n    it('should handle circular objects in errors', function (done) {\n      var testTitle = 'json test 1';\n      function CircleError() {\n        this.message = 'oh shit';\n        this.circular = this;\n      }\n      var error = new CircleError();\n\n      var test = new Test(testTitle, function (done) {\n        throw error;\n      });\n\n      test.file = testFile;\n      suite.addTest(test);\n\n      runner.run(function (failureCount) {\n        sinon.restore();\n        expect(runner, 'to satisfy', {\n          testResults: {\n            failures: [\n              {\n                title: testTitle,\n                file: testFile,\n                err: {\n                  message: error.message\n                }\n              }\n            ]\n          }\n        });\n        expect(failureCount, 'to be', 1);\n        done();\n      });\n    });\n  });\n\n  describe('when \"reporterOption.output\" is provided', function () {\n    var expectedDirName = 'reports';\n    var expectedFileName = 'reports/test-results.json';\n    var options = {\n      reporterOption: {\n        output: expectedFileName\n      }\n    };\n\n    beforeEach(function () {\n      /* eslint no-unused-vars: off */\n      var mochaReporter = new mocha._reporter(runner, options);\n    });\n\n    beforeEach(function () {\n      // Add one test to suite to avoid assertions against empty test results\n      var test = new Test(testTitle, () => {});\n      test.file = testFile;\n      suite.addTest(test);\n    });\n\n    it('should write test results to file', function (done) {\n      const fsMkdirSync = sinon.stub(fs, 'mkdirSync');\n      const fsWriteFileSync = sinon.stub(fs, 'writeFileSync');\n\n      fsWriteFileSync.callsFake(function (filename, content) {\n        const expectedJson = JSON.stringify(runner.testResults, null, 2);\n        expect(expectedFileName, 'to be', filename);\n        expect(content, 'to be', expectedJson);\n      });\n\n      runner.run(function () {\n        expect(\n          fsMkdirSync.calledWith(expectedDirName, {recursive: true}),\n          'to be true'\n        );\n        expect(fsWriteFileSync.calledOnce, 'to be true');\n        done();\n      });\n    });\n\n    it('should warn and write test results to console', function (done) {\n      const fsMkdirSync = sinon.stub(fs, 'mkdirSync');\n      const fsWriteFileSync = sinon.stub(fs, 'writeFileSync');\n\n      fsWriteFileSync.throws('unable to write file');\n\n      const outLog = [];\n      const fake = chunk => outLog.push(chunk);\n      sinon.stub(process.stderr, 'write').callsFake(fake);\n      sinon.stub(process.stdout, 'write').callsFake(fake);\n\n      runner.run(function () {\n        sinon.restore();\n        expect(\n          fsMkdirSync.calledWith(expectedDirName, {recursive: true}),\n          'to be true'\n        );\n        expect(fsWriteFileSync.calledOnce, 'to be true');\n        expect(\n          outLog[0],\n          'to contain',\n          `[mocha] writing output to \"${expectedFileName}\" failed:`\n        );\n        expect(outLog[1], 'to match', /\"fullTitle\": \"JSON suite json test 1\"/);\n        done();\n      });\n    });\n\n    it('should throw \"unsupported error\" in browser', function () {\n      sinon.stub(utils, 'isBrowser').callsFake(() => true);\n      expect(\n        () => new JSONReporter(runner, options),\n        'to throw',\n        'file output not supported in browser'\n      );\n    });\n  });\n});"}
{"prompt":"Landing reporter, function  {","test":"'use strict';\n\nvar sinon = require('sinon');\nvar events = require('../../').Runner.constants;\nvar helpers = require('./helpers');\nvar reporters = require('../../').reporters;\nvar states = require('../../').Runnable.constants;\n\nvar Base = reporters.Base;\nvar Landing = reporters.Landing;\nvar createMockRunner = helpers.createMockRunner;\nvar makeRunReporter = helpers.createRunReporterFunction;\n\nvar EVENT_RUN_BEGIN = events.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = events.EVENT_RUN_END;\nvar EVENT_TEST_END = events.EVENT_TEST_END;\n\nvar STATE_FAILED = states.STATE_FAILED;\nvar STATE_PASSED = states.STATE_PASSED;\n\ndescribe('Landing reporter', function () {\n  var runReporter = makeRunReporter(Landing);\n  var resetCode = '\\u001b[0m';\n  var expectedArray = [\n    '\\u001b[1D\\u001b[2A',\n    '  ',\n    '\\n  ',\n    '',\n    '✈',\n    '\\n',\n    '  ',\n    resetCode\n  ];\n\n  beforeEach(function () {\n    sinon.stub(Base, 'useColors').value(false);\n    sinon.stub(Base.window, 'width').value(1);\n  });\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('event handlers', function () {\n    describe(\"on 'start' event\", function () {\n      it('should write newlines', function () {\n        sinon.stub(Base.cursor, 'hide');\n\n        var runner = createMockRunner('start', EVENT_RUN_BEGIN);\n        var options = {};\n        var stdout = runReporter({}, runner, options);\n        sinon.restore();\n\n        expect(stdout[0], 'to equal', '\\n\\n\\n  ');\n      });\n\n      it('should call cursor hide', function () {\n        var hideCursorStub = sinon.stub(Base.cursor, 'hide');\n\n        var runner = createMockRunner('start', EVENT_RUN_BEGIN);\n        var options = {};\n        runReporter({}, runner, options);\n        sinon.restore();\n\n        expect(hideCursorStub.called, 'to be true');\n      });\n    });\n\n    describe(\"on 'test end' event\", function () {\n      describe('when test passes', function () {\n        it('should write expected landing strip', function () {\n          var test = {\n            state: STATE_PASSED\n          };\n          var runner = createMockRunner(\n            'test end',\n            EVENT_TEST_END,\n            null,\n            null,\n            test\n          );\n          var options = {};\n          var stdout = runReporter({}, runner, options);\n          sinon.restore();\n\n          expect(stdout, 'to equal', expectedArray);\n        });\n      });\n\n      describe('when test fails', function () {\n        it('should write expected landing strip', function () {\n          var test = {\n            state: STATE_FAILED\n          };\n          var runner = createMockRunner(\n            'test end',\n            EVENT_TEST_END,\n            null,\n            null,\n            test\n          );\n          runner.total = 12;\n          var options = {};\n          var stdout = runReporter({}, runner, options);\n          sinon.restore();\n\n          expect(stdout, 'to equal', expectedArray);\n        });\n      });\n    });\n\n    describe(\"on 'end' event\", function () {\n      it('should call cursor show and epilogue', function () {\n        var showCursorStub = sinon.stub(Base.cursor, 'show');\n\n        var fakeThis = {\n          epilogue: sinon.spy()\n        };\n        var runner = createMockRunner('end', EVENT_RUN_END);\n        var options = {};\n        runReporter(fakeThis, runner, options);\n        sinon.restore();\n\n        expect(fakeThis.epilogue.calledOnce, 'to be true');\n        expect(showCursorStub.called, 'to be true');\n      });\n    });\n  });\n});"}
{"prompt":"List reporter, function  {","test":"'use strict';\n\nvar sinon = require('sinon');\nvar events = require('../../').Runner.constants;\nvar helpers = require('./helpers');\nvar reporters = require('../../').reporters;\n\nvar Base = reporters.Base;\nvar List = reporters.List;\nvar createMockRunner = helpers.createMockRunner;\nvar makeRunReporter = helpers.createRunReporterFunction;\n\nvar EVENT_RUN_BEGIN = events.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = events.EVENT_RUN_END;\nvar EVENT_TEST_BEGIN = events.EVENT_TEST_BEGIN;\nvar EVENT_TEST_FAIL = events.EVENT_TEST_FAIL;\nvar EVENT_TEST_PASS = events.EVENT_TEST_PASS;\nvar EVENT_TEST_PENDING = events.EVENT_TEST_PENDING;\n\ndescribe('List reporter', function () {\n  var runReporter = makeRunReporter(List);\n  var expectedTitle = 'some title';\n  var expectedDuration = 100;\n  var noop = function () {};\n  var test = {\n    fullTitle: function () {\n      return expectedTitle;\n    },\n    duration: expectedDuration,\n    slow: noop\n  };\n\n  beforeEach(function () {\n    sinon.stub(Base, 'useColors').value(false);\n  });\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('event handlers', function () {\n    describe(\"on 'start' and 'test' events\", function () {\n      it('should write expected newline and title', function () {\n        var runner = createMockRunner(\n          'start test',\n          EVENT_RUN_BEGIN,\n          EVENT_TEST_BEGIN,\n          null,\n          test\n        );\n        var options = {};\n        var fakeThis = {\n          epilogue: noop\n        };\n        var stdout = runReporter(fakeThis, runner, options);\n        sinon.restore();\n\n        var startString = '\\n';\n        var testString = '    ' + expectedTitle + ': ';\n        var expectedArray = [startString, testString];\n        expect(stdout, 'to equal', expectedArray);\n      });\n    });\n\n    describe(\"on 'pending' event\", function () {\n      it('should write expected title', function () {\n        var runner = createMockRunner(\n          'pending test',\n          EVENT_TEST_PENDING,\n          null,\n          null,\n          test\n        );\n        var options = {};\n        var fakeThis = {\n          epilogue: noop\n        };\n        var stdout = runReporter(fakeThis, runner, options);\n        sinon.restore();\n\n        expect(stdout[0], 'to equal', '  - ' + expectedTitle + '\\n');\n      });\n    });\n\n    describe(\"on 'pass' event\", function () {\n      var crStub;\n\n      beforeEach(function () {\n        crStub = sinon.stub(Base.cursor, 'CR').callsFake(noop);\n      });\n\n      it('should call cursor CR', function () {\n        var runner = createMockRunner(\n          'pass',\n          EVENT_TEST_PASS,\n          null,\n          null,\n          test\n        );\n        var options = {};\n        var fakeThis = {\n          epilogue: noop\n        };\n        runReporter(fakeThis, runner, options);\n        sinon.restore();\n\n        expect(crStub.called, 'to be true');\n      });\n\n      it('should write expected symbol, title, and duration', function () {\n        var expectedOkSymbol = 'OK';\n        sinon.stub(Base.symbols, 'ok').value(expectedOkSymbol);\n\n        var runner = createMockRunner(\n          'pass',\n          EVENT_TEST_PASS,\n          null,\n          null,\n          test\n        );\n        var options = {};\n        var fakeThis = {\n          epilogue: noop\n        };\n        var stdout = runReporter(fakeThis, runner, options);\n        sinon.restore();\n\n        expect(\n          stdout[0],\n          'to be',\n          '  ' +\n            expectedOkSymbol +\n            ' ' +\n            expectedTitle +\n            ': ' +\n            expectedDuration +\n            'ms\\n'\n        );\n      });\n    });\n\n    describe(\"on 'fail' event\", function () {\n      var crStub;\n\n      beforeEach(function () {\n        crStub = sinon.stub(Base.cursor, 'CR').callsFake(noop);\n      });\n\n      it('should call cursor CR', function () {\n        var runner = createMockRunner(\n          'fail',\n          EVENT_TEST_FAIL,\n          null,\n          null,\n          test\n        );\n        var options = {};\n        var fakeThis = {\n          epilogue: noop\n        };\n        runReporter(fakeThis, runner, options);\n        sinon.restore();\n\n        expect(crStub.called, 'to be true');\n      });\n\n      it('should write expected error number and title', function () {\n        var expectedErrorCount = 1;\n        var runner = createMockRunner(\n          'fail',\n          EVENT_TEST_FAIL,\n          null,\n          null,\n          test\n        );\n        var options = {};\n        var fakeThis = {\n          epilogue: noop\n        };\n        var stdout = runReporter(fakeThis, runner, options);\n        sinon.restore();\n\n        expect(\n          stdout[0],\n          'to be',\n          '  ' + expectedErrorCount + ') ' + expectedTitle + '\\n'\n        );\n      });\n\n      it('should immediately construct fail strings', function () {\n        var actual = {a: 'actual'};\n        var expected = {a: 'expected'};\n        var checked = false;\n        var err;\n        test = {};\n\n        var runner = createMockRunner(\n          'fail',\n          EVENT_TEST_FAIL,\n          null,\n          null,\n          test\n        );\n        runner.on = runner.once = function (event, callback) {\n          if (\n            !checked &&\n            event === 'fail' &&\n            callback.toString().includes('stringifyDiffObjs') // target correct fail event callback\n          ) {\n            err = new Error('fake failure object with actual/expected');\n            err.actual = actual;\n            err.expected = expected;\n            err.showDiff = true;\n            callback(test, err);\n            checked = true;\n          }\n        };\n        var options = {};\n        var fakeThis = {\n          epilogue: noop\n        };\n        runReporter(fakeThis, runner, options);\n        sinon.restore();\n\n        expect(typeof err.actual, 'to be', 'string');\n        expect(typeof err.expected, 'to be', 'string');\n      });\n    });\n\n    describe(\"on 'end' event\", function () {\n      it('should call epilogue', function () {\n        var runner = createMockRunner('end', EVENT_RUN_END);\n        var options = {};\n        var fakeThis = {\n          epilogue: sinon.spy()\n        };\n        runReporter(fakeThis, runner, options);\n        sinon.restore();\n\n        expect(fakeThis.epilogue.calledOnce, 'to be true');\n      });\n    });\n  });\n});"}
{"prompt":"keep this low to avoid warning","test":"'use strict';\n\nconst assert = require('assert');\nconst mocha = require('../../../../lib/mocha');\n\n// keep this low to avoid warning\nfor (let i = 0; i < 5; i++) {\n  const r = new mocha.Runner(new mocha.Suite('' + i, undefined));\n  r.run();\n}\n\nassert.strictEqual(process.listenerCount('uncaughtException'), 1);\nassert.strictEqual(process.listeners('uncaughtException')[0].name, 'uncaught');"}
{"prompt":"--list-interfaces, function  {","test":"'use strict';\n\nvar helpers = require('../helpers');\nvar invokeMocha = helpers.invokeMocha;\nvar escapeRegExp = helpers.escapeRegExp;\nvar interfaces = require('../../../lib/mocha').interfaces;\n\ndescribe('--list-interfaces', function () {\n  it('should dump a list of all interfaces with descriptions', function (done) {\n    var expected = Object.keys(interfaces)\n      .filter(function (name) {\n        return /^[a-z]/.test(name);\n      })\n      .map(function (name) {\n        return {\n          name: escapeRegExp(name),\n          description: escapeRegExp(interfaces[name].description)\n        };\n      });\n\n    invokeMocha(['--list-interfaces'], function (err, result) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(result.code, 'to be', 0);\n      expected.forEach(function (ui) {\n        expect(\n          result.output,\n          'to match',\n          new RegExp(ui.name + '\\\\s*-\\\\s*' + ui.description)\n        );\n      });\n      done();\n    });\n  });\n});"}
{"prompt":"--list-reporters, function  {","test":"'use strict';\n\nvar helpers = require('../helpers');\nvar invokeMocha = helpers.invokeMocha;\nvar escapeRegExp = helpers.escapeRegExp;\nvar reporters = require('../../../lib/mocha').reporters;\n\ndescribe('--list-reporters', function () {\n  it('should dump a list of all reporters with descriptions', function (done) {\n    var expected = Object.keys(reporters)\n      .filter(function (name) {\n        return (\n          /^[a-z]/.test(name) &&\n          !(reporters[name].abstract || reporters[name].browserOnly)\n        );\n      })\n      .map(function (name) {\n        return {\n          name: escapeRegExp(name),\n          description: escapeRegExp(reporters[name].description)\n        };\n      });\n\n    invokeMocha(['--list-reporters'], function (err, result) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(result.code, 'to be', 0);\n      expected.forEach(function (reporter) {\n        expect(\n          result.output,\n          'to match',\n          new RegExp(reporter.name + '\\\\s*-\\\\s*' + reporter.description)\n        );\n      });\n      done();\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"import path from 'path'\nimport {fileURLToPath} from 'url'\n\n/**\n * @param {string} specifier\n * @param {{\n *   conditions: !Array<string>,\n *   parentURL: !(string | undefined),\n * }} context\n * @param {Function} defaultResolve\n * @returns {Promise<{ url: string }>}\n */\nexport async function resolve(specifier, context, defaultResolve) {\n  const extension = path.extname(\n    fileURLToPath(/**@type {import('url').URL}*/ (new URL(specifier, context.parentURL))),\n  )\n  return await defaultResolve(specifier.replace('.ts', '.mjs'), context, defaultResolve)\n}"}
{"prompt":"Markdown reporter, function  {","test":"'use strict';\n\nvar events = require('../../').Runner.constants;\nvar helpers = require('./helpers');\nvar reporters = require('../../').reporters;\n\nvar Markdown = reporters.Markdown;\nvar createMockRunner = helpers.createMockRunner;\nvar makeRunReporter = helpers.createRunReporterFunction;\n\nvar EVENT_RUN_END = events.EVENT_RUN_END;\nvar EVENT_SUITE_BEGIN = events.EVENT_SUITE_BEGIN;\nvar EVENT_SUITE_END = events.EVENT_SUITE_END;\nvar EVENT_TEST_PASS = events.EVENT_TEST_PASS;\n\ndescribe('Markdown reporter', function () {\n  var runReporter = makeRunReporter(Markdown);\n  var expectedTitle = 'expected title';\n  var expectedFullTitle = 'full title';\n  var sluggedFullTitle = 'full-title';\n  var noop = function () {};\n\n  describe('event handlers', function () {\n    describe(\"on 'suite' event\", function () {\n      it(\"should write expected slugged titles on 'end' event\", function () {\n        var expectedSuite = {\n          title: expectedTitle,\n          fullTitle: function () {\n            return expectedFullTitle;\n          },\n          suites: [\n            {\n              title: expectedTitle,\n              fullTitle: function () {\n                return expectedFullTitle;\n              },\n              suites: []\n            }\n          ]\n        };\n        var runner = createMockRunner(\n          'suite suite end',\n          EVENT_SUITE_BEGIN,\n          EVENT_SUITE_END,\n          EVENT_RUN_END,\n          expectedSuite\n        );\n        runner.suite = expectedSuite;\n        var options = {};\n        var stdout = runReporter({}, runner, options);\n\n        var expectedArray = [\n          '# TOC\\n',\n          ' - [' +\n            expectedTitle +\n            '](#' +\n            sluggedFullTitle +\n            ')\\n   - [' +\n            expectedTitle +\n            '](#' +\n            sluggedFullTitle +\n            ')\\n',\n          '<a name=\"' + sluggedFullTitle + '\"></a>\\n ' + expectedTitle + '\\n'\n        ];\n\n        expect(stdout, 'to equal', expectedArray);\n      });\n    });\n\n    describe(\"on 'pass' event\", function () {\n      it(\"should write test code inside js code block, on 'end' event\", function () {\n        var expectedSuite = {\n          title: expectedTitle,\n          fullTitle: function () {\n            return expectedFullTitle;\n          },\n          suites: []\n        };\n        var expectedDuration = 1000;\n        var currentRetry = 1;\n        var expectedBody = 'some body';\n        var expectedTest = {\n          title: expectedTitle,\n          fullTitle: function () {\n            return expectedFullTitle;\n          },\n          duration: expectedDuration,\n          currentRetry: function () {\n            return currentRetry;\n          },\n          slow: noop,\n          body: expectedBody\n        };\n        var runner = createMockRunner(\n          'pass end',\n          EVENT_TEST_PASS,\n          EVENT_RUN_END,\n          null,\n          expectedTest\n        );\n        runner.suite = expectedSuite;\n        var options = {};\n        var stdout = runReporter({}, runner, options);\n\n        var expectedArray = [\n          '# TOC\\n',\n          ' - [' + expectedTitle + '](#' + sluggedFullTitle + ')\\n',\n          expectedTitle + '.\\n\\n```js\\n' + expectedBody + '\\n```\\n\\n'\n        ];\n\n        expect(stdout, 'to equal', expectedArray);\n      });\n    });\n  });\n});"}
{"prompt":"Min reporter, function  {","test":"'use strict';\n\nvar sinon = require('sinon');\nvar events = require('../../').Runner.constants;\nvar helpers = require('./helpers');\nvar reporters = require('../../').reporters;\n\nvar Min = reporters.Min;\nvar createMockRunner = helpers.createMockRunner;\nvar makeRunReporter = helpers.createRunReporterFunction;\n\nvar EVENT_RUN_BEGIN = events.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = events.EVENT_RUN_END;\n\ndescribe('Min reporter', function () {\n  var runReporter = makeRunReporter(Min);\n  var noop = function () {};\n\n  describe('event handlers', function () {\n    describe(\"on 'start' event\", function () {\n      it('should clear screen then set cursor position', function () {\n        var runner = createMockRunner('start', EVENT_RUN_BEGIN);\n        var options = {};\n        var fakeThis = {\n          epilogue: noop\n        };\n        var stdout = runReporter(fakeThis, runner, options);\n\n        var expectedArray = ['\\u001b[2J', '\\u001b[1;3H'];\n        expect(stdout, 'to equal', expectedArray);\n      });\n    });\n\n    describe(\"on 'end' event\", function () {\n      it('should call epilogue', function () {\n        var fakeThis = {\n          epilogue: sinon.stub().callsFake(noop)\n        };\n        var runner = createMockRunner('end', EVENT_RUN_END);\n        var options = {};\n        runReporter(fakeThis, runner, options);\n\n        expect(fakeThis.epilogue.called, 'to be true');\n      });\n    });\n  });\n});"}
{"prompt":"mocha-flags, function  {","test":"'use strict';\n\nconst {\n  types,\n  expectedTypeForFlag\n} = require('../../../lib/cli/run-option-metadata');\n\ndescribe('mocha-flags', function () {\n  describe('expectedTypeForFlag()', function () {\n    Object.entries(types).forEach(([dataType, flags]) => {\n      flags.forEach(flag => {\n        it(`returns expected ${flag}'s type as ${dataType}`, function () {\n          expect(expectedTypeForFlag(flag), 'to equal', dataType);\n        });\n      });\n    });\n\n    it('returns undefined for node flags', function () {\n      expect(expectedTypeForFlag('--throw-deprecation'), 'to equal', undefined);\n      expect(expectedTypeForFlag('throw-deprecation'), 'to equal', undefined);\n    });\n\n    it('returns undefined for unsupported flags', function () {\n      expect(expectedTypeForFlag('--foo'), 'to equal', undefined);\n    });\n  });\n});"}
{"prompt":"Mocha, function  {","test":"'use strict';\n\nvar sinon = require('sinon');\nvar EventEmitter = require('node:events').EventEmitter;\nvar Mocha = require('../../lib/mocha');\nvar utils = require('../../lib/utils');\nconst errors = require('../../lib/errors');\n\ndescribe('Mocha', function () {\n  /**\n   * Options for `Mocha` constructor\n   */\n  var opts;\n\n  /**\n   * Stub `Runner` constructor; returns a stubbed `EventEmitter`\n   */\n  var Runner;\n\n  /**\n   * Stub `Suite` constructor; returns a stubbed `EventEmitter`\n   */\n  var Suite;\n\n  /**\n   * Stub `Suite` instance (root suite in our case)\n   */\n  var suite;\n\n  /**\n   * Stub `Runner` (`EventEmitter`) instance\n   */\n  var runner;\n\n  /**\n   * Stub `Base` reporter constructor\n   */\n  var Base;\n\n  /**\n   * Instance of a hypothetical reporter\n   */\n  var reporterInstance;\n\n  beforeEach(function () {\n    reporterInstance = {};\n    opts = {reporter: sinon.stub().returns(reporterInstance)};\n\n    // NOTE: calling `stub(someObject, someFunction)` where `someFunction` has\n    // its own static properties WILL NOT blast those static properties!\n    Base = sinon.stub(Mocha.reporters, 'Base').returns({});\n    sinon.stub(Mocha.reporters, 'base').returns({});\n    sinon.stub(Mocha.reporters, 'spec').returns({});\n\n    runner = {\n      ...sinon.createStubInstance(EventEmitter),\n      runAsync: sinon.stub().resolves(0),\n      globals: sinon.stub(),\n      grep: sinon.stub(),\n      dispose: sinon.stub()\n    };\n    Runner = sinon.stub(Mocha, 'Runner').returns(runner);\n    // the Runner constructor is the main export, and constants is a static prop.\n    // we don't need the constants themselves, but the object cannot be undefined\n    Runner.constants = {};\n    suite = {\n      ...sinon.createStubInstance(EventEmitter),\n      slow: sinon.stub(),\n      timeout: sinon.stub(),\n      bail: sinon.stub(),\n      dispose: sinon.stub(),\n      reset: sinon.stub(),\n      beforeAll: sinon.stub(),\n      beforeEach: sinon.stub(),\n      afterAll: sinon.stub(),\n      afterEach: sinon.stub()\n    };\n    Suite = sinon.stub(Mocha, 'Suite').returns(suite);\n    Suite.constants = {};\n\n    sinon.stub(errors, 'warn');\n    sinon.stub(utils, 'isString');\n    sinon.stub(utils, 'noop');\n  });\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('constructor', function () {\n    var mocha;\n\n    beforeEach(function () {\n      mocha = sinon.createStubInstance(Mocha);\n      mocha.timeout.returnsThis();\n      mocha.retries.returnsThis();\n      sinon.stub(Mocha.prototype, 'timeout').returnsThis();\n      sinon.stub(Mocha.prototype, 'global').returnsThis();\n      sinon.stub(Mocha.prototype, 'retries').returnsThis();\n      sinon.stub(Mocha.prototype, 'rootHooks').returnsThis();\n      sinon.stub(Mocha.prototype, 'parallelMode').returnsThis();\n      sinon.stub(Mocha.prototype, 'globalSetup').returnsThis();\n      sinon.stub(Mocha.prototype, 'globalTeardown').returnsThis();\n      sinon.stub(Mocha.prototype, 'enableGlobalSetup').returnsThis();\n      sinon.stub(Mocha.prototype, 'enableGlobalTeardown').returnsThis();\n    });\n\n    it('should set _cleanReferencesAfterRun to true', function () {\n      expect(new Mocha()._cleanReferencesAfterRun, 'to be', true);\n    });\n\n    describe('when `timeout` option is `undefined`', function () {\n      it('should not attempt to set timeout', function () {\n        // eslint-disable-next-line no-new\n        new Mocha({timeout: undefined});\n        expect(Mocha.prototype.timeout, 'was not called');\n      });\n    });\n\n    describe('when `timeout` option is `false`', function () {\n      it('should attempt to set timeout', function () {\n        // eslint-disable-next-line no-new\n        new Mocha({timeout: false});\n        expect(Mocha.prototype.timeout, 'to have a call satisfying', [0]).and(\n          'was called once'\n        );\n      });\n    });\n\n    describe('when `global` option is an `Array`', function () {\n      it('should attempt to set globals', function () {\n        // eslint-disable-next-line no-new\n        new Mocha({global: ['singular']});\n        expect(Mocha.prototype.global, 'to have a call satisfying', [\n          ['singular']\n        ]).and('was called once');\n      });\n    });\n\n    describe('when `retries` option is present', function () {\n      it('should attempt to set retries`', function () {\n        // eslint-disable-next-line no-new\n        new Mocha({retries: 1});\n        expect(Mocha.prototype.retries, 'to have a call satisfying', [1]).and(\n          'was called once'\n        );\n      });\n    });\n\n    describe('when `retries` option is not present', function () {\n      it('should not attempt to set retries', function () {\n        // eslint-disable-next-line no-new\n        new Mocha({});\n        expect(Mocha.prototype.retries, 'was not called');\n      });\n    });\n\n    describe('when `rootHooks` option is truthy', function () {\n      it('shouid attempt to set root hooks', function () {\n        // eslint-disable-next-line no-new\n        new Mocha({rootHooks: ['a root hook']});\n        expect(Mocha.prototype.rootHooks, 'to have a call satisfying', [\n          ['a root hook']\n        ]).and('was called once');\n      });\n    });\n\n    describe('when `parallel` option is true', function () {\n      describe('and `jobs` option > 1', function () {\n        it('should enable parallel mode', function () {\n          // eslint-disable-next-line no-new\n          new Mocha({parallel: true, jobs: 2});\n          expect(Mocha.prototype.parallelMode, 'to have a call satisfying', [\n            true\n          ]).and('was called once');\n        });\n      });\n\n      describe('and `jobs` option <= 1', function () {\n        it('should not enable parallel mode', function () {\n          // eslint-disable-next-line no-new\n          new Mocha({parallel: true, jobs: 1});\n          expect(Mocha.prototype.parallelMode, 'was not called');\n        });\n      });\n\n      describe('when `globalSetup` option is present', function () {\n        it('should configure global setup fixtures', function () {\n          const globalSetup = [() => {}];\n          const mocha = new Mocha({globalSetup});\n          expect(mocha.globalSetup, 'to have a call satisfying', [\n            globalSetup\n          ]).and('was called once');\n        });\n      });\n\n      describe('when `globalTeardown` option is present', function () {\n        it('should configure global teardown fixtures', function () {\n          const globalTeardown = [() => {}];\n          const mocha = new Mocha({globalTeardown});\n          expect(mocha.globalTeardown, 'to have a call satisfying', [\n            globalTeardown\n          ]).and('was called once');\n        });\n      });\n\n      describe('when `enableGlobalSetup` option is present', function () {\n        it('should toggle global setup fixtures', function () {\n          const mocha = new Mocha({enableGlobalSetup: 1});\n          expect(mocha.enableGlobalSetup, 'to have a call satisfying', [1]).and(\n            'was called once'\n          );\n        });\n      });\n\n      describe('when `enableGlobalTeardown` option is present', function () {\n        it('should configure global teardown fixtures', function () {\n          const mocha = new Mocha({enableGlobalTeardown: 1});\n          expect(mocha.enableGlobalTeardown, 'to have a call satisfying', [\n            1\n          ]).and('was called once');\n        });\n      });\n    });\n  });\n\n  describe('instance method', function () {\n    var mocha;\n\n    beforeEach(function () {\n      mocha = new Mocha(opts);\n    });\n\n    describe('allowUncaught()', function () {\n      it('should set the allowUncaught option to true', function () {\n        mocha.allowUncaught();\n        expect(mocha.options, 'to have property', 'allowUncaught', true);\n      });\n\n      it('should set the allowUncaught option to false', function () {\n        mocha.allowUncaught(false);\n        expect(mocha.options, 'to have property', 'allowUncaught', false);\n      });\n\n      it('should be chainable', function () {\n        expect(mocha.allowUncaught(), 'to be', mocha);\n      });\n    });\n\n    describe('asyncOnly()', function () {\n      it('should set the asyncOnly option to true', function () {\n        mocha.asyncOnly();\n        expect(mocha.options, 'to have property', 'asyncOnly', true);\n      });\n\n      it('should set the asyncOnly option to false', function () {\n        mocha.asyncOnly(false);\n        expect(mocha.options, 'to have property', 'asyncOnly', false);\n      });\n\n      it('should be chainable', function () {\n        expect(mocha.asyncOnly(), 'to be', mocha);\n      });\n    });\n\n    describe('bail()', function () {\n      it('should set the \"bail\" flag on the root suite', function () {\n        mocha.bail();\n        expect(suite.bail, 'to have a call satisfying', [true]).and(\n          'was called once'\n        );\n      });\n\n      it('should unset the \"bail\" flag on the root suite', function () {\n        mocha.bail(false);\n        expect(suite.bail, 'to have a call satisfying', [false]).and(\n          'was called once'\n        );\n      });\n\n      it('should be chainable', function () {\n        expect(mocha.bail(), 'to be', mocha);\n      });\n    });\n\n    describe('checkLeaks()', function () {\n      it('should set the checkLeaks option to true', function () {\n        mocha.checkLeaks();\n        expect(mocha.options, 'to have property', 'checkLeaks', true);\n      });\n    });\n\n    describe('cleanReferencesAfterRun()', function () {\n      it('should set the _cleanReferencesAfterRun attribute', function () {\n        mocha.cleanReferencesAfterRun();\n        expect(mocha._cleanReferencesAfterRun, 'to be', true);\n      });\n\n      it('should set the _cleanReferencesAfterRun attribute to false', function () {\n        mocha.cleanReferencesAfterRun(false);\n        expect(mocha._cleanReferencesAfterRun, 'to be', false);\n      });\n\n      it('should be chainable', function () {\n        expect(mocha.cleanReferencesAfterRun(), 'to be', mocha);\n      });\n    });\n\n    describe('color()', function () {\n      it('should set the color option to true', function () {\n        mocha.color();\n        expect(mocha.options, 'to have property', 'color', true);\n      });\n\n      it('should set the color option to false', function () {\n        mocha.color(false);\n        expect(mocha.options, 'to have property', 'color', false);\n      });\n\n      it('should be chainable', function () {\n        expect(mocha.color(), 'to be', mocha);\n      });\n    });\n\n    describe('delay()', function () {\n      it('should set the delay option to true', function () {\n        mocha.delay();\n        expect(mocha.options, 'to have property', 'delay', true);\n      });\n\n      it('should be chainable', function () {\n        expect(mocha.delay(), 'to be', mocha);\n      });\n    });\n\n    describe('diff()', function () {\n      it('should set the diff option to true', function () {\n        mocha.diff();\n        expect(mocha.options, 'to have property', 'diff', true);\n      });\n\n      it('should set the diff option to false', function () {\n        mocha.diff(false);\n        expect(mocha.options, 'to have property', 'diff', false);\n      });\n    });\n\n    describe('dispose()', function () {\n      it('should dispose the root suite', function () {\n        mocha.dispose();\n        expect(suite.dispose, 'was called once');\n      });\n\n      it('should dispose previous test runner', function () {\n        mocha._previousRunner = runner;\n        mocha.dispose();\n        expect(runner.dispose, 'was called once');\n      });\n\n      it('should unload the files', function () {\n        var unloadFilesStub = sinon.stub(mocha, 'unloadFiles');\n        mocha.dispose();\n        expect(unloadFilesStub, 'was called once');\n      });\n    });\n\n    describe('dryRun()', function () {\n      it('should set the dryRun option to true', function () {\n        mocha.dryRun();\n        expect(mocha.options, 'to have property', 'dryRun', true);\n      });\n\n      it('should set the dryRun option to false', function () {\n        mocha.dryRun(false);\n        expect(mocha.options, 'to have property', 'dryRun', false);\n      });\n    });\n\n    describe('passOnFailingTestSuite()', function() {\n      it('should set the passOnFailingTestSuite option to false', function() {\n        mocha.passOnFailingTestSuite();\n        expect(\n          mocha.options,\n          'to have property',\n          'passOnFailingTestSuite',\n          false\n        );\n      });\n\n      it('should set the passOnFailingTestSuite option to true', function() {\n        mocha.passOnFailingTestSuite(true);\n        expect(\n          mocha.options,\n          'to have property',\n          'passOnFailingTestSuite',\n          true\n        );\n      });\n    });\n\n    describe('failZero()', function () {\n      it('should set the failZero option to true', function () {\n        mocha.failZero();\n        expect(mocha.options, 'to have property', 'failZero', true);\n      });\n\n      it('should set the failZero option to false', function () {\n        mocha.failZero(false);\n        expect(mocha.options, 'to have property', 'failZero', false);\n      });\n    });\n\n    describe('forbidOnly()', function () {\n      it('should set the forbidOnly option to true', function () {\n        mocha.forbidOnly();\n        expect(mocha.options, 'to have property', 'forbidOnly', true);\n      });\n\n      it('should set the forbidOnly option to false', function () {\n        mocha.forbidOnly(false);\n        expect(mocha.options, 'to have property', 'forbidOnly', false);\n      });\n\n      it('should be chainable', function () {\n        expect(mocha.forbidOnly(), 'to be', mocha);\n      });\n    });\n\n    describe('forbidPending()', function () {\n      it('should set the forbidPending option to true', function () {\n        mocha.forbidPending();\n        expect(mocha.options, 'to have property', 'forbidPending', true);\n      });\n\n      it('should set the forbidPending option to false', function () {\n        mocha.forbidPending(false);\n        expect(mocha.options, 'to have property', 'forbidPending', false);\n      });\n\n      it('should be chainable', function () {\n        expect(mocha.forbidPending(), 'to be', mocha);\n      });\n    });\n\n    describe('fullTrace()', function () {\n      it('should set the fullTrace option to true', function () {\n        mocha.fullTrace();\n        expect(mocha.options, 'to have property', 'fullTrace', true);\n      });\n\n      it('should set the fullTrace option to false', function () {\n        mocha.fullTrace(false);\n        expect(mocha.options, 'to have property', 'fullTrace', false);\n      });\n\n      it('should be chainable', function () {\n        expect(mocha.fullTrace(), 'to be', mocha);\n      });\n    });\n\n    describe('global()', function () {\n      it('should be an empty array initially', function () {\n        expect(mocha.options.global, 'to be empty');\n      });\n\n      it('should be chainable', function () {\n        expect(mocha.global(), 'to be', mocha);\n      });\n\n      describe('when argument is invalid', function () {\n        it('should not modify the whitelist when given empty string', function () {\n          mocha.global('');\n          expect(mocha.options.global, 'to be empty');\n        });\n\n        it('should not modify the whitelist when given empty array', function () {\n          mocha.global([]);\n          expect(mocha.options.global, 'to be empty');\n        });\n      });\n\n      describe('when argument is valid', function () {\n        var elem = 'foo';\n        var elem2 = 'bar';\n        var elem3 = 'baz';\n\n        it('should add string to the whitelist', function () {\n          mocha.global(elem);\n          expect(mocha.options.global, 'to contain', elem);\n          expect(mocha.options.global, 'to have length', 1);\n        });\n\n        it('should add contents of string array to the whitelist', function () {\n          var elems = [elem, elem2];\n          mocha.global(elems);\n          expect(mocha.options.global, 'to contain', elem, elem2);\n          expect(mocha.options.global, 'to have length', elems.length);\n        });\n\n        it('should not have duplicates', function () {\n          var mocha = new Mocha({global: [elem, elem2]});\n          var elems = [elem, elem2, elem3];\n          mocha.global(elems);\n          expect(mocha.options.global, 'to contain', elem, elem2, elem3);\n          expect(mocha.options.global, 'to have length', elems.length);\n        });\n      });\n    });\n\n    describe('inlineDiffs()', function () {\n      it('should set the inlineDiffs option to true', function () {\n        mocha.inlineDiffs();\n        expect(mocha.options, 'to have property', 'inlineDiffs', true);\n      });\n\n      it('should set the inlineDiffs option to false', function () {\n        mocha.inlineDiffs(false);\n        expect(mocha.options, 'to have property', 'inlineDiffs', false);\n      });\n\n      it('should be chainable', function () {\n        expect(mocha.inlineDiffs(), 'to be', mocha);\n      });\n    });\n\n    describe('invert()', function () {\n      it('should set the invert option to true', function () {\n        mocha.invert();\n        expect(mocha.options, 'to have property', 'invert', true);\n      });\n\n      it('should be chainable', function () {\n        expect(mocha.invert(), 'to be', mocha);\n      });\n    });\n\n    describe('noHighlighting()', function () {\n      // :NOTE: Browser-only option...\n      it('should set the noHighlighting option to true', function () {\n        mocha.noHighlighting();\n        expect(mocha.options, 'to have property', 'noHighlighting', true);\n      });\n\n      it('should be chainable', function () {\n        expect(mocha.noHighlighting(), 'to be', mocha);\n      });\n    });\n\n    describe('reporter()', function () {\n      it('should be chainable', function () {\n        expect(mocha.reporter(), 'to be', mocha);\n      });\n\n      it('should keep reporterOption on options', function () {\n        var mocha = new Mocha({\n          reporter: 'spec',\n          reporterOption: {\n            foo: 'bar'\n          }\n        });\n        expect(mocha.options.reporterOption, 'to have property', 'foo', 'bar');\n        // To support the legacy property name that can be used by reporters\n        expect(mocha.options.reporterOptions, 'to have property', 'foo', 'bar');\n      });\n\n      it('should support legacy reporterOptions', function () {\n        var mocha = new Mocha({\n          reporter: 'spec',\n          reporterOptions: {\n            foo: 'bar'\n          }\n        });\n        expect(mocha.options.reporterOption, 'to have property', 'foo', 'bar');\n        // To support the legacy property name that can be used by reporters\n        expect(mocha.options.reporterOptions, 'to have property', 'foo', 'bar');\n      });\n    });\n\n    describe('run()', function () {\n      let globalFixtureContext;\n\n      beforeEach(function () {\n        globalFixtureContext = {};\n        sinon.stub(mocha, 'runGlobalSetup').returns(globalFixtureContext);\n        sinon.stub(mocha, 'runGlobalTeardown').returns(globalFixtureContext);\n      });\n\n      describe('when files have been added to the Mocha instance', function () {\n        beforeEach(function () {\n          sinon.stub(mocha, 'loadFiles');\n          mocha.addFile('some-file.js');\n        });\n\n        describe('when Mocha is set to eagerly load files', function () {\n          it('should eagerly load files', function (done) {\n            mocha.run(function () {\n              expect(mocha.loadFiles, 'was called once');\n              done();\n            });\n          });\n        });\n\n        describe('when Mocha is set to lazily load files', function () {\n          beforeEach(function () {\n            mocha.lazyLoadFiles(true);\n          });\n\n          it('should not eagerly load files', function (done) {\n            mocha.run(function () {\n              expect(mocha.loadFiles, 'was not called');\n              done();\n            });\n          });\n        });\n      });\n\n      describe('Runner initialization', function () {\n        it('should instantiate a Runner', function (done) {\n          mocha.run(function () {\n            expect(Runner, 'to have a call satisfying', {\n              calledWithNew: true,\n              args: [\n                mocha.suite,\n                {\n                  delay: mocha.options.delay,\n                  cleanReferencesAfterRun: mocha.options.cleanReferencesAfterRun\n                }\n              ]\n            }).and('was called once');\n            done();\n          });\n        });\n\n        describe('when \"grep\" option is present', function () {\n          beforeEach(function () {\n            mocha.options.grep = /foo/;\n            mocha.options.invert = false;\n          });\n\n          it('should configure \"grep\"', function (done) {\n            mocha.run(function () {\n              expect(runner.grep, 'to have a call satisfying', [\n                mocha.options.grep,\n                mocha.options.invert\n              ]).and('was called once');\n              done();\n            });\n          });\n        });\n\n        describe('when \"global\" option is present', function () {\n          beforeEach(function () {\n            mocha.options.global = ['foo', 'bar'];\n          });\n\n          it('should configure global vars', function (done) {\n            mocha.run(function () {\n              expect(runner.globals, 'to have a call satisfying', [\n                mocha.options.global\n              ]).and('was called once');\n              done();\n            });\n          });\n        });\n      });\n\n      describe('Base reporter initialization', function () {\n        beforeEach(function () {\n          mocha.options.inlineDiffs = 'some value';\n          mocha.options.diff = false;\n        });\n\n        describe('when \"color\" options is set', function () {\n          beforeEach(function () {\n            mocha.options.color = 'truthy';\n          });\n\n          it('should configure the Base reporter', function (done) {\n            mocha.run(function () {\n              expect(Base, 'to satisfy', {\n                inlineDiffs: 'some value',\n                hideDiff: true,\n                useColors: 'truthy'\n              });\n              done();\n            });\n          });\n        });\n\n        it('should configure the Base reporter', function (done) {\n          mocha.run(function () {\n            expect(Base, 'to satisfy', {\n              inlineDiffs: 'some value',\n              hideDiff: true\n            });\n            done();\n          });\n        });\n      });\n\n      it('should instantiate a reporter', function (done) {\n        mocha.run(function () {\n          expect(opts.reporter, 'to have a call satisfying', {\n            calledWithNew: true,\n            args: [runner, mocha.options]\n          }).and('was called once');\n          done();\n        });\n      });\n\n      // TODO: figure out how to stub the stats collector\n      it('should initialize the stats collector');\n\n      describe('when a reporter instance has a \"done\" method', function () {\n        beforeEach(function () {\n          reporterInstance.done = sinon.stub().callsArgAsync(1);\n        });\n\n        it('should call the reporter \"done\" method', function (done) {\n          mocha.run(function () {\n            expect(reporterInstance.done, 'was called once');\n            done();\n          });\n        });\n      });\n\n      it('should execute the callback when complete', function (done) {\n        mocha.run(done);\n      });\n\n      describe('when a run is in progress', function () {\n        it('should throw', function (done) {\n          mocha.run(done); // this is async!\n          expect(\n            function () {\n              mocha.run();\n            },\n            'to throw',\n            {\n              code: 'ERR_MOCHA_INSTANCE_ALREADY_RUNNING',\n              instance: mocha\n            }\n          );\n        });\n\n        it('should not call `Runner#runAsync`', function (done) {\n          mocha.run(done); // this is async!\n          try {\n            mocha.run();\n          } catch (ignored) {\n          } finally {\n            // it'll be 0 or 1, depending on timing.\n            expect(runner.runAsync.callCount, 'to be less than', 2);\n          }\n        });\n      });\n\n      describe('when the `Mocha` instance is already disposed', function () {\n        beforeEach(function () {\n          mocha.dispose();\n        });\n\n        it('should throw', function () {\n          expect(\n            function () {\n              mocha.run();\n            },\n            'to throw',\n            {\n              code: 'ERR_MOCHA_INSTANCE_ALREADY_DISPOSED',\n              cleanReferencesAfterRun: true,\n              instance: mocha\n            }\n          );\n        });\n\n        it('should not call `Runner#runAsync`', function () {\n          try {\n            mocha.run();\n          } catch (ignored) {\n          } finally {\n            expect(runner.runAsync, 'was not called');\n          }\n        });\n      });\n\n      describe('when a run has finished and is called again', function () {\n        beforeEach(function (done) {\n          mocha.run(function () {\n            runner.runAsync.reset();\n            done();\n          });\n        });\n\n        it('should throw', function () {\n          expect(\n            function () {\n              mocha.run();\n            },\n            'to throw',\n            {\n              code: 'ERR_MOCHA_INSTANCE_ALREADY_DISPOSED',\n              instance: mocha\n            }\n          );\n        });\n\n        it('should not call `Runner#runAsync()`', function () {\n          try {\n            mocha.run();\n          } catch (ignored) {\n          } finally {\n            expect(runner.runAsync, 'was not called');\n          }\n        });\n      });\n\n      describe('when Mocha configured for multiple runs and multiple runs are attempted', function () {\n        beforeEach(function () {\n          mocha.cleanReferencesAfterRun(false);\n        });\n\n        it('should not throw', function (done) {\n          mocha.run(function () {\n            mocha.run(done);\n          });\n        });\n\n        it('should call `Runner#runAsync` for each call', function (done) {\n          mocha.run(function () {\n            mocha.run(function () {\n              expect(runner.runAsync, 'was called twice');\n              done();\n            });\n          });\n        });\n\n        it('should reset the root Suite between runs', function (done) {\n          mocha.run(function () {\n            mocha.run(function () {\n              expect(suite.reset, 'was called once');\n              done();\n            });\n          });\n        });\n\n        it('should dispose the previous runner', function (done) {\n          mocha.run(function () {\n            mocha.run(function () {\n              expect(runner.dispose, 'was called once');\n              done();\n            });\n          });\n        });\n      });\n\n      describe('when global setup fixtures enabled', function () {\n        beforeEach(function () {\n          mocha.options.enableGlobalSetup = true;\n        });\n        describe('when global setup fixtures not present', function () {\n          beforeEach(function () {\n            sinon.stub(mocha, 'hasGlobalSetupFixtures').returns(false);\n          });\n\n          it('should not run global setup fixtures', function (done) {\n            mocha.run(() => {\n              expect(mocha.runGlobalSetup, 'was not called');\n              done();\n            });\n          });\n        });\n\n        describe('when global setup fixtures are present', function () {\n          beforeEach(function () {\n            sinon.stub(mocha, 'hasGlobalSetupFixtures').returns(true);\n          });\n\n          it('should run global setup fixtures', function (done) {\n            mocha.run(() => {\n              expect(mocha.runGlobalSetup, 'to have a call satisfying', {\n                args: [expect.it('to be', runner)]\n              }).and('was called once');\n              done();\n            });\n          });\n        });\n      });\n\n      describe('when global setup fixtures disabled', function () {\n        beforeEach(function () {\n          mocha.options.enableGlobalSetup = false;\n        });\n        describe('when global setup fixtures not present', function () {\n          beforeEach(function () {\n            sinon.stub(mocha, 'hasGlobalSetupFixtures').returns(false);\n          });\n\n          it('should not run global setup fixtures', function (done) {\n            mocha.run(() => {\n              expect(mocha.runGlobalSetup, 'was not called');\n              done();\n            });\n          });\n        });\n\n        describe('when global setup fixtures are present', function () {\n          beforeEach(function () {\n            sinon.stub(mocha, 'hasGlobalSetupFixtures').returns(true);\n          });\n\n          it('should not run global setup fixtures', function (done) {\n            mocha.run(() => {\n              expect(mocha.runGlobalSetup, 'was not called');\n              done();\n            });\n          });\n        });\n      });\n\n      describe('when global teardown fixtures enabled', function () {\n        beforeEach(function () {\n          mocha.options.enableGlobalTeardown = true;\n        });\n        describe('when global teardown fixtures not present', function () {\n          beforeEach(function () {\n            sinon.stub(mocha, 'hasGlobalTeardownFixtures').returns(false);\n          });\n\n          it('should not run global teardown fixtures', function (done) {\n            mocha.run(() => {\n              expect(mocha.runGlobalTeardown, 'was not called');\n              done();\n            });\n          });\n        });\n\n        describe('when global teardown fixtures are present', function () {\n          beforeEach(function () {\n            sinon.stub(mocha, 'hasGlobalTeardownFixtures').returns(true);\n          });\n\n          it('should run global teardown fixtures', function (done) {\n            mocha.run(() => {\n              expect(mocha.runGlobalTeardown, 'to have a call satisfying', {\n                args: [expect.it('to be', runner), {context: {}}]\n              }).and('was called once');\n              done();\n            });\n          });\n\n          describe('when global setup fixtures are present and enabled', function () {\n            beforeEach(function () {\n              sinon.stub(mocha, 'hasGlobalSetupFixtures').returns(true);\n              mocha.options.enableGlobalSetup = true;\n            });\n\n            it('should use the same context as returned by `runGlobalSetup`', function (done) {\n              mocha.run(() => {\n                expect(mocha.runGlobalTeardown, 'to have a call satisfying', {\n                  args: [\n                    expect.it('to be', runner),\n                    {context: globalFixtureContext}\n                  ]\n                }).and('was called once');\n                done();\n              });\n            });\n          });\n        });\n      });\n\n      describe('when global teardown fixtures disabled', function () {\n        beforeEach(function () {\n          mocha.options.enableGlobalTeardown = false;\n        });\n        describe('when global teardown fixtures not present', function () {\n          beforeEach(function () {\n            sinon.stub(mocha, 'hasGlobalTeardownFixtures').returns(false);\n          });\n\n          it('should not run global teardown fixtures', function (done) {\n            mocha.run(() => {\n              expect(mocha.runGlobalTeardown, 'was not called');\n              done();\n            });\n          });\n        });\n\n        describe('when global teardown fixtures are present', function () {\n          beforeEach(function () {\n            sinon.stub(mocha, 'hasGlobalTeardownFixtures').returns(true);\n          });\n\n          it('should not run global teardown fixtures', function (done) {\n            mocha.run(() => {\n              expect(mocha.runGlobalTeardown, 'was not called');\n              done();\n            });\n          });\n        });\n      });\n    });\n\n    describe('parallelMode()', function () {\n      describe('when `Mocha` is running in a browser', function () {\n        beforeEach(function () {\n          sinon.stub(utils, 'isBrowser').returns(true);\n        });\n\n        it('should throw', function () {\n          expect(\n            function () {\n              mocha.parallelMode();\n            },\n            'to throw',\n            {code: 'ERR_MOCHA_UNSUPPORTED'}\n          );\n        });\n      });\n    });\n\n    describe('unloadFile()', function () {\n      describe('when run in a browser', function () {\n        beforeEach(function () {\n          sinon.stub(utils, 'isBrowser').returns(true);\n        });\n\n        it('should throw', function () {\n          expect(() => Mocha.unloadFile('guy-fieri.js'), 'to throw', {\n            code: 'ERR_MOCHA_UNSUPPORTED'\n          });\n        });\n      });\n    });\n\n    describe('_runGlobalFixtures()', function () {\n      it('should execute multiple fixtures in order', async function () {\n        const fixtures = [\n          sinon.stub().resolves('foo'),\n          sinon.stub().returns('bar')\n        ];\n        const context = await mocha._runGlobalFixtures(fixtures);\n\n        return expect(fixtures, 'to satisfy', [\n          expect.it('to have a call satisfying', {\n            thisValue: context,\n            returnValue: expect.it('to be fulfilled with', 'foo')\n          }),\n          expect.it('to have a call satisfying', {\n            thisValue: context,\n            returnValue: 'bar'\n          })\n        ]);\n      });\n    });\n\n    describe('runGlobalSetup()', function () {\n      let context;\n\n      beforeEach(function () {\n        sinon.stub(mocha, '_runGlobalFixtures').resolvesArg(1);\n        context = {};\n      });\n\n      describe('when fixture(s) are present', function () {\n        beforeEach(function () {\n          mocha.options.globalSetup = [sinon.spy()];\n        });\n\n        it('should attempt run the fixtures', async function () {\n          await mocha.runGlobalSetup(context);\n          expect(mocha._runGlobalFixtures, 'to have a call satisfying', [\n            mocha.options.globalSetup,\n            context\n          ]);\n        });\n      });\n\n      describe('when a fixture is not present', function () {\n        it('should not attempt to run fixtures', async function () {\n          await mocha.runGlobalSetup();\n          expect(mocha._runGlobalFixtures, 'was not called');\n        });\n      });\n    });\n\n    describe('runGlobalTeardown()', function () {\n      let context;\n\n      beforeEach(function () {\n        sinon.stub(mocha, '_runGlobalFixtures').resolvesArg(1);\n        context = {};\n      });\n\n      describe('when fixture(s) are present', function () {\n        beforeEach(function () {\n          mocha.options.globalTeardown = [sinon.spy()];\n        });\n\n        it('should attempt to run the fixtures', async function () {\n          await mocha.runGlobalTeardown();\n          expect(mocha._runGlobalFixtures, 'to have a call satisfying', [\n            mocha.options.globalTeardown,\n            context\n          ]);\n        });\n      });\n\n      describe('when a fixture is not present', function () {\n        it('not attempt to run the fixtures', async function () {\n          await mocha.runGlobalTeardown();\n          expect(mocha._runGlobalFixtures, 'was not called');\n        });\n      });\n    });\n\n    describe('hasGlobalSetupFixtures()', function () {\n      describe('when one or more global setup fixtures are present', function () {\n        it('should return `true`', function () {\n          mocha.options.globalSetup = [() => {}];\n          expect(mocha.hasGlobalSetupFixtures(), 'to be true');\n        });\n      });\n\n      describe('when no global setup fixtures are present', function () {\n        it('should return `false`', function () {\n          mocha.options.globalSetup = [];\n          expect(mocha.hasGlobalSetupFixtures(), 'to be false');\n        });\n      });\n    });\n\n    describe('hasGlobalTeardownFixtures()', function () {\n      describe('when one or more global teardown fixtures are present', function () {\n        it('should return `true`', function () {\n          mocha.options.globalTeardown = [() => {}];\n          expect(mocha.hasGlobalTeardownFixtures(), 'to be true');\n        });\n      });\n\n      describe('when no global teardown fixtures are present', function () {\n        it('should return `false`', function () {\n          mocha.options.globalTeardown = [];\n          expect(mocha.hasGlobalTeardownFixtures(), 'to be false');\n        });\n      });\n    });\n\n    describe('rootHooks()', function () {\n      it('should be chainable', function () {\n        expect(mocha.rootHooks(), 'to be', mocha);\n      });\n\n      describe('when provided a single \"before all\" hook', function () {\n        it('should attach it to the root suite', function () {\n          const beforeAll = () => {};\n          mocha.rootHooks({beforeAll});\n          expect(mocha.suite.beforeAll, 'to have a call satisfying', [\n            beforeAll\n          ]).and('was called once');\n        });\n      });\n\n      describe('when provided a single \"before each\" hook', function () {\n        it('should attach it to the root suite', function () {\n          const beforeEach = () => {};\n          mocha.rootHooks({beforeEach});\n          expect(mocha.suite.beforeEach, 'to have a call satisfying', [\n            beforeEach\n          ]).and('was called once');\n        });\n      });\n\n      describe('when provided a single \"after all\" hook', function () {\n        it('should attach it to the root suite', function () {\n          const afterAll = () => {};\n          mocha.rootHooks({afterAll});\n          expect(mocha.suite.afterAll, 'to have a call satisfying', [\n            afterAll\n          ]).and('was called once');\n        });\n      });\n\n      describe('when provided a single \"after each\" hook', function () {\n        it('should attach it to the root suite', function () {\n          const afterEach = () => {};\n          mocha.rootHooks({afterEach});\n          expect(mocha.suite.afterEach, 'to have a call satisfying', [\n            afterEach\n          ]).and('was called once');\n        });\n      });\n\n      describe('when provided multiple \"before all\" hooks', function () {\n        it('should attach each to the root suite', function () {\n          const beforeAll = [() => {}, () => {}];\n          mocha.rootHooks({beforeAll});\n          expect(mocha.suite.beforeAll, 'to have calls satisfying', [\n            [beforeAll[0]],\n            [beforeAll[1]]\n          ]).and('was called twice');\n        });\n      });\n\n      describe('when provided multiple \"before each\" hooks', function () {\n        it('should attach each to the root suite', function () {\n          const beforeEach = [() => {}, () => {}];\n          mocha.rootHooks({beforeEach});\n          expect(mocha.suite.beforeEach, 'to have calls satisfying', [\n            [beforeEach[0]],\n            [beforeEach[1]]\n          ]).and('was called twice');\n        });\n      });\n\n      describe('when provided multiple \"after all\" hooks', function () {\n        it('should attach each to the root suite', function () {\n          const afterAll = [() => {}, () => {}];\n          mocha.rootHooks({afterAll});\n          expect(mocha.suite.afterAll, 'to have calls satisfying', [\n            [afterAll[0]],\n            [afterAll[1]]\n          ]).and('was called twice');\n        });\n      });\n\n      describe('when provided multiple \"after each\" hooks', function () {\n        it('should attach each to the root suite', function () {\n          const afterEach = [() => {}, () => {}];\n          mocha.rootHooks({afterEach});\n          expect(mocha.suite.afterEach, 'to have calls satisfying', [\n            [afterEach[0]],\n            [afterEach[1]]\n          ]).and('was called twice');\n        });\n      });\n    });\n  });\n});"}
{"prompt":"a comment","test":"'use strict';\n\n// a comment\nmodule.exports = {\n  require: ['foo', 'bar'],\n  bail: true,\n  reporter: 'dot',\n  slow: 60\n};"}
{"prompt":"a comment","test":"'use strict';\n\n// a comment\nmodule.exports = {\n  require: ['foo', 'bar'],\n  bail: true,\n  reporter: 'dot',\n  slow: 60\n};"}
{"prompt":"a comment","test":"{\n  // a comment\n  \"require\": [\"foo\", \"bar\"],\n  \"bail\": true,\n  \"reporter\": \"dot\",\n  \"slow\": 60\n}"}
{"prompt":"Test generated from existing file","test":"# a comment\nrequire:\n  - foo\n  - bar\nbail: true\nreporter: dot\nslow: 60"}
{"prompt":"a comment","test":"'use strict';\n\nthrow new Error(\"Error from mocharcWithThrowError\");\n\n// a comment\nmodule.exports = {\n  require: ['foo', 'bar'],\n  bail: true,\n  reporter: 'dot',\n  slow: 60\n};"}
{"prompt":"The sue below should result in an additional error, but does","test":"'use strict';\n\n// The suite below should result in an additional error, but does\n// not. Uncomment once this bug is resolved.\n\n// describe('suite', function() {\n//   beforeEach(function(done) {\n//     done();\n//     done();\n//   });\n\n//   it('test', function() {});\n// });\n\nit('should fail in an async test case', function (done) {\n  process.nextTick(function () {\n    done();\n    setTimeout(done);\n  });\n});"}
{"prompt":"suite1, function  {","test":"'use strict';\n\ndescribe('suite1', function () {\n  beforeEach(function (done) {\n    setTimeout(done, 10);\n    setTimeout(done, 20);\n  });\n\n  it('test1', function (done) {\n    setTimeout(done, 50);\n  });\n\n  it('test2', function (done) {\n    setTimeout(done, 50);\n  });\n});"}
{"prompt":"suite1, function  {","test":"'use strict';\n\ndescribe('suite1', function () {\n  before(function (done) {\n    setTimeout(done, 10);\n    setTimeout(done, 30);\n  });\n\n  it('test1', function (done) {\n    setTimeout(done, 50);\n  });\n});"}
{"prompt":"suite, function  {","test":"'use strict';\n\ndescribe('suite', function () {\n  it('test1', function (done) {\n    done();\n    setTimeout(done, 10);\n  });\n\n  it('test2', function (done) {\n    setTimeout(done, 20);\n  });\n});"}
{"prompt":"should fail in a test-case, function done {","test":"'use strict';\n\nit('should fail in a test-case', function (done) {\n  process.nextTick(function () {\n    done();\n    done(new Error('second error'));\n  });\n});"}
{"prompt":"The sue below should result in an additional error, but does","test":"'use strict';\n\n// The suite below should result in an additional error, but does\n// not. Uncomment once this bug is resolved.\n\n// describe('suite', function() {\n//   beforeEach(function(done) {\n//     done();\n//     done();\n//   });\n\n//   it('test', function() {});\n// });\n\nit('should fail in a test-case', function (done) {\n  process.nextTick(function () {\n    done();\n    done();\n  });\n});"}
{"prompt":"multiple calls to done, function  {","test":"'use strict';\n\nvar runMochaJSON = require('./helpers').runMochaJSON;\nvar invokeMocha = require('./helpers').invokeMocha;\nvar MULTIPLE_DONE = require('../../lib/errors').constants.MULTIPLE_DONE;\n\ndescribe('multiple calls to done()', function () {\n  var res;\n  describe('from a spec', function () {\n    before(function (done) {\n      runMochaJSON('multiple-done', function (err, result) {\n        res = result;\n        done(err);\n      });\n    });\n\n    it('results in failure', function () {\n      expect(res, 'to have failed test count', 1)\n        .and('to have passed test count', 1)\n        .and('to have pending test count', 0)\n        .and('to have failed');\n    });\n\n    it('throws a descriptive error', function () {\n      expect(res, 'to have failed with error', {\n        message:\n          /done\\(\\) called multiple times in test <should fail in a test-case> \\(of root suite\\) of file.+multiple-done\\.fixture\\.js/,\n        code: MULTIPLE_DONE\n      });\n    });\n  });\n\n  describe('with error passed on second call', function () {\n    before(function (done) {\n      runMochaJSON('multiple-done-with-error', function (err, result) {\n        res = result;\n        done(err);\n      });\n    });\n\n    it('results in failure', function () {\n      expect(res, 'to have failed test count', 1)\n        .and('to have passed test count', 1)\n        .and('to have pending test count', 0)\n        .and('to have failed');\n    });\n\n    it('should throw a descriptive error', function () {\n      expect(res, 'to have failed with error', {\n        message:\n          /done\\(\\) called multiple times in test <should fail in a test-case> \\(of root suite\\) of file.+multiple-done-with-error\\.fixture\\.js; in addition, done\\(\\) received error: Error: second error/,\n        code: MULTIPLE_DONE\n      });\n    });\n  });\n\n  describe('with multiple specs', function () {\n    before(function (done) {\n      runMochaJSON('multiple-done-specs', function (err, result) {\n        res = result;\n        done(err);\n      });\n    });\n\n    it('results in failure', function () {\n      expect(res, 'to have failed test count', 1)\n        .and('to have passed test count', 2)\n        .and('to have pending test count', 0)\n        .and('to have failed');\n    });\n\n    it('correctly attributes the error', function () {\n      expect(res.failures[0], 'to satisfy', {\n        fullTitle: 'suite test1',\n        err: {\n          message:\n            /done\\(\\) called multiple times in test <suite test1> of file.+multiple-done-specs\\.fixture\\.js/,\n          code: MULTIPLE_DONE\n        }\n      });\n    });\n  });\n\n  describe('from a before hook', function () {\n    before(function (done) {\n      runMochaJSON('multiple-done-before', function (err, result) {\n        res = result;\n        done(err);\n      });\n    });\n\n    it('results in failure', function () {\n      expect(res, 'to have failed test count', 1)\n        .and('to have passed test count', 1)\n        .and('to have pending test count', 0)\n        .and('to have failed');\n    });\n\n    it('correctly attributes the error', function () {\n      expect(res.failures[0], 'to satisfy', {\n        fullTitle: 'suite1 \"before all\" hook in \"suite1\"',\n        err: {\n          message:\n            /done\\(\\) called multiple times in hook <suite1 \"before all\" hook in \"suite1\"> of file.+multiple-done-before\\.fixture\\.js/\n        }\n      });\n    });\n  });\n\n  describe('from a \"before each\" hook', function () {\n    before(function (done) {\n      runMochaJSON('multiple-done-before-each', function (err, result) {\n        res = result;\n        done(err);\n      });\n    });\n\n    it('results in a failure', function () {\n      expect(res, 'to have failed test count', 2)\n        .and('to have passed test count', 2)\n        .and('to have pending test count', 0)\n        .and('to have exit code', 2);\n    });\n\n    it('correctly attributes the errors', function () {\n      expect(res.failures[0], 'to equal', res.failures[1]).and('to satisfy', {\n        fullTitle: 'suite1 \"before each\" hook in \"suite1\"',\n        err: {\n          message:\n            /done\\(\\) called multiple times in hook <suite1 \"before each\" hook in \"suite1\"> of file.+multiple-done-before-each\\.fixture\\.js/,\n          multiple: [\n            {\n              code: 'ERR_MOCHA_MULTIPLE_DONE'\n            }\n          ]\n        }\n      });\n    });\n  });\n\n  describe('when done() called asynchronously', function () {\n    before(function (done) {\n      // we can't be sure that mocha won't fail with an uncaught exception here, which would cause any JSON\n      // output to be befouled; we need to run \"raw\" and capture STDERR\n      invokeMocha(\n        require.resolve('./fixtures/multiple-done-async.fixture.js'),\n        function (err, result) {\n          res = result;\n          done(err);\n        },\n        'pipe'\n      );\n    });\n\n    it('results in error', function () {\n      expect(res, 'to satisfy', {\n        code: expect.it('to be greater than', 0),\n        output:\n          /done\\(\\) called multiple times in test <should fail in an async test case> \\(of root suite\\) of file.+multiple-done-async\\.fixture\\.js/\n      });\n    });\n  });\n});"}
{"prompt":"1, function  {","test":"'use strict';\n\nbefore(function () {\n  console.log('root before');\n});\nbeforeEach(function () {\n  console.log('root before each');\n});\ndescribe('1', function () {\n  beforeEach(function () {\n    console.log('1 before each');\n  });\n\n  describe('1-1', function () {\n    before(function () {\n      console.log('1-1 before');\n    });\n    beforeEach(function (done) {\n      console.log('1-1 before each');\n      process.nextTick(function () {\n        throw new Error('1-1 before each hook failed');\n      });\n    });\n    it('1-1 test 1', function () {\n      console.log('1-1 test 1');\n    });\n    it('1-1 test 2', function () {\n      console.log('1-1 test 2');\n    });\n    afterEach(function () {\n      console.log('1-1 after each');\n    });\n    after(function (done) {\n      console.log('1-1 after');\n      process.nextTick(function () {\n        throw new Error('1-1 after hook failed');\n      });\n    });\n  });\n\n  describe('1-2', function () {\n    before(function () {\n      console.log('1-2 before');\n    });\n    beforeEach(function () {\n      console.log('1-2 before each');\n    });\n    it('1-2 test 1', function () {\n      console.log('1-2 test 1');\n    });\n    it('1-2 test 2', function () {\n      console.log('1-2 test 2');\n    });\n    afterEach(function (done) {\n      console.log('1-2 after each');\n      process.nextTick(function () {\n        throw new Error('1-2 after each hook failed');\n      });\n    });\n    after(function () {\n      console.log('1-2 after');\n    });\n  });\n\n  afterEach(function () {\n    console.log('1 after each');\n  });\n\n  after(function () {\n    console.log('1 after');\n  });\n});\n\ndescribe('2', function () {\n  beforeEach(function (done) {\n    console.log('2 before each');\n    process.nextTick(function () {\n      throw new Error('2 before each hook failed');\n    });\n  });\n\n  describe('2-1', function () {\n    before(function () {\n      console.log('2-1 before');\n    });\n    beforeEach(function () {\n      console.log('2-1 before each');\n    });\n    it('2-1 test 1', function () {\n      console.log('2-1 test 1');\n    });\n    it('2-1 test 2', function () {\n      console.log('2-1 test 2');\n    });\n    afterEach(function () {\n      console.log('2-1 after each');\n    });\n    after(function () {\n      console.log('2-1 after');\n    });\n  });\n\n  describe('2-2', function () {\n    before(function () {\n      console.log('2-2 before');\n    });\n    beforeEach(function () {\n      console.log('2-2 before each');\n    });\n    it('2-2 test 1', function () {\n      console.log('2-2 test 1');\n    });\n    it('2-2 test 2', function () {\n      console.log('2-2 test 2');\n    });\n    afterEach(function () {\n      console.log('2-2 after each');\n    });\n    after(function () {\n      console.log('2-2 after');\n    });\n  });\n\n  afterEach(function (done) {\n    console.log('2 after each');\n    process.nextTick(function () {\n      throw new Error('2 after each hook failed');\n    });\n  });\n\n  after(function () {\n    console.log('2 after');\n  });\n});\n\nafter(function () {\n  console.log('root after');\n});\nafterEach(function () {\n  console.log('root after each');\n});"}
{"prompt":"1, function  {","test":"'use strict';\n\nbefore(function () {\n  console.log('root before');\n});\nbeforeEach(function () {\n  console.log('root before each');\n});\ndescribe('1', function () {\n  beforeEach(function () {\n    console.log('1 before each');\n  });\n\n  describe('1-1', function () {\n    before(function () {\n      console.log('1-1 before');\n    });\n    beforeEach(function () {\n      console.log('1-1 before each');\n      throw new Error('1-1 before each hook failed');\n    });\n    it('1-1 test 1', function () {\n      console.log('1-1 test 1');\n    });\n    it('1-1 test 2', function () {\n      console.log('1-1 test 2');\n    });\n    afterEach(function () {\n      console.log('1-1 after each');\n    });\n    after(function () {\n      console.log('1-1 after');\n      throw new Error('1-1 after hook failed');\n    });\n  });\n\n  describe('1-2', function () {\n    before(function () {\n      console.log('1-2 before');\n    });\n    beforeEach(function () {\n      console.log('1-2 before each');\n    });\n    it('1-2 test 1', function () {\n      console.log('1-2 test 1');\n    });\n    it('1-2 test 2', function () {\n      console.log('1-2 test 2');\n    });\n    afterEach(function () {\n      console.log('1-2 after each');\n      throw new Error('1-2 after each hook failed');\n    });\n    after(function () {\n      console.log('1-2 after');\n    });\n  });\n\n  afterEach(function () {\n    console.log('1 after each');\n  });\n\n  after(function () {\n    console.log('1 after');\n  });\n});\n\ndescribe('2', function () {\n  beforeEach(function () {\n    console.log('2 before each');\n    throw new Error('2 before each hook failed');\n  });\n\n  describe('2-1', function () {\n    before(function () {\n      console.log('2-1 before');\n    });\n    beforeEach(function () {\n      console.log('2-1 before each');\n    });\n    it('2-1 test 1', function () {\n      console.log('2-1 test 1');\n    });\n    it('2-1 test 2', function () {\n      console.log('2-1 test 2');\n    });\n    afterEach(function () {\n      console.log('2-1 after each');\n    });\n    after(function () {\n      console.log('2-1 after');\n    });\n  });\n\n  describe('2-2', function () {\n    before(function () {\n      console.log('2-2 before');\n    });\n    beforeEach(function () {\n      console.log('2-2 before each');\n    });\n    it('2-2 test 1', function () {\n      console.log('2-2 test 1');\n    });\n    it('2-2 test 2', function () {\n      console.log('2-2 test 2');\n    });\n    afterEach(function () {\n      console.log('2-2 after each');\n    });\n    after(function () {\n      console.log('2-2 after');\n    });\n  });\n\n  afterEach(function () {\n    console.log('2 after each');\n    throw new Error('2 after each hook failed');\n  });\n\n  after(function () {\n    console.log('2 after');\n  });\n});\n\nafter(function () {\n  console.log('root after');\n});\nafterEach(function () {\n  console.log('root after each');\n});"}
{"prompt":"Multiple runs,  => {","test":"describe('Multiple runs', () => {\n\n  /**\n   * Shared state! Bad practice, but nice for this test\n   */\n  let i = 0;\n\n  it('should skip, fail and pass respectively', function () {\n    switch (i++) {\n      case 0:\n        this.skip();\n      case 1:\n        throw new Error('Expected error');\n      default:\n        // this is fine ☕\n        break;\n    }\n  });\n});"}
{"prompt":"Multiple runs,  => {","test":"describe('Multiple runs', () => {\n\n  /**\n   * Shared state! Bad practice, but nice for this test\n   */\n  let i = 0;\n\n  beforeEach(function () {\n    if (i++ === 0) {\n      throw new Error('Expected error for this test');\n    }\n  });\n\n\n  it('should be a dummy test', function () {\n    // this is fine ☕\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\nconst Mocha = require('../../../../lib/mocha');\n\nconst mocha = new Mocha({ reporter: 'json' });\nmocha.cleanReferencesAfterRun(false);\nmocha.addFile(require.resolve('./multiple-runs-with-flaky-before-each-suite.fixture.js'));\nconsole.log('[');\nmocha.run(() => {\n  console.log(',');\n  mocha.run(() => {\n    console.log(']');\n  });\n});"}
{"prompt":"multiple runs, function  {","test":"'use strict';\n\nconst {invokeNode} = require('./helpers');\n\ndescribe('multiple runs', function () {\n  it('should be allowed to run multiple times if cleanReferences is turned off', function (done) {\n    var path = require.resolve(\n      './fixtures/multiple-runs/run-thrice.fixture.js'\n    );\n    invokeNode([path], function (err, res) {\n      if (err) {\n        done(err);\n        return;\n      }\n      expect(res.code, 'to be', 0);\n      var results = JSON.parse(res.output);\n      expect(results, 'to have length', 3);\n      expect(results[0].pending, 'to have length', 1);\n      expect(results[0].failures, 'to have length', 0);\n      expect(results[0].passes, 'to have length', 0);\n      expect(results[1].pending, 'to have length', 0);\n      expect(results[1].failures, 'to have length', 1);\n      expect(results[1].passes, 'to have length', 0);\n      expect(results[2].pending, 'to have length', 0);\n      expect(results[2].failures, 'to have length', 0);\n      expect(results[2].passes, 'to have length', 1);\n      done();\n    });\n  });\n\n  it('should not be allowed if cleanReferences is true', function (done) {\n    var path = require.resolve(\n      './fixtures/multiple-runs/clean-references.fixture.js'\n    );\n    invokeNode(\n      [path],\n      function (err, res) {\n        if (err) {\n          done(err);\n          return;\n        }\n        expect(res, 'to have failed').and(\n          'to contain output',\n          /ERR_MOCHA_INSTANCE_ALREADY_DISPOSED/\n        );\n\n        done();\n      },\n      {stdio: ['ignore', 'pipe', 'pipe']}\n    );\n  });\n\n  it('should not be allowed if the instance is disposed', function (done) {\n    var path = require.resolve('./fixtures/multiple-runs/dispose.fixture.js');\n    invokeNode(\n      [path, '--directly-dispose'],\n      function (err, res) {\n        if (err) {\n          done(err);\n          return;\n        }\n        expect(res.code, 'not to be', 0);\n        expect(res.output, 'to contain', 'ERR_MOCHA_INSTANCE_ALREADY_DISPOSED');\n        done();\n      },\n      {stdio: ['ignore', 'pipe', 'pipe']}\n    );\n  });\n\n  it('should not be allowed to run while a previous run is in progress', function (done) {\n    var path = require.resolve(\n      './fixtures/multiple-runs/start-second-run-if-previous-is-still-running.fixture'\n    );\n    invokeNode(\n      [path],\n      function (err, res) {\n        if (err) {\n          done(err);\n          return;\n        }\n        expect(res.output, 'to contain', 'ERR_MOCHA_INSTANCE_ALREADY_RUNNING');\n        done();\n      },\n      {stdio: ['ignore', 'pipe', 'pipe']}\n    );\n  });\n\n  it('should reset the hooks between runs', function (done) {\n    var path = require.resolve(\n      './fixtures/multiple-runs/multiple-runs-with-flaky-before-each.fixture'\n    );\n    invokeNode([path], function (err, res) {\n      expect(err, 'to be null');\n      expect(res.code, 'to be', 0);\n      var results = JSON.parse(res.output);\n      expect(results, 'to have length', 2);\n      expect(results[0].failures, 'to have length', 1);\n      expect(results[0].passes, 'to have length', 0);\n      expect(results[1].passes, 'to have length', 1);\n      expect(results[1].failures, 'to have length', 0);\n      done();\n    });\n  });\n});"}
{"prompt":"retries, function  {","test":"'use strict';\n\ndescribe('retries', function () {\n  this.retries(3);\n  describe('nested', function () {\n    it('should fail after only 1 retry', function () {\n      this.retries(1);\n      throw new Error('retry error');\n    });\n  });\n});"}
{"prompt":"Example test, function  {","test":"'use strict';\nvar assert = require('assert');\n\ndescribe('Example test', function () {\n  it('should fail', function () {\n    assert.deepStrictEqual([1, 2, 3], ['foo', 'bar', 'baz']);\n  });\n});"}
{"prompt":"no-diff, function  {","test":"'use strict';\n\nvar helpers = require('./helpers');\nvar run = helpers.runMocha;\n\ndescribe('no-diff', function () {\n  describe('when enabled', function () {\n    it('should not display a diff', function (done) {\n      run('no-diff.fixture.js', ['--no-diff'], function (err, res) {\n        if (err) {\n          done(err);\n          return;\n        }\n        expect(res.output, 'not to match', /\\+ expected/);\n        expect(res.output, 'not to match', /- actual/);\n        done();\n      });\n    });\n  });\n\n  describe('when disabled', function () {\n    it('should display a diff', function (done) {\n      run('no-diff.fixture.js', ['--diff'], function (err, res) {\n        if (err) {\n          done(err);\n          return;\n        }\n        expect(res.output, 'to match', /\\+ expected/);\n        expect(res.output, 'to match', /- actual/);\n        done();\n      });\n    });\n  });\n});"}
{"prompt":"node-flags, function  {","test":"'use strict';\n\nconst nodeEnvFlags = [...process.allowedNodeEnvironmentFlags];\nconst {\n  isNodeFlag,\n  impliesNoTimeouts,\n  unparseNodeFlags\n} = require('../../../lib/cli/node-flags');\n\nconst {isMochaFlag} = require('../../../lib/cli/run-option-metadata');\n\ndescribe('node-flags', function () {\n  describe('isNodeFlag()', function () {\n    describe('for all allowed node environment flags', function () {\n      nodeEnvFlags\n        .filter(flag => !isMochaFlag(flag))\n        .forEach(envFlag => {\n          it(`${envFlag} should return true`, function () {\n            expect(isNodeFlag(envFlag), 'to be true');\n          });\n        });\n    });\n\n    describe('for all allowed node env flags which conflict with mocha flags', function () {\n      nodeEnvFlags\n        .filter(flag => isMochaFlag(flag))\n        .forEach(envFlag => {\n          it(`${envFlag} should return false`, function () {\n            expect(isNodeFlag(envFlag), 'to be false');\n          });\n        });\n    });\n\n    describe('when expecting leading dashes', function () {\n      it('should require leading dashes', function () {\n        expect(isNodeFlag('throw-deprecation', false), 'to be false');\n        expect(isNodeFlag('--throw-deprecation', false), 'to be true');\n      });\n    });\n\n    describe('special cases', function () {\n      it('should return true for flags starting with \"preserve-symlinks\"', function () {\n        expect(isNodeFlag('preserve-symlinks'), 'to be true');\n        expect(isNodeFlag('preserve-symlinks-main'), 'to be true');\n        expect(isNodeFlag('preserve_symlinks'), 'to be true');\n      });\n\n      it('should return true for flags starting with \"harmony-\" or \"harmony_\"', function () {\n        expect(isNodeFlag('harmony-literally-anything'), 'to be true');\n        expect(isNodeFlag('harmony_literally_underscores'), 'to be true');\n        expect(isNodeFlag('harmonynope'), 'to be false');\n      });\n\n      it('should return true for flags starting with \"trace-\" or \"trace_\"', function () {\n        expect(isNodeFlag('trace-literally-anything'), 'to be true');\n        expect(isNodeFlag('trace_literally_underscores'), 'to be true');\n        expect(isNodeFlag('tracenope'), 'to be false');\n      });\n\n      it('should return true for \"harmony\" itself', function () {\n        expect(isNodeFlag('harmony'), 'to be true');\n      });\n\n      it('should return true for \"gc-global\"', function () {\n        expect(isNodeFlag('gc-global'), 'to be true');\n        expect(isNodeFlag('gc_global'), 'to be true');\n      });\n\n      it('should return true for \"es-staging\"', function () {\n        expect(isNodeFlag('es-staging'), 'to be true');\n        expect(isNodeFlag('es_staging'), 'to be true');\n      });\n\n      it('should return true for \"use-strict\"', function () {\n        expect(isNodeFlag('use-strict'), 'to be true');\n        expect(isNodeFlag('use_strict'), 'to be true');\n      });\n\n      it('should return true for flags starting with \"--v8-\"', function () {\n        expect(isNodeFlag('v8-'), 'to be false');\n        expect(isNodeFlag('v8-options'), 'to be false');\n        expect(isNodeFlag('v8_options'), 'to be false');\n        expect(isNodeFlag('v8-anything-else'), 'to be true');\n        expect(isNodeFlag('v8_anything_else'), 'to be true');\n      });\n    });\n  });\n\n  describe('impliesNoTimeouts()', function () {\n    it('should return true for inspect flags', function () {\n      expect(impliesNoTimeouts('inspect'), 'to be true');\n      expect(impliesNoTimeouts('inspect-brk'), 'to be true');\n    });\n  });\n\n  describe('unparseNodeFlags()', function () {\n    it('should handle single v8 flags', function () {\n      expect(unparseNodeFlags({'v8-numeric': 100}), 'to equal', [\n        '--v8-numeric=100'\n      ]);\n      expect(unparseNodeFlags({'v8-boolean': true}), 'to equal', [\n        '--v8-boolean'\n      ]);\n    });\n\n    it('should handle multiple v8 flags', function () {\n      expect(\n        unparseNodeFlags({'v8-numeric-one': 1, 'v8-numeric-two': 2}),\n        'to equal',\n        ['--v8-numeric-one=1', '--v8-numeric-two=2']\n      );\n      expect(\n        unparseNodeFlags({'v8-boolean-one': true, 'v8-boolean-two': true}),\n        'to equal',\n        ['--v8-boolean-one', '--v8-boolean-two']\n      );\n      expect(\n        unparseNodeFlags({\n          'v8-boolean-one': true,\n          'v8-numeric-one': 1,\n          'v8-boolean-two': true\n        }),\n        'to equal',\n        ['--v8-boolean-one', '--v8-numeric-one=1', '--v8-boolean-two']\n      );\n      expect(\n        unparseNodeFlags({\n          'v8-numeric-one': 1,\n          'v8-boolean-one': true,\n          'v8-numeric-two': 2\n        }),\n        'to equal',\n        ['--v8-numeric-one=1', '--v8-boolean-one', '--v8-numeric-two=2']\n      );\n    });\n  });\n});"}
{"prompt":"test,  => {","test":"import {it} from '../../../../index.js';\n\nit('test', () => {\n  throw new Error('Foo');\n});"}
{"prompt":"Nyan reporter, function  {","test":"'use strict';\n\nvar sinon = require('sinon');\nvar events = require('../../').Runner.constants;\nvar helpers = require('./helpers');\nvar reporters = require('../../').reporters;\n\nvar Base = reporters.Base;\nvar NyanCat = reporters.Nyan;\nvar createMockRunner = helpers.createMockRunner;\nvar makeRunReporter = helpers.createRunReporterFunction;\n\nvar EVENT_RUN_BEGIN = events.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = events.EVENT_RUN_END;\nvar EVENT_TEST_FAIL = events.EVENT_TEST_FAIL;\nvar EVENT_TEST_PASS = events.EVENT_TEST_PASS;\nvar EVENT_TEST_PENDING = events.EVENT_TEST_PENDING;\n\ndescribe('Nyan reporter', function () {\n  var noop = function () {};\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('event handlers', function () {\n    var runReporter = makeRunReporter(NyanCat);\n\n    describe(\"on 'start' event\", function () {\n      it('should call draw', function () {\n        var fakeThis = {\n          draw: sinon.stub().callsFake(noop),\n          generateColors: noop\n        };\n\n        var runner = createMockRunner('start', EVENT_RUN_BEGIN);\n        var options = {};\n        runReporter(fakeThis, runner, options);\n\n        expect(fakeThis.draw.called, 'to be true');\n      });\n    });\n\n    describe(\"on 'pending' event\", function () {\n      it('should call draw', function () {\n        var fakeThis = {\n          draw: sinon.stub().callsFake(noop),\n          generateColors: noop\n        };\n        var runner = createMockRunner('pending', EVENT_TEST_PENDING);\n        var options = {};\n        runReporter(fakeThis, runner, options);\n\n        expect(fakeThis.draw.called, 'to be true');\n      });\n    });\n\n    describe(\"on 'pass' event\", function () {\n      it('should call draw', function () {\n        var test = {\n          duration: '',\n          slow: noop\n        };\n        var fakeThis = {\n          draw: sinon.stub().callsFake(noop),\n          generateColors: noop\n        };\n        var runner = createMockRunner(\n          'pass',\n          EVENT_TEST_PASS,\n          null,\n          null,\n          test\n        );\n        var options = {};\n        runReporter(fakeThis, runner, options);\n\n        expect(fakeThis.draw.called, 'to be true');\n      });\n    });\n\n    describe(\"on 'fail' event\", function () {\n      it('should call draw', function () {\n        var test = {\n          err: ''\n        };\n        var fakeThis = {\n          draw: sinon.stub().callsFake(noop),\n          generateColors: noop\n        };\n        var runner = createMockRunner(\n          'fail',\n          EVENT_TEST_FAIL,\n          null,\n          null,\n          test\n        );\n        var options = {};\n        runReporter(fakeThis, runner, options);\n\n        expect(fakeThis.draw.called, 'to be true');\n      });\n    });\n\n    describe(\"on 'end' event\", function () {\n      it('should call epilogue', function () {\n        var fakeThis = {\n          draw: noop,\n          epilogue: sinon.stub().callsFake(noop),\n          generateColors: noop\n        };\n        var runner = createMockRunner('end', EVENT_RUN_END);\n        var options = {};\n        runReporter(fakeThis, runner, options);\n\n        expect(fakeThis.epilogue.called, 'to be true');\n      });\n\n      it('should write numberOfLines amount of newlines', function () {\n        var expectedNumberOfLines = 4;\n        var fakeThis = {\n          draw: noop,\n          epilogue: noop,\n          generateColors: noop\n        };\n        var runner = createMockRunner('end', EVENT_RUN_END);\n        var options = {};\n        var stdout = runReporter(fakeThis, runner, options);\n\n        var isBlankLine = function (value) {\n          return value === '\\n';\n        };\n\n        expect(\n          stdout.filter(isBlankLine),\n          'to have length',\n          expectedNumberOfLines\n        );\n      });\n\n      it('should call Base show', function () {\n        var showCursorStub = sinon.stub(Base.cursor, 'show');\n        var fakeThis = {\n          draw: noop,\n          epilogue: noop,\n          generateColors: noop\n        };\n        var runner = createMockRunner('end', EVENT_RUN_END);\n        var options = {};\n        runReporter(fakeThis, runner, options);\n        sinon.restore();\n\n        expect(showCursorStub.called, 'to be true');\n      });\n    });\n  });\n\n  describe('#draw', function () {\n    var stdoutWriteStub;\n    var stdout;\n\n    beforeEach(function () {\n      stdoutWriteStub = sinon.stub(process.stdout, 'write');\n      stdoutWriteStub.callsFake(function (chunk, encoding, cb) {\n        stdout.push(chunk);\n      });\n      stdout = [];\n    });\n\n    describe(\"when 'tick' is false\", function () {\n      it('should draw face with expected spaces, _ and ^', function () {\n        var runner = {on: noop, once: noop};\n        var options = {};\n        var nyanCat = new NyanCat(runner, options);\n        nyanCat.stats = {passes: 2, pending: 1, failures: 0};\n        var fakeThis = {\n          tick: false,\n          appendRainbow: noop,\n          rainbowify: noop,\n          drawScoreboard: noop,\n          drawRainbow: noop,\n          drawNyanCat: NyanCat.prototype.drawNyanCat,\n          scoreboardWidth: 0,\n          trajectories: [[]],\n          face: noop,\n          cursorUp: noop\n        };\n\n        try {\n          nyanCat.draw.call(fakeThis);\n        } finally {\n          sinon.restore();\n        }\n\n        var expectedArray = [\n          '\\u001b[0C',\n          '_,------,',\n          '\\n',\n          '\\u001b[0C',\n          '_|   /\\\\_/\\\\ ',\n          '\\n',\n          '\\u001b[0C',\n          '^|__undefined ',\n          '\\n',\n          '\\u001b[0C',\n          '  \"\"  \"\" ',\n          '\\n'\n        ];\n        expect(stdout, 'to equal', expectedArray);\n      });\n    });\n\n    describe(\"when 'tick' is true\", function () {\n      it('should draw face with expected spaces, _ and ~', function () {\n        var runner = {on: noop, once: noop};\n        var options = {};\n        var nyanCat = new NyanCat(runner, options);\n        nyanCat.stats = {passes: 2, pending: 1, failures: 0};\n        var fakeThis = {\n          tick: true,\n          appendRainbow: noop,\n          rainbowify: noop,\n          drawScoreboard: noop,\n          drawRainbow: noop,\n          drawNyanCat: NyanCat.prototype.drawNyanCat,\n          scoreboardWidth: 0,\n          trajectories: [[]],\n          face: noop,\n          cursorUp: noop\n        };\n\n        try {\n          nyanCat.draw.call(fakeThis);\n        } finally {\n          sinon.restore();\n        }\n\n        var expectedArray = [\n          '\\u001b[0C',\n          '_,------,',\n          '\\n',\n          '\\u001b[0C',\n          '_|  /\\\\_/\\\\ ',\n          '\\n',\n          '\\u001b[0C',\n          '~|_undefined ',\n          '\\n',\n          '\\u001b[0C',\n          ' \"\"  \"\" ',\n          '\\n'\n        ];\n        expect(stdout, 'to equal', expectedArray);\n      });\n    });\n  });\n\n  describe('#cursorDown', function () {\n    var stdoutWriteStub;\n    var stdout;\n\n    beforeEach(function () {\n      stdoutWriteStub = sinon.stub(process.stdout, 'write');\n      stdoutWriteStub.callsFake(function (chunk, encoding, cb) {\n        stdout.push(chunk);\n      });\n      stdout = [];\n    });\n\n    it('should write cursor down interaction with expected number', function () {\n      var runner = {on: noop, once: noop};\n      var options = {};\n      var nyanCat = new NyanCat(runner, options);\n      var expectedNumber = 25;\n\n      try {\n        nyanCat.cursorDown(expectedNumber);\n      } finally {\n        sinon.restore();\n      }\n\n      var expectedArray = ['\\u001b[' + expectedNumber + 'B'];\n      expect(stdout, 'to equal', expectedArray);\n    });\n  });\n\n  describe('#cursorUp', function () {\n    var stdoutWriteStub;\n    var stdout;\n\n    beforeEach(function () {\n      stdoutWriteStub = sinon.stub(process.stdout, 'write');\n      stdoutWriteStub.callsFake(function (chunk, encoding, cb) {\n        stdout.push(chunk);\n      });\n      stdout = [];\n    });\n\n    it('should write cursor up interaction with expected number', function () {\n      var runner = {on: noop, once: noop};\n      var options = {};\n      var nyanCat = new NyanCat(runner, options);\n      var expectedNumber = 25;\n\n      try {\n        nyanCat.cursorUp(expectedNumber);\n      } finally {\n        sinon.restore();\n      }\n\n      var expectedArray = ['\\u001b[' + expectedNumber + 'A'];\n      expect(stdout, 'to equal', expectedArray);\n    });\n  });\n\n  describe('#rainbowify', function () {\n    var useColorsStub;\n\n    beforeEach(function () {\n      useColorsStub = sinon.stub(Base, 'useColors');\n    });\n\n    afterEach(function () {\n      sinon.restore();\n    });\n\n    describe(\"when 'useColors' is false\", function () {\n      beforeEach(function () {\n        useColorsStub.value(false);\n      });\n\n      it('should return argument string', function () {\n        var runner = {on: noop, once: noop};\n        var options = {};\n        var nyanCat = new NyanCat(runner, options);\n\n        var inputString = 'hello';\n        var outputString = nyanCat.rainbowify(inputString);\n        sinon.restore();\n\n        var expectedString = inputString;\n        expect(outputString, 'to be', expectedString);\n      });\n    });\n\n    describe(\"when 'useColors' is true\", function () {\n      beforeEach(function () {\n        useColorsStub.value(true);\n      });\n\n      it('should return rainbowified string from the given string and predefined codes', function () {\n        var runner = {on: noop, once: noop};\n        var options = {};\n        var nyanCat = new NyanCat(runner, options);\n\n        var inputString = 'hello';\n        var colorCode = 'somecode';\n        var fakeThis = {\n          rainbowColors: [colorCode],\n          colorIndex: 0\n        };\n        var outputString = nyanCat.rainbowify.call(fakeThis, inputString);\n        sinon.restore();\n\n        var startCode = '\\u001b[38;5;';\n        var endCode = '\\u001b[0m';\n        var expectedString =\n          startCode + colorCode + 'm' + inputString + endCode;\n        expect(outputString, 'to be', expectedString);\n      });\n    });\n  });\n\n  describe('#appendRainbow', function () {\n    describe(\"when 'tick' is true\", function () {\n      it('should set an underscore segment', function () {\n        var runner = {on: noop, once: noop};\n        var options = {};\n        var nyanCat = new NyanCat(runner, options);\n        var expectedSegment;\n        var inputArray = [];\n        var trajectories = [inputArray, inputArray, inputArray, inputArray];\n        nyanCat.appendRainbow.call({\n          tick: true,\n          rainbowify: function (segment) {\n            expectedSegment = segment;\n          },\n          numberOfLines: 4,\n          trajectoryWidthMax: 0,\n          trajectories\n        });\n\n        expect(expectedSegment, 'to be', '_');\n      });\n\n      it('should shift each trajectory item if its length is greater than or equal to its max width', function () {\n        var runner = {on: noop, once: noop};\n        var options = {};\n        var nyanCat = new NyanCat(runner, options);\n\n        var rainbowifyResult = 'rainbowify';\n        var inputArray = ['itemToShify'];\n        var trajectories = [inputArray, inputArray, inputArray, inputArray];\n        var expectedArray = [rainbowifyResult];\n        var expectedTrajectories = [\n          expectedArray,\n          expectedArray,\n          expectedArray,\n          expectedArray\n        ];\n        nyanCat.appendRainbow.call({\n          tick: true,\n          rainbowify: function () {\n            return rainbowifyResult;\n          },\n          numberOfLines: 4,\n          trajectoryWidthMax: 0,\n          trajectories\n        });\n\n        expect(trajectories, 'to equal', expectedTrajectories);\n      });\n    });\n\n    describe(\"when 'tick' is false\", function () {\n      it('should set a dash segment', function () {\n        var runner = {on: noop, once: noop};\n        var options = {};\n        var nyanCat = new NyanCat(runner, options);\n        var expectedSegment;\n        var inputArray = [];\n        var trajectories = [inputArray, inputArray, inputArray, inputArray];\n        nyanCat.appendRainbow.call({\n          tick: false,\n          rainbowify: function (segment) {\n            expectedSegment = segment;\n          },\n          numberOfLines: 4,\n          trajectoryWidthMax: 5,\n          trajectories\n        });\n\n        expect(expectedSegment, 'to equal', '-');\n      });\n    });\n  });\n\n  describe('#drawScoreboard', function () {\n    var stdout;\n\n    beforeEach(function () {\n      sinon.stub(Base, 'color').callsFake(function (type, n) {\n        return type + n;\n      });\n      var stdoutWriteStub = sinon.stub(process.stdout, 'write');\n      stdoutWriteStub.callsFake(function (chunk, encoding, cb) {\n        stdout.push(chunk);\n      });\n      stdout = [];\n    });\n\n    it('should write scoreboard with color set with each stat', function () {\n      var runner = {on: noop, once: noop};\n      var options = {};\n      var nyanCat = new NyanCat(runner, options);\n\n      var passes = 2;\n      var pending = 1;\n      var failures = 1;\n\n      var fakeThis = {\n        cursorUp: noop,\n        stats: {passes, pending, failures},\n        numberOfLines: 4\n      };\n\n      try {\n        nyanCat.drawScoreboard.call(fakeThis);\n      } finally {\n        sinon.restore();\n      }\n\n      var expectedArray = [\n        ' ',\n        'green' + passes,\n        '\\n',\n        ' ',\n        'fail' + failures,\n        '\\n',\n        ' ',\n        'pending' + pending,\n        '\\n',\n        '\\n'\n      ];\n      expect(stdout, 'to equal', expectedArray);\n    });\n\n    it('should call cursorUp with given numberOfLines', function () {\n      var expectedNumberOfLines = 1000;\n\n      var runner = {on: noop, once: noop};\n      var options = {};\n      var nyanCat = new NyanCat(runner, options);\n      var fakeThis = {\n        cursorUp: sinon.spy(),\n        stats: {passes: 0, pending: 0, failures: 0},\n        numberOfLines: expectedNumberOfLines\n      };\n\n      try {\n        nyanCat.drawScoreboard.call(fakeThis);\n      } finally {\n        sinon.restore();\n      }\n\n      expect(fakeThis.cursorUp.calledWith(expectedNumberOfLines), 'to be true');\n    });\n  });\n\n  describe('#drawRainbow', function () {\n    var stdout;\n\n    beforeEach(function () {\n      var stdoutWriteStub = sinon.stub(process.stdout, 'write');\n      stdoutWriteStub.callsFake(function (chunk, encoding, cb) {\n        stdout.push(chunk);\n      });\n      stdout = [];\n    });\n\n    it('should write width, contents and newline for each trajectory', function () {\n      var expectedWidth = 444;\n\n      var expectedContents = 'input';\n      var inputArray = [expectedContents];\n      var trajectories = [inputArray];\n      var runner = {on: noop, once: noop};\n      var options = {};\n      var nyanCat = new NyanCat(runner, options);\n      var fakeThis = {\n        cursorUp: noop,\n        trajectories,\n        scoreboardWidth: expectedWidth,\n        numberOfLines: 1\n      };\n\n      try {\n        nyanCat.drawRainbow.call(fakeThis);\n      } finally {\n        sinon.restore();\n      }\n\n      var expectedArray = [\n        '\\u001b[' + expectedWidth + 'C',\n        expectedContents,\n        '\\n'\n      ];\n      expect(stdout, 'to equal', expectedArray);\n    });\n\n    it('should call cursorUp with given numberOfLines', function () {\n      var expectedCursorArgument = null;\n      var expectedNumberOfLines = 1000;\n\n      var runner = {on: noop, once: noop};\n      var options = {};\n      var nyanCat = new NyanCat(runner, options);\n      var fakeThis = {\n        cursorUp: function (lines) {\n          expectedCursorArgument = lines;\n        },\n        trajectories: [['input']],\n        scoreboardWidth: 1,\n        numberOfLines: expectedNumberOfLines\n      };\n\n      try {\n        nyanCat.drawRainbow.call(fakeThis);\n      } finally {\n        sinon.restore();\n      }\n\n      expect(expectedCursorArgument, 'to be', expectedNumberOfLines);\n    });\n  });\n\n  describe('#face', function () {\n    it('should expect \"( x .x)\" if any failures', function () {\n      var runner = {on: noop, once: noop};\n      var options = {};\n      var nyanCat = new NyanCat(runner, options);\n      nyanCat.stats = {passes: 2, pending: 1, failures: 1};\n\n      expect(nyanCat.face(), 'to be', '( x .x)');\n    });\n\n    it('should expect \"( o .o)\" if any pending but none failing', function () {\n      var runner = {on: noop, once: noop};\n      var options = {};\n      var nyanCat = new NyanCat(runner, options);\n      nyanCat.stats = {passes: 2, pending: 1, failures: 0};\n\n      expect(nyanCat.face(), 'to be', '( o .o)');\n    });\n\n    it('should expect \"( ^ .^)\" if all passing', function () {\n      var runner = {on: noop, once: noop};\n      var options = {};\n      var nyanCat = new NyanCat(runner, options);\n      nyanCat.stats = {passes: 1, pending: 0, failures: 0};\n\n      expect(nyanCat.face(), 'to be', '( ^ .^)');\n    });\n\n    it('should expect \"( - .-)\" otherwise', function (done) {\n      var runner = {on: noop, once: noop};\n      var options = {};\n      var nyanCat = new NyanCat(runner, options);\n      nyanCat.stats = {passes: 0, pending: 0, failures: 0};\n\n      expect(nyanCat.face(), 'to be', '( - .-)');\n      done();\n    });\n  });\n});"}
{"prompt":"test marked with only and beforeEach has skip, function {","test":"'use strict';\n\ndescribe('test marked with only and beforeEach has skip', function() {\n  beforeEach(function() {\n    this.skip();\n  });\n  it.only('only test', function() {});\n});"}
{"prompt":"test marked with only and before has skip, function {","test":"'use strict';\n\ndescribe('test marked with only and before has skip', function() {\n  before(function() {\n    this.skip();\n  });\n  it.only('only test', function() {});\n});"}
{"prompt":".onlyforbid only - suite marked with only, function {};","test":"'use strict';\n\ndescribe.only('forbid only - suite marked with only', function() {});"}
{"prompt":".onlyforbid only - suite marked with only, function {","test":"'use strict';\n\ndescribe.only('forbid only - suite marked with only', function() {\n  it('test1', function() {});\n});"}
{"prompt":"forbid only - test marked with only, function {","test":"'use strict';\n\ndescribe('forbid only - test marked with only', function() {\n  it('test1', function() {});\n  it.only('test2', function() {});\n  it('test3', function() {});\n});"}
{"prompt":".only, function  {","test":"'use strict';\n\nvar run = require('./helpers').runMochaJSON;\nvar assert = require('node:assert');\n\ndescribe('.only()', function () {\n  describe('bdd', function () {\n    it('should run only tests that marked as `only`', function (done) {\n      run('options/only/bdd.fixture.js', ['--ui', 'bdd'], function (err, res) {\n        if (err) {\n          done(err);\n          return;\n        }\n        assert.strictEqual(res.stats.pending, 0);\n        assert.strictEqual(res.stats.passes, 11);\n        assert.strictEqual(res.stats.failures, 0);\n        assert.strictEqual(res.code, 0);\n        done();\n      });\n    });\n  });\n\n  describe('tdd', function () {\n    it('should run only tests that marked as `only`', function (done) {\n      run('options/only/tdd.fixture.js', ['--ui', 'tdd'], function (err, res) {\n        if (err) {\n          done(err);\n          return;\n        }\n        assert.strictEqual(res.stats.pending, 0);\n        assert.strictEqual(res.stats.passes, 8);\n        assert.strictEqual(res.stats.failures, 0);\n        assert.strictEqual(res.code, 0);\n        done();\n      });\n    });\n  });\n\n  describe('qunit', function () {\n    it('should run only tests that marked as `only`', function (done) {\n      run(\n        'options/only/qunit.fixture.js',\n        ['--ui', 'qunit'],\n        function (err, res) {\n          if (err) {\n            done(err);\n            return;\n          }\n          assert.strictEqual(res.stats.pending, 0);\n          assert.strictEqual(res.stats.passes, 5);\n          assert.strictEqual(res.stats.failures, 0);\n          assert.strictEqual(res.code, 0);\n          done();\n        }\n      );\n    });\n  });\n});"}
{"prompt":"options, function  {","test":"'use strict';\n\nconst sinon = require('sinon');\nconst rewiremock = require('rewiremock/node');\nconst {ONE_AND_DONE_ARGS} = require('../../../lib/cli/one-and-dones');\nconst {constants} = require('../../../lib/errors');\n\nconst modulePath = require.resolve('../../../lib/cli/options');\nconst mocharcPath = require.resolve('../../../lib/mocharc.json');\nconst configPath = require.resolve('../../../lib/cli/config');\n\nconst proxyLoadOptions = ({\n  readFileSync = {},\n  findupSync = null,\n  findConfig = {},\n  loadConfig = {}\n} = {}) =>\n  rewiremock.proxy(modulePath, r => ({\n    'node:fs': r.with({readFileSync}).directChildOnly(),\n    [mocharcPath]: defaults,\n    'find-up': r\n      .by(() => (findupSync ? {sync: findupSync} : {}))\n      .directChildOnly(),\n    [configPath]: r.with({findConfig, loadConfig}).directChildOnly()\n  })).loadOptions;\n\nconst defaults = {\n  timeout: 1000,\n  extension: ['js']\n};\n\ndescribe('options', function () {\n  let readFileSync;\n  let findupSync;\n  let loadOptions;\n  let findConfig;\n  let loadConfig;\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  /**\n   * Order of priority:\n   * 1. Command-line args\n   * 2. `MOCHA_OPTIONS` environment variable\n   * 3. RC file (`.mocharc.js`, `.mocharc.ya?ml`, `mocharc.json`)\n   * 4. `mocha` prop of `package.json`\n   * 5. default rc\n   */\n  describe('loadOptions()', function () {\n    describe('when no parameter provided', function () {\n      beforeEach(function () {\n        this.timeout(1000);\n        readFileSync = sinon.stub();\n        readFileSync.onFirstCall().returns('{}');\n        findConfig = sinon.stub().returns('/some/.mocharc.json');\n        loadConfig = sinon.stub().returns({});\n        findupSync = sinon.stub().returns('/some/package.json');\n\n        loadOptions = proxyLoadOptions({\n          readFileSync,\n          findConfig,\n          loadConfig,\n          findupSync\n        });\n      });\n\n      it('should return an object containing positional args, defaults, and anti-reloading flags', function () {\n        expect(\n          loadOptions(),\n          'to equal',\n          Object.assign({}, defaults, {\n            _: [],\n            config: false,\n            package: false\n          })\n        );\n      });\n    });\n\n    describe('when parameter provided', function () {\n      describe('package.json', function () {\n        describe('when path to package.json (`--package <path>`) is valid', function () {\n          let result;\n\n          beforeEach(function () {\n            const filepath = '/some/package.json';\n            readFileSync = sinon.stub();\n            // package.json\n            readFileSync.onFirstCall().returns('{\"mocha\": {\"retries\": 3}}');\n            findConfig = sinon.stub().returns('/some/.mocharc.json');\n            loadConfig = sinon.stub().returns({});\n            findupSync = sinon.stub();\n            loadOptions = proxyLoadOptions({\n              readFileSync,\n              findConfig,\n              loadConfig,\n              findupSync\n            });\n            result = loadOptions(['--package', filepath]);\n          });\n\n          it('should return merged options incl. package.json opts', function () {\n            expect(\n              result,\n              'to equal',\n              Object.assign(\n                {\n                  _: []\n                },\n                defaults,\n                {\n                  config: false,\n                  package: false,\n                  retries: 3\n                }\n              )\n            );\n          });\n\n          it('should not try to find a package.json', function () {\n            expect(findupSync, 'was not called');\n          });\n\n          it('should set package = false', function () {\n            expect(result, 'to have property', 'package', false);\n          });\n        });\n\n        describe('when path to package.json (`--package <path>`) is invalid', function () {\n          beforeEach(function () {\n            readFileSync = sinon.stub();\n            // package.json\n            readFileSync.onFirstCall().throws('bad file message');\n            findConfig = sinon.stub().returns('/some/.mocharc.json');\n            loadConfig = sinon.stub().returns({});\n            findupSync = sinon.stub();\n            loadOptions = proxyLoadOptions({\n              readFileSync,\n              findConfig,\n              loadConfig,\n              findupSync\n            });\n          });\n\n          it('should throw', function () {\n            expect(\n              () => {\n                loadOptions('--package /something/wherever --require butts');\n              },\n              'to throw',\n              'Unable to read /something/wherever: bad file message'\n            );\n          });\n        });\n\n        describe('when path to package.json unspecified', function () {\n          let result;\n\n          beforeEach(function () {\n            const filepath = '/some/package.json';\n            readFileSync = sinon.stub();\n            // package.json\n            readFileSync\n              .onFirstCall()\n              .returns('{\"mocha\": {\"retries\": 3, \"_\": [\"foobar.spec.js\"]}}');\n            findConfig = sinon.stub().returns('/some/.mocharc.json');\n            loadConfig = sinon.stub().returns({});\n            findupSync = sinon.stub().returns(filepath);\n            loadOptions = proxyLoadOptions({\n              readFileSync,\n              findConfig,\n              loadConfig,\n              findupSync\n            });\n            result = loadOptions();\n          });\n\n          it('should return merged options incl. found package.json', function () {\n            expect(\n              result,\n              'to equal',\n              Object.assign(\n                {\n                  _: ['foobar.spec.js']\n                },\n                defaults,\n                {\n                  config: false,\n                  package: false,\n                  retries: 3\n                }\n              )\n            );\n          });\n\n          it('should set package = false', function () {\n            expect(result, 'to have property', 'package', false);\n          });\n        });\n\n        describe('when path to package.json unspecified and package.json exists but is invalid', function () {\n          beforeEach(function () {\n            const filepath = '/some/package.json';\n            readFileSync = sinon.stub();\n            // package.json\n            readFileSync\n              .onFirstCall()\n              .returns('{definitely-invalid');\n            findConfig = sinon.stub().returns('/some/.mocharc.json');\n            loadConfig = sinon.stub().returns({});\n            findupSync = sinon.stub().returns(filepath);\n            loadOptions = proxyLoadOptions({\n              readFileSync,\n              findConfig,\n              loadConfig,\n              findupSync\n            });\n          });\n\n          it('should throw', function () {\n            expect(\n              () => {\n                loadOptions();\n              },\n              'to throw',\n                /SyntaxError/,\n            );\n          });\n        });\n\n        describe('when called with package = false (`--no-package`)', function () {\n          let result;\n          beforeEach(function () {\n            readFileSync = sinon.stub();\n            readFileSync.onFirstCall().returns('{}');\n            findConfig = sinon.stub().returns('/some/path/to/.mocharc.json');\n            loadConfig = sinon.stub().returns({'check-leaks': true});\n            findupSync = sinon.stub().returns('/some/package.json');\n\n            loadOptions = proxyLoadOptions({\n              readFileSync,\n              findConfig,\n              loadConfig,\n              findupSync\n            });\n\n            result = loadOptions('--no-diff --no-package');\n          });\n\n          it('should return parsed args and default config', function () {\n            expect(\n              result,\n              'to equal',\n              Object.assign({_: []}, defaults, {\n                diff: false,\n                'check-leaks': true,\n                config: false,\n                package: false\n              })\n            );\n          });\n\n          it('should not look for package.json', function () {\n            expect(findupSync, 'was not called');\n          });\n\n          it('should set package = false', function () {\n            expect(result, 'to have property', 'package', false);\n          });\n        });\n      });\n\n      describe('rc file', function () {\n        describe('when called with config = false (`--no-config`)', function () {\n          let result;\n          beforeEach(function () {\n            readFileSync = sinon.stub();\n            readFileSync\n              .onFirstCall()\n              .returns(\n                '{\"mocha\": {\"check-leaks\": true, \"_\": [\"foobar.spec.js\"]}}'\n              );\n            findConfig = sinon.stub();\n            loadConfig = sinon.stub();\n            findupSync = sinon.stub().returns('/some/package.json');\n\n            loadOptions = proxyLoadOptions({\n              readFileSync,\n              findConfig,\n              loadConfig,\n              findupSync\n            });\n\n            result = loadOptions('--no-diff --no-config');\n          });\n\n          it('should return parsed args, default config and package.json', function () {\n            expect(\n              result,\n              'to equal',\n              Object.assign({_: ['foobar.spec.js']}, defaults, {\n                diff: false,\n                'check-leaks': true,\n                config: false,\n                package: false\n              })\n            );\n          });\n\n          it('should not attempt to load a config file', function () {\n            expect(loadConfig, 'was not called');\n          });\n\n          it('should not attempt to find a config file', function () {\n            expect(findConfig, 'was not called');\n          });\n\n          it('should set config = false', function () {\n            expect(result, 'to have property', 'config', false);\n          });\n        });\n\n        describe('when path to config (`--config <path>`) is invalid', function () {\n          let config;\n\n          beforeEach(function () {\n            readFileSync = sinon.stub();\n            config = '/some/.mocharc.json';\n            readFileSync.onFirstCall().returns('{}');\n            findConfig = sinon.stub();\n            loadConfig = sinon.stub().throws('Error', 'failed to parse');\n            findupSync = sinon.stub().returns('/some/package.json');\n\n            loadOptions = proxyLoadOptions({\n              readFileSync,\n              findConfig,\n              loadConfig,\n              findupSync\n            });\n          });\n\n          it('should not look for a config', function () {\n            try {\n              loadOptions(`--config ${config}`);\n            } catch (ignored) {}\n            expect(findConfig, 'was not called');\n          });\n\n          it('should attempt to load file at path', function () {\n            try {\n              loadOptions(`--config ${config}`);\n            } catch (ignored) {}\n            expect(loadConfig, 'to have a call satisfying', [config]);\n          });\n\n          it('should throw to warn the user', function () {\n            expect(\n              () => {\n                loadOptions(`--config ${config}`);\n              },\n              'to throw',\n              'failed to parse'\n            );\n          });\n        });\n\n        describe('when called with unspecified config', function () {\n          describe('when an rc file would be found', function () {\n            let result;\n\n            beforeEach(function () {\n              readFileSync = sinon.stub();\n              readFileSync.onFirstCall().returns('{}');\n              readFileSync.onSecondCall().throws();\n              findConfig = sinon.stub().returns('/some/.mocharc.json');\n              loadConfig = sinon.stub().returns({});\n              findupSync = sinon.stub().returns('/some/package.json');\n\n              loadOptions = proxyLoadOptions({\n                readFileSync,\n                findConfig,\n                loadConfig,\n                findupSync\n              });\n\n              result = loadOptions();\n            });\n\n            it('should look for a config', function () {\n              expect(findConfig, 'was called');\n            });\n\n            it('should attempt to load file at found path', function () {\n              expect(loadConfig, 'to have a call satisfying', [\n                '/some/.mocharc.json'\n              ]);\n            });\n\n            it('should set config = false', function () {\n              expect(result, 'to have property', 'config', false);\n            });\n          });\n\n          describe('when an rc file would not be found', function () {\n            let result;\n\n            beforeEach(function () {\n              readFileSync = sinon.stub();\n              readFileSync.onFirstCall().returns('{}');\n              readFileSync.onSecondCall().throws();\n              findConfig = sinon.stub().returns(null);\n              loadConfig = sinon.stub().returns({});\n              findupSync = sinon.stub().returns('/some/package.json');\n\n              loadOptions = proxyLoadOptions({\n                readFileSync,\n                findConfig,\n                loadConfig,\n                findupSync\n              });\n\n              result = loadOptions();\n            });\n\n            it('should look for a config', function () {\n              expect(findConfig, 'was called');\n            });\n\n            it('should not attempt to load a config file', function () {\n              expect(loadConfig, 'was not called');\n            });\n\n            it('should set config = false', function () {\n              expect(result, 'to have property', 'config', false);\n            });\n          });\n        });\n      });\n    });\n\n    describe('env options', function () {\n      it('should parse flags from MOCHA_OPTIONS', function () {\n        readFileSync = sinon.stub().onFirstCall().returns('{}');\n        findConfig = sinon.stub().returns('/some/.mocharc.json');\n        loadConfig = sinon.stub().returns({});\n        findupSync = sinon.stub().returns('/some/package.json');\n        sinon\n          .stub(process, 'env')\n          .value({MOCHA_OPTIONS: '--retries 42 --color'});\n\n        loadOptions = proxyLoadOptions({\n          readFileSync,\n          findConfig,\n          loadConfig,\n          findupSync\n        });\n\n        expect(loadOptions(), 'to satisfy', {\n          retries: 42,\n          color: true\n        });\n      });\n    });\n\n    describe('config priority', function () {\n      it('should prioritize package.json over defaults', function () {\n        readFileSync = sinon.stub();\n        readFileSync\n          .onFirstCall()\n          .returns(\n            '{\"mocha\": {\"timeout\": 700, \"require\": \"bar\", \"extension\": \"ts\"}}'\n          );\n        findConfig = sinon.stub().returns('/some/.mocharc.json');\n        loadConfig = sinon.stub().returns({});\n        findupSync = sinon.stub().returns('/some/package.json');\n\n        loadOptions = proxyLoadOptions({\n          readFileSync,\n          findConfig,\n          loadConfig,\n          findupSync\n        });\n\n        expect(loadOptions(), 'to satisfy', {\n          timeout: 700,\n          require: ['bar'],\n          extension: ['ts']\n        });\n      });\n\n      it('should prioritize rc file over package.json', function () {\n        readFileSync = sinon.stub();\n        readFileSync.onFirstCall().returns('{\"mocha\": {\"timeout\": 700}}');\n        readFileSync.onSecondCall().returns('--timeout 800');\n        findConfig = sinon.stub().returns('/some/.mocharc.json');\n        loadConfig = sinon.stub().returns({timeout: 600});\n        findupSync = sinon.stub().returns('/some/package.json');\n\n        loadOptions = proxyLoadOptions({\n          readFileSync,\n          findConfig,\n          loadConfig,\n          findupSync\n        });\n\n        expect(loadOptions(), 'to have property', 'timeout', 600);\n      });\n\n      it('should prioritize args over rc file', function () {\n        readFileSync = sinon.stub();\n        readFileSync.onFirstCall().returns('{\"mocha\": {\"timeout\": 700}}');\n        readFileSync.onSecondCall().returns('--timeout 800');\n        findConfig = sinon.stub().returns('/some/.mocharc.json');\n        loadConfig = sinon.stub().returns({timeout: 600});\n        findupSync = sinon.stub().returns('/some/package.json');\n\n        loadOptions = proxyLoadOptions({\n          readFileSync,\n          findConfig,\n          loadConfig,\n          findupSync\n        });\n\n        expect(\n          loadOptions('--timeout 500'),\n          'to have property',\n          'timeout',\n          '500'\n        );\n      });\n\n      it('should prioritize env over rc file', function () {\n        readFileSync = sinon.stub();\n        readFileSync.onFirstCall().returns('{}');\n        readFileSync.onSecondCall().returns('');\n        findConfig = sinon.stub().returns('/some/.mocharc.json');\n        loadConfig = sinon.stub().returns({retries: 300});\n        findupSync = sinon.stub().returns('/some/package.json');\n        sinon\n          .stub(process, 'env')\n          .value({MOCHA_OPTIONS: '--retries 800 --color'});\n\n        loadOptions = proxyLoadOptions({\n          readFileSync,\n          findConfig,\n          loadConfig,\n          findupSync\n        });\n\n        expect(loadOptions(), 'to have property', 'retries', 800);\n      });\n    });\n\n    describe('when called with a one-and-done arg', function () {\n      beforeEach(function () {\n        readFileSync = sinon.stub();\n        findConfig = sinon.stub();\n        loadConfig = sinon.stub();\n        findupSync = sinon.stub();\n        loadOptions = proxyLoadOptions({\n          readFileSync,\n          findConfig,\n          loadConfig,\n          findupSync\n        });\n      });\n\n      ONE_AND_DONE_ARGS.forEach(arg => {\n        describe(`\"${arg}\"`, function () {\n          it(`should return basic parsed arguments and flag`, function () {\n            expect(loadOptions(`--${arg}`), 'to equal', {_: [], [arg]: true});\n          });\n        });\n      });\n    });\n\n    describe('\"extension\" handling', function () {\n      describe('when user supplies \"extension\" option', function () {\n        let result;\n\n        beforeEach(function () {\n          readFileSync = sinon.stub();\n          readFileSync.onFirstCall().throws();\n          findConfig = sinon.stub().returns('/some/.mocharc.json');\n          loadConfig = sinon.stub().returns({extension: ['tsx']});\n          findupSync = sinon.stub();\n          loadOptions = proxyLoadOptions({\n            readFileSync,\n            findConfig,\n            loadConfig,\n            findupSync\n          });\n          result = loadOptions(['--extension', 'ts']);\n        });\n\n        it('should not concatenate the default value', function () {\n          expect(result, 'to have property', 'extension', ['ts', 'tsx']);\n        });\n      });\n\n      describe('when user does not supply \"extension\" option', function () {\n        let result;\n\n        beforeEach(function () {\n          readFileSync = sinon.stub();\n          readFileSync.onFirstCall().throws();\n          findConfig = sinon.stub().returns('/some/.mocharc.json');\n          loadConfig = sinon.stub().returns({});\n          findupSync = sinon.stub();\n          loadOptions = proxyLoadOptions({\n            readFileSync,\n            findConfig,\n            loadConfig,\n            findupSync\n          });\n          result = loadOptions();\n        });\n\n        it('should retain the default', function () {\n          expect(result, 'to have property', 'extension', ['js']);\n        });\n      });\n    });\n\n    describe('\"spec\" handling', function () {\n      describe('when user supplies \"spec\" in config and positional arguments', function () {\n        let result;\n\n        beforeEach(function () {\n          readFileSync = sinon.stub();\n          readFileSync.onFirstCall().throws();\n          findConfig = sinon.stub().returns('/some/.mocharc.json');\n          loadConfig = sinon.stub().returns({spec: '{dirA,dirB}/**/*.spec.js'});\n          findupSync = sinon.stub();\n          loadOptions = proxyLoadOptions({\n            readFileSync,\n            findConfig,\n            loadConfig,\n            findupSync\n          });\n          result = loadOptions(['*.test.js']);\n        });\n\n        it('should place both - unsplitted - into the positional arguments array', function () {\n          expect(result, 'to have property', '_', [\n            '*.test.js',\n            '{dirA,dirB}/**/*.spec.js'\n          ]);\n        });\n      });\n    });\n\n    describe('\"ignore\" handling', function () {\n      let result;\n\n      beforeEach(function () {\n        readFileSync = sinon.stub();\n        readFileSync.onFirstCall().throws();\n        findConfig = sinon.stub().returns('/some/.mocharc.json');\n        loadConfig = sinon.stub().returns({ignore: '{dirA,dirB}/**/*.spec.js'});\n        findupSync = sinon.stub();\n        loadOptions = proxyLoadOptions({\n          readFileSync,\n          findConfig,\n          loadConfig,\n          findupSync\n        });\n        result = loadOptions(['--ignore', '*.test.js']);\n      });\n\n      it('should not split option values by comma', function () {\n        expect(result, 'to have property', 'ignore', [\n          '*.test.js',\n          '{dirA,dirB}/**/*.spec.js'\n        ]);\n      });\n    });\n\n    describe('\"numeric arguments\"', function () {\n      const numericArg = 123;\n\n      const unsupportedError = arg => {\n        return {\n          message: `Option ${arg} is unsupported by the mocha cli`,\n          code: constants.UNSUPPORTED\n        };\n      };\n\n      const invalidArgError = (flag, arg, expectedType = 'string') => {\n        return {\n          message: `Mocha flag '${flag}' given invalid option: '${arg}'`,\n          code: constants.INVALID_ARG_TYPE,\n          argument: arg,\n          actual: 'number',\n          expected: expectedType\n        };\n      };\n\n      beforeEach(function () {\n        readFileSync = sinon.stub();\n        findConfig = sinon.stub();\n        loadConfig = sinon.stub();\n        findupSync = sinon.stub();\n        loadOptions = proxyLoadOptions({\n          readFileSync,\n          findConfig,\n          loadConfig,\n          findupSync\n        });\n      });\n\n      it('throws UNSUPPORTED error when numeric option is passed to cli', function () {\n        expect(\n          () => loadOptions(`${numericArg}`),\n          'to throw',\n          unsupportedError(numericArg)\n        );\n      });\n\n      it('throws INVALID_ARG_TYPE error when numeric argument is passed to mocha flag that does not accept numeric value', function () {\n        const flag = '--delay';\n        expect(\n          () => loadOptions(`${flag} ${numericArg}`),\n          'to throw',\n          invalidArgError(flag, numericArg, 'boolean')\n        );\n      });\n\n      it('throws INVALID_ARG_TYPE error when incompatible flag does not have preceding \"--\"', function () {\n        const flag = 'delay';\n        expect(\n          () => loadOptions(`${flag} ${numericArg}`),\n          'to throw',\n          invalidArgError(flag, numericArg, 'boolean')\n        );\n      });\n\n      it('shows correct flag in error when multiple mocha flags have numeric values', function () {\n        const flag = '--delay';\n        expect(\n          () =>\n            loadOptions(\n              `--timeout ${numericArg} ${flag} ${numericArg} --retries ${numericArg}`\n            ),\n          'to throw',\n          invalidArgError(flag, numericArg, 'boolean')\n        );\n      });\n\n      it('throws UNSUPPORTED error when numeric arg is passed to unsupported flag', function () {\n        const invalidFlag = 'foo';\n        expect(\n          () => loadOptions(`${invalidFlag} ${numericArg}`),\n          'to throw',\n          unsupportedError(numericArg)\n        );\n      });\n\n      it('does not throw error if numeric value is passed to a compatible mocha flag', function () {\n        expect(() => loadOptions(`--retries ${numericArg}`), 'not to throw');\n      });\n\n      it('does not throw error if numeric value is passed to a node options', function () {\n        expect(\n          () =>\n            loadOptions(\n              `--secure-heap-min=${numericArg} --conditions=${numericArg}`\n            ),\n          'not to throw'\n        );\n      });\n\n      it('does not throw error if numeric value is passed to string flag', function () {\n        expect(() => loadOptions(`--grep ${numericArg}`), 'not to throw');\n      });\n\n      it('does not throw error if numeric value is passed to an array flag', function () {\n        expect(() => loadOptions(`--spec ${numericArg}`), 'not to throw');\n      });\n    });\n  });\n});"}
{"prompt":"--opts, function  {","test":"'use strict';\n\nvar invokeMocha = require('../helpers').invokeMocha;\n\ndescribe('--opts', function () {\n  it('should report deprecation', function (done) {\n    invokeMocha(\n      ['--opts', './test/mocha.opts'],\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n        expect(\n          res,\n          'to have failed with output',\n          /'mocha.opts' is DEPRECATED/i\n        );\n        done();\n      },\n      'pipe'\n    );\n  });\n});"}
{"prompt":"DIFF","test":"// DIFF\n      -foo rar baz\n      +foo bar baz\n\n// DIFF\n       {\n         \"age\": 23\n      -  \"name\": \"travis j\"\n      +  \"name\": \"travis\"\n       }\n\n// DIFF\n       foo bar baz\n      -foo rar baz\n      -foo bar raz\n      +foo bar baz\n      +foo bar baz\n\n// DIFF\n       {\n         \"address\": {\n           \"city\": \"new york\"\n      -    \"country\": \"usa\"\n      +    \"country\": \"us\"\n         }\n         \"age\": 30\n      -  \"name\": \"joel\"\n      +  \"name\": \"joe\"\n       }\n\n// DIFF\n       one two three\n      -four zzzz six\n      +four five six\n       seven eight nine\n\n// DIFF\n       {\n         \"address\": {\n           \"city\": \"new york\"\n      -    \"country\": \"usa\"\n      +    \"country\": \"us\"\n         }\n         \"age\": 30\n      -  \"name\": \"joel\"\n      +  \"name\": \"joe\"\n       }\n\n// DIFF\n       one\ttab\n      -two\t\t\ttabs\n      +two\t\ttabs\n\n// DIFF\n       body {\n         font: \"Helvetica Neue\", Helvetica, arial, sans-serif;\n         background: black;\n      -  color: white;\n      +  color: #fff;\n       }\n       a {\n      -  color: blue\n      +  color: blue;\n       }\n      +\n      +foo {\n      +  bar: 'baz';\n      +}\n\n// DIFF\n       {\n         \"age\": 2\n      -  \"color\": \"white\"\n      -  \"name\": \"tobi\"\n      +  \"color\": \"brown\"\n      +  \"name\": \"loki\"\n         \"species\": \"ferret\"\n       }\n\n// DIFF\n       {\n         \"a\": 123\n      +  \"b\": 456\n       }\n\n// DIFF\n       [\n      -  1\n      +  2\n       ]"}
{"prompt":"overspecified asynchronous resolution method, function  {","test":"'use strict';\n\ndescribe('overspecified asynchronous resolution method', function () {\n  it('should fail when multiple methods are used', function (done) {\n    setTimeout(done, 0);\n\n    // uncomment\n    // return { then: function() {} };\n  });\n});"}
{"prompt":"Test generated from existing file","test":"{ \"type\": \"module\" }"}
{"prompt":"parallel-buffered-runner, function  {","test":"'use strict';\n\nconst {\n  EVENT_RUN_BEGIN,\n  EVENT_TEST_PASS,\n  EVENT_TEST_FAIL,\n  EVENT_SUITE_END,\n  EVENT_SUITE_BEGIN\n} = require('../../lib/runner').constants;\nconst rewiremock = require('rewiremock/node');\nconst Suite = require('../../lib/suite');\nconst Runner = require('../../lib/runner');\nconst sinon = require('sinon');\nconst {constants} = require('../../lib/utils');\nconst {MOCHA_ID_PROP_NAME} = constants;\n\ndescribe('parallel-buffered-runner', function () {\n  describe('ParallelBufferedRunner', function () {\n    let run;\n    let BufferedWorkerPool;\n    let terminate;\n    let ParallelBufferedRunner;\n    let suite;\n    let warn;\n    let fatalError;\n\n    beforeEach(function () {\n      suite = new Suite('a root suite', {}, true);\n      warn = sinon.stub();\n\n      fatalError = new Error();\n\n      // tests will want to further define the behavior of these.\n      run = sinon.stub();\n      terminate = sinon.stub();\n      BufferedWorkerPool = {\n        create: sinon.stub().returns({\n          run,\n          terminate,\n          stats: sinon.stub().returns({})\n        })\n      };\n      /**\n       * @type {ParallelBufferedRunner}\n       */\n      ParallelBufferedRunner = rewiremock.proxy(\n        () => require('../../lib/nodejs/parallel-buffered-runner'),\n        r => ({\n          '../../lib/nodejs/buffered-worker-pool': {\n            BufferedWorkerPool\n          },\n          '../../lib/utils': r.with({warn}).callThrough(),\n          '../../lib/errors': r\n            .with({\n              createFatalError: sinon.stub().returns(fatalError)\n            })\n            .callThrough()\n        })\n      );\n    });\n\n    describe('constructor', function () {\n      it('should start in \"IDLE\" state', function () {\n        expect(\n          new ParallelBufferedRunner(suite),\n          'to have property',\n          '_state',\n          'IDLE'\n        );\n      });\n    });\n\n    describe('instance property', function () {\n      let runner;\n\n      beforeEach(function () {\n        runner = new ParallelBufferedRunner(suite);\n      });\n\n      describe('_state', function () {\n        it('should disallow an invalid state transition', function () {\n          expect(\n            () => {\n              runner._state = 'BAILED';\n            },\n            'to throw',\n            /invalid state transition/\n          );\n        });\n      });\n    });\n\n    describe('event', function () {\n      let runner;\n\n      beforeEach(function () {\n        runner = new ParallelBufferedRunner(suite);\n      });\n\n      describe('EVENT_RUN_END', function () {\n        it('should change the state to COMPLETE', function () {\n          runner._state = 'RUNNING';\n          runner.emit(Runner.constants.EVENT_RUN_END);\n          expect(runner._state, 'to be', 'COMPLETE');\n        });\n      });\n    });\n\n    describe('instance method', function () {\n      describe('run()', function () {\n        let runner;\n\n        beforeEach(function () {\n          runner = new ParallelBufferedRunner(suite);\n        });\n\n        // the purpose of this is to ensure that--despite using `Promise`s\n        // internally--`BufferedRunner#run` does not return a `Promise`.\n        it('should be chainable', function (done) {\n          expect(runner.run(done, {files: [], options: {}}), 'to be', runner);\n        });\n\n        it('should emit `EVENT_RUN_BEGIN`', async function () {\n          return expect(\n            () =>\n              new Promise(resolve => {\n                runner.run(resolve, {files: [], options: {}});\n              }),\n            'to emit from',\n            runner,\n            EVENT_RUN_BEGIN\n          );\n        });\n\n        describe('when instructed to link objects', function () {\n          beforeEach(function () {\n            runner._linkPartialObjects = true;\n          });\n\n          it('should create object references', function () {\n            const options = {reporter: runner._workerReporter};\n            const someSuite = {\n              title: 'some suite',\n              [MOCHA_ID_PROP_NAME]: 'bar'\n            };\n\n            run.withArgs('some-file.js', options).resolves({\n              failureCount: 0,\n              events: [\n                {\n                  eventName: EVENT_SUITE_END,\n                  data: someSuite\n                },\n                {\n                  eventName: EVENT_TEST_PASS,\n                  data: {\n                    title: 'some test',\n                    [MOCHA_ID_PROP_NAME]: 'foo',\n                    parent: {\n                      // this stub object points to someSuite with id 'bar'\n                      [MOCHA_ID_PROP_NAME]: 'bar'\n                    }\n                  }\n                },\n                {\n                  eventName: EVENT_SUITE_END,\n                  // ensure we are not passing the _same_ someSuite,\n                  // because we won't get the same one from the subprocess\n                  data: {...someSuite}\n                }\n              ]\n            });\n\n            return expect(\n              () =>\n                new Promise(resolve => {\n                  runner.run(resolve, {files: ['some-file.js'], options: {}});\n                }),\n              'to emit from',\n              runner,\n              EVENT_TEST_PASS,\n              {\n                title: 'some test',\n                [MOCHA_ID_PROP_NAME]: 'foo',\n                parent: expect\n                  .it('to be', someSuite)\n                  .and('to have property', 'title', 'some suite')\n              }\n            );\n          });\n\n          describe('when event data object is missing an ID', function () {\n            it('should result in an uncaught exception', function (done) {\n              const options = {reporter: runner._workerReporter};\n              sinon.spy(runner, 'uncaught');\n              const someSuite = {\n                title: 'some suite',\n                [MOCHA_ID_PROP_NAME]: 'bar'\n              };\n\n              run.withArgs('some-file.js', options).resolves({\n                failureCount: 0,\n                events: [\n                  {\n                    eventName: EVENT_SUITE_END,\n                    data: someSuite\n                  },\n                  {\n                    eventName: EVENT_TEST_PASS,\n                    data: {\n                      title: 'some test',\n                      // note missing ID right here\n                      parent: {\n                        // this stub object points to someSuite with id 'bar'\n                        [MOCHA_ID_PROP_NAME]: 'bar'\n                      }\n                    }\n                  },\n                  {\n                    eventName: EVENT_SUITE_END,\n                    // ensure we are not passing the _same_ someSuite,\n                    // because we won't get the same one from the subprocess\n                    data: {...someSuite}\n                  }\n                ]\n              });\n\n              runner.run(\n                () => {\n                  expect(runner.uncaught, 'to have a call satisfying', [\n                    fatalError\n                  ]);\n                  done();\n                },\n                {files: ['some-file.js'], options: {}}\n              );\n            });\n          });\n        });\n\n        describe('when a worker fails', function () {\n          it('should recover', function (done) {\n            const options = {reporter: runner._workerReporter};\n            run.withArgs('some-file.js', options).rejects(new Error('whoops'));\n            run.withArgs('some-other-file.js', options).resolves({\n              failureCount: 0,\n              events: [\n                {\n                  eventName: EVENT_TEST_PASS,\n                  data: {\n                    title: 'some test'\n                  }\n                },\n                {\n                  eventName: EVENT_SUITE_END,\n                  data: {\n                    title: 'some suite'\n                  }\n                }\n              ]\n            });\n\n            runner.run(\n              () => {\n                expect(terminate, 'to have calls satisfying', [{args: []}]);\n                done();\n              },\n              {\n                files: ['some-file.js', 'some-other-file.js'],\n                options\n              }\n            );\n          });\n\n          it('should delegate to Runner#uncaught', function (done) {\n            const options = {reporter: runner._workerReporter};\n            sinon.spy(runner, 'uncaught');\n            const err = new Error('whoops');\n            run.withArgs('some-file.js', options).rejects(new Error('whoops'));\n            run.withArgs('some-other-file.js', options).resolves({\n              failureCount: 0,\n              events: [\n                {\n                  eventName: EVENT_TEST_PASS,\n                  data: {\n                    title: 'some test'\n                  }\n                },\n                {\n                  eventName: EVENT_SUITE_END,\n                  data: {\n                    title: 'some suite'\n                  }\n                }\n              ]\n            });\n\n            runner.run(\n              () => {\n                expect(runner.uncaught, 'to have a call satisfying', [err]);\n                done();\n              },\n              {\n                files: ['some-file.js', 'some-other-file.js'],\n                options\n              }\n            );\n          });\n        });\n\n        describe('when suite should bail', function () {\n          describe('when no event contains an error', function () {\n            it('should not force-terminate', function (done) {\n              run.resolves({\n                failureCount: 0,\n                events: [\n                  {\n                    eventName: EVENT_SUITE_BEGIN,\n                    data: {\n                      title: 'some suite',\n                      _bail: true\n                    }\n                  },\n                  {\n                    eventName: EVENT_TEST_PASS,\n                    data: {\n                      title: 'some test'\n                    }\n                  },\n                  {\n                    eventName: EVENT_SUITE_END,\n                    data: {\n                      title: 'some suite',\n                      _bail: true\n                    }\n                  }\n                ]\n              });\n\n              runner.run(\n                () => {\n                  expect(terminate, 'to have a call satisfying', {\n                    args: []\n                  }).and('was called once');\n                  done();\n                },\n                {\n                  files: ['some-file.js', 'some-other-file.js'],\n                  options: {}\n                }\n              );\n            });\n          });\n\n          describe('when an event contains an error and has positive failures', function () {\n            describe('when subsequent files have not yet been run', function () {\n              it('should cleanly terminate the thread pool', function (done) {\n                const options = {reporter: runner._workerReporter};\n                const err = {\n                  __type: 'Error',\n                  message: 'oh no'\n                };\n                run.withArgs('some-file.js', options).resolves({\n                  failureCount: 1,\n                  events: [\n                    {\n                      eventName: EVENT_SUITE_BEGIN,\n                      data: {\n                        title: 'some suite',\n                        _bail: true\n                      }\n                    },\n                    {\n                      eventName: EVENT_TEST_FAIL,\n                      data: {\n                        title: 'some test'\n                      },\n                      error: err\n                    },\n                    {\n                      eventName: EVENT_SUITE_END,\n                      data: {\n                        title: 'some suite',\n                        _bail: true\n                      }\n                    }\n                  ]\n                });\n                run.withArgs('some-other-file.js', options).rejects();\n\n                runner.run(\n                  () => {\n                    expect(terminate, 'to have calls satisfying', [\n                      {args: []}, // this is the pool force-terminating\n                      {args: []} // this will always be called, and will do nothing due to the previous call\n                    ]).and('was called twice');\n                    done();\n                  },\n                  {\n                    files: ['some-file.js', 'some-other-file.js'],\n                    options\n                  }\n                );\n              });\n            });\n\n            describe('when subsequent files already started running', function () {\n              it('should cleanly terminate the thread pool', function (done) {\n                const options = {reporter: runner._workerReporter};\n                const err = {\n                  __type: 'Error',\n                  message: 'oh no'\n                };\n                run.withArgs('some-file.js', options).resolves({\n                  failureCount: 1,\n                  events: [\n                    {\n                      eventName: EVENT_SUITE_BEGIN,\n                      data: {\n                        title: 'some suite',\n                        _bail: true\n                      }\n                    },\n                    {\n                      eventName: EVENT_TEST_FAIL,\n                      data: {\n                        title: 'some test'\n                      },\n                      error: err\n                    },\n                    {\n                      eventName: EVENT_SUITE_END,\n                      data: {\n                        title: 'some suite',\n                        _bail: true\n                      }\n                    }\n                  ]\n                });\n                run.withArgs('some-other-file.js', options).resolves({\n                  failureCount: 0,\n                  events: [\n                    {\n                      eventName: EVENT_SUITE_BEGIN,\n                      data: {\n                        title: 'some suite'\n                      }\n                    },\n                    {\n                      eventName: EVENT_TEST_PASS,\n                      data: {\n                        title: 'some test'\n                      }\n                    },\n                    {\n                      eventName: EVENT_SUITE_END,\n                      data: {\n                        title: 'some suite'\n                      }\n                    }\n                  ]\n                });\n\n                runner.run(\n                  () => {\n                    expect(terminate, 'to have calls satisfying', [\n                      {args: []}, // this is the pool force-terminating\n                      {args: []} // this will always be called, and will do nothing due to the previous call\n                    ]).and('was called twice');\n                    done();\n                  },\n                  {\n                    files: ['some-file.js', 'some-other-file.js'],\n                    options\n                  }\n                );\n              });\n            });\n          });\n        });\n\n        describe('when a suite has a bail flag', function () {\n          describe('when no event contains an error', function () {\n            it('should not force-terminate', function (done) {\n              run.resolves({\n                failureCount: 0,\n                events: [\n                  {\n                    eventName: EVENT_TEST_PASS,\n                    data: {\n                      title: 'some test'\n                    }\n                  },\n                  {\n                    eventName: EVENT_SUITE_END,\n                    data: {\n                      title: 'some suite',\n                      _bail: true\n                    }\n                  }\n                ]\n              });\n\n              runner.run(\n                () => {\n                  expect(terminate, 'to have a call satisfying', {\n                    args: []\n                  }).and('was called once');\n                  done();\n                },\n                {\n                  files: ['some-file.js', 'some-other-file.js'],\n                  options: {}\n                }\n              );\n            });\n          });\n\n          describe('when an event contains an error and has positive failures', function () {\n            describe('when subsequent files have not yet been run', function () {\n              it('should cleanly terminate the thread pool', function (done) {\n                const options = {reporter: runner._workerReporter};\n                const err = {\n                  __type: 'Error',\n                  message: 'oh no'\n                };\n                run.withArgs('some-file.js', options).resolves({\n                  failureCount: 1,\n                  events: [\n                    {\n                      eventName: EVENT_TEST_FAIL,\n                      data: {\n                        title: 'some test'\n                      },\n                      error: err\n                    },\n                    {\n                      eventName: EVENT_SUITE_END,\n                      data: {\n                        title: 'some suite',\n                        _bail: true\n                      }\n                    }\n                  ]\n                });\n                run.withArgs('some-other-file.js', options).rejects();\n\n                runner.run(\n                  () => {\n                    expect(terminate, 'to have calls satisfying', [\n                      {args: []}, // this is the pool force-terminating\n                      {args: []} // this will always be called, and will do nothing due to the previous call\n                    ]).and('was called twice');\n                    done();\n                  },\n                  {\n                    files: ['some-file.js', 'some-other-file.js'],\n                    options\n                  }\n                );\n              });\n            });\n\n            describe('when subsequent files already started running', function () {\n              it('should cleanly terminate the thread pool', function (done) {\n                const options = {reporter: runner._workerReporter};\n                const err = {\n                  __type: 'Error',\n                  message: 'oh no'\n                };\n                run.withArgs('some-file.js', options).resolves({\n                  failureCount: 1,\n                  events: [\n                    {\n                      eventName: EVENT_TEST_FAIL,\n                      data: {\n                        title: 'some test'\n                      },\n                      error: err\n                    },\n                    {\n                      eventName: EVENT_SUITE_END,\n                      data: {\n                        title: 'some suite',\n                        _bail: true\n                      }\n                    }\n                  ]\n                });\n                run.withArgs('some-other-file.js', options).resolves({\n                  failureCount: 0,\n                  events: [\n                    {\n                      eventName: EVENT_TEST_PASS,\n                      data: {\n                        title: 'some test'\n                      }\n                    },\n                    {\n                      eventName: EVENT_SUITE_END,\n                      data: {\n                        title: 'some suite'\n                      }\n                    }\n                  ]\n                });\n\n                runner.run(\n                  () => {\n                    expect(terminate, 'to have calls satisfying', [\n                      {args: []}, // this is the pool force-terminating\n                      {args: []} // this will always be called, and will do nothing due to the previous call\n                    ]).and('was called twice');\n                    done();\n                  },\n                  {\n                    files: ['some-file.js', 'some-other-file.js'],\n                    options\n                  }\n                );\n              });\n            });\n\n            describe('when subsequent files have not yet been run', function () {\n              it('should cleanly terminate the thread pool', function (done) {\n                const options = {reporter: runner._workerReporter};\n                const err = {\n                  __type: 'Error',\n                  message: 'oh no'\n                };\n                run.withArgs('some-file.js', options).resolves({\n                  failureCount: 1,\n                  events: [\n                    {\n                      eventName: EVENT_TEST_FAIL,\n                      data: {\n                        title: 'some test'\n                      },\n                      error: err\n                    },\n                    {\n                      eventName: EVENT_SUITE_END,\n                      data: {\n                        title: 'some suite',\n                        _bail: true\n                      }\n                    }\n                  ]\n                });\n                run.withArgs('some-other-file.js', options).rejects();\n\n                runner.run(\n                  () => {\n                    expect(terminate, 'to have calls satisfying', [\n                      {args: []}, // this is the pool force-terminating\n                      {args: []} // this will always be called, and will do nothing due to the previous call\n                    ]).and('was called twice');\n                    done();\n                  },\n                  {\n                    files: ['some-file.js', 'some-other-file.js'],\n                    options\n                  }\n                );\n              });\n            });\n          });\n        });\n      });\n\n      describe('linkPartialObjects()', function () {\n        let runner;\n\n        beforeEach(function () {\n          runner = new ParallelBufferedRunner(suite);\n        });\n\n        it('should return the runner', function () {\n          expect(runner.linkPartialObjects(), 'to be', runner);\n        });\n\n        // avoid testing implementation details; don't check _linkPartialObjects\n      });\n\n      describe('isParallelMode()', function () {\n        let runner;\n\n        beforeEach(function () {\n          runner = new ParallelBufferedRunner(suite);\n        });\n\n        it('should return true', function () {\n          expect(runner.isParallelMode(), 'to be true');\n        });\n      });\n\n      describe('workerReporter()', function () {\n        let runner;\n\n        beforeEach(function () {\n          runner = new ParallelBufferedRunner(suite);\n        });\n\n        it('should return its context', function () {\n          expect(runner.workerReporter(), 'to be', runner);\n        });\n      });\n    });\n  });\n});"}
{"prompt":"this reporter does not actually output anything to the terminal, so we","test":"'use strict';\n\n// this reporter does not actually output anything to the terminal, so we\n// need to test it differently.\n\nconst {\n  EVENT_SUITE_BEGIN,\n  EVENT_SUITE_END,\n  EVENT_TEST_FAIL,\n  EVENT_TEST_PASS,\n  EVENT_TEST_PENDING,\n  EVENT_TEST_BEGIN,\n  EVENT_TEST_END,\n  EVENT_TEST_RETRY,\n  EVENT_DELAY_BEGIN,\n  EVENT_DELAY_END,\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_RUN_END\n} = require('../../../lib/runner').constants;\nconst {EventEmitter} = require('node:events');\nconst sinon = require('sinon');\nconst rewiremock = require('rewiremock/node');\n\ndescribe('ParallelBuffered', function () {\n  let runner;\n  let ParallelBuffered;\n\n  beforeEach(function () {\n    runner = new EventEmitter();\n    ParallelBuffered = rewiremock.proxy(\n      () => require('../../../lib/nodejs/reporters/parallel-buffered'),\n      {\n        '../../../lib/nodejs/serializer': {\n          SerializableEvent: {\n            create: (eventName, runnable, err) => ({\n              eventName,\n              data: runnable,\n              error: err,\n              __type: 'MockSerializableEvent'\n            })\n          },\n          SerializableWorkerResult: {\n            create: (events, failures) => ({\n              events,\n              failures,\n              __type: 'MockSerializableWorkerResult'\n            })\n          }\n        },\n        '../../../lib/reporters/base': class MockBase {}\n      }\n    );\n  });\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('constructor', function () {\n    it('should listen for Runner events', function () {\n      // EventEmitter#once calls thru to EventEmitter#on, which\n      // befouls our assertion below.\n      sinon.stub(runner, 'once');\n      sinon.stub(runner, 'on');\n      // eslint-disable-next-line no-new\n      new ParallelBuffered(runner);\n      expect(runner.on, 'to have calls satisfying', [\n        // via Buffered\n        [EVENT_SUITE_BEGIN, expect.it('to be a function')],\n        [EVENT_SUITE_END, expect.it('to be a function')],\n        [EVENT_TEST_BEGIN, expect.it('to be a function')],\n        [EVENT_TEST_PENDING, expect.it('to be a function')],\n        [EVENT_TEST_FAIL, expect.it('to be a function')],\n        [EVENT_TEST_PASS, expect.it('to be a function')],\n        [EVENT_TEST_RETRY, expect.it('to be a function')],\n        [EVENT_TEST_END, expect.it('to be a function')],\n        [EVENT_HOOK_BEGIN, expect.it('to be a function')],\n        [EVENT_HOOK_END, expect.it('to be a function')]\n      ]);\n    });\n\n    it('should listen for Runner events expecting to occur once', function () {\n      sinon.stub(runner, 'once');\n      // eslint-disable-next-line no-new\n      new ParallelBuffered(runner);\n      expect(runner.once, 'to have calls satisfying', [\n        [EVENT_DELAY_BEGIN, expect.it('to be a function')],\n        [EVENT_DELAY_END, expect.it('to be a function')],\n        [EVENT_RUN_END, expect.it('to be a function')]\n      ]);\n    });\n  });\n\n  describe('event', function () {\n    let reporter;\n\n    beforeEach(function () {\n      reporter = new ParallelBuffered(runner);\n    });\n\n    describe('on EVENT_RUN_END', function () {\n      it('should remove all listeners', function () {\n        runner.emit(EVENT_RUN_END);\n        expect(runner.listeners(), 'to be empty');\n      });\n    });\n\n    describe('on any other event listened for', function () {\n      it('should populate its `events` array with SerializableEvents', function () {\n        const suite = {\n          title: 'some suite'\n        };\n        const test = {\n          title: 'some test'\n        };\n        runner.emit(EVENT_SUITE_BEGIN, suite);\n        runner.emit(EVENT_TEST_BEGIN, test);\n        runner.emit(EVENT_TEST_PASS, test);\n        runner.emit(EVENT_TEST_END, test);\n        runner.emit(EVENT_SUITE_END, suite);\n        expect(reporter.events, 'to equal', [\n          {\n            eventName: EVENT_SUITE_BEGIN,\n            data: suite,\n            __type: 'MockSerializableEvent'\n          },\n          {\n            eventName: EVENT_TEST_BEGIN,\n            data: test,\n            __type: 'MockSerializableEvent'\n          },\n          {\n            eventName: EVENT_TEST_PASS,\n            data: test,\n            __type: 'MockSerializableEvent'\n          },\n          {\n            eventName: EVENT_TEST_END,\n            data: test,\n            __type: 'MockSerializableEvent'\n          },\n          {\n            eventName: EVENT_SUITE_END,\n            data: suite,\n            __type: 'MockSerializableEvent'\n          }\n        ]);\n      });\n    });\n  });\n\n  describe('instance method', function () {\n    let reporter;\n\n    beforeEach(function () {\n      reporter = new ParallelBuffered(runner);\n    });\n\n    describe('done', function () {\n      it('should execute its callback with a SerializableWorkerResult', function () {\n        const suite = {\n          title: 'some suite'\n        };\n        const test = {\n          title: 'some test'\n        };\n        runner.emit(EVENT_SUITE_BEGIN, suite);\n        runner.emit(EVENT_TEST_BEGIN, test);\n        runner.emit(EVENT_TEST_PASS, test);\n        runner.emit(EVENT_TEST_END, test);\n        runner.emit(EVENT_SUITE_END, suite);\n        const cb = sinon.stub();\n        reporter.done(0, cb);\n        expect(cb, 'to have a call satisfying', [\n          {\n            events: [\n              {\n                eventName: EVENT_SUITE_BEGIN,\n                data: suite,\n                __type: 'MockSerializableEvent'\n              },\n              {\n                eventName: EVENT_TEST_BEGIN,\n                data: test,\n                __type: 'MockSerializableEvent'\n              },\n              {\n                eventName: EVENT_TEST_PASS,\n                data: test,\n                __type: 'MockSerializableEvent'\n              },\n              {\n                eventName: EVENT_TEST_END,\n                data: test,\n                __type: 'MockSerializableEvent'\n              },\n              {\n                eventName: EVENT_SUITE_END,\n                data: suite,\n                __type: 'MockSerializableEvent'\n              }\n            ],\n            failures: 0,\n            __type: 'MockSerializableWorkerResult'\n          }\n        ]);\n      });\n\n      it('should reset its `events` prop', function () {\n        const suite = {\n          title: 'some suite'\n        };\n        const test = {\n          title: 'some test'\n        };\n        runner.emit(EVENT_SUITE_BEGIN, suite);\n        runner.emit(EVENT_TEST_BEGIN, test);\n        runner.emit(EVENT_TEST_PASS, test);\n        runner.emit(EVENT_TEST_END, test);\n        runner.emit(EVENT_SUITE_END, suite);\n        const cb = sinon.stub();\n        reporter.done(0, cb);\n        expect(reporter.events, 'to be empty');\n      });\n    });\n  });\n});"}
{"prompt":"parallel run,  => {","test":"'use strict';\n\nconst assert = require('node:assert');\nconst {runMochaJSONAsync} = require('./helpers');\n\ndescribe('parallel run', () => {\n  /**\n   * @see https://github.com/mochajs/mocha/issues/4559\n   */\n  it('should allow `import {it} from \"mocha\"` module syntax', async () => {\n    const result = await runMochaJSONAsync('parallel/test3.mjs', [\n      '--parallel',\n      '--jobs',\n      '2',\n      require.resolve('./fixtures/parallel/test1.mjs'),\n      require.resolve('./fixtures/parallel/test2.mjs')\n    ]);\n    assert.strictEqual(result.stats.failures, 1);\n    assert.strictEqual(result.stats.passes, 2);\n  });\n\n  it('should correctly set worker ids for each process', async () => {\n    const result = await runMochaJSONAsync('parallel/testworkerid3.mjs', [\n      '--parallel',\n      '--jobs',\n      '2',\n      require.resolve('./fixtures/parallel/testworkerid1.mjs'),\n      require.resolve('./fixtures/parallel/testworkerid2.mjs')\n    ]);\n    assert.strictEqual(result.stats.failures, 0);\n    assert.strictEqual(result.stats.passes, 3);\n  });\n\n  it('should correctly handle circular array references in an exception', async () => {\n    const result = await runMochaJSONAsync('parallel/circular-error-array.mjs', [\n      '--parallel',\n      '--jobs',\n      '2',\n      require.resolve('./fixtures/parallel/testworkerid1.mjs')\n    ]);\n    assert.strictEqual(result.stats.failures, 1);\n    assert.strictEqual(result.stats.passes, 1);\n    assert.strictEqual(result.failures[0].err.message, 'Foo');\n    assert.strictEqual(result.failures[0].err.foo.props[0], '[Circular]');\n  });\n\n  it('should correctly handle an exception with retries', async () => {\n    const result = await runMochaJSONAsync('parallel/circular-error-array.mjs', [\n      '--parallel',\n      '--jobs',\n      '2',\n      '--retries',\n      '1',\n      require.resolve('./fixtures/parallel/testworkerid1.mjs')\n    ]);\n    assert.strictEqual(result.stats.failures, 1);\n    assert.strictEqual(result.stats.passes, 1);\n    assert.strictEqual(result.failures[0].err.message, 'Foo');\n    assert.strictEqual(result.failures[0].err.foo.props[0], '[Circular]');\n  });\n\n  it('should correctly handle circular object references in an exception', async () => {\n    const result = await runMochaJSONAsync('parallel/circular-error-object.mjs', [\n      '--parallel',\n      '--jobs',\n      '2',\n      require.resolve('./fixtures/parallel/testworkerid1.mjs')\n    ]);\n    assert.strictEqual(result.stats.failures, 1);\n    assert.strictEqual(result.stats.passes, 1);\n    assert.strictEqual(result.failures[0].err.message, 'Oh no!');\n    assert.deepStrictEqual(result.failures[0].err.values, [ { toB: { toA: '[Circular]' } } ]);\n  });\n\n  it('should correctly handle a non-writable getter reference in an exception', async () => {\n    const result = await runMochaJSONAsync('parallel/getter-error-object.mjs', [\n      '--parallel',\n      '--jobs',\n      '2',\n      require.resolve('./fixtures/parallel/testworkerid1.mjs')\n    ]);\n    assert.strictEqual(result.stats.failures, 1);\n    assert.strictEqual(result.stats.passes, 1);\n    assert.strictEqual(result.failures[0].err.message, 'Oh no!');\n  });\n});"}
{"prompt":"parseQuery, function  {","test":"'use strict';\n\nvar parseQuery = require('../../lib/browser/parse-query');\n\ndescribe('parseQuery()', function () {\n  it('should get queryString and return key-value object', function () {\n    expect(parseQuery('?foo=1&bar=2&baz=3'), 'to equal', {\n      foo: '1',\n      bar: '2',\n      baz: '3'\n    });\n\n    expect(parseQuery('?r1=^@(?!.*\\\\)$)&r2=m{2}&r3=^co.*'), 'to equal', {\n      r1: '^@(?!.*\\\\)$)',\n      r2: 'm{2}',\n      r3: '^co.*'\n    });\n  });\n\n  it('should parse \"+\" as a space', function () {\n    expect(parseQuery('?grep=foo+bar'), 'to equal', {grep: 'foo bar'});\n  });\n});"}
{"prompt":"ignore test pass, function  {","test":"'use strict';\n\ndescribe('ignore test pass', function () {\n  it('should find this test', function () {});\n});"}
{"prompt":"forbid pending - all test pass, function {","test":"'use strict';\n\ndescribe('forbid pending - all test pass', function() {\n  it('test1', function() {});\n  it('test2', function() {});\n  it('test3', function() {});\n});"}
{"prompt":"a suite, function {","test":"'use strict';\n\ndescribe('a suite', function() {\n  it('should succeed in 50ms', function(done) {\n    setTimeout(done, 50);\n  });\n});"}
{"prompt":"a suite, function {","test":"'use strict';\n\ndescribe('a suite', function() {\n  it('should succeed', function() {\n  });\n});"}
{"prompt":"suite, function  {","test":"'use strict';\n\nvar assert = require('assert');\n\ndescribe('suite', function () {\n  it('test1', function () {\n    assert(true);\n  });\n\n  it('test2', function () {\n    assert(true);\n  });\n});"}
{"prompt":"Enabled --pass-on-failing-test-suite, function {","test":"'use strict';\n\nvar helpers = require('../helpers');\nvar runMochaJSON = helpers.runMochaJSON;\n\ndescribe('Enabled --pass-on-failing-test-suite', function() {\n  var args = ['--pass-on-failing-test-suite=true'];\n\n  it('Test should finish with zero code with disabled option', function(done) {\n    var fixture = 'failing-sync.fixture.js';\n    runMochaJSON(fixture, args, function(err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have passed test count', 0)\n        .and('to have test count', 1)\n        .and('to have exit code', 0);\n      done();\n    });\n  });\n});\n\ndescribe('Disabled --pass-on-failing-test-suite', function() {\n  var args = ['--pass-on-failing-test-suite=false'];\n\n  it('Test should return non-zero code with enabled option', function(done) {\n    var fixture = 'failing-sync.fixture.js';\n    runMochaJSON(fixture, args, function(err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have passed test count', 0)\n        .and('to have test count', 1)\n        .and('to have exit code', 1);\n      done();\n    });\n  });\n});"}
{"prompt":"Uncaught exception within pending test,  => {","test":"'use strict';\n\ndescribe('Uncaught exception within pending test', () => {\n  it('test1', function () { });\n\n  it('test2', function () {\n    process.nextTick(function () {\n      throw new Error('I am uncaught!');\n    });\n    this.skip();\n  });\n\n  it('test3 - should run', function () { });\n  it('test4 - should run', function () { });\n});"}
{"prompt":"pending, function  {","test":"'use strict';\n\nvar assert = require('node:assert');\nvar helpers = require('./helpers');\nvar run = helpers.runMochaJSON;\nvar invokeNode = helpers.invokeNode;\nvar toJSONResult = helpers.toJSONResult;\nvar args = [];\n\ndescribe('pending', function () {\n  describe('pending specs', function () {\n    it('should be created by omitting a function', function (done) {\n      run('pending/spec.fixture.js', args, function (err, res) {\n        if (err) {\n          done(err);\n          return;\n        }\n        assert.strictEqual(res.stats.pending, 1);\n        assert.strictEqual(res.stats.passes, 0);\n        assert.strictEqual(res.stats.failures, 0);\n        assert.strictEqual(res.code, 0);\n        done();\n      });\n    });\n    it('should return the test object when used via shorthand methods', function (done) {\n      run('pending/skip-shorthand.fixture.js', args, function (err, res) {\n        if (err) {\n          done(err);\n          return;\n        }\n        assert.strictEqual(res.stats.pending, 3);\n        assert.strictEqual(res.stats.passes, 0);\n        assert.strictEqual(res.stats.failures, 0);\n        assert.strictEqual(res.code, 0);\n        done();\n      });\n    });\n    it('should keep hierarchies of suites', function (done) {\n      run('pending/skip-hierarchy.fixture.js', args, function (err, res) {\n        if (err) {\n          done(err);\n          return;\n        }\n        assert.strictEqual(res.stats.suites, 2);\n        assert.strictEqual(res.stats.pending, 0);\n        assert.strictEqual(res.stats.passes, 1);\n        assert.strictEqual(res.stats.failures, 0);\n        assert.strictEqual(res.code, 0);\n        assert.strictEqual(\n          res.passes[0].fullTitle,\n          'a suite another suite a test'\n        );\n        done();\n      });\n    });\n  });\n\n  describe('synchronous skip()', function () {\n    describe('in spec', function () {\n      it('should immediately skip the spec and run all others', function (done) {\n        run('pending/skip-sync-spec.fixture.js', args, function (err, res) {\n          if (err) {\n            return done(err);\n          }\n          expect(res, 'to have failed with error', 'should throw this error')\n            .and('to have failed test count', 1)\n            .and('to have pending test count', 1)\n            .and('to have pending test order', 'should skip immediately')\n            .and('to have passed test count', 1)\n            .and('to have passed tests', 'should run other tests in suite');\n          done();\n        });\n      });\n    });\n\n    describe('in after', function () {\n      it('should throw, but run all tests', function (done) {\n        run('pending/skip-sync-after.fixture.js', args, function (err, res) {\n          if (err) {\n            return done(err);\n          }\n          expect(res, 'to have failed with error', '`this.skip` forbidden')\n            .and('to have failed test count', 1)\n            .and('to have pending test count', 0)\n            .and('to have passed test count', 3)\n            .and(\n              'to have passed test order',\n              'should run this test-1',\n              'should run this test-2',\n              'should run this test-3'\n            );\n          done();\n        });\n      });\n    });\n\n    describe('in before', function () {\n      it('should skip all suite specs', function (done) {\n        run('pending/skip-sync-before.fixture.js', args, function (err, res) {\n          if (err) {\n            done(err);\n            return;\n          }\n          assert.strictEqual(res.stats.pending, 2);\n          assert.strictEqual(res.stats.passes, 2);\n          assert.strictEqual(res.stats.failures, 0);\n          assert.strictEqual(res.code, 0);\n          done();\n        });\n      });\n      it('should run before and after hooks', function (done) {\n        run('pending/skip-sync-before-hooks.fixture.js', function (err, res) {\n          if (err) {\n            return done(err);\n          }\n          expect(res, 'to have failed with error', 'should throw this error')\n            .and('to have failed test count', 1)\n            .and('to have pending test count', 2)\n            .and('to have passed test count', 2)\n            .and(\n              'to have passed test order',\n              'should run test-1',\n              'should run test-2'\n            );\n          done();\n        });\n      });\n      it('should skip all sync/async inner before/after hooks', function (done) {\n        run('pending/skip-sync-before-inner.fixture.js', function (err, res) {\n          if (err) {\n            return done(err);\n          }\n          expect(res, 'to have failed with error', 'should throw this error')\n            .and('to have failed test count', 1)\n            .and('to have pending test count', 2)\n            .and('to have passed test count', 0)\n            .and(\n              'to have pending test order',\n              'should never run this outer test',\n              'should never run this inner test'\n            );\n          done();\n        });\n      });\n    });\n\n    describe('in before with nested describe', function () {\n      it('should skip all suite specs, even if nested', function (done) {\n        run(\n          'pending/skip-sync-before-nested.fixture.js',\n          args,\n          function (err, res) {\n            if (err) {\n              done(err);\n              return;\n            }\n            assert.strictEqual(res.stats.pending, 3);\n            assert.strictEqual(res.stats.passes, 0);\n            assert.strictEqual(res.stats.failures, 0);\n            assert.strictEqual(res.code, 0);\n            done();\n          }\n        );\n      });\n    });\n\n    describe('in beforeEach', function () {\n      it('should skip all suite specs', function (done) {\n        var fixture = 'pending/skip-sync-beforeEach.fixture.js';\n        run(fixture, args, function (err, res) {\n          if (err) {\n            return done(err);\n          }\n          expect(res, 'to have failed with error', 'should throw this error')\n            .and('to have failed test count', 1)\n            .and('to have pending test count', 3)\n            .and(\n              'to have pending test order',\n              'should skip this test-1',\n              'should skip this test-2',\n              'should skip this test-3'\n            )\n            .and('to have passed test count', 0);\n          done();\n        });\n      });\n      it('should skip only two suite specs', function (done) {\n        var fixture = 'pending/skip-sync-beforeEach-cond.fixture.js';\n        run(fixture, args, function (err, res) {\n          if (err) {\n            return done(err);\n          }\n          expect(res, 'to have failed with error', 'should throw this error')\n            .and('to have failed test count', 1)\n            .and('to have pending test count', 2)\n            .and(\n              'to have pending test order',\n              'should skip this test-1',\n              'should skip this test-3'\n            )\n            .and('to have passed test count', 1)\n            .and('to have passed test', 'should run this test-2');\n          done();\n        });\n      });\n    });\n  });\n\n  describe('asynchronous skip()', function () {\n    describe('in spec', function () {\n      it('should immediately skip the spec and run all others', function (done) {\n        run('pending/skip-async-spec.fixture.js', args, function (err, res) {\n          if (err) {\n            return done(err);\n          }\n          expect(res, 'to have failed with error', 'should throw this error')\n            .and('to have failed test count', 1)\n            .and('to have pending test count', 1)\n            .and('to have pending test order', 'should skip async')\n            .and('to have passed test count', 1)\n            .and('to have passed tests', 'should run other tests in suite');\n          done();\n        });\n      });\n    });\n\n    describe('in before', function () {\n      it('should skip all suite specs', function (done) {\n        run('pending/skip-async-before.fixture.js', args, function (err, res) {\n          if (err) {\n            done(err);\n            return;\n          }\n          assert.strictEqual(res.stats.pending, 2);\n          assert.strictEqual(res.stats.passes, 2);\n          assert.strictEqual(res.stats.failures, 0);\n          assert.strictEqual(res.code, 0);\n          done();\n        });\n      });\n      it('should run before and after hooks', function (done) {\n        run('pending/skip-async-before-hooks.fixture.js', function (err, res) {\n          if (err) {\n            return done(err);\n          }\n          expect(res, 'to have failed with error', 'should throw this error')\n            .and('to have failed test count', 1)\n            .and('to have pending test count', 2)\n            .and('to have passed test count', 2)\n            .and(\n              'to have passed test order',\n              'should run test-1',\n              'should run test-2'\n            );\n          done();\n        });\n      });\n    });\n\n    describe('in before with nested describe', function () {\n      it('should skip all suite specs, even if nested', function (done) {\n        run(\n          'pending/skip-async-before-nested.fixture.js',\n          args,\n          function (err, res) {\n            if (err) {\n              done(err);\n              return;\n            }\n            assert.strictEqual(res.stats.pending, 3);\n            assert.strictEqual(res.stats.passes, 0);\n            assert.strictEqual(res.stats.failures, 0);\n            assert.strictEqual(res.code, 0);\n            done();\n          }\n        );\n      });\n    });\n\n    describe('in beforeEach', function () {\n      it('should skip all suite specs', function (done) {\n        var fixture = 'pending/skip-async-beforeEach.fixture.js';\n        run(fixture, args, function (err, res) {\n          if (err) {\n            return done(err);\n          }\n          expect(res, 'to have failed with error', 'should throw this error')\n            .and('to have failed test count', 1)\n            .and('to have pending test count', 3)\n            .and(\n              'to have pending test order',\n              'should skip this test-1',\n              'should skip this test-2',\n              'should skip this test-3'\n            )\n            .and('to have passed test count', 0);\n          done();\n        });\n      });\n    });\n  });\n\n  describe('programmatic usage', function () {\n    it('should skip the test by listening to test event', function (done) {\n      var path = require.resolve('./fixtures/pending/programmatic.fixture.js');\n      invokeNode([path], function (err, res) {\n        if (err) {\n          return done(err);\n        }\n        var result = toJSONResult(res);\n        expect(result, 'to have passed')\n          .and('to have passed test count', 0)\n          .and('to have pending test count', 1)\n          .and('to have pending test order', 'should succeed');\n        done();\n      });\n    });\n  });\n});"}
{"prompt":"plugin module, function  {","test":"'use strict';\n\nconst PluginLoader = require('../../lib/plugin-loader');\nconst sinon = require('sinon');\nconst {INVALID_PLUGIN_DEFINITION, INVALID_PLUGIN_IMPLEMENTATION} =\n  require('../../lib/errors').constants;\n\ndescribe('plugin module', function () {\n  describe('class PluginLoader', function () {\n    describe('constructor', function () {\n      describe('when passed no options', function () {\n        it('should populate a registry of built-in plugins', function () {\n          expect(new PluginLoader().registered.has('mochaHooks'), 'to be true');\n        });\n      });\n\n      describe('when passed custom plugins', function () {\n        it('should register the custom plugins', function () {\n          const plugin = {exportName: 'mochaBananaPhone'};\n          expect(\n            new PluginLoader({pluginDefs: [plugin]}).registered,\n            'to satisfy',\n            new Map([['mochaBananaPhone', plugin]])\n          );\n        });\n      });\n\n      describe('when passed ignored plugins', function () {\n        it('should retain a list of ignored plugins', function () {\n          expect(\n            new PluginLoader({\n              ignore: ['elephantInRoom']\n            }).ignoredExportNames,\n            'to contain',\n            'elephantInRoom'\n          );\n        });\n      });\n    });\n\n    describe('static method', function () {\n      describe('create()', function () {\n        it('should return a PluginLoader instance', function () {\n          expect(PluginLoader.create(), 'to be a', PluginLoader);\n        });\n      });\n    });\n\n    describe('instance method', function () {\n      let pluginLoader;\n\n      beforeEach(function () {\n        pluginLoader = PluginLoader.create({\n          ignore: ['elephantInRoom']\n        });\n      });\n\n      describe('register()', function () {\n        describe('when the plugin export name is not in use', function () {\n          it('should not throw', function () {\n            expect(\n              () => pluginLoader.register({exportName: 'butts'}),\n              'not to throw'\n            );\n          });\n        });\n\n        describe('when the plugin export name is already in use', function () {\n          it('should throw', function () {\n            const pluginDef = {exportName: 'butts'};\n            pluginLoader.register(pluginDef);\n            expect(() => pluginLoader.register(pluginDef), 'to throw', {\n              code: INVALID_PLUGIN_DEFINITION,\n              pluginDef\n            });\n          });\n        });\n\n        describe('when the plugin export name is ignored', function () {\n          let pluginDef;\n\n          beforeEach(function () {\n            pluginDef = {exportName: 'elephantInRoom'};\n          });\n\n          it('should not throw', function () {\n            expect(() => pluginLoader.register(pluginDef), 'not to throw');\n          });\n\n          it('should not register the plugin', function () {\n            pluginLoader.register(pluginDef);\n            expect(\n              pluginLoader.registered,\n              'not to have key',\n              'elephantInRoom'\n            );\n          });\n        });\n\n        describe('when passed a falsy parameter', function () {\n          it('should throw', function () {\n            expect(() => pluginLoader.register(), 'to throw', {\n              code: INVALID_PLUGIN_DEFINITION\n            });\n          });\n        });\n\n        describe('when passed a non-object parameter', function () {\n          it('should throw', function () {\n            expect(() => pluginLoader.register(1), 'to throw', {\n              code: INVALID_PLUGIN_DEFINITION,\n              pluginDef: 1\n            });\n          });\n        });\n\n        describe('when passed a definition w/o an exportName', function () {\n          it('should throw', function () {\n            const pluginDef = {foo: 'bar'};\n            expect(() => pluginLoader.register(pluginDef), 'to throw', {\n              code: INVALID_PLUGIN_DEFINITION,\n              pluginDef\n            });\n          });\n        });\n      });\n\n      describe('load()', function () {\n        let pluginLoader;\n\n        beforeEach(function () {\n          pluginLoader = PluginLoader.create();\n        });\n\n        describe('when called with a falsy value', function () {\n          it('should return false', function () {\n            expect(pluginLoader.load(), 'to be false');\n          });\n        });\n\n        describe('when called with an object containing no recognized plugin', function () {\n          it('should return false', function () {\n            // also it should not throw\n            expect(\n              pluginLoader.load({mochaBananaPhone: () => {}}),\n              'to be false'\n            );\n          });\n        });\n\n        describe('when called with an object containing a recognized plugin', function () {\n          let plugin;\n          let pluginLoader;\n\n          beforeEach(function () {\n            plugin = {\n              exportName: 'mochaBananaPhone',\n              validate: sinon.spy()\n            };\n            pluginLoader = PluginLoader.create({pluginDefs: [plugin]});\n          });\n\n          it('should return true', function () {\n            const func = () => {};\n            expect(pluginLoader.load({mochaBananaPhone: func}), 'to be true');\n          });\n\n          it('should retain the value of any matching property in its mapping', function () {\n            const func = () => {};\n            pluginLoader.load({mochaBananaPhone: func});\n            expect(\n              pluginLoader.loaded,\n              'to satisfy',\n              new Map([['mochaBananaPhone', [func]]])\n            );\n          });\n\n          it('should call the associated validator, if present', function () {\n            const func = () => {};\n            pluginLoader.load({mochaBananaPhone: func});\n            expect(plugin.validate, 'was called once');\n          });\n        });\n      });\n\n      describe('load()', function () {\n        let pluginLoader;\n        let fooPlugin;\n        let barPlugin;\n\n        beforeEach(function () {\n          fooPlugin = {\n            exportName: 'foo',\n            validate: sinon.stub()\n          };\n          fooPlugin.validate.withArgs('ERROR').throws();\n          barPlugin = {\n            exportName: 'bar',\n            validate: sinon.stub()\n          };\n          pluginLoader = PluginLoader.create({\n            pluginDefs: [fooPlugin, barPlugin]\n          });\n        });\n\n        describe('when passed a falsy or non-object value', function () {\n          it('should return false', function () {\n            expect(pluginLoader.load(), 'to be false');\n          });\n\n          it('should not call a validator', function () {\n            expect([fooPlugin, barPlugin], 'to have items satisfying', {\n              validate: expect.it('was not called')\n            });\n          });\n        });\n\n        describe('when passed an object value', function () {\n          describe('when no keys match any known named exports', function () {\n            let retval;\n\n            beforeEach(function () {\n              retval = pluginLoader.load({butts: () => {}});\n            });\n\n            it('should return false', function () {\n              expect(retval, 'to be false');\n            });\n          });\n\n          describe('when a key matches a known named export', function () {\n            let retval;\n            let impl;\n\n            beforeEach(function () {\n              impl = sinon.stub();\n            });\n\n            it('should call the associated validator', function () {\n              retval = pluginLoader.load({foo: impl});\n\n              expect(fooPlugin.validate, 'to have a call satisfying', [\n                impl\n              ]).and('was called once');\n            });\n\n            it('should not call validators whose keys were not found', function () {\n              retval = pluginLoader.load({foo: impl});\n              expect(barPlugin.validate, 'was not called');\n            });\n\n            describe('when the value passes the associated validator', function () {\n              beforeEach(function () {\n                retval = pluginLoader.load({foo: impl});\n              });\n\n              it('should return true', function () {\n                expect(retval, 'to be true');\n              });\n\n              it('should add the implementation to the internal mapping', function () {\n                expect(\n                  pluginLoader.loaded,\n                  'to satisfy',\n                  new Map([['foo', expect.it('to have length', 1)]])\n                );\n              });\n\n              it('should not add an implementation of plugins not present', function () {\n                expect(\n                  pluginLoader.loaded,\n                  'to satisfy',\n                  new Map([['bar', expect.it('to be empty')]])\n                );\n              });\n            });\n\n            describe('when the value does not pass the associated validator', function () {\n              it('should throw', function () {\n                expect(() => pluginLoader.load({foo: 'ERROR'}), 'to throw');\n              });\n            });\n          });\n        });\n      });\n\n      describe('finalize()', function () {\n        let pluginLoader;\n        let fooPlugin;\n        let barPlugin;\n        let bazPlugin;\n\n        beforeEach(function () {\n          fooPlugin = {\n            exportName: 'foo',\n            optionName: 'fooOption',\n            validate: sinon.stub(),\n            finalize: impls => impls.map(() => 'FOO')\n          };\n          fooPlugin.validate.withArgs('ERROR').throws();\n          barPlugin = {\n            exportName: 'bar',\n            validate: sinon.stub(),\n            finalize: impls => impls.map(() => 'BAR')\n          };\n          bazPlugin = {\n            exportName: 'baz'\n          };\n          pluginLoader = PluginLoader.create({\n            pluginDefs: [fooPlugin, barPlugin, bazPlugin]\n          });\n        });\n\n        describe('when no plugins have been loaded', function () {\n          it('should return an empty map', async function () {\n            return expect(pluginLoader.finalize(), 'to be fulfilled with', {});\n          });\n        });\n\n        describe('when a plugin has one or more implementations', function () {\n          beforeEach(function () {\n            pluginLoader.load({foo: sinon.stub()});\n            pluginLoader.load({foo: sinon.stub()});\n          });\n\n          it('should return an object map using `optionName` key for each registered plugin', async function () {\n            return expect(pluginLoader.finalize(), 'to be fulfilled with', {\n              fooOption: ['FOO', 'FOO']\n            });\n          });\n\n          it('should omit unused plugins', async function () {\n            pluginLoader.load({bar: sinon.stub()});\n            return expect(pluginLoader.finalize(), 'to be fulfilled with', {\n              fooOption: ['FOO', 'FOO'],\n              bar: ['BAR']\n            });\n          });\n        });\n\n        describe('when a plugin has no \"finalize\" function', function () {\n          it('should return an array of raw implementations', function () {\n            pluginLoader.load({baz: 'polar bears'});\n            return expect(pluginLoader.finalize(), 'to be fulfilled with', {\n              baz: ['polar bears']\n            });\n          });\n        });\n      });\n    });\n  });\n\n  describe('root hooks plugin 🎣', function () {\n    let pluginLoader;\n\n    beforeEach(function () {\n      pluginLoader = PluginLoader.create();\n    });\n\n    describe('when impl is an array', function () {\n      it('should fail validation', function () {\n        expect(() => pluginLoader.load({mochaHooks: []}), 'to throw', {\n          code: INVALID_PLUGIN_IMPLEMENTATION\n        });\n      });\n    });\n\n    describe('when impl is a primitive', function () {\n      it('should fail validation', function () {\n        expect(() => pluginLoader.load({mochaHooks: 'nuts'}), 'to throw', {\n          code: INVALID_PLUGIN_IMPLEMENTATION\n        });\n      });\n    });\n\n    describe('when impl is a function', function () {\n      it('should pass validation', function () {\n        expect(pluginLoader.load({mochaHooks: sinon.stub()}), 'to be true');\n      });\n    });\n\n    describe('when impl is an object of functions', function () {\n      // todo: hook name validation?\n      it('should pass validation');\n    });\n\n    describe('when a loaded impl is finalized', function () {\n      it('should flatten the implementations', async function () {\n        function a() {}\n        function b() {}\n        function d() {}\n        function g() {}\n        async function f() {}\n        function c() {\n          return {\n            beforeAll: d,\n            beforeEach: g\n          };\n        }\n        async function e() {\n          return {\n            afterEach: f\n          };\n        }\n\n        [\n          {\n            beforeEach: a\n          },\n          {\n            afterAll: b\n          },\n          c,\n          e\n        ].forEach(impl => {\n          pluginLoader.load({mochaHooks: impl});\n        });\n\n        return expect(pluginLoader.finalize(), 'to be fulfilled with', {\n          rootHooks: {\n            beforeAll: [d],\n            beforeEach: [a, g],\n            afterAll: [b],\n            afterEach: [f]\n          }\n        });\n      });\n    });\n  });\n\n  describe('global fixtures plugin', function () {\n    let pluginLoader;\n\n    beforeEach(function () {\n      pluginLoader = PluginLoader.create();\n    });\n\n    describe('global setup', function () {\n      describe('when an implementation is a primitive', function () {\n        it('should fail validation', function () {\n          expect(\n            () => pluginLoader.load({mochaGlobalSetup: 'nuts'}),\n            'to throw'\n          );\n        });\n      });\n      describe('when an implementation is an array of primitives', function () {\n        it('should fail validation', function () {\n          expect(\n            () => pluginLoader.load({mochaGlobalSetup: ['nuts']}),\n            'to throw'\n          );\n        });\n      });\n\n      describe('when an implementation is a function', function () {\n        it('should pass validation', function () {\n          expect(\n            pluginLoader.load({mochaGlobalSetup: sinon.stub()}),\n            'to be true'\n          );\n        });\n      });\n\n      describe('when an implementation is an array of functions', function () {\n        it('should pass validation', function () {\n          expect(\n            pluginLoader.load({mochaGlobalSetup: [sinon.stub()]}),\n            'to be true'\n          );\n        });\n      });\n    });\n\n    describe('global teardown', function () {\n      describe('when an implementation is a primitive', function () {\n        it('should fail validation', function () {\n          expect(\n            () => pluginLoader.load({mochaGlobalTeardown: 'nuts'}),\n            'to throw'\n          );\n        });\n      });\n      describe('when an implementation is an array of primitives', function () {\n        it('should fail validation', function () {\n          expect(\n            () => pluginLoader.load({mochaGlobalTeardown: ['nuts']}),\n            'to throw'\n          );\n        });\n      });\n\n      describe('when an implementation is a function', function () {\n        it('should pass validation', function () {\n          expect(\n            pluginLoader.load({mochaGlobalTeardown: sinon.stub()}),\n            'to be true'\n          );\n        });\n      });\n\n      describe('when an implementation is an array of functions', function () {\n        it('should pass validation', function () {\n          expect(\n            pluginLoader.load({mochaGlobalTeardown: [sinon.stub()]}),\n            'to be true'\n          );\n        });\n      });\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\nconst Mocha = require('../../../../lib/mocha');\n\nconst mocha = new Mocha({reporter: 'json'});\nmocha.addFile(\"./test/integration/fixtures/__default__.fixture.js\");\n\nconst runner = mocha.run();\nrunner.on('test', function (test) { test.pending = true; });"}
{"prompt":"Progress reporter, function  {","test":"'use strict';\n\nvar sinon = require('sinon');\nvar events = require('../../').Runner.constants;\nvar helpers = require('./helpers');\nvar reporters = require('../../').reporters;\n\nvar Base = reporters.Base;\nvar Progress = reporters.Progress;\nvar createMockRunner = helpers.createMockRunner;\nvar makeRunReporter = helpers.createRunReporterFunction;\n\nvar EVENT_RUN_BEGIN = events.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = events.EVENT_RUN_END;\nvar EVENT_TEST_END = events.EVENT_TEST_END;\n\ndescribe('Progress reporter', function () {\n  var runReporter = makeRunReporter(Progress);\n  var noop = function () {};\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('event handlers', function () {\n    describe(\"on 'start' event\", function () {\n      it('should call cursor hide', function () {\n        var hideCursorStub = sinon.stub(Base.cursor, 'hide');\n\n        var runner = createMockRunner('start', EVENT_RUN_BEGIN);\n        var options = {};\n        runReporter({}, runner, options);\n        sinon.restore();\n\n        expect(hideCursorStub.called, 'to be true');\n      });\n    });\n\n    describe(\"on 'test end' event\", function () {\n      describe('when line has changed', function () {\n        it('should write expected progress of open and close options', function () {\n          var crCursorStub = sinon.stub(Base.cursor, 'CR').callsFake(noop);\n          sinon.stub(Base, 'useColors').value(false);\n          sinon.stub(Base.window, 'width').value(5);\n\n          var expectedTotal = 12;\n          var expectedOpen = 'OpEn';\n          var expectedClose = 'cLoSe';\n          var expectedIncomplete = 'iNcOmPlEtE';\n          var expectedOptions = {\n            open: expectedOpen,\n            complete: 'cOmPlEtE',\n            incomplete: expectedIncomplete,\n            close: expectedClose\n          };\n\n          var runner = createMockRunner('test end', EVENT_TEST_END);\n          runner.total = expectedTotal;\n          var options = {\n            reporterOptions: expectedOptions\n          };\n          var stdout = runReporter({}, runner, options);\n          sinon.restore();\n\n          var expectedArray = [\n            '\\u001b[J',\n            '  ' + expectedOpen,\n            '',\n            expectedIncomplete,\n            expectedClose\n          ];\n\n          expect(crCursorStub.called, 'to be true');\n          expect(stdout, 'to equal', expectedArray);\n        });\n      });\n\n      describe('when line has not changed', function () {\n        it('should not write anything', function () {\n          sinon.stub(Base, 'useColors').value(false);\n          sinon.stub(Base.cursor, 'CR').callsFake(noop);\n          sinon.stub(Base.window, 'width').value(-3);\n\n          var expectedTotal = 1;\n          var runner = createMockRunner('test end', EVENT_TEST_END);\n          runner.total = expectedTotal;\n          var options = {};\n          var stdout = runReporter({}, runner, options);\n          sinon.restore();\n\n          expect(stdout, 'to equal', []);\n        });\n      });\n    });\n\n    describe(\"on 'end' event\", function () {\n      it('should call cursor show and epilogue', function () {\n        var showCursorStub = sinon.stub(Base.cursor, 'show');\n        var fakeThis = {\n          epilogue: sinon.spy()\n        };\n        var runner = createMockRunner('end', EVENT_RUN_END);\n        var options = {};\n        runReporter(fakeThis, runner, options);\n        sinon.restore();\n\n        expect(fakeThis.epilogue.calledOnce, 'to be true');\n        expect(showCursorStub.called, 'to be true');\n      });\n    });\n  });\n});"}
{"prompt":"Uncaught exception - throw and exit,  => {","test":"'use strict';\n\ndescribe('Uncaught exception - throw and exit', () => {\n  it('test1', () => {\n    setTimeout(() => {\n      throw new Error('Uncaught error after test1');\n    }, 1);\n  });\n  it('test2', function () { });\n  it('test3', function () { });\n  it('test4', function () { });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nsuite.only('should run all tests in this suite');\n\ntest('should run this test #1', function () {});\n\ntest('should run this test #2', function () {});\n\ntest('should run this test #3', function () {});\n\ntest('should run this test #4', function () {});\n\ntest('should run this test #5', function () {});\n\nsuite('should not run any of this suite\\'s tests');\n\ntest('should not run this test', function () {\n  (false).should.equal(true);\n});\n\ntest('should not run this test', function () {\n  (false).should.equal(true);\n});\n\ntest('should not run this test', function () {\n  (false).should.equal(true);\n});"}
{"prompt":"Root-only test cases","test":"'use strict';\n\n// Root-only test cases\ntest.only('#Root-Suite, should run this qunit test-case #1', function () {\n  expect(true, 'to be', true);\n});\n\ntest('#Root-Suite, should not run this qunit test-case #2', function () {\n  expect(false, 'to be', true);\n});\n\ntest('#Root-Suite, should not run this qunit test-case #3', function () {\n  expect(false, 'to be', true);\n});"}
{"prompt":"Test generated from existing file","test":"# About Mocha's Tests\n\n- **All assertions should be made using [unexpected](http://unexpected.js.org)**, unless there's a good reason not to.  Exceptions include:\n  - Testing diff output.  Mocha generates diff output unless the assertion library decides to do this itself.  Since `unexpected` generates its *own* diff output, we need to use an assertion library that does not; we use the built-in `assert` module.\n  - `test/unit/runnable.spec.js` must avoid 3rd-party code; read source for more info\n  - Tests asserting interop with other specific assertion libraries.\n- All tests have extension `.spec.js`.\n- All test fixtures have extension `.fixture.js`.\n- All test fixtures are *ignored* by ESLint.\n- `mocha.opts` will require `test/setup.js`, which is the main harness.\n- `test/assertions.js` contains Mocha-specific types and assertions for `unexpected`\n- `test/node-unit/` only runs in Node.js; `test/browser-specific/` only runs in the browser.\n  - See `../karma.conf.js` for more information on which tests run in the browser.\n- We can't run all of the Node.js tests in one `mocha` command, because we need to use different command-line options to test the various reporters and interfaces.\n  - See `../package-scripts.js` for more info about how things are split up."}
{"prompt":"uncaught, function {","test":"'use strict';\nconst assert = require('assert');\n\ndescribe('uncaught', function() {\n  var hookOrder = [];\n  it('throw delayed error', (done) => {\n    setTimeout(() => {\n      throw new Error('Whoops!');\n    }, 10)\n    setTimeout(done, 10);\n  });\n  it('should wait 15ms', (done) => {      \n    setTimeout(done, 15);\n  });\n  it('test 3', () => { });\n\n  afterEach(function() {\n    hookOrder.push(this.currentTest.title);\n  });\n  after(function() {\n    hookOrder.push('after');\n    assert.deepEqual(\n      hookOrder,\n      ['throw delayed error', 'should wait 15ms', 'test 3', 'after']\n    );\n    throw new Error('should get upto here and throw');\n  });\n});"}
{"prompt":"regressions, function  {","test":"'use strict';\n\nvar run = require('./helpers').runMocha;\nvar runJSON = require('./helpers').runMochaJSON;\n\ndescribe('regressions', function () {\n  it('issue-1991: Declarations do not get cleaned up unless you set them to `null` - Memory Leak', function (done) {\n    // on a modern MBP takes ±5 seconds on node 4.0, but on older laptops with node 0.12 ±40 seconds.\n    // Could easily take longer on even weaker machines (Travis-CI containers for example).\n    this.timeout(120000);\n    this.slow(12000);\n    run('regression/issue-1991.fixture.js', [], function (err, res) {\n      if (err) {\n        done(err);\n        return;\n      }\n      expect(res, 'not to contain output', 'process out of memory').and(\n        'to have passed'\n      );\n      done();\n    });\n  });\n\n  describe(\"issue-2286: after doesn't execute if test was skipped in beforeEach\", function () {\n    var afterWasRun = false;\n    describe('suite with skipped test for meta test', function () {\n      beforeEach(function () {\n        this.skip();\n      });\n      after(function () {\n        afterWasRun = true;\n      });\n      it('should be pending', function () {});\n    });\n    after('meta test', function () {\n      expect(afterWasRun, 'to be', true);\n    });\n  });\n\n  it('issue-2315: cannot read property currentRetry of undefined', function (done) {\n    runJSON('regression/issue-2315.fixture.js', [], function (err, res) {\n      if (err) {\n        done(err);\n        return;\n      }\n      expect(res, 'to have failed')\n        .and('not to have pending tests')\n        .and('to have failed test count', 1);\n      done();\n    });\n  });\n\n  it('issue-2406: should run nested describe.only suites', function (done) {\n    runJSON('regression/issue-2406.fixture.js', [], function (err, res) {\n      if (err) {\n        done(err);\n        return;\n      }\n      expect(res, 'to have passed')\n        .and('not to have pending tests')\n        .and('to have passed test count', 2);\n      done();\n    });\n  });\n\n  it('issue-2417: should not recurse infinitely with .only suites nested within each other', function (done) {\n    runJSON('regression/issue-2417.fixture.js', [], function (err, res) {\n      if (err) {\n        done(err);\n        return;\n      }\n      expect(res, 'to have passed')\n        .and('not to have pending tests')\n        .and('to have passed test count', 1);\n      done();\n    });\n  });\n});"}
{"prompt":"--reporter-option, function  {","test":"'use strict';\n\nvar runMocha = require('../helpers').runMocha;\nvar path = require('node:path');\n\ndescribe('--reporter-option', function () {\n  describe('when given options w/ invalid format', function () {\n    it('should display an error', function (done) {\n      runMocha(\n        'passing.fixture.js',\n        ['--reporter-option', 'foo=bar=baz'],\n        function (err, res) {\n          if (err) {\n            return done(err);\n          }\n          expect(res, 'to have failed').and(\n            'to contain output',\n            /invalid reporter option/i\n          );\n          done();\n        },\n        'pipe'\n      );\n    });\n\n    it('should allow comma-separated values', function (done) {\n      runMocha(\n        'passing.fixture.js',\n        [\n          '--reporter',\n          path.join(\n            __dirname,\n            '..',\n            'fixtures',\n            'options',\n            'reporter-with-options.fixture.js'\n          ),\n          '--reporter-option',\n          'foo=bar,baz=quux'\n        ],\n        function (err, res) {\n          if (err) {\n            return done(err);\n          }\n          expect(res, 'to have passed').and(\n            'to contain output',\n            /{\"foo\":\"bar\",\"baz\":\"quux\"}/\n          );\n          done();\n        },\n        'pipe'\n      );\n    });\n\n    it('should allow repeated options', function (done) {\n      runMocha(\n        'passing.fixture.js',\n        [\n          '--reporter',\n          path.join(\n            __dirname,\n            '..',\n            'fixtures',\n            'options',\n            'reporter-with-options.fixture.js'\n          ),\n          '--reporter-option',\n          'foo=bar',\n          '--reporter-option',\n          'baz=quux'\n        ],\n        function (err, res) {\n          if (err) {\n            return done(err);\n          }\n          expect(res, 'to have passed').and(\n            'to contain output',\n            /{\"foo\":\"bar\",\"baz\":\"quux\"}/\n          );\n          done();\n        },\n        'pipe'\n      );\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nfunction ReporterWithOptions(runner, options) {\n  console.log(JSON.stringify(options.reporterOption));\n}\n\nmodule.exports = ReporterWithOptions;"}
{"prompt":"Animals, function {","test":"'use strict';\n\n/**\n * This file generates a wide range of output to test reporter functionality.\n */\n\ndescribe('Animals', function() {\n\n  it('should consume organic material', function(done) { done(); });\n  it('should breathe oxygen', function(done) {\n    // we're a jellyfish\n    var actualBreathe = 'nothing';\n    var expectedBreathe = 'oxygen';\n    expect(actualBreathe, 'to equal', expectedBreathe);\n    done();\n  });\n  it('should be able to move', function(done) { done(); });\n  it('should reproduce sexually', function(done) { done(); });\n  it('should grow from a hollow sphere of cells', function(done) { done(); });\n\n  describe('Vertebrates', function() {\n    describe('Mammals', function() {\n      it('should give birth to live young', function(done) {\n        var expectedMammal = {\n          consumesMaterial: 'organic',\n          breathe: 'oxygen',\n          reproduction: {\n            type: 'sexually',\n            spawnType: 'live',\n          }\n        };\n        var platypus = JSON.parse(JSON.stringify(expectedMammal));\n        platypus['reproduction']['spawnType'] = 'hard-shelled egg';\n\n        expect(platypus, 'to equal', expectedMammal);\n        done();\n      });\n\n      describe('Blue Whale', function() {\n        it('should be the largest of all mammals', function(done) { done(); });\n        it('should have a body in some shade of blue', function(done) {\n          var bodyColor = 'blueish_grey';\n          var shadesOfBlue = ['cyan', 'light_blue', 'blue', 'indigo'];\n          expect(bodyColor, 'to be one of', shadesOfBlue);\n\n          done();\n        });\n      });\n    });\n    describe('Birds', function() {\n      it('should have feathers', function(done) { done(); });\n      it('should lay hard-shelled eggs', function(done) { done(); });\n    });\n  });\n\n  describe('Tardigrades', function() {\n    it('should answer to \"water bear\"', function(done) { done(); });\n    it('should be able to survive global mass extinction events', function(done) {\n      throw new Error(\"How do we even test for this without causing one?\")\n      done();\n    });\n  });\n});"}
{"prompt":"reporters, function  {","test":"'use strict';\n\nvar os = require('node:os');\nvar fs = require('node:fs');\nvar crypto = require('node:crypto');\nvar path = require('node:path');\nvar run = require('./helpers').runMocha;\n\ndescribe('reporters', function () {\n  describe('markdown', function () {\n    var res;\n\n    before(function (done) {\n      run(\n        'passing.fixture.js',\n        ['--reporter', 'markdown'],\n        function (err, result) {\n          res = result;\n          done(err);\n        }\n      );\n    });\n\n    it('does not exceed maximum callstack (issue: 1875)', function () {\n      expect(res.output, 'not to contain', 'RangeError');\n    });\n\n    it('contains spec src', function () {\n      var src = ['```js', 'assert(true);', '```'].join('\\n');\n\n      expect(res.output, 'to contain', src);\n    });\n  });\n\n  describe('xunit', function () {\n    it('prints test cases with --reporter-options output (issue: 1864)', function (done) {\n      var randomStr = crypto.randomBytes(8).toString('hex');\n      var tmpDir = os.tmpdir().replace(new RegExp(path.sep + '$'), '');\n      var tmpFile = tmpDir + path.sep + 'test-issue-1864-' + randomStr + '.xml';\n\n      var args = [\n        '--reporter=xunit',\n        '--reporter-options',\n        'output=' + tmpFile\n      ];\n      var expectedOutput = [\n        '<testcase classname=\"suite\" name=\"test1\" file=\"',\n        '<testcase classname=\"suite\" name=\"test2\" file=\"',\n        '</testsuite>'\n      ];\n\n      run('passing.fixture.js', args, function (err, result) {\n        if (err) return done(err);\n\n        var xml = fs.readFileSync(tmpFile, 'utf8');\n        fs.unlinkSync(tmpFile);\n\n        expectedOutput.forEach(function (line) {\n          expect(xml, 'to contain', line);\n        });\n\n        done(err);\n      });\n    });\n  });\n\n  describe('loader', function () {\n    it('loads a reporter from a path relative to the current working directory', function (done) {\n      var reporterAtARelativePath =\n        'test/integration/fixtures/simple-reporter.js';\n\n      var args = ['--reporter=' + reporterAtARelativePath];\n\n      run('passing.fixture.js', args, function (err, result) {\n        if (err) {\n          done(err);\n          return;\n        }\n        expect(result, 'to have passed');\n        done();\n      });\n    });\n\n    it('loads a reporter from an absolute path', function (done) {\n      // Generates an absolute path string\n      var reporterAtAnAbsolutePath = path.join(\n        process.cwd(),\n        'test/integration/fixtures/simple-reporter.js'\n      );\n\n      var args = ['--reporter=' + reporterAtAnAbsolutePath];\n\n      run('passing.fixture.js', args, function (err, result) {\n        if (err) {\n          done(err);\n          return;\n        }\n        expect(result, 'to have passed');\n        done();\n      });\n    });\n  });\n\n  describe('tap', function () {\n    var not = function (predicate) {\n      return function () {\n        return !predicate.apply(this, arguments);\n      };\n    };\n    var versionPredicate = function (line) {\n      return line.match(/^TAP version \\d+$/) != null;\n    };\n    var planPredicate = function (line) {\n      return line.match(/^1\\.\\.\\d+$/) != null;\n    };\n    var testLinePredicate = function (line) {\n      return line.match(/^not ok/) != null || line.match(/^ok/) != null;\n    };\n    var diagnosticPredicate = function (line) {\n      return line.match(/^#/) != null;\n    };\n    var bailOutPredicate = function (line) {\n      return line.match(/^Bail out!/) != null;\n    };\n    var anythingElsePredicate = function (line) {\n      return (\n        versionPredicate(line) === false &&\n        planPredicate(line) === false &&\n        testLinePredicate(line) === false &&\n        diagnosticPredicate(line) === false &&\n        bailOutPredicate(line) === false\n      );\n    };\n\n    describe('produces valid TAP v13 output', function () {\n      var runFixtureAndValidateOutput = function (fixture, expected) {\n        it('for ' + fixture, function (done) {\n          var args = ['--reporter=tap', '--reporter-option', 'tapVersion=13'];\n\n          run(fixture, args, function (err, res) {\n            if (err) {\n              done(err);\n              return;\n            }\n\n            var expectedVersion = 13;\n            var expectedPlan = '1..' + expected.numTests;\n\n            var outputLines = res.output.split('\\n');\n\n            // first line must be version line\n            expect(\n              outputLines[0],\n              'to equal',\n              'TAP version ' + expectedVersion\n            );\n\n            // plan must appear once\n            expect(outputLines, 'to contain', expectedPlan);\n            expect(\n              outputLines.filter(function (l) {\n                return l === expectedPlan;\n              }),\n              'to have length',\n              1\n            );\n            // plan cannot appear in middle of the output\n            var firstTestLine = outputLines.findIndex(testLinePredicate);\n            // there must be at least one test line\n            expect(firstTestLine, 'to be greater than', -1);\n            var lastTestLine =\n              outputLines.length -\n              1 -\n              outputLines.slice().reverse().findIndex(testLinePredicate);\n            var planLine = outputLines.findIndex(function (line) {\n              return line === expectedPlan;\n            });\n            expect(\n              planLine < firstTestLine || planLine > lastTestLine,\n              'to equal',\n              true\n            );\n\n            done();\n          });\n        });\n      };\n\n      runFixtureAndValidateOutput('passing.fixture.js', {\n        numTests: 2\n      });\n      runFixtureAndValidateOutput('reporters.fixture.js', {\n        numTests: 12\n      });\n    });\n\n    it('should fail if given invalid `tapVersion`', function (done) {\n      var invalidTapVersion = 'nosuch';\n      var args = [\n        '--reporter=tap',\n        '--reporter-option',\n        'tapVersion=' + invalidTapVersion\n      ];\n\n      run(\n        'reporters.fixture.js',\n        args,\n        function (err, res) {\n          if (err) {\n            done(err);\n            return;\n          }\n\n          var pattern = `Error: invalid or unsupported TAP version: \"${invalidTapVersion}\"`;\n          expect(res, 'to satisfy', {\n            code: 1,\n            output: new RegExp(pattern, 'm')\n          });\n          done();\n        },\n        {stdio: 'pipe'}\n      );\n    });\n\n    it('places exceptions correctly in YAML blocks', function (done) {\n      var args = ['--reporter=tap', '--reporter-option', 'tapVersion=13'];\n\n      run('reporters.fixture.js', args, function (err, res) {\n        if (err) {\n          done(err);\n          return;\n        }\n\n        var outputLines = res.output.split('\\n');\n\n        for (var i = 0; i + 1 < outputLines.length; i++) {\n          if (\n            testLinePredicate(outputLines[i]) &&\n            testLinePredicate(outputLines[i + 1]) === false\n          ) {\n            var blockLinesStart = i + 1;\n            var blockLinesEnd =\n              i +\n              1 +\n              outputLines.slice(i + 1).findIndex(not(anythingElsePredicate));\n            var blockLines =\n              blockLinesEnd > blockLinesStart\n                ? outputLines.slice(blockLinesStart, blockLinesEnd)\n                : outputLines.slice(blockLinesStart);\n            i += blockLines.length;\n\n            expect(blockLines[0], 'to match', /^\\s+---/);\n            expect(blockLines[blockLines.length - 1], 'to match', /^\\s+\\.\\.\\./);\n          }\n        }\n\n        done();\n      });\n    });\n  });\n});"}
{"prompt":"require test, function  {","test":"'use strict';\n\ndescribe('require test', function () {\n  it('should require args in order', function () {\n    var req = global.required;\n    expect(req.indexOf('a.js'), 'to be', 0);\n    expect(req.indexOf('b.coffee'), 'to be', 1);\n    expect(req.indexOf('c.js'), 'to be', 2);\n    expect(req.indexOf('d.coffee'), 'to be', 3);\n  });\n});"}
{"prompt":"using imported describe, function  {","test":"'use strict';\n\nconst assert = require('node:assert');\nconst {describe, it} = require('../..');\n\ndescribe('using imported \"describe\"', function () {\n  it('using imported \"it\"', function (done) {\n    assert.ok(true);\n    done();\n  });\n});"}
{"prompt":"retry suite A, function {","test":"describe('retry suite A', function() {\n  it('should pass', function() {\n\n  });\n});"}
{"prompt":"retry suite B, function {","test":"describe('retry suite B', function() {\n  let count = 0;\n  it('should retry', function() {\n    this.retries(3);\n    console.log(`count: ${++count}`);\n    throw new Error('failure');\n  });\n});"}
{"prompt":"retries, function  {","test":"'use strict';\n\ndescribe('retries', function () {\n  it('should fail', function () {\n    throw new Error('retry failure');\n  });\n});"}
{"prompt":"retries, function  {","test":"'use strict';\n\nvar assert = require('node:assert');\nvar helpers = require('./helpers');\nvar runJSON = helpers.runMochaJSON;\nvar args = [];\nvar bang = require('../../lib/reporters/base').symbols.bang;\n\ndescribe('retries', function () {\n  it('are ran in correct order', function (done) {\n    helpers.runMocha(\n      'retries/hooks.fixture.js',\n      ['--reporter', 'dot'],\n      function (err, res) {\n        var lines, expected;\n\n        if (err) {\n          done(err);\n          return;\n        }\n\n        lines = res.output\n          .split(helpers.SPLIT_DOT_REPORTER_REGEXP)\n          .map(function (line) {\n            return line.trim();\n          })\n          .filter(function (line) {\n            return line.length;\n          })\n          .slice(0, -1);\n\n        expected = [\n          'before',\n          'before each 0',\n          'TEST 0',\n          'after each 1',\n          'before each 1',\n          'TEST 1',\n          'after each 2',\n          'before each 2',\n          'TEST 2',\n          'after each 3',\n          'before each 3',\n          'TEST 3',\n          'after each 4',\n          'before each 4',\n          'TEST 4',\n          bang + 'after each 5',\n          'after'\n        ];\n\n        expected.forEach(function (line, i) {\n          assert.strictEqual(lines[i], line);\n        });\n\n        assert.strictEqual(res.code, 1);\n        done();\n      }\n    );\n  });\n\n  it('should exit early if test passes', function (done) {\n    runJSON('retries/early-pass.fixture.js', args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have passed')\n        .and('to have passed test count', 2)\n        .and('to have failed test count', 0)\n        .and('to have retried test', 'should pass after 1 retry', 1);\n\n      done();\n    });\n  });\n\n  it('should let test override', function (done) {\n    runJSON('retries/nested.fixture.js', args, function (err, res) {\n      if (err) {\n        done(err);\n        return;\n      }\n      assert.strictEqual(res.stats.passes, 0);\n      assert.strictEqual(res.stats.failures, 1);\n      assert.strictEqual(res.stats.tests, 1);\n      assert.strictEqual(res.tests[0].currentRetry, 1);\n      assert.strictEqual(res.code, 1);\n      done();\n    });\n  });\n\n  it('should not hang w/ async test', function (done) {\n    helpers.runMocha(\n      'retries/async.fixture.js',\n      ['--reporter', 'dot'],\n      function (err, res) {\n        var lines, expected;\n\n        if (err) {\n          done(err);\n          return;\n        }\n\n        lines = res.output\n          .split(helpers.SPLIT_DOT_REPORTER_REGEXP)\n          .map(function (line) {\n            return line.trim();\n          })\n          .filter(function (line) {\n            return line.length;\n          })\n          .slice(0, -1);\n\n        expected = [\n          'before',\n          'before each 0',\n          'TEST 0',\n          'after each 1',\n          'before each 1',\n          'TEST 1',\n          'after each 2',\n          'before each 2',\n          'TEST 2',\n          'after each 3',\n          'after'\n        ];\n\n        expected.forEach(function (line, i) {\n          assert.strictEqual(lines[i], line);\n        });\n\n        assert.strictEqual(res.code, 0);\n        done();\n      }\n    );\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nexports.mochaHooks = {\n  beforeAll() {\n    console.log('beforeAll');\n  },\n  beforeEach() {\n    console.log('beforeEach');\n  },\n  afterAll() {\n    console.log('afterAll');\n  },\n  afterEach() {\n    console.log('afterEach');\n  }\n};"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nexports.mochaHooks = {\n  beforeAll: [\n    function() {\n      console.log('beforeAll array 1');\n    },\n    function() {\n      console.log('beforeAll array 2');\n    }\n  ],\n  beforeEach: [\n    function() {\n      console.log('beforeEach array 1');\n    },\n    function() {\n      console.log('beforeEach array 2');\n    }\n  ],\n  afterAll: [\n    function() {\n      console.log('afterAll array 1');\n    },\n    function() {\n      console.log('afterAll array 2');\n    }\n  ],\n  afterEach: [\n    function() {\n      console.log('afterEach array 1');\n    },\n    function() {\n      console.log('afterEach array 2');\n    }\n  ]\n};"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nexports.mochaHooks = async () => ({\n  beforeAll() {\n    console.log('beforeAll');\n  },\n  beforeEach() {\n    console.log('beforeEach');\n  },\n  afterAll() {\n    console.log('afterAll');\n  },\n  afterEach() {\n    console.log('afterEach');\n  }\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nexports.mochaHooks = async() => ({\n  beforeAll: [\n    function() {\n      console.log('beforeAll array 1');\n    },\n    function() {\n      console.log('beforeAll array 2');\n    }\n  ],\n  beforeEach: [\n    function() {\n      console.log('beforeEach array 1');\n    },\n    function() {\n      console.log('beforeEach array 2');\n    }\n  ],\n  afterAll: [\n    function() {\n      console.log('afterAll array 1');\n    },\n    function() {\n      console.log('afterAll array 2');\n    }\n  ],\n  afterEach: [\n    function() {\n      console.log('afterEach array 1');\n    },\n    function() {\n      console.log('afterEach array 2');\n    }\n  ]\n});"}
{"prompt":"Test generated from existing file","test":"export const mochaHooks = {\n  beforeAll() {\n    console.log('mjs beforeAll');\n  },\n  afterAll() {\n    console.log('mjs afterAll');\n  },\n};"}
{"prompt":"Test generated from existing file","test":"export const mochaHooks = () => ({\n  beforeEach() {\n    console.log('esm beforeEach');\n  },\n  afterEach() {\n    console.log('esm afterEach');\n  },\n});"}
{"prompt":"Test generated from existing file","test":"export const mochaHooks = {\n  beforeAll() {\n    console.log('mjs beforeAll');\n  },\n  afterAll() {\n    console.log('mjs afterAll');\n  },\n};"}
{"prompt":"run wh --require root-hook-defs-a.fixture.js --require","test":"// run with --require root-hook-defs-a.fixture.js --require\n// root-hook-defs-b.fixture.js\n\nit('should also have some root hooks', function() {\n  // test\n});"}
{"prompt":"run wh --require root-hook-defs-a.fixture.js --require","test":"// run with --require root-hook-defs-a.fixture.js --require\n// root-hook-defs-b.fixture.js\n\nit('should have some root hooks', function() {\n  // test\n});"}
{"prompt":"every line that begins wh whitespace e.g., the test name should be ignored;","test":"'use strict';\n\nvar invokeMochaAsync = require('../helpers').invokeMochaAsync;\n\n/**\n * Extracts root hook log messages from run results\n * `root-hook-defs-*` fixtures are root hook plugins which call `console.log()`\n * for verification that they have been run.\n * @param {RawResult} res - result of invokeMochaAsync()\n */\nfunction extractHookOutputFromResult(res) {\n  return res.output\n    .trim()\n    .split('\\n')\n    .filter(function (line) {\n      // every line that begins with whitespace (e.g., the test name) should be ignored;\n      // we just want the console.log messages\n      return /^\\S/.test(line);\n    })\n    .sort();\n}\n\n/**\n * Helper to call Mocha and pipe the result through `extractHookOutputFromResult`\n * @param {*} args - args for invokeMochaAsync\n * @param {*} opts - opts for invokeMochaAsync\n */\nfunction runMochaForHookOutput(args, opts) {\n  return invokeMochaAsync(args, opts)[1].then(extractHookOutputFromResult);\n}\n\ndescribe('root hooks', function () {\n  describe('when mocha run in serial mode', function () {\n    it('should run root hooks when provided via mochaHooks object export', function () {\n      return expect(\n        runMochaForHookOutput([\n          '--require=' +\n            require.resolve(\n              '../fixtures/plugins/root-hooks/root-hook-defs-a.fixture.js'\n            ),\n          '--require=' +\n            require.resolve(\n              '../fixtures/plugins/root-hooks/root-hook-defs-b.fixture.js'\n            ),\n          require.resolve(\n            '../fixtures/plugins/root-hooks/root-hook-test.fixture.js'\n          )\n        ]),\n        'to be fulfilled with',\n        [\n          'afterAll',\n          'afterAll array 1',\n          'afterAll array 2',\n          'afterEach',\n          'afterEach array 1',\n          'afterEach array 2',\n          'beforeAll',\n          'beforeAll array 1',\n          'beforeAll array 2',\n          'beforeEach',\n          'beforeEach array 1',\n          'beforeEach array 2'\n        ]\n      );\n    });\n\n    it('should run root hooks when provided via mochaHooks function export', function () {\n      return expect(\n        runMochaForHookOutput([\n          '--require=' +\n            require.resolve(\n              '../fixtures/plugins/root-hooks/root-hook-defs-c.fixture.js'\n            ),\n          '--require=' +\n            require.resolve(\n              '../fixtures/plugins/root-hooks/root-hook-defs-d.fixture.js'\n            ),\n          require.resolve(\n            '../fixtures/plugins/root-hooks/root-hook-test.fixture.js'\n          )\n        ]),\n        'to be fulfilled with',\n        [\n          'afterAll',\n          'afterAll array 1',\n          'afterAll array 2',\n          'afterEach',\n          'afterEach array 1',\n          'afterEach array 2',\n          'beforeAll',\n          'beforeAll array 1',\n          'beforeAll array 2',\n          'beforeEach',\n          'beforeEach array 1',\n          'beforeEach array 2'\n        ]\n      );\n    });\n\n    describe('support ESM when type=module or .mjs extension', function () {\n      it('should run root hooks when provided via mochaHooks', function () {\n        return expect(\n          runMochaForHookOutput([\n            '--require=' +\n              require.resolve(\n                // as object\n                '../fixtures/plugins/root-hooks/root-hook-defs-esm.fixture.mjs'\n              ),\n            '--require=' +\n              require.resolve(\n                // as function\n                '../fixtures/plugins/root-hooks/esm/root-hook-defs-esm.fixture.js'\n              ),\n            '--require=' +\n              require.resolve(\n                // mixed with commonjs\n                '../fixtures/plugins/root-hooks/root-hook-defs-a.fixture.js'\n              ),\n            require.resolve(\n              '../fixtures/plugins/root-hooks/root-hook-test.fixture.js'\n            )\n          ]),\n          'to be fulfilled with',\n          [\n            'afterAll',\n            'afterEach',\n            'beforeAll',\n            'beforeEach',\n            'esm afterEach',\n            'esm beforeEach',\n            'mjs afterAll',\n            'mjs beforeAll'\n          ]\n        );\n      });\n    });\n\n    describe('support ESM via .js extension w/o type=module', function () {\n      describe('should fail due to ambiguous file type', function () {\n        const filename =\n          '../fixtures/plugins/root-hooks/root-hook-defs-esm-broken.fixture.js';\n        const noDetectModuleRegex = /SyntaxError: Unexpected token/;\n        const detectModuleRegex = /Cannot require\\(\\) ES Module/;\n\n        it('with --no-experimental-detect-module', function () {\n          return expect(\n            invokeMochaAsync(\n              [\n                '--require=' + require.resolve(filename), // as object\n                '--no-experimental-detect-module'\n              ],\n              'pipe'\n            )[1],\n            'when fulfilled',\n            'to contain output',\n            noDetectModuleRegex\n          );\n        });\n\n        it('with --experimental-detect-module', function () {\n          // --experimental-detect-module was introduced in Node 21.1.0\n          const expectedRegex =\n            process.version >= 'v21.1.0'\n              ? detectModuleRegex\n              : noDetectModuleRegex;\n          return expect(\n            invokeMochaAsync(\n              [\n                '--require=' + require.resolve(filename), // as object\n                '--experimental-detect-module'\n              ],\n              'pipe'\n            )[1],\n            'when fulfilled',\n            'to contain output',\n            expectedRegex\n          );\n        });\n      });\n    });\n  });\n\n  describe('when mocha in parallel mode', function () {\n    it('should run root hooks when provided via mochaHooks object exports', function () {\n      return expect(\n        runMochaForHookOutput([\n          '--require=' +\n            require.resolve(\n              '../fixtures/plugins/root-hooks/root-hook-defs-a.fixture.js'\n            ),\n          '--require=' +\n            require.resolve(\n              '../fixtures/plugins/root-hooks/root-hook-defs-b.fixture.js'\n            ),\n          '--parallel',\n          require.resolve(\n            '../fixtures/plugins/root-hooks/root-hook-test.fixture.js'\n          )\n        ]),\n        'to be fulfilled with',\n        [\n          'afterAll',\n          'afterAll array 1',\n          'afterAll array 2',\n          'afterEach',\n          'afterEach array 1',\n          'afterEach array 2',\n          'beforeAll',\n          'beforeAll array 1',\n          'beforeAll array 2',\n          'beforeEach',\n          'beforeEach array 1',\n          'beforeEach array 2'\n        ]\n      );\n    });\n\n    it('should run root hooks when provided via mochaHooks function export', function () {\n      return expect(\n        runMochaForHookOutput([\n          '--require=' +\n            require.resolve(\n              '../fixtures/plugins/root-hooks/root-hook-defs-c.fixture.js'\n            ),\n          '--require=' +\n            require.resolve(\n              '../fixtures/plugins/root-hooks/root-hook-defs-d.fixture.js'\n            ),\n          '--parallel',\n          require.resolve(\n            '../fixtures/plugins/root-hooks/root-hook-test.fixture.js'\n          )\n        ]),\n        'to be fulfilled with',\n        [\n          'afterAll',\n          'afterAll array 1',\n          'afterAll array 2',\n          'afterEach',\n          'afterEach array 1',\n          'afterEach array 2',\n          'beforeAll',\n          'beforeAll array 1',\n          'beforeAll array 2',\n          'beforeEach',\n          'beforeEach array 1',\n          'beforeEach array 2'\n        ]\n      );\n    });\n\n    describe('when running multiple jobs', function () {\n      it('should run root hooks when provided via mochaHooks object exports for each job', function () {\n        return expect(\n          runMochaForHookOutput([\n            '--require=' +\n              require.resolve(\n                '../fixtures/plugins/root-hooks/root-hook-defs-a.fixture.js'\n              ),\n            '--require=' +\n              require.resolve(\n                '../fixtures/plugins/root-hooks/root-hook-defs-b.fixture.js'\n              ),\n            '--parallel',\n            require.resolve(\n              '../fixtures/plugins/root-hooks/root-hook-test.fixture.js'\n            ),\n            require.resolve(\n              '../fixtures/plugins/root-hooks/root-hook-test-2.fixture.js'\n            )\n          ]),\n          'to be fulfilled with',\n          [\n            'afterAll',\n            'afterAll',\n            'afterAll array 1',\n            'afterAll array 1',\n            'afterAll array 2',\n            'afterAll array 2',\n            'afterEach',\n            'afterEach',\n            'afterEach array 1',\n            'afterEach array 1',\n            'afterEach array 2',\n            'afterEach array 2',\n            'beforeAll',\n            'beforeAll',\n            'beforeAll array 1',\n            'beforeAll array 1',\n            'beforeAll array 2',\n            'beforeAll array 2',\n            'beforeEach',\n            'beforeEach',\n            'beforeEach array 1',\n            'beforeEach array 1',\n            'beforeEach array 2',\n            'beforeEach array 2'\n          ]\n        );\n      });\n    });\n  });\n});"}
{"prompt":"root, function  {","test":"'use strict';\n\nvar calls = [];\n\nbefore(function () {\n  calls.push('before');\n});\n\ndescribe('root', function () {\n  it('should be a valid suite', function () {\n    expect(calls, 'to equal', ['before']);\n  });\n});"}
{"prompt":"helpers, function  {","test":"'use strict';\n\nconst {validateLegacyPlugin, list} = require('../../../lib/cli/run-helpers');\nconst Mocha = require('../../../lib/mocha');\n\ndescribe('helpers', function () {\n  describe('validateLegacyPlugin()', function () {\n    describe('when used with \"reporter\" key', function () {\n      it('should disallow an array of names', function () {\n        expect(\n          () => validateLegacyPlugin({reporter: ['bar']}, 'reporter'),\n          'to throw',\n          {\n            code: 'ERR_MOCHA_INVALID_REPORTER',\n            message: /can only be specified once/i\n          }\n        );\n      });\n\n      it('should fail to recognize an unknown reporter', function () {\n        expect(\n          () => validateLegacyPlugin({reporter: 'bar'}, 'reporter'),\n          'to throw',\n          {code: 'ERR_MOCHA_INVALID_REPORTER', message: /cannot find module/i}\n        );\n      });\n    });\n\n    describe('when used with an \"ui\" key', function () {\n      it('should disallow an array of names', function () {\n        expect(() => validateLegacyPlugin({ui: ['bar']}, 'ui'), 'to throw', {\n          code: 'ERR_MOCHA_INVALID_INTERFACE',\n          message: /can only be specified once/i\n        });\n      });\n\n      it('should fail to recognize an unknown interface', function () {\n        expect(() => validateLegacyPlugin({ui: 'bar'}, 'ui'), 'to throw', {\n          code: 'ERR_MOCHA_INVALID_INTERFACE',\n          message: /cannot find module/i\n        });\n      });\n    });\n\n    describe('when used with an unknown plugin type', function () {\n      it('should fail', function () {\n        expect(\n          () => validateLegacyPlugin({frog: 'bar'}, 'frog'),\n          'to throw',\n          /unknown plugin/i\n        );\n      });\n    });\n\n    describe('when used with a third-party interface', function () {\n      it('should add the interface to \"Mocha.interfaces\"', function () {\n        // let's suppose that `glob` is an interface\n        const opts = {ui: 'glob'};\n        validateLegacyPlugin(opts, 'ui', Mocha.interfaces);\n        expect(opts.ui, 'to equal', 'glob');\n        expect(Mocha.interfaces, 'to satisfy', {glob: require('glob')});\n        delete Mocha.interfaces.glob;\n      });\n    });\n\n    describe('when a plugin throws an exception upon load', function () {\n      it('should fail and report the original error', function () {\n        expect(\n          () =>\n            validateLegacyPlugin(\n              {\n                reporter: require.resolve('./fixtures/bad-module.fixture.js')\n              },\n              'reporter'\n            ),\n          'to throw',\n          {message: /wonky/, code: 'ERR_MOCHA_INVALID_REPORTER'}\n        );\n      });\n\n      it('should fail and report the original \"MODULE_NOT_FOUND\" error.message', function () {\n        expect(\n          () =>\n            validateLegacyPlugin(\n              {\n                reporter: require.resolve('./fixtures/bad-require.fixture.js')\n              },\n              'reporter'\n            ),\n          'to throw',\n          {\n            message: /Error: Cannot find module 'fake'/,\n            code: 'ERR_MOCHA_INVALID_REPORTER'\n          }\n        );\n      });\n    });\n  });\n\n  describe('list()', function () {\n    describe('when provided a flat array', function () {\n      it('should return a flat array', function () {\n        expect(list(['foo', 'bar']), 'to equal', ['foo', 'bar']);\n      });\n    });\n    describe('when provided a nested array', function () {\n      it('should return a flat array', function () {\n        expect(list([['foo', 'bar'], 'baz']), 'to equal', [\n          'foo',\n          'bar',\n          'baz'\n        ]);\n      });\n    });\n    describe('when given a comma-delimited string', function () {\n      it('should return a flat array', function () {\n        expect(list('foo,bar'), 'to equal', ['foo', 'bar']);\n      });\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"module.exports = function (mocha) {\n  mocha.addFile(require.resolve('./multiple-runs-with-different-output-suite.fixture.js'));\n  console.log('[');\n  try {\n    mocha.run(() => {\n      console.log(',');\n      try {\n        mocha.run(() => {\n          console.log(',');\n          mocha.run(() => {\n            console.log(']');\n          });\n        });\n      } catch (err) {\n        console.error(err.code);\n        throw err;\n      }\n    });\n  } catch (err) {\n    console.error(err.code);\n    throw err;\n  }\n\n}"}
{"prompt":"Test generated from existing file","test":"'use strict';\nconst Mocha = require('../../../../lib/mocha');\n\nconst mocha = new Mocha({ reporter: 'json' });\nmocha.cleanReferencesAfterRun(false);\nrequire('./run-thrice-helper')(mocha);"}
{"prompt":"command, function  {","test":"'use strict';\n\nconst {builder} = require('../../../lib/cli/run');\nconst {types} = require('../../../lib/cli/run-option-metadata');\n\ndescribe('command', function () {\n  describe('run', function () {\n    describe('builder', function () {\n      const IGNORED_OPTIONS = new Set(['help', 'version']);\n      const options = builder(require('yargs')()).getOptions();\n      ['number', 'string', 'boolean', 'array'].forEach(type => {\n        describe(`${type} type`, function () {\n          Array.from(new Set(options[type])).forEach(option => {\n            if (!IGNORED_OPTIONS.has(option)) {\n              it(`should include option ${option}`, function () {\n                expect(types[type], 'to contain', option);\n              });\n            }\n          });\n        });\n      });\n    });\n  });\n});"}
{"prompt":"Runnabletitle, fn, function  {","test":"'use strict';\n\nvar Mocha = require('../../lib/mocha');\nvar Runnable = Mocha.Runnable;\nvar Suite = Mocha.Suite;\nvar sinon = require('sinon');\nconst {TIMEOUT} = require('../../lib/errors').constants;\nvar STATE_FAILED = Runnable.constants.STATE_FAILED;\n\ndescribe('Runnable(title, fn)', function () {\n  describe('#timeout(ms)', function () {\n    var DISABLED_TIMEOUTS = 0;\n    var MAX_TIMEOUT = 2147483647; // INT_MAX (32-bit signed integer)\n\n    describe('when value is less than lower bound', function () {\n      it('should clamp to lower bound given numeric', function () {\n        var run = new Runnable();\n        run.timeout(-1);\n        expect(run.timeout(), 'to be', DISABLED_TIMEOUTS);\n      });\n      it('should clamp to lower bound given timestamp', function () {\n        var run = new Runnable();\n        run.timeout('-1 ms');\n        expect(run.timeout(), 'to be', DISABLED_TIMEOUTS);\n      });\n    });\n\n    describe('when value is equal to lower bound', function () {\n      var run;\n\n      beforeEach(function () {\n        run = new Runnable();\n        run.timeout(DISABLED_TIMEOUTS);\n      });\n      describe('given numeric value', function () {\n        it('should set the timeout value to disabled', function () {\n          expect(run.timeout(), 'to be', DISABLED_TIMEOUTS);\n        });\n      });\n\n      describe('given string timestamp', function () {\n        it('should set the timeout value to disabled', function () {\n          expect(run.timeout(), 'to be', DISABLED_TIMEOUTS);\n        });\n      });\n    });\n\n    describe('when value is within `setTimeout` bounds', function () {\n      var run;\n      var timeout = 1000;\n\n      beforeEach(function () {\n        run = new Runnable();\n        run.timeout(timeout);\n      });\n\n      describe('given numeric value', function () {\n        it('should set the timeout value', function () {\n          expect(run.timeout(), 'to be', timeout);\n        });\n      });\n\n      describe('given string timestamp', function () {\n        it('should set the timeout value', function () {\n          expect(run.timeout(), 'to be', timeout);\n        });\n      });\n    });\n\n    describe('when value is equal to upper bound', function () {\n      var run;\n\n      beforeEach(function () {\n        run = new Runnable();\n        run.timeout(MAX_TIMEOUT);\n      });\n      describe('given numeric value', function () {\n        it('should set the disabled timeout value', function () {\n          expect(run.timeout(), 'to be', 0);\n        });\n      });\n    });\n\n    describe('when value is out-of-bounds', function () {\n      var run;\n      var timeout = MAX_TIMEOUT + 1;\n\n      beforeEach(function () {\n        run = new Runnable();\n        run.timeout(timeout);\n      });\n\n      describe('given numeric value', function () {\n        it('should set the disabled timeout value', function () {\n          expect(run.timeout(), 'to be', 0);\n        });\n      });\n    });\n  });\n\n  describe('#slow(ms)', function () {\n    var run;\n\n    beforeEach(function () {\n      run = new Runnable();\n    });\n\n    it('should set the slow threshold', function () {\n      run.slow(100);\n      expect(run.slow(), 'to be', 100);\n    });\n\n    it('should not set the slow threshold if the parameter is not passed', function () {\n      run.slow();\n      expect(run.slow(), 'to be', 75);\n    });\n\n    it('should not set the slow threshold if the parameter is undefined', function () {\n      run.slow(undefined);\n      expect(run.slow(), 'to be', 75);\n    });\n\n    describe('when passed a time-formatted string', function () {\n      it('should convert to ms', function () {\n        run.slow('1s');\n        expect(run.slow(), 'to be', 1000);\n      });\n    });\n  });\n\n  describe('#reset', function () {\n    var run;\n\n    beforeEach(function () {\n      run = new Runnable();\n    });\n\n    it('should reset current run state', function () {\n      run.timedOut = true;\n      run._currentRetry = 5;\n      run.pending = true;\n      run.err = new Error();\n      run.state = 'error';\n\n      run.reset();\n      expect(run.timedOut, 'to be false');\n      expect(run._currentRetry, 'to be', 0);\n      expect(run.pending, 'to be false');\n      expect(run.err, 'to be undefined');\n      expect(run.state, 'to be undefined');\n    });\n  });\n\n  describe('.title', function () {\n    it('should be present', function () {\n      expect(new Runnable('foo').title, 'to be', 'foo');\n    });\n  });\n\n  describe('.titlePath()', function () {\n    it(\"returns the concatenation of the parent's title path and runnable's title\", function () {\n      var runnable = new Runnable('bar');\n      runnable.parent = new Suite('foo');\n      expect(\n        JSON.stringify(runnable.titlePath()),\n        'to be',\n        JSON.stringify(['foo', 'bar'])\n      );\n    });\n  });\n\n  describe('when arity >= 1', function () {\n    var run;\n\n    beforeEach(function () {\n      run = new Runnable('foo', function (done) {});\n    });\n\n    it('should be .async', function () {\n      expect(run.async, 'to be', 1);\n    });\n\n    it('should not be .sync', function () {\n      expect(run.sync, 'to be false');\n    });\n  });\n\n  describe('when arity == 0', function () {\n    var run;\n\n    beforeEach(function () {\n      run = new Runnable('foo', function () {});\n    });\n\n    it('should not be .async', function () {\n      expect(run.async, 'to be', 0);\n    });\n\n    it('should be .sync', function () {\n      expect(run.sync, 'to be true');\n    });\n  });\n\n  describe('#globals', function () {\n    it('should allow for whitelisting globals', function () {\n      var runnable = new Runnable('foo', function () {});\n      runnable.globals(['foobar']);\n      expect(runnable._allowedGlobals, 'to equal', ['foobar']);\n    });\n  });\n\n  describe('#retries(n)', function () {\n    it('should set the number of retries', function () {\n      var run = new Runnable();\n      run.retries(1);\n      expect(run.retries(), 'to be', 1);\n    });\n  });\n\n  describe('.run(fn)', function () {\n    describe('when .pending', function () {\n      it('should not invoke the callback', function (done) {\n        var spy = sinon.spy();\n        var runnable = new Runnable('foo', spy);\n\n        runnable.pending = true;\n        runnable.run(function (err) {\n          if (err) {\n            return done(err);\n          }\n          expect(spy, 'was not called');\n          done();\n        });\n      });\n    });\n\n    describe('when sync', function () {\n      describe('without error', function () {\n        it('should invoke the callback', function (done) {\n          var spy = sinon.spy();\n          var runnable = new Runnable('foo', spy);\n\n          runnable.run(function (err) {\n            if (err) {\n              return done(err);\n            }\n\n            expect(spy, 'was called times', 1);\n            done();\n          });\n        });\n      });\n\n      describe('when an exception is thrown', function () {\n        it('should invoke the callback with error', function (done) {\n          var stub = sinon.stub().throws('Error', 'fail');\n          var runnable = new Runnable('foo', stub);\n\n          runnable.run(function (err) {\n            expect(err.message, 'to be', 'fail');\n            expect(stub, 'was called');\n            done();\n          });\n        });\n      });\n\n      describe('when an exception is thrown and is allowed to remain uncaught', function () {\n        it('throws an error when it is allowed', function () {\n          var stub = sinon.stub().throws('Error', 'fail');\n          var runnable = new Runnable('foo', stub);\n          runnable.allowUncaught = true;\n\n          function fail() {\n            runnable.run(function () {});\n          }\n          expect(fail, 'to throw', 'fail');\n        });\n      });\n    });\n\n    describe('when timeouts are disabled', function () {\n      it('should not error with timeout', function (done) {\n        var runnable = new Runnable('foo', function (done) {\n          setTimeout(function () {\n            setTimeout(done);\n          }, 2);\n        });\n        runnable.timeout(1);\n        runnable.timeout(0);\n        runnable.run(function (err) {\n          expect(err, 'to be falsy');\n          done();\n        });\n      });\n    });\n\n    describe('when async', function () {\n      describe('without error', function () {\n        it('should invoke the callback', function (done) {\n          var runnable = new Runnable('foo', function (done) {\n            setTimeout(done);\n          });\n\n          runnable.run(function (err) {\n            expect(err, 'to be falsy');\n            done();\n          });\n        });\n      });\n\n      describe('when the callback is invoked several times', function () {\n        describe('without an error', function () {\n          it('should emit a single \"error\" event', function (done) {\n            var callbackSpy = sinon.spy();\n            var errorSpy = sinon.spy();\n\n            var runnable = new Runnable('foo', function (done) {\n              process.nextTick(done);\n              setTimeout(done);\n              setTimeout(done);\n              setTimeout(done);\n            });\n\n            // XXX too many diff assertions and very flimsy assertion that this\n            // event was only emitted once.  think of a better way.\n            runnable.on('error', errorSpy).on('error', function (err) {\n              process.nextTick(function () {\n                expect(errorSpy, 'was called times', 1);\n                expect(\n                  err.message,\n                  'to match',\n                  /done\\(\\) called multiple times/\n                );\n                expect(callbackSpy, 'was called times', 1);\n                done();\n              });\n            });\n\n            runnable.run(callbackSpy);\n          });\n        });\n\n        describe('with an error', function () {\n          it('should emit a single \"error\" event', function (done) {\n            var callbackSpy = sinon.spy();\n            var errorSpy = sinon.spy();\n\n            var runnable = new Runnable('foo', function (done) {\n              done(new Error('fail'));\n              setTimeout(done);\n              done(new Error('fail'));\n              setTimeout(done);\n              setTimeout(done);\n            });\n\n            // XXX too many diff assertions and very flimsy assertion that this\n            // event was only emitted once.  think of a better way.\n            runnable.on('error', errorSpy).on('error', function (err) {\n              process.nextTick(function () {\n                expect(errorSpy, 'was called times', 1);\n                expect(\n                  err.message,\n                  'to match',\n                  /done\\(\\) called multiple times.+received error: Error: fail/\n                );\n                expect(callbackSpy, 'was called times', 1);\n                done();\n              });\n            });\n\n            runnable.run(callbackSpy);\n          });\n        });\n      });\n\n      describe('when an exception is thrown', function () {\n        it('should invoke the callback', function (done) {\n          var runnable = new Runnable(\n            'foo',\n            sinon.stub().throws('Error', 'fail')\n          );\n\n          runnable.run(function (err) {\n            expect(err.message, 'to be', 'fail');\n            done();\n          });\n        });\n\n        it('should not throw its own exception if passed a non-object', function (done) {\n          var runnable = new Runnable('foo', function (done) {\n            /* eslint no-throw-literal: off */\n            throw null;\n          });\n\n          runnable.run(function (err) {\n            expect(err.message, 'to be', Runnable.toValueOrError().message);\n            done();\n          });\n        });\n      });\n\n      describe('when an exception is thrown and is allowed to remain uncaught', function () {\n        it('throws an error when it is allowed', function (done) {\n          var runnable = new Runnable('foo', function (done) {\n            throw new Error('fail');\n          });\n          runnable.allowUncaught = true;\n\n          function fail() {\n            runnable.run(function () {});\n          }\n          expect(fail, 'to throw', 'fail');\n          done();\n        });\n      });\n\n      describe('when an error is passed', function () {\n        it('should invoke the callback', function (done) {\n          var runnable = new Runnable('foo', function (done) {\n            done(new Error('fail'));\n          });\n\n          runnable.run(function (err) {\n            expect(err.message, 'to be', 'fail');\n            done();\n          });\n        });\n      });\n\n      describe('when done() is invoked with a non-Error object', function () {\n        it('should invoke the callback', function (done) {\n          var runnable = new Runnable('foo', function (done) {\n            done({\n              error: 'Test error'\n            });\n          });\n\n          runnable.run(function (err) {\n            expect(\n              err.message,\n              'to be',\n              'done() invoked with non-Error: {\"error\":\"Test error\"}'\n            );\n            done();\n          });\n        });\n      });\n\n      describe('when done() is invoked with a string', function () {\n        it('should invoke the callback', function (done) {\n          var runnable = new Runnable('foo', function (done) {\n            done('Test error');\n          });\n\n          runnable.run(function (err) {\n            expect(\n              err.message,\n              'to be',\n              'done() invoked with non-Error: Test error'\n            );\n            done();\n          });\n        });\n      });\n\n      it('should allow updating the timeout', function (done) {\n        var spy = sinon.spy();\n        var runnable = new Runnable('foo', function (done) {\n          setTimeout(spy, 1);\n          setTimeout(spy, 100);\n        });\n        runnable.timeout(50);\n        runnable.run(function (err) {\n          expect(err, 'to be truthy');\n          expect(spy, 'was called times', 1);\n          done();\n        });\n      });\n\n      it('should allow a timeout of 0', function (done) {\n        const runnable = new Runnable('foo', () => {});\n        runnable.timeout(0);\n        runnable.run(err => {\n          expect(err, 'to be falsy');\n          done();\n        });\n      });\n    });\n\n    describe('when fn returns a promise', function () {\n      describe('when the promise is fulfilled with no value', function () {\n        var fulfilledPromise = {\n          then: function (fulfilled) {\n            setTimeout(fulfilled);\n          }\n        };\n\n        it('should invoke the callback', function (done) {\n          var runnable = new Runnable('foo', function () {\n            return fulfilledPromise;\n          });\n\n          runnable.run(function (err) {\n            expect(err, 'to be falsy');\n            done();\n          });\n        });\n      });\n\n      describe('when the promise is fulfilled with a value', function () {\n        var fulfilledPromise = {\n          then: function (fulfilled, rejected) {\n            setTimeout(function () {\n              fulfilled({});\n            });\n          }\n        };\n\n        it('should invoke the callback', function (done) {\n          var runnable = new Runnable('foo', function () {\n            return fulfilledPromise;\n          });\n\n          runnable.run(function (err) {\n            expect(err, 'to be falsy');\n            done();\n          });\n        });\n      });\n\n      describe('when the promise is rejected', function () {\n        var expectedErr = new Error('fail');\n        var rejectedPromise = {\n          then: function (fulfilled, rejected) {\n            setTimeout(function () {\n              rejected(expectedErr);\n            });\n          }\n        };\n\n        it('should invoke the callback', function (done) {\n          var runnable = new Runnable('foo', function () {\n            return rejectedPromise;\n          });\n\n          runnable.run(function (err) {\n            expect(err, 'to be', expectedErr);\n            done();\n          });\n        });\n      });\n\n      describe('when the promise is rejected without a reason', function () {\n        var expectedErr = new Error('Promise rejected with no or falsy reason');\n        var rejectedPromise = {\n          then: function (fulfilled, rejected) {\n            setTimeout(function () {\n              rejected();\n            });\n          }\n        };\n\n        it('should invoke the callback', function (done) {\n          var runnable = new Runnable('foo', function () {\n            return rejectedPromise;\n          });\n\n          runnable.run(function (err) {\n            expect(err.message, 'to be', expectedErr.message);\n            done();\n          });\n        });\n      });\n\n      describe('when the promise takes too long to settle', function () {\n        var foreverPendingPromise = {\n          then: function () {}\n        };\n\n        it('should throw the timeout error', function (done) {\n          var runnable = new Runnable('foo', function () {\n            return foreverPendingPromise;\n          });\n          runnable.file = '/some/path';\n\n          runnable.timeout(10);\n          runnable.run(function (err) {\n            expect(err, 'to satisfy', {code: TIMEOUT, timeout: 10});\n            done();\n          });\n        });\n      });\n    });\n\n    describe('when fn returns a non-promise', function () {\n      it('should invoke the callback', function (done) {\n        var runnable = new Runnable('foo', function () {\n          return {\n            then: 'i ran my tests'\n          };\n        });\n\n        runnable.run(done);\n      });\n    });\n\n    describe('if timed-out', function () {\n      it('should ignore call to `done` and not execute callback again', function (done) {\n        var runnable = new Runnable('foo', function (done) {\n          setTimeout(done, 20);\n        });\n        runnable.timeout(10);\n        runnable.run(function (err) {\n          expect(err, 'to satisfy', {code: TIMEOUT, timeout: 10});\n          // timedOut is set *after* this callback is executed\n          process.nextTick(function () {\n            expect(runnable.timedOut, 'to be truthy');\n            done();\n          });\n        });\n      });\n    });\n\n    describe('if async', function () {\n      it('this.skip() should set runnable to pending', function (done) {\n        var runnable = new Runnable('foo', function (done) {\n          // normally \"this\" but it gets around having to muck with a context\n          runnable.skip();\n        });\n        runnable.run(function (err) {\n          expect(err, 'to be undefined');\n          expect(runnable.pending, 'to be true');\n          done();\n        });\n      });\n\n      it('this.skip() should halt synchronous execution', function (done) {\n        var aborted = true;\n        var runnable = new Runnable('foo', function (done) {\n          // normally \"this\" but it gets around having to muck with a context\n          runnable.skip();\n          /* istanbul ignore next */\n          aborted = false;\n        });\n        runnable.run(function () {\n          process.nextTick(function () {\n            expect(aborted, 'to be true');\n            done();\n          });\n        });\n      });\n    });\n\n    describe('when fn is not a function', function () {\n      it('should throw an error', function () {\n        var runnable = new Runnable('foo', 4);\n\n        runnable.run(function (err) {\n          expect(\n            err.message,\n            'to be',\n            'A runnable must be passed a function as its second argument.'\n          );\n        });\n      });\n    });\n  });\n\n  describe('#isFailed()', function () {\n    it('should return `true` if test has not failed', function () {\n      var runnable = new Runnable('foo', function () {});\n      // runner sets the state\n      runnable.run(function () {\n        expect(runnable.isFailed(), 'to be false');\n      });\n    });\n\n    it('should return `true` if test has failed', function () {\n      var runnable = new Runnable('foo', function () {});\n      // runner sets the state\n      runnable.state = STATE_FAILED;\n      runnable.run(function () {\n        expect(runnable.isFailed(), 'to be false');\n      });\n    });\n\n    it('should return `false` if test is pending', function () {\n      var runnable = new Runnable('foo', function () {});\n      // runner sets the state\n      runnable.isPending = function () {\n        return true;\n      };\n      runnable.run(function () {\n        expect(runnable.isFailed(), 'to be false');\n      });\n    });\n  });\n\n  describe('#resetTimeout()', function () {\n    it('should not time out if timeouts disabled after reset', function (done) {\n      var runnable = new Runnable('foo', function () {});\n      runnable.timeout(10);\n      runnable.resetTimeout();\n      runnable.timeout(0);\n      runnable.run();\n      setTimeout(function () {\n        expect(runnable.timedOut, 'to be', false);\n        done();\n      }, 20);\n    });\n  });\n\n  describe('static method', function () {\n    describe('toValueOrError', function () {\n      it('should return identity if parameter is truthy', function () {\n        expect(Runnable.toValueOrError('foo'), 'to be', 'foo');\n      });\n\n      it('should return an Error if parameter is falsy', function () {\n        expect(Runnable.toValueOrError(null), 'to be an', Error);\n      });\n    });\n  });\n\n  describe('interesting property', function () {\n    describe('id', function () {\n      it('should have a unique identifier', function () {\n        expect(new Runnable('foo', () => {}), 'to have property', 'id');\n      });\n\n      it('should have a permanent identifier', function () {\n        const runnable = new Runnable('foo', () => {});\n        expect(runnable.id, 'to be', runnable.id);\n      });\n    });\n  });\n});"}
{"prompt":"Runner, function  {","test":"'use strict';\n\nconst path = require('node:path');\nconst sinon = require('sinon');\nconst Mocha = require('../../lib/mocha');\nconst Pending = require('../../lib/pending');\nconst {Suite, Runner, Test, Hook, Runnable} = Mocha;\nconst {noop} = Mocha.utils;\nconst {FATAL, MULTIPLE_DONE, UNSUPPORTED} =\n  require('../../lib/errors').constants;\n\nconst {\n  EVENT_HOOK_BEGIN,\n  EVENT_HOOK_END,\n  EVENT_TEST_FAIL,\n  EVENT_TEST_PASS,\n  EVENT_TEST_RETRY,\n  EVENT_TEST_END,\n  EVENT_RUN_END,\n  EVENT_SUITE_END,\n  STATE_IDLE,\n  STATE_RUNNING,\n  STATE_STOPPED\n} = Runner.constants;\nconst {STATE_FAILED} = Mocha.Runnable.constants;\n\ndescribe('Runner', function () {\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('instance method', function () {\n    let suite;\n    let runner;\n    beforeEach(function () {\n      suite = new Suite('Suite', 'root');\n      runner = new Runner(suite, {cleanReferencesAfterRun: true});\n      runner.checkLeaks = true;\n    });\n\n    describe('grep()', function () {\n      it('should update the runner.total with number of matched tests', function () {\n        suite.addTest(new Test('im a test about lions', noop));\n        suite.addTest(new Test('im another test about lions', noop));\n        suite.addTest(new Test('im a test about bears', noop));\n        var newRunner = new Runner(suite);\n        newRunner.grep(/lions/);\n        expect(newRunner.total, 'to be', 2);\n      });\n\n      it('should update the runner.total with number of matched tests when inverted', function () {\n        suite.addTest(new Test('im a test about lions', noop));\n        suite.addTest(new Test('im another test about lions', noop));\n        suite.addTest(new Test('im a test about bears', noop));\n        var newRunner = new Runner(suite);\n        newRunner.grep(/lions/, true);\n        expect(newRunner.total, 'to be', 1);\n      });\n    });\n\n    describe('grepTotal()', function () {\n      it('should return the total number of matched tests', function () {\n        suite.addTest(new Test('im a test about lions', noop));\n        suite.addTest(new Test('im another test about lions', noop));\n        suite.addTest(new Test('im a test about bears', noop));\n        runner.grep(/lions/);\n        expect(runner.grepTotal(suite), 'to be', 2);\n      });\n\n      it('should return the total number of matched tests when inverted', function () {\n        suite.addTest(new Test('im a test about lions', noop));\n        suite.addTest(new Test('im another test about lions', noop));\n        suite.addTest(new Test('im a test about bears', noop));\n        runner.grep(/lions/, true);\n        expect(runner.grepTotal(suite), 'to be', 1);\n      });\n    });\n    describe('globalProps()', function () {\n      it('should include common non enumerable globals', function () {\n        var props = runner.globalProps();\n        expect(\n          props,\n          'to contain',\n          'setTimeout',\n          'clearTimeout',\n          'setInterval',\n          'clearInterval',\n          'Date',\n          'XMLHttpRequest'\n        );\n      });\n    });\n\n    describe('globals()', function () {\n      it('should default to the known globals', function () {\n        expect(runner.globals().length, 'to be greater than', 16);\n      });\n\n      it('should white-list globals', function () {\n        runner.globals(['foo', 'bar']);\n        expect(runner.globals(), 'to contain', 'foo', 'bar');\n      });\n    });\n\n    describe('checkGlobals(test)', function () {\n      before(function () {\n        if (!Object.create) {\n          this.skip();\n        }\n      });\n\n      it('should allow variables that match a wildcard', function (done) {\n        runner.globals(['foo*', 'giz*']);\n        global.foo = 'baz';\n        global.gizmo = 'quux';\n        runner.checkGlobals();\n        delete global.foo;\n        delete global.gizmo;\n        done();\n      });\n\n      it('should emit \"fail\" when a new global is introduced', function (done) {\n        var test = new Test('im a test', noop);\n        runner.checkGlobals();\n        global.foo = 'bar';\n        runner.on(EVENT_TEST_FAIL, function (_test, _err) {\n          expect(_test, 'to be', test);\n          expect(_err, 'to have message', \"global leak(s) detected: 'foo'\");\n          delete global.foo;\n          done();\n        });\n        runner.checkGlobals(test);\n      });\n\n      it('should emit \"fail\" when a single new disallowed global is introduced after a single extra global is allowed', function (done) {\n        var doneCalled = false;\n        runner.globals('good');\n        global.bad = 1;\n        runner.on(EVENT_TEST_FAIL, function () {\n          delete global.bad;\n          done();\n          doneCalled = true;\n        });\n        runner.checkGlobals(new Test('yet another test', noop));\n        if (!doneCalled) {\n          done(Error('Expected test failure did not occur.'));\n        }\n      });\n\n      it('should not fail when a new common global is introduced', function () {\n        if (process.browser) {\n          this.skip();\n          return;\n        }\n        // verify that the prop isn't enumerable\n        expect(\n          Object.prototype.propertyIsEnumerable.call(global, 'XMLHttpRequest'),\n          'to be',\n          false\n        );\n\n        // create a new runner and keep a reference to the test.\n        var test = new Test('im a test about bears', noop);\n        suite.addTest(test);\n        var newRunner = new Runner(suite);\n\n        // make the prop enumerable again.\n        global.XMLHttpRequest = noop;\n        expect(\n          Object.prototype.propertyIsEnumerable.call(global, 'XMLHttpRequest'),\n          'to be',\n          true\n        );\n\n        // verify the test hasn't failed.\n        newRunner.checkGlobals(test);\n        expect(test, 'not to have key', 'state');\n\n        // clean up our global space.\n        delete global.XMLHttpRequest;\n      });\n\n      it('should pluralize the error message when several are introduced', function (done) {\n        var test = new Test('im a test', noop);\n        runner.checkGlobals();\n        global.foo = 'bar';\n        global.bar = 'baz';\n        runner.on(EVENT_TEST_FAIL, function (_test, _err) {\n          expect(_test, 'to be', test);\n          expect(\n            _err.message,\n            'to be',\n            \"global leak(s) detected: 'foo', 'bar'\"\n          );\n          delete global.foo;\n          delete global.bar;\n          done();\n        });\n        runner.checkGlobals(test);\n      });\n\n      it('should respect per test whitelisted globals', function () {\n        var test = new Test('im a test about lions', noop);\n        test.globals(['foo']);\n\n        suite.addTest(test);\n        var runner = new Runner(suite);\n\n        global.foo = 'bar';\n\n        // verify the test hasn't failed.\n        runner.checkGlobals(test);\n        expect(test, 'not to have key', 'state');\n\n        delete global.foo;\n      });\n\n      it('should respect per test whitelisted globals but still detect other leaks', function (done) {\n        var test = new Test('im a test about lions', noop);\n        test.globals(['foo']);\n\n        suite.addTest(test);\n\n        global.foo = 'whitelisted';\n        global.bar = 'detect-me';\n        runner.on(EVENT_TEST_FAIL, function (_test, _err) {\n          expect(_test.title, 'to be', 'im a test about lions');\n          expect(_err, 'to have message', \"global leak(s) detected: 'bar'\");\n          delete global.foo;\n          delete global.bar;\n          done();\n        });\n        runner.checkGlobals(test);\n      });\n\n      it('should emit \"fail\" when a global beginning with \"d\" is introduced', function (done) {\n        global.derp = 'bar';\n        runner.on(EVENT_TEST_FAIL, function (_test, _err) {\n          expect(_test.title, 'to be', 'herp');\n          expect(_err, 'to have message', \"global leak(s) detected: 'derp'\");\n          delete global.derp;\n          done();\n        });\n        runner.checkGlobals(new Test('herp', noop));\n      });\n    });\n    describe('hook()', function () {\n      it('should execute hooks after failed test if suite bail is true', function (done) {\n        runner.fail(new Test('failed test', noop), new Error());\n        suite.bail(true);\n        suite.afterEach(function () {\n          suite.afterAll(function () {\n            done();\n          });\n        });\n        runner.hook('afterEach', noop);\n        runner.hook('afterAll', noop);\n      });\n\n      it('should augment hook title with current test title', function (done) {\n        var expectedHookTitle;\n        function assertHookTitle() {\n          expect(hook.title, 'to be', expectedHookTitle);\n        }\n        var failHook = false;\n        var hookError = new Error('failed hook');\n        suite.beforeEach(function () {\n          assertHookTitle();\n          if (failHook) {\n            throw hookError;\n          }\n        });\n        runner.on(EVENT_HOOK_BEGIN, assertHookTitle);\n        runner.on(EVENT_HOOK_END, assertHookTitle);\n        runner.on(EVENT_TEST_FAIL, assertHookTitle);\n        runner.on(EVENT_TEST_PASS, assertHookTitle);\n        var hook = suite._beforeEach[0];\n\n        suite.addTest(new Test('should behave', noop));\n        suite.addTest(new Test('should obey', noop));\n        runner.suite = suite;\n\n        runner.test = suite.tests[0];\n        expectedHookTitle = '\"before each\" hook for \"should behave\"';\n        runner.hook('beforeEach', function (err) {\n          if (err && err !== hookError) return done(err);\n\n          runner.test = suite.tests[1];\n          failHook = true;\n          expectedHookTitle = '\"before each\" hook for \"should obey\"';\n          runner.hook('beforeEach', function (err) {\n            if (err && err !== hookError) return done(err);\n            return done();\n          });\n        });\n      });\n    });\n\n    describe('fail()', function () {\n      it('should increment `Runner#failures`', function () {\n        expect(runner.failures, 'to be', 0);\n        runner.fail(new Test('one', noop), {});\n        expect(runner.failures, 'to be', 1);\n        runner.fail(new Test('two', noop), new Error());\n        expect(runner.failures, 'to be', 2);\n      });\n\n      it('should set `Test#state` to \"failed\"', function () {\n        var test = new Test('some test', noop);\n        runner.fail(test, 'some error');\n        expect(test.state, 'to be', STATE_FAILED);\n      });\n\n      it('should emit \"fail\"', function (done) {\n        var test = new Test('some other test', noop);\n        var err = {};\n        runner.on(EVENT_TEST_FAIL, function (_test, _err) {\n          expect(_test, 'to be', test);\n          expect(_err, 'to be an', Error);\n          expect(_err, 'not to be', {});\n          done();\n        });\n        runner.fail(test, err);\n      });\n\n      it('should emit a helpful message when failed with a string', function (done) {\n        var test = new Test('helpful test', noop);\n        var err = 'string';\n        runner.on(EVENT_TEST_FAIL, function (_test, _err) {\n          expect(_err, 'to be an', Error);\n          expect(\n            _err,\n            'to have message',\n            'the string \"string\" was thrown, throw an Error :)'\n          );\n          done();\n        });\n        runner.fail(test, err);\n      });\n\n      it('should emit a the error when failed with an Error instance', function (done) {\n        var test = new Test('a test', noop);\n        var err = new Error('an error message');\n        runner.on(EVENT_TEST_FAIL, function (_test, _err) {\n          expect(_err, 'to be an', Error);\n          expect(_err, 'to have message', 'an error message');\n          done();\n        });\n        runner.fail(test, err);\n      });\n\n      it('should emit the error when failed with an Error-like object', function (done) {\n        var test = new Test('a test', noop);\n        var err = {message: 'an error message'};\n        runner.on(EVENT_TEST_FAIL, function (_test, _err) {\n          expect(_err, 'not to be an', Error);\n          expect(_err.message, 'to be', 'an error message');\n          done();\n        });\n        runner.fail(test, err);\n      });\n\n      it('should emit a helpful message when failed with an Object', function (done) {\n        var test = new Test('a test', noop);\n        var err = {x: 1};\n        runner.on(EVENT_TEST_FAIL, function (_test, _err) {\n          expect(_err, 'to be an', Error);\n          expect(\n            _err,\n            'to have message',\n            'the object {\\n  \"x\": 1\\n} was thrown, throw an Error :)'\n          );\n          done();\n        });\n        runner.fail(test, err);\n      });\n\n      it('should emit a helpful message when failed with an Array', function (done) {\n        var test = new Test('a test', noop);\n        var err = [1, 2];\n        runner.on(EVENT_TEST_FAIL, function (_test, _err) {\n          expect(_err, 'to be an', Error);\n          expect(\n            _err,\n            'to have message',\n            'the array [\\n  1\\n  2\\n] was thrown, throw an Error :)'\n          );\n          done();\n        });\n        runner.fail(test, err);\n      });\n\n      it('should recover if the error stack is not writable', function (done) {\n        if (!Object.create) {\n          this.skip();\n          return;\n        }\n\n        var err = new Error('not evil');\n        Object.defineProperty(err, 'stack', {\n          value: err.stack\n        });\n        var test = new Test('a test', noop);\n\n        runner.on(EVENT_TEST_FAIL, function (_test, _err) {\n          expect(_err, 'to have message', 'not evil');\n          done();\n        });\n\n        runner.fail(test, err);\n      });\n\n      it('should return and not increment failures when test is pending', function () {\n        var test = new Test('a test');\n        suite.addTest(test);\n        test.pending = true;\n        runner.fail(test, new Error());\n        expect(runner.failures, 'to be', 0);\n      });\n\n      describe('when Runner has stopped', function () {\n        beforeEach(function () {\n          runner.state = STATE_STOPPED;\n        });\n\n        describe('when test is not pending', function () {\n          describe('when error is the \"multiple done\" variety', function () {\n            it('should throw the \"multiple done\" error', function () {\n              var test = new Test('test', function () {});\n              suite.addTest(test);\n              var err = new Error();\n              err.code = MULTIPLE_DONE;\n              expect(\n                function () {\n                  runner.fail(test, err);\n                },\n                'to throw',\n                err\n              );\n            });\n          });\n\n          describe('when error is not of the \"multiple done\" variety', function () {\n            it('should throw a \"fatal\" error', function () {\n              var test = new Test('test', function () {});\n              suite.addTest(test);\n              var err = new Error();\n              expect(\n                function () {\n                  runner.fail(test, err);\n                },\n                'to throw',\n                {\n                  code: FATAL\n                }\n              );\n            });\n          });\n        });\n      });\n      it('should increment .failures', function () {\n        expect(runner.failures, 'to be', 0);\n        var test1 = new Test('fail hook 1', noop);\n        var test2 = new Test('fail hook 2', noop);\n        suite.addTest(test1);\n        suite.addTest(test2);\n        runner.fail(test1, new Error('error1'));\n        expect(runner.failures, 'to be', 1);\n        runner.fail(test2, new Error('error2'));\n        expect(runner.failures, 'to be', 2);\n      });\n\n      it('should emit \"fail\"', function (done) {\n        var hook = new Hook();\n        hook.parent = suite;\n        var err = new Error('error');\n        runner.on(EVENT_TEST_FAIL, function (_hook, _err) {\n          expect(_hook, 'to be', hook);\n          expect(_err, 'to be', err);\n          done();\n        });\n        runner.fail(hook, err);\n      });\n\n      it('should not emit \"end\" if suite bail is not true', function (done) {\n        var hook = new Hook();\n        hook.parent = suite;\n        var err = new Error('error');\n        suite.bail(false);\n        expect(\n          function () {\n            runner.fail(hook, err);\n          },\n          'not to emit from',\n          hook,\n          EVENT_RUN_END\n        );\n        done();\n      });\n    });\n\n    describe('run()', function () {\n      it('should emit \"retry\" when a retryable test fails', function (done) {\n        var retries = 2;\n        var retryableFails = 0;\n        var err = new Error('bear error');\n\n        var test = new Test('im a test about bears', function () {\n          if (retryableFails < retries) {\n            throw err;\n          }\n        });\n\n        suite.retries(retries);\n        suite.addTest(test);\n\n        runner.on(EVENT_TEST_RETRY, function (testClone, testErr) {\n          retryableFails += 1;\n          expect(testClone.title, 'to be', test.title);\n          expect(testErr, 'to be', err);\n        });\n\n        runner.run(function (failures) {\n          expect(failures, 'to be', 0);\n          expect(retryableFails, 'to be', retries);\n\n          done();\n        });\n      });\n\n      // karma-mocha is inexplicably doing this with a Hook\n      it('should not throw an exception if something emits EVENT_TEST_END with a non-Test object', function () {\n        expect(function () {\n          runner.emit(EVENT_TEST_END, {});\n        }, 'not to throw');\n      });\n\n      it('should clean references after a run', function () {\n        runner = new Runner(suite, {\n          delay: false,\n          cleanReferencesAfterRun: true\n        });\n        var cleanReferencesStub = sinon.stub(suite, 'cleanReferences');\n        runner.run();\n        runner.emit(EVENT_SUITE_END, suite);\n        expect(cleanReferencesStub, 'was called once');\n      });\n\n      it('should not clean references after a run when `cleanReferencesAfterRun` is `false`', function () {\n        runner = new Runner(suite, {\n          delay: false,\n          cleanReferencesAfterRun: false\n        });\n        var cleanReferencesStub = sinon.stub(suite, 'cleanReferences');\n        runner.run();\n        runner.emit(EVENT_SUITE_END, suite);\n        expect(cleanReferencesStub, 'was not called');\n      });\n\n      it('should not leak `Process.uncaughtException` listeners', function (done) {\n        var normalUncaughtExceptionListenerCount =\n          process.listenerCount('uncaughtException');\n\n        runner.run();\n        runner.run();\n        runner.run();\n        expect(\n          process.listenerCount('uncaughtException'),\n          'to be',\n          normalUncaughtExceptionListenerCount + 1\n        );\n        done();\n      });\n\n      describe('stack traces', function () {\n        var stack = [\n          'AssertionError: foo bar',\n          'at EventEmitter.<anonymous> (/usr/local/dev/test.js:16:12)',\n          'at Context.<anonymous> (/usr/local/dev/test.js:19:5)',\n          'Test.Runnable.run (/usr/local/lib/node_modules/mocha/lib/runnable.js:244:7)',\n          'Runner.runTest (/usr/local/lib/node_modules/mocha/lib/runner.js:374:10)',\n          '/usr/local/lib/node_modules/mocha/lib/runner.js:452:12',\n          'next (/usr/local/lib/node_modules/mocha/lib/runner.js:299:14)',\n          '/usr/local/lib/node_modules/mocha/lib/runner.js:309:7',\n          'next (/usr/local/lib/node_modules/mocha/lib/runner.js:248:23)',\n          'Immediate._onImmediate (/usr/local/lib/node_modules/mocha/lib/runner.js:276:5)',\n          'at processImmediate [as _immediateCallback] (timers.js:321:17)'\n        ];\n\n        before(function () {\n          // Only for Node running on Windows\n          if (process.platform === 'win32') {\n            var addDrive = function (str) {\n              var drive = 'C:';\n              var pos = str.indexOf(path.posix.sep);\n              return pos !== -1\n                ? str.slice(0, pos) + drive + str.slice(pos)\n                : str;\n            };\n\n            var useWinPathSep = function (str) {\n              return str.split(path.posix.sep).join(path.win32.sep);\n            };\n\n            // Fake Windows pathnames in stacktrace\n            stack = stack.map(function (line) {\n              return useWinPathSep(addDrive(line));\n            });\n          }\n        });\n\n        describe('short', function () {\n          before(function () {\n            if (process.browser) {\n              this.skip();\n            }\n          });\n\n          it('should prettify the stack-trace', function (done) {\n            var hook = new Hook();\n            hook.parent = suite;\n            var err = new Error();\n            // Fake stack-trace\n            err.stack = stack.join('\\n');\n\n            runner.on(EVENT_TEST_FAIL, function (_hook, _err) {\n              expect(_err.stack, 'to be', stack.slice(0, 3).join('\\n'));\n              done();\n            });\n            runner.fail(hook, err);\n          });\n\n          it('should prettify stack-traces in error cause trail', function (done) {\n            var hook = new Hook();\n            hook.parent = suite;\n            var causeErr = new Error();\n            // Fake stack-trace\n            causeErr.stack = stack.join('\\n');\n            var err = new Error();\n            err.cause = causeErr;\n\n            runner.on(EVENT_TEST_FAIL, function (_hook, _err) {\n              expect(_err.cause.stack, 'to be', stack.slice(0, 3).join('\\n'));\n              done();\n            });\n            runner.fail(hook, err);\n          });\n        });\n\n        describe('long', function () {\n          it('should display the full stack-trace', function (done) {\n            var hook = new Hook();\n            hook.parent = suite;\n            var err = new Error();\n            // Fake stack-trace\n            err.stack = stack.join('\\n');\n            // Add --stack-trace option\n            runner.fullStackTrace = true;\n\n            runner.on(EVENT_TEST_FAIL, function (_hook, _err) {\n              expect(_err.stack, 'to be', stack.join('\\n'));\n              done();\n            });\n            runner.fail(hook, err);\n          });\n\n          it('should display full stack-traces in error cause trail', function (done) {\n            var hook = new Hook();\n            hook.parent = suite;\n            var causeErr = new Error();\n            // Fake stack-trace\n            causeErr.stack = stack.join('\\n');\n            var err = new Error();\n            err.cause = causeErr;\n            // Add --stack-trace option\n            runner.fullStackTrace = true;\n\n            runner.on(EVENT_TEST_FAIL, function (_hook, _err) {\n              expect(_err.cause.stack, 'to be', stack.join('\\n'));\n              done();\n            });\n            runner.fail(hook, err);\n          });\n        });\n\n        describe('ginormous', function () {\n          before(function () {\n            if (process.browser) {\n              this.skip();\n            }\n          });\n\n          // Generate 64k string\n          function genOverlongSingleLineMessage() {\n            var n = 8200;\n            var data = [];\n            data.length = n;\n            for (var i = 0; i < n; i++) {\n              data[i] = {a: 1};\n            }\n            return JSON.stringify(data);\n          }\n\n          // Generate 64k string\n          function genOverlongMultiLineMessage() {\n            var n = 1150;\n            var data = [];\n            data.length = n;\n            var str =\n              'Lorem ipsum dolor sit amet, consectetur adipiscing elit.';\n            for (var i = 0; i < n; i++) {\n              data[i] = str;\n            }\n            return data.join('\\n');\n          }\n\n          it('should not hang if overlong error message is single line', function (done) {\n            var hook = new Hook();\n            hook.parent = suite;\n            var message = genOverlongSingleLineMessage();\n            var err = new Error();\n            // Fake stack-trace\n            err.stack = [message].concat(stack).join('\\n');\n\n            runner.on(EVENT_TEST_FAIL, function (_hook, _err) {\n              var filteredErrStack = _err.stack.split('\\n').slice(1);\n              expect(\n                filteredErrStack.join('\\n'),\n                'to be',\n                stack.slice(0, 3).join('\\n')\n              );\n              done();\n            });\n            runner.fail(hook, err);\n          });\n\n          it('should not hang if overlong error message is multiple lines', function (done) {\n            var hook = new Hook();\n            hook.parent = suite;\n            var message = genOverlongMultiLineMessage();\n            var err = new Error();\n            // Fake stack-trace\n            err.stack = [message].concat(stack).join('\\n');\n\n            runner.on(EVENT_TEST_FAIL, function (_hook, _err) {\n              var filteredErrStack = _err.stack.split('\\n').slice(-3);\n              expect(\n                filteredErrStack.join('\\n'),\n                'to be',\n                stack.slice(0, 3).join('\\n')\n              );\n              done();\n            });\n            runner.fail(hook, err);\n          });\n        });\n      });\n    });\n\n    describe('runAsync()', function () {\n      beforeEach(function () {\n        sinon.stub(runner, 'run').callsArgWithAsync(0, 42).returnsThis();\n      });\n\n      it('should return a Promise with a failure count', async function () {\n        return expect(runner.runAsync(), 'to be fulfilled with', 42);\n      });\n\n      it('should pass through options to Runner#run', async function () {\n        await runner.runAsync({foo: 'bar'});\n        expect(runner.run, 'to have a call satisfying', [\n          expect.it('to be a function'),\n          {foo: 'bar'}\n        ]).and('was called once');\n      });\n    });\n\n    describe('dispose()', function () {\n      it('should remove all listeners from itself', function () {\n        runner.on('disposeShouldRemoveThis', noop);\n        runner.dispose();\n        expect(runner.listenerCount('disposeShouldRemoveThis'), 'to be', 0);\n      });\n\n      it('should remove \"error\" listeners from a test', function () {\n        var fn = sinon.stub();\n        runner.test = new Test('test for dispose', fn);\n        runner.runTest(noop);\n        // sanity check\n        expect(runner.test.listenerCount('error'), 'to be', 1);\n        runner.dispose();\n        expect(runner.test.listenerCount('error'), 'to be', 0);\n      });\n\n      it('should remove \"uncaughtException\" listeners from the process', function () {\n        var normalUncaughtExceptionListenerCount =\n          process.listenerCount('uncaughtException');\n        runner.run(noop);\n        // sanity check\n        expect(\n          process.listenerCount('uncaughtException'),\n          'to be',\n          normalUncaughtExceptionListenerCount + 1\n        );\n        runner.dispose();\n        expect(\n          process.listenerCount('uncaughtException'),\n          'to be',\n          normalUncaughtExceptionListenerCount\n        );\n      });\n    });\n\n    describe('runTest()', function () {\n      it('should return when no tests to run', function () {\n        runner.test = undefined;\n        expect(runner.runTest(noop), 'to be undefined');\n      });\n    });\n\n    describe('allowUncaught()', function () {\n      it('should allow unhandled errors to propagate through', function () {\n        var newRunner = new Runner(suite);\n        newRunner.allowUncaught = true;\n        newRunner.test = new Test('failing test', function () {\n          throw new Error('allow unhandled errors');\n        });\n        function fail() {\n          newRunner.runTest();\n        }\n        expect(fail, 'to throw', 'allow unhandled errors');\n      });\n\n      it('should not allow unhandled errors in sync hooks to propagate through', function (done) {\n        suite.beforeEach(function () {\n          throw new Error();\n        });\n        var runner = new Runner(suite);\n        runner.allowUncaught = false;\n\n        // We are monkey patching here with runner.once and a hook.run wrapper to effectively\n        // capture thrown errors within the event loop phase where Runner.immediately executes\n        runner.once(EVENT_HOOK_BEGIN, function (hook) {\n          var _run = hook.run;\n          hook.run = function (fn) {\n            function throwError() {\n              _run.call(hook, fn);\n            }\n            expect(throwError, 'not to throw');\n            done();\n          };\n        });\n\n        runner.hook('beforeEach', noop);\n      });\n\n      it('should allow unhandled errors in sync hooks to propagate through', function (done) {\n        suite.beforeEach(function () {\n          throw new Error('allow unhandled errors in sync hooks');\n        });\n        var runner = new Runner(suite);\n        runner.allowUncaught = true;\n\n        runner.once(EVENT_HOOK_BEGIN, function (hook) {\n          var _run = hook.run;\n          hook.run = function (fn) {\n            function throwError() {\n              _run.call(hook, fn);\n            }\n            var expected = 'allow unhandled errors in sync hooks';\n            expect(throwError, 'to throw', expected);\n            done();\n          };\n        });\n\n        runner.hook('beforeEach', noop);\n      });\n\n      it('async - should allow unhandled errors in hooks to propagate through', function (done) {\n        // the `done` argument, although unused, it triggers the async path\n        // see this.async in the Runnable constructor\n        suite.beforeEach(function (done) {\n          throw new Error('allow unhandled errors in async hooks');\n        });\n        var runner = new Runner(suite);\n        runner.allowUncaught = true;\n\n        runner.once(EVENT_HOOK_BEGIN, function (hook) {\n          var _run = hook.run;\n          hook.run = function (fn) {\n            function throwError() {\n              _run.call(hook, fn);\n            }\n            var expected = 'allow unhandled errors in async hooks';\n            expect(throwError, 'to throw', expected);\n            done();\n          };\n        });\n\n        runner.hook('beforeEach', noop);\n      });\n    });\n\n    describe('abort()', function () {\n      it('should set _abort property to true', function () {\n        runner.abort();\n        expect(runner._abort, 'to be true');\n      });\n\n      it('should return the Runner', function () {\n        expect(runner.abort(), 'to be', runner);\n      });\n    });\n\n    describe('_uncaught()', function () {\n      describe('when called with a non-Runner context', function () {\n        it('should throw', function () {\n          expect(runner._uncaught.bind({}), 'to throw', {\n            code: FATAL\n          });\n        });\n      });\n    });\n\n    describe('uncaught()', function () {\n      beforeEach(function () {\n        sinon.stub(runner, 'fail');\n      });\n\n      describe('when allow-uncaught is set to true', function () {\n        it('should propagate error and throw', function () {\n          if (process.browser) this.skip();\n\n          var err = new Error('should rethrow err');\n          runner.allowUncaught = true;\n          expect(\n            function () {\n              runner.uncaught(err);\n            },\n            'to throw',\n            'should rethrow err'\n          );\n        });\n      });\n\n      describe('when provided an object argument', function () {\n        describe('when argument is not an Error', function () {\n          var err;\n          beforeEach(function () {\n            err = {whatever: 'yolo'};\n          });\n\n          it('should fail with a transient Runnable and a new Error coerced from the object', function () {\n            runner.uncaught(err);\n\n            expect(runner.fail, 'to have all calls satisfying', [\n              expect.it('to be a', Runnable).and('to satisfy', {\n                parent: runner.suite,\n                title: /uncaught error outside test suite/i\n              }),\n              expect.it('to be an', Error).and('to satisfy', {\n                message: /throw an error/i,\n                uncaught: true\n              })\n            ]).and('was called once');\n          });\n        });\n\n        describe('when argument is a Pending', function () {\n          it('should ignore argument and return', function () {\n            var err = new Pending();\n            expect(runner.uncaught(err), 'to be undefined');\n          });\n        });\n\n        describe('when argument is an Error', function () {\n          var err;\n          beforeEach(function () {\n            err = new Error('sorry dave');\n          });\n\n          it('should add the \"uncaught\" property to the Error', function () {\n            runner.uncaught(err);\n            expect(err, 'to have property', 'uncaught', true);\n          });\n\n          describe('when no Runnables are running', function () {\n            beforeEach(function () {\n              delete runner.currentRunnable;\n            });\n\n            it('should fail with a transient Runnable and the error', function () {\n              runner.uncaught(err);\n\n              expect(runner.fail, 'to have all calls satisfying', [\n                expect.it('to be a', Runnable).and('to satisfy', {\n                  parent: runner.suite,\n                  title: /uncaught error outside test suite/i\n                }),\n                err\n              ]).and('was called once');\n            });\n\n            describe('when Runner is RUNNING', function () {\n              beforeEach(function () {\n                runner.state = STATE_RUNNING;\n              });\n\n              it('should not emit start/end events', function () {\n                expect(\n                  function () {\n                    runner.uncaught(err);\n                  },\n                  'not to emit from',\n                  runner,\n                  'start'\n                ).and('not to emit from', runner, 'end');\n              });\n            });\n\n            describe('when Runner is IDLE', function () {\n              beforeEach(function () {\n                runner.state = STATE_IDLE;\n              });\n\n              it('should emit start/end events for the benefit of reporters', function () {\n                expect(\n                  function () {\n                    runner.uncaught(err);\n                  },\n                  'to emit from',\n                  runner,\n                  'start'\n                ).and('to emit from', runner, 'end');\n              });\n            });\n\n            describe('when Runner is STOPPED', function () {\n              beforeEach(function () {\n                runner.state = STATE_STOPPED;\n              });\n\n              it('should not emit start/end events, since this presumably would have already happened', function () {\n                expect(\n                  function () {\n                    try {\n                      runner.uncaught(err);\n                    } catch (ignored) {}\n                  },\n                  'not to emit from',\n                  runner,\n                  'start'\n                ).and('not to emit from', runner, 'end');\n              });\n\n              it('should throw', function () {\n                expect(function () {\n                  runner.uncaught(err);\n                }, 'to throw');\n              });\n            });\n          });\n\n          describe('when a Runnable is running or has run', function () {\n            var runnable;\n            beforeEach(function () {\n              runnable = new Runnable();\n              runnable.parent = runner.suite;\n              sinon.stub(runnable, 'clearTimeout');\n              runner.currentRunnable = runnable;\n            });\n\n            it('should clear any pending timeouts', function () {\n              runnable.callback = sinon.fake();\n              runner.uncaught(err);\n              expect(runnable.clearTimeout, 'was called times', 1);\n            });\n\n            describe('when current Runnable has already failed', function () {\n              beforeEach(function () {\n                sinon.stub(runnable, 'isFailed').returns(true);\n              });\n\n              it('should not attempt to fail again', function () {\n                runner.uncaught(err);\n                expect(runner.fail, 'was not called');\n              });\n            });\n\n            describe('when current Runnable has been marked pending', function () {\n              beforeEach(function () {\n                sinon.stub(runnable, 'isPending').returns(true);\n              });\n\n              it('should attempt to fail', function () {\n                runner.uncaught(err);\n                expect(runner.fail, 'was called once');\n              });\n            });\n\n            describe('when the current Runnable has already passed', function () {\n              beforeEach(function () {\n                sinon.stub(runnable, 'isPassed').returns(true);\n              });\n\n              it('should fail with the current Runnable and the error', function () {\n                runner.uncaught(err);\n\n                expect(runner.fail, 'to have all calls satisfying', [\n                  expect.it('to be', runnable),\n                  err\n                ]).and('was called once');\n              });\n\n              it('should abort the runner without emitting end event', function () {\n                expect(\n                  function () {\n                    runner.uncaught(err);\n                  },\n                  'not to emit from',\n                  runner,\n                  'end'\n                );\n                expect(runner._abort, 'to be', true);\n              });\n            });\n\n            describe('when the current Runnable is still running', function () {\n              describe('when the current Runnable is a Test', function () {\n                beforeEach(function () {\n                  runnable = new Test('goomba', noop);\n                  runnable.parent = runner.suite;\n                  runner.currentRunnable = runnable;\n                  runnable.callback = sinon.fake();\n                });\n\n                it('should run callback(err) to handle failing and hooks', function () {\n                  runner.uncaught(err);\n\n                  expect(runner.fail, 'was not called');\n                  expect(runnable.callback, 'to have all calls satisfying', [\n                    err\n                  ]).and('was called once');\n                });\n\n                it('should not notify test has ended', function () {\n                  expect(\n                    function () {\n                      runner.uncaught(err);\n                    },\n                    'not to emit from',\n                    runner,\n                    EVENT_TEST_END\n                  );\n                });\n\n                it('should not notify run has ended', function () {\n                  expect(\n                    function () {\n                      runner.uncaught(err);\n                    },\n                    'not to emit from',\n                    runner,\n                    EVENT_RUN_END\n                  );\n                });\n              });\n\n              describe('when the current Runnable is a Hook', function () {\n                beforeEach(function () {\n                  runnable = new Hook();\n                  runnable.parent = runner.suite;\n                  runner.currentRunnable = runnable;\n                  runnable.callback = sinon.fake();\n                });\n\n                it('should run callback(err) to handle failing hook pattern', function () {\n                  runner.uncaught(err);\n\n                  expect(runner.fail, 'was not called');\n                  expect(runnable.callback, 'to have all calls satisfying', [\n                    err\n                  ]).and('was called once');\n                });\n\n                it('should not notify test has ended', function () {\n                  expect(\n                    function () {\n                      runner.uncaught(err);\n                    },\n                    'not to emit from',\n                    runner,\n                    EVENT_TEST_END\n                  );\n                });\n\n                it('should not notify run has ended', function () {\n                  expect(\n                    function () {\n                      runner.uncaught(err);\n                    },\n                    'not to emit from',\n                    runner,\n                    EVENT_RUN_END\n                  );\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n\n    describe('linkPartialObjects()', function () {\n      it('should return the Runner', function () {\n        expect(runner.linkPartialObjects(), 'to be', runner);\n      });\n    });\n\n    describe('isParallelMode()', function () {\n      it('should return false', function () {\n        expect(runner.isParallelMode(), 'to be false');\n      });\n    });\n\n    describe('workerReporter()', function () {\n      it('should throw', function () {\n        expect(() => runner.workerReporter(), 'to throw', {code: UNSUPPORTED});\n      });\n    });\n  });\n});"}
{"prompt":"serializer, function  {","test":"'use strict';\n\nconst sinon = require('sinon');\nconst {\n  serialize,\n  deserialize,\n  SerializableEvent,\n  SerializableWorkerResult\n} = require('../../lib/nodejs/serializer');\n\ndescribe('serializer', function () {\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('function', function () {\n    describe('serialize', function () {\n      describe('when passed a non-object value', function () {\n        it('should return the value', function () {\n          expect(serialize('knees & toes'), 'to be', 'knees & toes');\n        });\n      });\n\n      describe('when passed an object value', function () {\n        describe('w/o a `serialize` method', function () {\n          it('should return the value', function () {\n            const obj = {};\n            expect(serialize(obj), 'to be', obj);\n          });\n        });\n\n        describe('having a `serialize` method', function () {\n          it('should return the result of the `serialize` method', function () {\n            const serializedObj = {foo: 'bar'};\n            const obj = {serialize: sinon.stub().returns(serializedObj)};\n            expect(serialize(obj), 'to be', serializedObj);\n          });\n        });\n      });\n\n      describe('when not passed anything', function () {\n        it('should return `undefined`', function () {\n          expect(serialize(), 'to be undefined');\n        });\n      });\n    });\n\n    describe('deserialize', function () {\n      describe('when passed nothing', function () {\n        it('should return `undefined`', function () {\n          expect(deserialize(), 'to be undefined');\n        });\n      });\n\n      describe('when passed a non-object value', function () {\n        it('should return the value', function () {\n          expect(deserialize(500), 'to be', 500);\n        });\n      });\n\n      describe('when passed an object value which is not a SerializedWorkerResult', function () {\n        it('should return the value', function () {\n          const obj = {};\n          expect(deserialize(obj), 'to be', obj);\n        });\n      });\n\n      describe('when passed a SerializedWorkerResult object', function () {\n        // note that SerializedWorkerResult is an interface (typedef), not a class.\n\n        it('should return the result of `SerializableWorkerResult.deserialize` called on the value', function () {\n          const obj = Object.assign({}, SerializableWorkerResult.create());\n          sinon.stub(SerializableWorkerResult, 'deserialize').returns('butts');\n          deserialize(obj);\n          expect(\n            SerializableWorkerResult.deserialize,\n            'to have a call satisfying',\n            {\n              args: [obj],\n              returned: 'butts'\n            }\n          );\n        });\n      });\n    });\n  });\n\n  describe('SerializableEvent', function () {\n    describe('constructor', function () {\n      describe('when called without `eventName`', function () {\n        it('should throw \"invalid arg value\" error', function () {\n          expect(() => new SerializableEvent(), 'to throw', {\n            code: 'ERR_MOCHA_INVALID_ARG_TYPE'\n          });\n        });\n      });\n\n      describe('when called with a non-object `rawObject`', function () {\n        it('should throw \"invalid arg type\" error', function () {\n          expect(() => new SerializableEvent('blub', 'glug'), 'to throw', {\n            code: 'ERR_MOCHA_INVALID_ARG_TYPE'\n          });\n        });\n      });\n    });\n\n    describe('instance method', function () {\n      describe('serialize', function () {\n        it('should mutate the instance in-place', function () {\n          const evt = SerializableEvent.create('foo');\n          expect(evt.serialize(), 'to be', evt);\n        });\n\n        it('should freeze the instance', function () {\n          expect(\n            Object.isFrozen(SerializableEvent.create('foo').serialize()),\n            'to be true'\n          );\n        });\n\n        describe('when passed an object with a `serialize` method', function () {\n          it('should call the `serialize` method', function () {\n            const obj = {\n              serialize: sinon.stub()\n            };\n            SerializableEvent.create('some-event', obj).serialize();\n            expect(obj.serialize, 'was called once');\n          });\n        });\n\n        describe('when passed an object containing an object with a `serialize` method', function () {\n          it('should call the `serialize` method', function () {\n            const stub = sinon.stub();\n            const obj = {\n              nested: {\n                serialize: stub\n              }\n            };\n            SerializableEvent.create('some-event', obj).serialize();\n            expect(stub, 'was called once');\n          });\n        });\n\n        describe('when passed an object containing a non-`serialize` method', function () {\n          it('should remove the method', function () {\n            const obj = {\n              func: () => {}\n            };\n\n            expect(\n              SerializableEvent.create('some-event', obj).serialize(),\n              'to satisfy',\n              {\n                data: expect.it('not to have property', 'func')\n              }\n            );\n          });\n        });\n\n        describe('when passed an object containing an array', function () {\n          it('should serialize the array', function () {\n            const obj = {\n              list: [{herp: 'derp'}, {bing: 'bong'}]\n            };\n            expect(\n              SerializableEvent.create('some-event', obj).serialize(),\n              'to satisfy',\n              {data: {list: [{herp: 'derp'}, {bing: 'bong'}]}}\n            );\n          });\n        });\n\n        describe('when passed an error', function () {\n          it('should serialize the error', function () {\n            const obj = {};\n            const err = new Error('monkeypants');\n            expect(\n              SerializableEvent.create('some-event', obj, err).serialize(),\n              'to satisfy',\n              {\n                eventName: 'some-event',\n                error: {\n                  message: 'monkeypants',\n                  stack: /^Error: monkeypants/,\n                  __type: 'Error'\n                },\n                data: obj\n              }\n            );\n          });\n\n          it('should retain own props', function () {\n            const obj = {};\n            const err = new Error('monkeypants');\n            err.code = 'MONKEY';\n            expect(\n              SerializableEvent.create('some-event', obj, err).serialize(),\n              'to satisfy',\n              {\n                eventName: 'some-event',\n                error: {\n                  code: 'MONKEY',\n                  message: 'monkeypants',\n                  stack: /^Error: monkeypants/,\n                  __type: 'Error'\n                },\n                data: obj\n              }\n            );\n          });\n\n          it('should not retain not-own props', function () {\n            const obj = {};\n            const err = new Error('monkeypants');\n            // eslint-disable-next-line no-proto\n            err.__proto__.code = 'MONKEY';\n            expect(\n              SerializableEvent.create('some-event', obj, err).serialize(),\n              'to satisfy',\n              {\n                eventName: 'some-event',\n                error: {\n                  message: 'monkeypants',\n                  stack: /^Error: monkeypants/,\n                  __type: 'Error'\n                },\n                data: obj\n              }\n            );\n          });\n        });\n\n        describe('when passed an object containing a top-level prop with an Error value', function () {\n          it('should serialize the Error', function () {\n            const obj = {\n              monkeyError: new Error('pantsmonkey')\n            };\n            const evt = SerializableEvent.create('some-event', obj);\n            expect(evt.serialize(), 'to satisfy', {\n              eventName: 'some-event',\n              data: {\n                monkeyError: {\n                  message: 'pantsmonkey',\n                  stack: /^Error: pantsmonkey/,\n                  __type: 'Error'\n                }\n              }\n            });\n          });\n        });\n        describe('when passed an object containing a nested prop with an Error value', function () {\n          it('should serialize the Error', function () {\n            const obj = {\n              nestedObj: {\n                monkeyError: new Error('pantsmonkey')\n              }\n            };\n            const evt = SerializableEvent.create('some-event', obj);\n            expect(evt.serialize(), 'to satisfy', {\n              eventName: 'some-event',\n              data: {\n                nestedObj: {\n                  monkeyError: {\n                    message: 'pantsmonkey',\n                    stack: /^Error: pantsmonkey/,\n                    __type: 'Error'\n                  }\n                }\n              }\n            });\n          });\n        });\n      });\n    });\n\n    describe('static method', function () {\n      describe('deserialize', function () {\n        describe('when passed a falsy parameter', function () {\n          it('should throw \"invalid arg type\" error', function () {\n            expect(SerializableEvent.deserialize, 'to throw', {\n              code: 'ERR_MOCHA_INVALID_ARG_TYPE'\n            });\n          });\n        });\n\n        it('should return a new object w/ null prototype', function () {\n          const obj = {bob: 'bob'};\n          expect(SerializableEvent.deserialize(obj), 'to satisfy', obj)\n            .and('not to equal', obj)\n            .and('not to have property', 'constructor');\n        });\n\n        describe('when passed value contains `data` prop', function () {\n          it('should ignore __proto__', function () {\n            const obj = {\n              data: Object.create(null)\n            };\n            // eslint-disable-next-line no-proto\n            obj.data.__proto__ = {peaches: 'prunes'};\n\n            const expected = Object.assign(Object.create(null), {\n              data: Object.create(null)\n            });\n            expect(SerializableEvent.deserialize(obj), 'to equal', expected);\n          });\n\n          describe('when `data` prop contains a nested serialized Error prop', function () {\n            it('should create an Error instance from the nested serialized Error prop', function () {\n              const message = 'problems!';\n              const stack = 'problem instructions';\n              const code = 'EIEIO';\n              const expected = Object.assign(Object.create(null), {\n                data: {\n                  whoops: Object.assign(new Error(message), {\n                    stack,\n                    code\n                  })\n                }\n              });\n\n              expect(\n                SerializableEvent.deserialize({\n                  data: {\n                    whoops: {\n                      message,\n                      stack,\n                      code,\n                      __type: 'Error'\n                    }\n                  }\n                }),\n                'to equal',\n                expected\n              );\n            });\n          });\n        });\n\n        describe('when passed value contains an `error` prop', function () {\n          it('should create an Error instance from the prop', function () {\n            const message = 'problems!';\n            const stack = 'problem instructions';\n            const code = 'EIEIO';\n            const expected = Object.assign(Object.create(null), {\n              error: Object.assign(new Error(message), {\n                stack,\n                code\n              })\n            });\n\n            expect(\n              SerializableEvent.deserialize({\n                error: {\n                  message,\n                  stack,\n                  code,\n                  __type: 'Error'\n                }\n              }),\n              'to equal',\n              expected\n            );\n          });\n        });\n\n        describe('when passed value data contains a prop beginning with \"$$\"', function () {\n          let result;\n\n          beforeEach(function () {\n            result = SerializableEvent.deserialize({data: {$$foo: 'bar'}});\n          });\n          it('should create a new prop having a function value', function () {\n            expect(result, 'to satisfy', {\n              data: {\n                foo: expect.it('to be a function')\n              }\n            });\n          });\n\n          it('should create a new prop returning the original value', function () {\n            expect(result.data.foo(), 'to equal', 'bar');\n          });\n\n          it('should remove the prop with the \"$$\" prefix', function () {\n            expect(result, 'not to have property', '$$foo');\n          });\n        });\n\n        describe('when the value data contains a prop with an array value', function () {\n          beforeEach(function () {\n            sinon.spy(SerializableEvent, '_deserializeObject');\n          });\n\n          it('should deserialize each prop', function () {\n            const obj = {data: {foo: [{bar: 'baz'}]}};\n            SerializableEvent.deserialize(obj);\n            expect(\n              SerializableEvent._deserializeObject,\n              'to have a call satisfying',\n              {\n                args: [obj.data.foo, 0]\n              }\n            );\n          });\n        });\n      });\n\n      describe('create', function () {\n        it('should instantiate a SerializableEvent', function () {\n          expect(\n            SerializableEvent.create('some-event'),\n            'to be a',\n            SerializableEvent\n          );\n        });\n      });\n    });\n  });\n\n  describe('SerializableWorkerResult', function () {\n    describe('static method', function () {\n      describe('create', function () {\n        it('should return a new SerializableWorkerResult instance', function () {\n          expect(\n            SerializableWorkerResult.create(),\n            'to be a',\n            SerializableWorkerResult\n          );\n        });\n      });\n\n      describe('isSerializedWorkerResult', function () {\n        describe('when passed an instance', function () {\n          it('should return `true`', function () {\n            expect(\n              SerializableWorkerResult.isSerializedWorkerResult(\n                new SerializableWorkerResult()\n              ),\n              'to be true'\n            );\n          });\n        });\n\n        describe('when passed an object with an appropriate `__type` prop', function () {\n          it('should return `true`', function () {\n            // this is the most likely use-case, as the object is transmitted over IPC\n            // and loses its prototype\n            const original = new SerializableWorkerResult();\n            const clone = Object.assign({}, original);\n            expect(\n              SerializableWorkerResult.isSerializedWorkerResult(clone),\n              'to be true'\n            );\n          });\n        });\n\n        describe('when passed an object without an appropriate `__type` prop', function () {\n          it('should return `false`', function () {\n            expect(\n              SerializableWorkerResult.isSerializedWorkerResult({\n                mister: 'mister'\n              }),\n              'to be false'\n            );\n          });\n        });\n      });\n\n      describe('deserialize', function () {\n        beforeEach(function () {\n          sinon.stub(SerializableEvent, 'deserialize');\n        });\n\n        it('should call SerializableEvent#deserialize on each item in its `events` prop', function () {\n          const result = Object.assign(\n            {},\n            SerializableWorkerResult.create([\n              {eventName: 'foo'},\n              {eventName: 'bar'}\n            ])\n          );\n          SerializableWorkerResult.deserialize(result);\n          expect(SerializableEvent.deserialize, 'to have calls satisfying', [\n            {args: [{eventName: 'foo'}]},\n            {args: [{eventName: 'bar'}]}\n          ]);\n        });\n\n        it('should return the deserialized value', function () {\n          const result = Object.assign(\n            {},\n            SerializableWorkerResult.create([\n              {eventName: 'foo'},\n              {eventName: 'bar'}\n            ])\n          );\n          expect(\n            SerializableWorkerResult.deserialize(result),\n            'to equal',\n            result\n          );\n        });\n      });\n    });\n\n    describe('instance method', function () {\n      describe('serialize', function () {\n        it('should return a read-only value', function () {\n          expect(\n            Object.isFrozen(SerializableWorkerResult.create().serialize()),\n            'to be true'\n          );\n        });\n\n        it('should call `SerializableEvent#serialize` of each of its events', function () {\n          sinon.spy(SerializableEvent.prototype, 'serialize');\n          const events = [\n            SerializableEvent.create('foo'),\n            SerializableEvent.create('bar')\n          ];\n          SerializableWorkerResult.create(events).serialize();\n          expect(\n            SerializableEvent.prototype.serialize,\n            'to have calls satisfying',\n            [{thisValue: events[0]}, {thisValue: events[1]}]\n          );\n        });\n      });\n    });\n    describe('constructor', function () {\n      // the following two tests should be combined into one, but not sure how to express\n      // as a single assertion\n\n      it('should add a readonly `__type` prop', function () {\n        expect(\n          new SerializableWorkerResult(),\n          'to have readonly property',\n          '__type'\n        );\n      });\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nconst unexpected = require('unexpected');\n\nglobal.expect = unexpected\n  .clone()\n  .use(require('unexpected-sinon'))\n  .use(require('unexpected-eventemitter'))\n  .use(require('unexpected-map'))\n  .use(require('unexpected-set'))\n  .use(require('./assertions'));"}
{"prompt":"this reporter outputs test results, indenting two spaces per sue","test":"'use strict';\n\nconst Mocha = require('../../..');\nconst {\n  EVENT_RUN_BEGIN,\n  EVENT_RUN_END,\n  EVENT_TEST_FAIL,\n  EVENT_TEST_PASS,\n  EVENT_SUITE_BEGIN,\n  EVENT_SUITE_END\n} = Mocha.Runner.constants;\n\n// this reporter outputs test results, indenting two spaces per suite\nclass MyReporter {\n  constructor(runner) {\n    this._indents = 0;\n    const stats = runner.stats;\n\n    runner\n      .once(EVENT_RUN_BEGIN, () => {\n        console.log('start');\n      })\n      .on(EVENT_SUITE_BEGIN, () => {\n        this.increaseIndent();\n      })\n      .on(EVENT_SUITE_END, () => {\n        this.decreaseIndent();\n      })\n      .on(EVENT_TEST_PASS, test => {\n        // Test#fullTitle() returns the suite name(s)\n        // prepended to the test title\n        console.log(`${this.indent()}pass: ${test.fullTitle()}`);\n      })\n      .on(EVENT_TEST_FAIL, (test, err) => {\n        console.log(\n          `${this.indent()}fail: ${test.fullTitle()} - error: ${err.message}`\n        );\n      })\n      .once(EVENT_RUN_END, () => {\n        console.log(`end: ${stats.passes}/${stats.passes + stats.failures} ok`);\n      });\n  }\n\n  indent() {\n    return Array(this._indents).join('  ');\n  }\n\n  increaseIndent() {\n    this._indents++;\n  }\n\n  decreaseIndent() {\n    this._indents--;\n  }\n}\n\nmodule.exports = MyReporter;"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nvar Mocha = require('../../../lib/mocha');\nvar Test = Mocha.Test;\nvar EVENT_FILE_PRE_REQUIRE = Mocha.Suite.constants.EVENT_FILE_PRE_REQUIRE;\n\n/**\n * A simple UI that only exposes a single function: test\n */\nmodule.exports = Mocha.interfaces['simple-ui'] = function(suite) {\n  suite.on(EVENT_FILE_PRE_REQUIRE, function(\n    context,\n    file,\n    mocha\n  ) {\n    var common = require('../../../lib/interfaces/common')(\n      [suite],\n      context\n    );\n\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n\n    /**\n     * Describes a specification or test-case with the given `title`\n     * and callback `fn` acting as a thunk.\n     */\n    context.test = function(title, fn) {\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n\n      return test;\n    };\n  });\n};"}
{"prompt":"outer suite, function {","test":"'use strict';\nvar assert = require('assert');\n\ndescribe('outer suite', function() {\n  var runOrder = [];\n  before(function() {\n    runOrder.push('outer before');\n  });\n\n  it('should run test-1', function() {\n    runOrder.push('should run test-1');\n  });\n\n  describe('inner suite', function() {\n    before(function(done) {\n      runOrder.push('inner before');\n      var self = this;\n      setTimeout(function() {\n        self.skip();   // done() is not required\n      }, 0);\n    });\n\n    before(function() {\n      runOrder.push('inner before-2 should not run');\n    });\n\n    beforeEach(function() {\n      runOrder.push('beforeEach should not run');\n    });\n\n    afterEach(function() {\n      runOrder.push('afterEach should not run');\n    });\n\n    after(function() {\n      runOrder.push('inner after');\n    });\n\n    it('should not run this test', function() {\n      throw new Error('inner suite test should not run');\n    });\n\n    describe('skipped suite', function() {\n      before(function() {\n        runOrder.push('skipped suite before should not run');\n      });\n\n      it('should not run this test', function() {\n        throw new Error('skipped suite test should not run');\n      });\n\n      after(function() {\n        runOrder.push('skipped suite after should not run');\n      });\n    });\n  });\n\n  it('should run test-2', function() {\n    runOrder.push('should run test-2');\n  });\n\n  after(function() {\n    runOrder.push('outer after');\n    assert.deepStrictEqual(runOrder, [\n      'outer before', \n      'should run test-1', 'should run test-2',\n      'inner before', 'inner after',\n      'outer after'\n    ]);\n    throw new Error('should throw this error');\n  });\n});"}
{"prompt":"skip in before with nested describes, function  {","test":"describe('skip in before with nested describes', function () {\n  before(function (done) {\n    var self = this;\n    setTimeout(function () {\n      self.skip();   // done() is not required\n    }, 0);\n  });\n\n  it('should never run this test', function () {\n    throw new Error('never run this test');\n  });\n\n  describe('nested describe', function () {\n    before(function () {\n      throw new Error('first level before should not run');\n    });\n\n    it('should never run this test', function () {\n      throw new Error('never run this test');\n    });\n\n    after(function () {\n      throw new Error('first level after should not run');\n    });\n\n    describe('nested again', function () {\n      before(function () {\n        throw new Error('second level before should not run');\n      });\n\n      it('should never run this test', function () {\n        throw new Error('never run this test');\n      });\n\n      after(function () {\n        throw new Error('second level after should not run');\n      });\n    });\n  });\n});"}
{"prompt":"outer describe, function  {","test":"'use strict';\n\ndescribe('outer describe', function () {\n  it('should run this test', function () {});\n\n  describe('skip in before', function () {\n    before(function (done) {\n      var self = this;\n      setTimeout(function () {\n        self.skip();   // done() is not required\n      }, 0);\n    });\n\n    it('should never run this test', function () {\n      throw new Error('never run this test');\n    });\n    it('should never run this test', function () {\n      throw new Error('never run this test');\n    });\n  });\n\n  it('should run this test', function () {});\n});"}
{"prompt":"skip in beforeEach, function {","test":"'use strict';\nvar assert = require('assert');\n\ndescribe('skip in beforeEach', function() {\n  var runOrder = [];\n  beforeEach(function(done) {\n    runOrder.push('beforeEach');\n    var self = this;\n    setTimeout(function() {\n      self.skip();   // done() is not required\n    }, 10);\n  });\n\n  it('should skip this test-1', function() {\n    throw new Error('never run this test');\n  });\n\n  describe('inner', function() {\n    beforeEach(function() {\n      runOrder.push('should not run');\n    });\n\n    it('should skip this test-2', function() {\n      throw new Error('never run this test');\n    });\n    it('should skip this test-3', function() {\n      throw new Error('never run this test');\n    });\n\n    afterEach(function() {\n      runOrder.push('should not run');\n    });\n  });\n\n  afterEach(function() {\n    runOrder.push('afterEach');\n  });\n  after(function() {\n    runOrder.push('after');\n    assert.deepStrictEqual(runOrder, [\n      'beforeEach', 'afterEach',\n      'beforeEach', 'afterEach',\n      'beforeEach', 'afterEach',\n      'after'\n    ]);\n    throw new Error('should throw this error');\n  });\n});"}
{"prompt":"skip in test, function  {","test":"'use strict';\nvar assert = require('assert');\n\ndescribe('skip in test', function () {\n  var runOrder = [];\n  beforeEach(function () {\n    runOrder.push('beforeEach');\n  });\n\n  it('should skip async', function (done) {\n    var self = this;\n    setTimeout(function () {\n      self.skip();   // done() is not required\n    }, 0);\n  });\n  it('should run other tests in suite', function () {});\n\n  afterEach(function() {\n    runOrder.push('afterEach');\n  });\n  after(function() {\n    runOrder.push('after');\n    assert.deepStrictEqual(runOrder, [\n      'beforeEach', 'afterEach',\n      'beforeEach', 'afterEach',\n      'after'\n    ]);\n    throw new Error('should throw this error');\n  });\n});"}
{"prompt":".skipforbid pending - suite marked with skip, function {};","test":"'use strict';\n\ndescribe.skip('forbid pending - suite marked with skip', function() {});"}
{"prompt":"a suite, function{","test":"'use strict';\n\ndescribe('a suite', function(){\n  describe.skip('skipped suite 1');\n  describe.skip('skipped suite 2');\n  describe('another suite', function(){\n    it('a test', function(){})\n  })\n});"}
{"prompt":"pending shorthand, function  {","test":"'use strict';\n\ndescribe('pending shorthand', function () {\n  xit('pending spec', function () {}).timeout(0);\n  xspecify('pending spec', function () {}).timeout(0);\n  it.skip('pending spec', function () {}).timeout(0);\n});"}
{"prompt":".skipforbid pending - suite marked with skip, function {","test":"'use strict';\n\ndescribe.skip('forbid pending - suite marked with skip', function() {\n  it('test1', function() {});\n});"}
{"prompt":"skip in after, function  {","test":"'use strict';\n\ndescribe('skip in after', function () {\n  it('should run this test-1', function () {});\n\n  after('should throw \"this.skip forbidden\"', function () {\n    this.skip();\n  });\n\n  describe('inner suite', function () {\n    it('should run this test-2', function () {});\n  });\n});\n\ndescribe('second suite', function () {\n  it('should run this test-3', function () {});\n});"}
{"prompt":"outer suite, function {","test":"'use strict';\nvar assert = require('assert');\n\ndescribe('outer suite', function() {\n  var runOrder = [];\n  before(function() {\n    runOrder.push('outer before');\n  });\n\n  it('should run test-1', function() {\n    runOrder.push('should run test-1');\n  });\n\n  describe('inner suite', function() {\n    before(function() {\n      runOrder.push('inner before');\n      this.skip();\n    });\n\n    before(function() {\n      runOrder.push('inner before-2 should not run');\n    });\n\n    beforeEach(function() {\n      runOrder.push('beforeEach should not run');\n    });\n\n    afterEach(function() {\n      runOrder.push('afterEach should not run');\n    });\n\n    after(function() {\n      runOrder.push('inner after');\n    });\n\n    it('should never run this test', function() {\n      throw new Error('inner suite test should not run');\n    });\n\n    describe('skipped suite', function() {\n      before(function() {\n        runOrder.push('skipped suite before should not run');\n      });\n\n      it('should never run this test', function() {\n        throw new Error('skipped suite test should not run');\n      });\n\n      after(function() {\n        runOrder.push('skipped suite after should not run');\n      });\n    });\n  });\n\n  it('should run test-2', function() {\n    runOrder.push('should run test-2');\n  });\n\n  after(function() {\n    runOrder.push('outer after');\n    assert.deepStrictEqual(runOrder, [\n      'outer before', \n      'should run test-1', 'should run test-2',\n      'inner before', 'inner after',\n      'outer after'\n    ]);\n    throw new Error('should throw this error');\n  });\n});"}
{"prompt":"outer suite, function {","test":"'use strict';\nvar assert = require('assert');\n\ndescribe('outer suite', function() {\n  var runOrder = [];\n  before(function() {\n    runOrder.push('outer before');\n    this.skip();\n  });\n\n  it('should never run this outer test', function() {\n    throw new Error('outer suite test should not run');\n  });\n\n  describe('inner suite', function() {\n    before(function() { runOrder.push('no inner before'); });\n    before(function(done) { runOrder.push('no inner before'); done(); });\n    before(async function() { runOrder.push('no inner before'); });\n    before(function() { return Promise.resolve(runOrder.push('no inner before')) });\n\n    after(function() { runOrder.push('no inner after'); });\n    after(function(done) { runOrder.push('no inner after'); done(); });\n    after(async function() { runOrder.push('no inner after'); });\n    after(function() { return Promise.resolve(runOrder.push('no inner after')) });\n\n    it('should never run this inner test', function() {\n      throw new Error('inner suite test should not run');\n    });\n  });\n\n  after(function() {\n    runOrder.push('outer after');\n    assert.deepStrictEqual(runOrder, [\n      'outer before', 'outer after'\n    ]);\n    throw new Error('should throw this error');\n  });\n});"}
{"prompt":"skip in before with nested describes, function  {","test":"'use strict';\n\ndescribe('skip in before with nested describes', function () {\n  before(function () {\n    this.skip();\n  });\n\n  it('should never run this test', function () {\n    throw new Error('never run this test');\n  });\n\n  describe('nested describe', function () {\n    before(function () {\n      throw new Error('first level before should not run');\n    });\n\n    it('should never run this test', function () {\n      throw new Error('never run this test');\n    });\n\n    after(function () {\n      throw new Error('first level after should not run');\n    });\n\n    describe('nested again', function () {\n      before(function () {\n        throw new Error('second level before should not run');\n      });\n\n      it('should never run this test', function () {\n        throw new Error('never run this test');\n      });\n\n      after(function () {\n        throw new Error('second level after should not run');\n      });\n    });\n  });\n});"}
{"prompt":"outer describe, function  {","test":"'use strict';\n\ndescribe('outer describe', function () {\n  it('should run this test', function () {});\n\n  describe('skip in before', function () {\n    before(function () {\n      this.skip();\n    });\n\n    it('should never run this test', function () {\n      throw new Error('never run this test');\n    });\n    it('should never run this test', function () {\n      throw new Error('never run this test');\n    });\n  });\n\n  it('should run this test', function () {});\n});"}
{"prompt":"skip conditionally in beforeEach, function {","test":"'use strict';\n\ndescribe('skip conditionally in beforeEach', function() {\n  var n = 1;\n  beforeEach(function() {\n    if (n !== 2) {\n        this.skip();\n    }\n  });\n\n  it('should skip this test-1', function() {\n    throw new Error('never run this test');\n  });\n  it('should run this test-2', function() {});\n\n  describe('inner suite', function() {\n    it('should skip this test-3', function() {\n      throw new Error('never run this test');\n    });\n  });\n\n  afterEach(function() { n++; });\n  after(function() {\n    if (n === 4) {\n      throw new Error('should throw this error');\n    }\n  });\n});"}
{"prompt":"skip in beforeEach, function {","test":"'use strict';\nvar assert = require('assert');\n\ndescribe('skip in beforeEach', function() {\n  var runOrder = [];\n  beforeEach(function() {\n    runOrder.push('beforeEach');\n    this.skip();\n  });\n\n  it('should skip this test-1', function() {\n    throw new Error('never run this test');\n  });\n\n  describe('inner', function() {\n    beforeEach(function() {\n      runOrder.push('should not run');\n    });\n\n    it('should skip this test-2', function() {\n      throw new Error('never run this test');\n    });\n    it('should skip this test-3', function() {\n      throw new Error('never run this test');\n    });\n\n    afterEach(function() {\n      runOrder.push('should not run');\n    });\n  });\n\n  afterEach(function() {\n    runOrder.push('afterEach');\n  });\n  after(function() {\n    runOrder.push('after');\n    assert.deepStrictEqual(runOrder, [\n      'beforeEach', 'afterEach',\n      'beforeEach', 'afterEach',\n      'beforeEach', 'afterEach',\n      'after'\n    ]);\n    throw new Error('should throw this error');\n  });\n});"}
{"prompt":"skip in test, function  {","test":"'use strict';\nvar assert = require('assert');\n\ndescribe('skip in test', function () {\n  var runOrder = [];\n  beforeEach(function () {\n    runOrder.push('beforeEach');\n  });\n\n  it('should skip immediately', function () {\n    this.skip();\n    throw new Error('never run this test');\n  });\n  it('should run other tests in suite', function () {});\n\n  afterEach(function() {\n    runOrder.push('afterEach');\n  });\n  after(function() {\n    runOrder.push('after');\n    assert.deepStrictEqual(runOrder, [\n      'beforeEach', 'afterEach',\n      'beforeEach', 'afterEach',\n      'after'\n    ]);\n    throw new Error('should throw this error');\n  });\n});"}
{"prompt":"forbid pending - test marked with skip, function {","test":"'use strict';\n\ndescribe('forbid pending - test marked with skip', function() {\n  it('test1', function() {});\n  it.skip('test2', function() {});\n  it('test3', function() {});\n});"}
{"prompt":"a suite, function {","test":"'use strict';\n\ndescribe('a suite', function() {\n  it('should succeed in 500ms', function(done) {\n    setTimeout(done, 500);\n  });\n\n  it('should succeed in 1.1s', function(done) {\n    setTimeout(done, 1100);\n  });\n});"}
{"prompt":"This test ensures Mochas dependencies are properly in place,","test":"'use strict';\n\n// This test ensures Mocha's dependencies are properly in place,\n// and is intended to be run after an `npm install --production` in a clean\n// working copy. It helps avoid publishing Mocha with `dependencies`\n// in `devDependencies` or otherwise in the wrong place.\n// It does not ensure that all files are present in the published package!\n\nvar assert = require('node:assert');\n\ndescribe('a production installation of Mocha', function () {\n  it('should be able to execute a test', function () {\n    assert.ok(true);\n  });\n});"}
{"prompt":"alpha, function  {","test":"'use strict';\n\ndescribe('alpha', function () {\n  it('should be executed first', function () {\n    if (global.beta) {\n      throw new Error('alpha was not executed first');\n    }\n  });\n});"}
{"prompt":"beta, function  {","test":"'use strict';\n\ndescribe('beta', function () {\n  it('should be executed second', function () {\n    global.beta = 1;\n  });\n});"}
{"prompt":"--sort, function  {","test":"'use strict';\n\nvar path = require('node:path').posix;\nvar helpers = require('../helpers');\nvar runMochaJSON = helpers.runMochaJSON;\n\ndescribe('--sort', function () {\n  var args = [];\n\n  before(function () {\n    args = ['--sort'];\n  });\n\n  it('should sort tests in alphabetical order', function (done) {\n    var fixtures = path.join('options', 'sort*');\n    runMochaJSON(fixtures, args, function (err, res) {\n      if (err) {\n        done(err);\n        return;\n      }\n      expect(res, 'to have passed test count', 2).and(\n        'to have passed test order',\n        'should be executed first'\n      );\n      done();\n    });\n  });\n});"}
{"prompt":"suite, function  {","test":"'use strict';\n\ndescribe('suite', function () {\n  it('pending spec');\n});"}
{"prompt":"Spec reporter, function  {","test":"'use strict';\n\nvar sinon = require('sinon');\nvar events = require('../../').Runner.constants;\nvar helpers = require('./helpers');\nvar reporters = require('../../').reporters;\n\nvar Base = reporters.Base;\nvar Spec = reporters.Spec;\nvar createMockRunner = helpers.createMockRunner;\nvar makeRunReporter = helpers.createRunReporterFunction;\n\nvar EVENT_SUITE_BEGIN = events.EVENT_SUITE_BEGIN;\nvar EVENT_TEST_FAIL = events.EVENT_TEST_FAIL;\nvar EVENT_TEST_PASS = events.EVENT_TEST_PASS;\nvar EVENT_TEST_PENDING = events.EVENT_TEST_PENDING;\n\ndescribe('Spec reporter', function () {\n  var runReporter = makeRunReporter(Spec);\n  var expectedTitle = 'expectedTitle';\n  var noop = function () {};\n\n  beforeEach(function () {\n    sinon.stub(Base, 'useColors').value(false);\n  });\n\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('event handlers', function () {\n    describe(\"on 'suite' event\", function () {\n      it('should return title', function () {\n        var suite = {\n          title: expectedTitle\n        };\n        var runner = createMockRunner(\n          'suite',\n          EVENT_SUITE_BEGIN,\n          null,\n          null,\n          suite\n        );\n        var options = {};\n        var stdout = runReporter({epilogue: noop}, runner, options);\n        sinon.restore();\n\n        var expectedArray = [expectedTitle + '\\n'];\n        expect(stdout, 'to equal', expectedArray);\n      });\n    });\n\n    describe(\"on 'pending' event\", function () {\n      it('should return title', function () {\n        var suite = {\n          title: expectedTitle\n        };\n        var runner = createMockRunner(\n          'pending test',\n          EVENT_TEST_PENDING,\n          null,\n          null,\n          suite\n        );\n        var options = {};\n        var stdout = runReporter({epilogue: noop}, runner, options);\n        sinon.restore();\n\n        var expectedArray = ['  - ' + expectedTitle + '\\n'];\n        expect(stdout, 'to equal', expectedArray);\n      });\n    });\n\n    describe(\"on 'pass' event\", function () {\n      describe('when test speed is slow', function () {\n        it('should return expected tick, title, and duration', function () {\n          var expectedDuration = 2;\n          var test = {\n            title: expectedTitle,\n            duration: expectedDuration,\n            slow: function () {\n              return 1;\n            }\n          };\n          var runner = createMockRunner(\n            'pass',\n            EVENT_TEST_PASS,\n            null,\n            null,\n            test\n          );\n          var options = {};\n          var stdout = runReporter({epilogue: noop}, runner, options);\n          sinon.restore();\n\n          var expectedString =\n            '  ' +\n            Base.symbols.ok +\n            ' ' +\n            expectedTitle +\n            ' (' +\n            expectedDuration +\n            'ms)' +\n            '\\n';\n          expect(stdout[0], 'to be', expectedString);\n        });\n      });\n\n      describe('when test speed is fast', function () {\n        it('should return expected tick, title without a duration', function () {\n          var expectedDuration = 1;\n          var test = {\n            title: expectedTitle,\n            duration: expectedDuration,\n            slow: function () {\n              return 2;\n            }\n          };\n          var runner = createMockRunner(\n            'pass',\n            EVENT_TEST_PASS,\n            null,\n            null,\n            test\n          );\n          var options = {};\n          var stdout = runReporter({epilogue: noop}, runner, options);\n          sinon.restore();\n\n          var expectedString =\n            '  ' + Base.symbols.ok + ' ' + expectedTitle + '\\n';\n          expect(stdout[0], 'to be', expectedString);\n        });\n      });\n    });\n\n    describe(\"on 'fail' event\", function () {\n      it('should return title and function count', function () {\n        var functionCount = 1;\n        var test = {\n          title: expectedTitle\n        };\n        var runner = createMockRunner(\n          'fail',\n          EVENT_TEST_FAIL,\n          null,\n          null,\n          test\n        );\n        var options = {};\n        var stdout = runReporter({epilogue: noop}, runner, options);\n        sinon.restore();\n\n        var expectedArray = [\n          '  ' + functionCount + ') ' + expectedTitle + '\\n'\n        ];\n        expect(stdout, 'to equal', expectedArray);\n      });\n    });\n  });\n});"}
{"prompt":"Wrapper suite, function  {","test":"var assert = require('assert');\n\ndescribe('Wrapper suite', function () {\n  for(let i=0; i < 400; i++) {\n    describe(`suite ${i}`, function () {\n      it(`test ${i}`, function () {\n        assert.equal(1, 1);\n      });\n    });\n  }\n});"}
{"prompt":"stackTraceFilter, function  {","test":"'use strict';\n\nvar path = require('node:path');\nvar utils = require('../../lib/utils');\n\ndescribe('stackTraceFilter()', function () {\n  describe('on node', function () {\n    var filter = utils.stackTraceFilter();\n\n    describe('on POSIX OS', function () {\n      before(function () {\n        if (path.sep !== '/') {\n          this.skip();\n        }\n      });\n\n      it('should get a stack-trace as a string and prettify it', function () {\n        var stack = [\n          'AssertionError: foo bar',\n          'at EventEmitter.<anonymous> (/usr/local/dev/test.js:16:12)',\n          'at Context.<anonymous> (/usr/local/dev/test.js:19:5)',\n          'Test.Runnable.run (/usr/local/lib/node_modules/mocha/lib/runnable.js:244:7)',\n          'Runner.runTest (/usr/local/lib/node_modules/mocha/lib/runner.js:374:10)',\n          '/usr/local/lib/node_modules/mocha/lib/runner.js:452:12',\n          'next (/usr/local/lib/node_modules/mocha/lib/runner.js:299:14)',\n          '/usr/local/lib/node_modules/mocha/lib/runner.js:309:7',\n          'next (/usr/local/lib/node_modules/mocha/lib/runner.js:248:23)',\n          'Immediate._onImmediate (/usr/local/lib/node_modules/mocha/lib/runner.js:276:5)',\n          'at processImmediate [as _immediateCallback] (timers.js:321:17)'\n        ];\n        expect(filter(stack.join('\\n')), 'to be', stack.slice(0, 3).join('\\n'));\n\n        stack = [\n          'AssertionError: bar baz',\n          'at /usr/local/dev/some-test-file.js:25:8',\n          'at tryCatcher (/usr/local/dev/own/tmp/node_modules/bluebird/js/main/util.js:24:31)',\n          'at Promise._resolveFromResolver (/usr/local/dev/own/tmp/node_modules/bluebird/js/main/promise.js:439:31)',\n          'at new Promise (/usr/local/dev/own/tmp/node_modules/bluebird/js/main/promise.js:53:37)',\n          'at yourFunction (/usr/local/dev/own/tmp/test1.js:24:13)',\n          'at Context.<anonymous> (/usr/local/dev/some-test-file:30:4)',\n          'Test.Runnable.run (/usr/local/lib/node_modules/mocha/lib/runnable.js:218:15)',\n          'next (/usr/local/lib/node_modules/mocha/lib/runner.js:248:23)',\n          'Immediate._onImmediate (/usr/local/lib/node_modules/mocha/lib/runner.js:276:5)',\n          'at processImmediate [as _immediateCallback] (timers.js:321:17)'\n        ];\n\n        expect(filter(stack.join('\\n')), 'to be', stack.slice(0, 7).join('\\n'));\n      });\n\n      it('does not ignore other bower_components and components', function () {\n        var stack = [\n          'Error: failed',\n          'at assert (index.html:11:26)',\n          'at Context.<anonymous> (test.js:17:18)',\n          'at bower_components/should/should.js:4827:7',\n          'at next (file:///.../bower_components/should/should.js:4766:23)',\n          'at components/should/5.0.0/should.js:4827:7',\n          'at next (file:///.../components/should/5.0.0/should.js:4766:23)',\n          'at file:///.../bower_components/mocha/mocha.js:4794:5',\n          'at timeslice (.../components/mocha/mocha.js:6218:27)',\n          'at Test.require.register.Runnable.run (file:///.../components/mochajs/mocha/2.1.0/mocha.js:4463:15)',\n          'at Runner.require.register.Runner.runTest (file:///.../components/mochajs/mocha/2.1.0/mocha.js:4892:10)',\n          'at file:///.../components/mochajs/mocha/2.1.0/mocha.js:4970:12',\n          'at next (file:///.../components/mochajs/mocha/2.1.0/mocha.js:4817:14)'\n        ];\n        expect(filter(stack.join('\\n')), 'to be', stack.slice(0, 7).join('\\n'));\n      });\n\n      it('should replace absolute with relative paths', function () {\n        var stack = [\n          'Error: ' + process.cwd() + '/bla.js has a problem',\n          'at foo (' + process.cwd() + '/foo/index.js:13:226)',\n          'at bar (/usr/local/dev/own/tmp/node_modules/bluebird/js/main/promise.js:11:26)'\n        ];\n\n        var expected = [\n          'Error: ' + process.cwd() + '/bla.js has a problem',\n          'at foo (foo/index.js:13:226)',\n          'at bar (/usr/local/dev/own/tmp/node_modules/bluebird/js/main/promise.js:11:26)'\n        ];\n\n        expect(filter(stack.join('\\n')), 'to be', expected.join('\\n'));\n      });\n\n      it('should not replace absolute path which has cwd as infix', function () {\n        var stack = [\n          'Error: /www' + process.cwd() + '/bla.js has a problem',\n          'at foo (/www' + process.cwd() + '/foo/index.js:13:226)',\n          'at bar (/usr/local/dev/own/tmp/node_modules/bluebird/js/main/promise.js:11:26)'\n        ];\n\n        var expected = [\n          'Error: /www' + process.cwd() + '/bla.js has a problem',\n          'at foo (/www' + process.cwd() + '/foo/index.js:13:226)',\n          'at bar (/usr/local/dev/own/tmp/node_modules/bluebird/js/main/promise.js:11:26)'\n        ];\n\n        expect(filter(stack.join('\\n')), 'to be', expected.join('\\n'));\n      });\n    });\n\n    describe('on Windows', function () {\n      before(function () {\n        if (path.sep === '/') {\n          this.skip();\n        }\n      });\n\n      it('should work on Windows', function () {\n        var stack = [\n          'Error: failed',\n          'at Context.<anonymous> (C:\\\\Users\\\\ishida\\\\src\\\\test\\\\test\\\\mytest.js:5:9)',\n          'at callFn (C:\\\\Users\\\\ishida\\\\src\\\\test\\\\node_modules\\\\mocha\\\\lib\\\\runnable.js:326:21)',\n          'at Test.Runnable.run (C:\\\\Users\\\\ishida\\\\src\\\\test\\\\node_modules\\\\mocha\\\\lib\\\\runnable.js:319:7)',\n          'at Runner.runTest (C:\\\\Users\\\\ishida\\\\src\\\\test\\\\node_modules\\\\mocha\\\\lib\\\\runner.js:422:10)',\n          'at C:\\\\Users\\\\ishida\\\\src\\\\test\\\\node_modules\\\\mocha\\\\lib\\\\runner.js:528:12',\n          'at next (C:\\\\Users\\\\ishida\\\\src\\\\test\\\\node_modules\\\\mocha\\\\lib\\\\runner.js:342:14)',\n          'at C:\\\\Users\\\\ishida\\\\src\\\\test\\\\node_modules\\\\mocha\\\\lib\\\\runner.js:352:7',\n          'at next (C:\\\\Users\\\\ishida\\\\src\\\\test\\\\node_modules\\\\mocha\\\\lib\\\\runner.js:284:14)',\n          'at Immediate._onImmediate (C:\\\\Users\\\\ishida\\\\src\\\\test\\\\node_modules\\\\mocha\\\\lib\\\\runner.js:320:5)'\n        ];\n        expect(filter(stack.join('\\n')), 'to be', stack.slice(0, 2).join('\\n'));\n      });\n    });\n  });\n\n  describe('on browser', function () {\n    var filter;\n    before(function () {\n      global.document = true;\n      global.location = {href: 'localhost:3000/foo/bar/index.html'};\n      filter = utils.stackTraceFilter();\n    });\n    it('does not strip out other bower_components', function () {\n      var stack = [\n        'Error: failed',\n        'at assert (index.html:11:26)',\n        'at Context.<anonymous> (test.js:17:18)',\n        'at bower_components/should/should.js:4827:7',\n        'at next (bower_components/should/should.js:4766:23)',\n        'at components/should/5.0.0/should.js:4827:7',\n        'at next (components/should/5.0.0/should.js:4766:23)',\n        'at Runner.require.register.Runner.runTest (node_modules/mocha.js:4892:10)',\n        'at localhost:3000/foo/bar/node_modules/mocha.js:4970:12',\n        'at next (node_modules/mocha.js:4817:14)'\n      ];\n      expect(filter(stack.join('\\n')), 'to be', stack.slice(0, 7).join('\\n'));\n    });\n\n    after(function () {\n      delete global.document;\n      delete global.location;\n    });\n  });\n});"}
{"prompt":"slow suite,  => {","test":"describe('slow suite', () => {\n  it('should be slow', (done) => {\n    setTimeout(200, done);\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\nconst Mocha = require('../../../../lib/mocha');\n\nconst mocha = new Mocha({ reporter: 'json' });\nmocha.addFile(require.resolve('./start-second-run-if-previous-is-still-running-suite.fixture.js'));\nmocha.run();\ntry {\n  mocha.run();\n} catch (err) {\n  console.error(err.code);\n}"}
{"prompt":"a suite without a callback;","test":"'use strict';\n\ndescribe('a suite without a callback');"}
{"prompt":"a suite returning a value, function  {","test":"'use strict';\n\ndescribe('a suite returning a value', function () {\n  return Promise.resolve();\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nxdescribe('a pending suite with a callback', function () {});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nxdescribe('a pending suite without a callback');"}
{"prompt":"eslint-disable-next-line no-extra-parens","test":"'use strict';\n\nconst Mocha = require('../../lib/mocha');\nconst {Suite, Test, Context} = Mocha;\nconst sinon = require('sinon');\nconst errors = require('../../lib/errors');\n\nfunction supportsFunctionNames() {\n  // eslint-disable-next-line no-extra-parens\n  return function foo() {}.name === 'foo';\n}\n\ndescribe('Suite', function () {\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('instance method', function () {\n    let suite;\n\n    describe('clone()', function () {\n      beforeEach(function () {\n        suite = new Suite('To be cloned', {}, true);\n        suite._timeout = 3043;\n        suite._slow = 101;\n        suite._bail = true;\n        suite.suites.push(1);\n        suite.tests.push('hello');\n        suite._beforeEach.push(2);\n        suite._beforeAll.push(3);\n        suite._afterEach.push(4);\n        suite._afterAll.push(5);\n      });\n\n      it('should clone the Suite, omitting children', function () {\n        expect(suite.clone(), 'to satisfy', {\n          title: 'To be cloned',\n          _timeout: 3043,\n          _slow: 101,\n          _bail: true,\n          suites: expect.it('to be empty'),\n          tests: expect.it('to be empty'),\n          _beforeEach: expect.it('to be empty'),\n          _beforeAll: expect.it('to be empty'),\n          _afterEach: expect.it('to be empty'),\n          _afterAll: expect.it('to be empty'),\n          root: true\n        }).and('not to be', suite);\n      });\n    });\n\n    describe('reset()', function () {\n      beforeEach(function () {\n        suite = new Suite('Suite to be reset', function () {});\n      });\n\n      it('should reset the `delayed` state', function () {\n        suite.delayed = true;\n        suite.reset();\n        expect(suite.delayed, 'to be', false);\n      });\n\n      it('should forward reset to suites and tests', function () {\n        const childSuite = new Suite('child suite', suite.context);\n        const test = new Test('test', function () {});\n        suite.addSuite(childSuite);\n        suite.addTest(test);\n        const testResetStub = sinon.stub(test, 'reset');\n        const suiteResetStub = sinon.stub(childSuite, 'reset');\n        suite.reset();\n        expect(testResetStub, 'was called once');\n        expect(suiteResetStub, 'was called once');\n      });\n\n      it('should forward reset to all hooks', function () {\n        suite.beforeEach(function () {});\n        suite.afterEach(function () {});\n        suite.beforeAll(function () {});\n        suite.afterAll(function () {});\n        sinon.stub(suite.getHooks('beforeEach')[0], 'reset');\n        sinon.stub(suite.getHooks('afterEach')[0], 'reset');\n        sinon.stub(suite.getHooks('beforeAll')[0], 'reset');\n        sinon.stub(suite.getHooks('afterAll')[0], 'reset');\n\n        suite.reset();\n\n        expect(suite.getHooks('beforeEach')[0].reset, 'was called once');\n        expect(suite.getHooks('afterEach')[0].reset, 'was called once');\n        expect(suite.getHooks('beforeAll')[0].reset, 'was called once');\n        expect(suite.getHooks('afterAll')[0].reset, 'was called once');\n      });\n    });\n\n    describe('timeout()', function () {\n      beforeEach(function () {\n        suite = new Suite('A Suite');\n      });\n\n      describe('when no argument is passed', function () {\n        it('should return the timeout value', function () {\n          expect(suite.timeout(), 'to be', 2000);\n        });\n      });\n\n      describe('when argument is passed', function () {\n        it('should return the Suite object', function () {\n          const newSuite = suite.timeout(5000);\n          expect(newSuite.timeout(), 'to be', 5000);\n        });\n      });\n    });\n\n    describe('slow()', function () {\n      beforeEach(function () {\n        suite = new Suite('A Suite');\n      });\n\n      describe('when given a string', function () {\n        it('should parse it', function () {\n          suite.slow('5 seconds');\n          expect(suite.slow(), 'to be', 5000);\n        });\n      });\n\n      describe('when no argument is passed', function () {\n        it('should return the slow value', function () {\n          expect(suite.slow(), 'to be', 75);\n        });\n      });\n\n      describe('when argument is passed', function () {\n        it('should return the Suite object', function () {\n          const newSuite = suite.slow(5000);\n          expect(newSuite.slow(), 'to be', 5000);\n        });\n      });\n    });\n\n    describe('bail()', function () {\n      beforeEach(function () {\n        suite = new Suite('A Suite');\n        suite._bail = true;\n      });\n\n      describe('when no argument is passed', function () {\n        it('should return the bail value', function () {\n          expect(suite.bail(), 'to be', true);\n        });\n      });\n\n      describe('when argument is passed', function () {\n        it('should return the Suite object', function () {\n          const newSuite = suite.bail(false);\n          expect(newSuite.bail(), 'to be', false);\n        });\n      });\n    });\n\n    describe('beforeAll()', function () {\n      beforeEach(function () {\n        suite = new Suite('A Suite');\n      });\n\n      describe('wraps the passed in function in a Hook', function () {\n        it('adds it to _beforeAll', function () {\n          const fn = function () {};\n          suite.beforeAll(fn);\n\n          expect(suite._beforeAll, 'to have length', 1);\n          const beforeAllItem = suite._beforeAll[0];\n          expect(beforeAllItem.title, 'to match', /^\"before all\" hook/);\n          expect(beforeAllItem.fn, 'to be', fn);\n        });\n\n        it('appends title to hook', function () {\n          const fn = function () {};\n          suite.beforeAll('test', fn);\n\n          expect(suite._beforeAll, 'to have length', 1);\n          const beforeAllItem = suite._beforeAll[0];\n          expect(beforeAllItem.title, 'to be', '\"before all\" hook: test');\n          expect(beforeAllItem.fn, 'to be', fn);\n        });\n\n        it('uses function name if available', function () {\n          if (!supportsFunctionNames()) {\n            this.skip();\n            return;\n          }\n          function namedFn() {}\n          suite.beforeAll(namedFn);\n          const beforeAllItem = suite._beforeAll[0];\n          expect(beforeAllItem.title, 'to be', '\"before all\" hook: namedFn');\n          expect(beforeAllItem.fn, 'to be', namedFn);\n        });\n      });\n    });\n\n    describe('afterAll()', function () {\n      beforeEach(function () {\n        suite = new Suite('A Suite');\n      });\n\n      describe('wraps the passed in function in a Hook', function () {\n        it('adds it to _afterAll', function () {\n          const fn = function () {};\n          suite.afterAll(fn);\n\n          expect(suite._afterAll, 'to have length', 1);\n          const afterAllItem = suite._afterAll[0];\n          expect(afterAllItem.title, 'to match', /^\"after all\" hook/);\n          expect(afterAllItem.fn, 'to be', fn);\n        });\n        it('appends title to hook', function () {\n          const fn = function () {};\n          suite.afterAll('test', fn);\n\n          expect(suite._afterAll, 'to have length', 1);\n          const beforeAllItem = suite._afterAll[0];\n          expect(beforeAllItem.title, 'to be', '\"after all\" hook: test');\n          expect(beforeAllItem.fn, 'to be', fn);\n        });\n\n        it('uses function name if available', function () {\n          if (!supportsFunctionNames()) {\n            this.skip();\n            return;\n          }\n          function namedFn() {}\n          suite.afterAll(namedFn);\n          const afterAllItem = suite._afterAll[0];\n          expect(afterAllItem.title, 'to be', '\"after all\" hook: namedFn');\n          expect(afterAllItem.fn, 'to be', namedFn);\n        });\n      });\n    });\n\n    describe('beforeEach()', function () {\n      let suite;\n\n      beforeEach(function () {\n        suite = new Suite('A Suite');\n      });\n\n      describe('wraps the passed in function in a Hook', function () {\n        it('adds it to _beforeEach', function () {\n          const fn = function () {};\n          suite.beforeEach(fn);\n\n          expect(suite._beforeEach, 'to have length', 1);\n          const beforeEachItem = suite._beforeEach[0];\n          expect(beforeEachItem.title, 'to match', /^\"before each\" hook/);\n          expect(beforeEachItem.fn, 'to be', fn);\n        });\n\n        it('appends title to hook', function () {\n          const fn = function () {};\n          suite.beforeEach('test', fn);\n\n          expect(suite._beforeEach, 'to have length', 1);\n          const beforeAllItem = suite._beforeEach[0];\n          expect(beforeAllItem.title, 'to be', '\"before each\" hook: test');\n          expect(beforeAllItem.fn, 'to be', fn);\n        });\n\n        it('uses function name if available', function () {\n          if (!supportsFunctionNames()) {\n            this.skip();\n            return;\n          }\n          function namedFn() {}\n          suite.beforeEach(namedFn);\n          const beforeEachItem = suite._beforeEach[0];\n          expect(beforeEachItem.title, 'to be', '\"before each\" hook: namedFn');\n          expect(beforeEachItem.fn, 'to be', namedFn);\n        });\n      });\n\n      describe('when the suite is pending', function () {\n        beforeEach(function () {\n          suite.pending = true;\n        });\n\n        it('should not create a hook', function () {\n          suite.beforeEach(function () {});\n          expect(suite._beforeEach, 'to be empty');\n        });\n      });\n    });\n\n    describe('afterEach()', function () {\n      beforeEach(function () {\n        suite = new Suite('A Suite');\n      });\n\n      describe('wraps the passed in function in a Hook', function () {\n        it('adds it to _afterEach', function () {\n          const fn = function () {};\n          suite.afterEach(fn);\n\n          expect(suite._afterEach, 'to have length', 1);\n          const afterEachItem = suite._afterEach[0];\n          expect(afterEachItem.title, 'to match', /^\"after each\" hook/);\n          expect(afterEachItem.fn, 'to be', fn);\n        });\n\n        it('appends title to hook', function () {\n          const fn = function () {};\n          suite.afterEach('test', fn);\n\n          expect(suite._afterEach, 'to have length', 1);\n          const beforeAllItem = suite._afterEach[0];\n          expect(beforeAllItem.title, 'to be', '\"after each\" hook: test');\n          expect(beforeAllItem.fn, 'to be', fn);\n        });\n\n        it('uses function name if available', function () {\n          if (!supportsFunctionNames()) {\n            this.skip();\n            return;\n          }\n          function namedFn() {}\n          suite.afterEach(namedFn);\n          const afterEachItem = suite._afterEach[0];\n          expect(afterEachItem.title, 'to be', '\"after each\" hook: namedFn');\n          expect(afterEachItem.fn, 'to be', namedFn);\n        });\n      });\n    });\n\n    describe('create()', function () {\n      let first;\n      let second;\n\n      before(function () {\n        first = new Suite('Root suite', {}, true);\n        second = new Suite('RottenRoot suite', {}, true);\n        first.addSuite(second);\n      });\n\n      it('does not create a second root suite', function () {\n        expect(second.parent, 'to be', first);\n        expect(first.root, 'to be', true);\n        expect(second.root, 'to be', false);\n      });\n\n      it('does not denote the root suite by being titleless', function () {\n        const emptyTitleSuite = Suite.create(second, '');\n        expect(emptyTitleSuite.parent, 'to be', second);\n        expect(emptyTitleSuite.root, 'to be', false);\n        expect(second.root, 'to be', false);\n      });\n    });\n\n    describe('addSuite()', function () {\n      let first;\n      let second;\n\n      beforeEach(function () {\n        first = new Suite('First suite');\n        first.timeout(4002);\n        first.slow(200);\n        second = new Suite('Second suite');\n        first.addSuite(second);\n      });\n\n      it('sets the parent on the added Suite', function () {\n        expect(second.parent, 'to be', first);\n      });\n\n      it('copies the timeout value', function () {\n        expect(second.timeout(), 'to be', 4002);\n      });\n\n      it('copies the slow value', function () {\n        expect(second.slow(), 'to be', 200);\n      });\n\n      it('adds the suite to the suites collection', function () {\n        expect(first.suites, 'to have length', 1);\n        expect(first.suites[0], 'to be', second);\n      });\n\n      it('treats suite as pending if its parent is pending', function () {\n        first.pending = true;\n        expect(second.isPending(), 'to be', true);\n      });\n    });\n\n    describe('addTest()', function () {\n      let test;\n\n      beforeEach(function () {\n        suite = new Suite('A Suite', new Context());\n        suite.timeout(4002);\n        test = new Test('test');\n        suite.addTest(test);\n      });\n\n      it('sets the parent on the added test', function () {\n        expect(test.parent, 'to be', suite);\n      });\n\n      it('copies the timeout value', function () {\n        expect(test.timeout(), 'to be', 4002);\n      });\n\n      it('adds the test to the tests collection', function () {\n        expect(suite.tests, 'to satisfy', [test]).and('to have length', 1);\n      });\n    });\n\n    describe('fullTitle()', function () {\n      beforeEach(function () {\n        suite = new Suite('A Suite');\n      });\n\n      describe('when there is no parent', function () {\n        it('returns the suite title', function () {\n          expect(suite.fullTitle(), 'to be', 'A Suite');\n        });\n      });\n\n      describe('when there is a parent', function () {\n        it(\"returns the combination of parent's and suite's title\", function () {\n          const parentSuite = new Suite('I am a parent');\n          parentSuite.addSuite(suite);\n          expect(suite.fullTitle(), 'to be', 'I am a parent A Suite');\n        });\n      });\n    });\n\n    describe('titlePath()', function () {\n      beforeEach(function () {\n        suite = new Suite('A Suite');\n      });\n\n      describe('when there is no parent', function () {\n        it('returns the suite title', function () {\n          expect(suite.titlePath(), 'to equal', ['A Suite']);\n        });\n      });\n\n      describe('when there is a parent', function () {\n        describe('the parent is the root suite', function () {\n          it('returns the suite title', function () {\n            const rootSuite = new Suite('', {}, true);\n            rootSuite.addSuite(suite);\n            expect(suite.titlePath(), 'to equal', ['A Suite']);\n          });\n        });\n\n        describe('the parent is not the root suite', function () {\n          it(\"returns the concatenation of parent's and suite's title\", function () {\n            const parentSuite = new Suite('I am a parent');\n            parentSuite.addSuite(suite);\n            expect(suite.titlePath(), 'to equal', ['I am a parent', 'A Suite']);\n          });\n        });\n      });\n    });\n\n    describe('total()', function () {\n      beforeEach(function () {\n        suite = new Suite('A Suite');\n      });\n\n      describe('when there are no nested suites or tests', function () {\n        it('should return 0', function () {\n          expect(suite.total(), 'to be', 0);\n        });\n      });\n\n      describe('when there are several tests in the suite', function () {\n        it('should return the number', function () {\n          suite.addTest(new Test('a child test'));\n          suite.addTest(new Test('another child test'));\n          expect(suite.total(), 'to be', 2);\n        });\n      });\n    });\n\n    describe('eachTest(fn)', function () {\n      beforeEach(function () {\n        suite = new Suite('A Suite');\n      });\n\n      describe('when there are no nested suites or tests', function () {\n        it('should return 0', function () {\n          let n = 0;\n          function fn() {\n            n++;\n          }\n          suite.eachTest(fn);\n          expect(n, 'to be', 0);\n        });\n      });\n\n      describe('when there are several tests in the suite', function () {\n        it('should return the number', function () {\n          suite.addTest(new Test('a child test'));\n          suite.addTest(new Test('another child test'));\n\n          let n = 0;\n          function fn() {\n            n++;\n          }\n          suite.eachTest(fn);\n          expect(n, 'to be', 2);\n        });\n      });\n\n      describe('when there are several levels of nested suites', function () {\n        it('should return the number', function () {\n          suite.addTest(new Test('a child test'));\n          const childSuite = new Suite('a child suite');\n          childSuite.addTest(new Test('a test in a child suite'));\n          suite.addSuite(childSuite);\n\n          let n = 0;\n          function fn() {\n            n++;\n          }\n          suite.eachTest(fn);\n          expect(n, 'to be', 2);\n        });\n      });\n    });\n\n    describe('constructor', function () {\n      beforeEach(function () {\n        sinon.stub(errors, 'deprecate');\n      });\n\n      /* eslint no-new: off */\n      it(\"should throw an error if the title isn't a string\", function () {\n        expect(function () {\n          new Suite(undefined, 'root');\n        }, 'to throw');\n\n        expect(function () {\n          new Suite(function () {}, 'root');\n        }, 'to throw');\n      });\n\n      it('should not throw if the title is a string', function () {\n        expect(function () {\n          new Suite('Bdd suite', 'root');\n        }, 'not to throw');\n      });\n    });\n\n    describe('timeout()', function () {\n      it('should convert a string to milliseconds', function () {\n        const suite = new Suite('some suite');\n        suite.timeout('100');\n        expect(suite.timeout(), 'to be', 100);\n      });\n    });\n\n    describe('hasOnly()', function () {\n      it('should return true if a test has `only`', function () {\n        const suite = new Suite('foo');\n        const test = new Test('bar');\n\n        suite.appendOnlyTest(test);\n\n        expect(suite.hasOnly(), 'to be', true);\n      });\n\n      it('should return true if a suite has `only`', function () {\n        const suite = new Suite('foo');\n        const nested = new Suite('bar');\n\n        suite.appendOnlySuite(nested);\n\n        expect(suite.hasOnly(), 'to be', true);\n      });\n\n      it('should return true if nested suite has `only`', function () {\n        const suite = new Suite('foo');\n        const nested = new Suite('bar');\n        const test = new Test('baz');\n\n        nested.appendOnlyTest(test);\n        // `nested` has a `only` test, but `suite` doesn't know about it\n        suite.suites.push(nested);\n\n        expect(suite.hasOnly(), 'to be', true);\n      });\n\n      it('should return false if no suite or test is marked `only`', function () {\n        const suite = new Suite('foo');\n        const nested = new Suite('bar');\n        const test = new Test('baz');\n\n        suite.suites.push(nested);\n        nested.tests.push(test);\n\n        expect(suite.hasOnly(), 'to be', false);\n      });\n    });\n\n    describe('filterOnly()', function () {\n      it('should filter out all other tests and suites if a test has `only`', function () {\n        const suite = new Suite('a');\n        const nested = new Suite('b');\n        const test = new Test('c');\n        const test2 = new Test('d');\n\n        suite.suites.push(nested);\n        suite.appendOnlyTest(test);\n        suite.tests.push(test2);\n\n        suite.filterOnly();\n\n        expect(suite, 'to satisfy', {\n          suites: expect.it('to be empty'),\n          tests: expect\n            .it('to have length', 1)\n            .and('to have an item satisfying', {title: 'c'})\n        });\n      });\n\n      it('should filter out all other tests and suites if a suite has `only`', function () {\n        const suite = new Suite('a');\n        const nested1 = new Suite('b');\n        const nested2 = new Suite('c');\n        const test = new Test('d');\n        const nestedTest = new Test('e');\n\n        nested1.appendOnlyTest(nestedTest);\n\n        suite.tests.push(test);\n        suite.suites.push(nested1);\n        suite.appendOnlySuite(nested1);\n        suite.suites.push(nested2);\n\n        suite.filterOnly();\n\n        expect(suite, 'to satisfy', {\n          suites: expect\n            .it('to have length', 1)\n            .and('to have an item satisfying', {title: 'b'}),\n          tests: expect.it('to be empty')\n        });\n      });\n    });\n\n    describe('markOnly()', function () {\n      it('should call appendOnlySuite on parent', function () {\n        const suite = new Suite('foo');\n        const spy = sinon.spy();\n        suite.parent = {\n          appendOnlySuite: spy\n        };\n        suite.markOnly();\n\n        expect(spy, 'to have a call exhaustively satisfying', [suite]).and(\n          'was called once'\n        );\n      });\n    });\n  });\n});\n\ndescribe('Test', function () {\n  describe('initialization', function () {\n    it(\"should throw an error if the title isn't a string\", function () {\n      expect(function () {\n        new Test(function () {});\n      }, 'to throw');\n\n      expect(() => {\n        new Test(undefined, function () {});\n      }, 'to throw');\n    });\n\n    it('should not throw if the title is a string', function () {\n      expect(function () {\n        new Test('test-case', function () {});\n      }, 'not to throw');\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"var foo ="}
{"prompt":"TAP reporter, function  {","test":"'use strict';\n\nvar events = require('../../').Runner.constants;\nvar helpers = require('./helpers');\nvar reporters = require('../../').reporters;\n\nvar TAP = reporters.TAP;\nvar createMockRunner = helpers.createMockRunner;\nvar makeRunReporter = helpers.createRunReporterFunction;\n\nvar EVENT_RUN_BEGIN = events.EVENT_RUN_BEGIN;\nvar EVENT_RUN_END = events.EVENT_RUN_END;\nvar EVENT_TEST_END = events.EVENT_TEST_END;\nvar EVENT_TEST_FAIL = events.EVENT_TEST_FAIL;\nvar EVENT_TEST_PASS = events.EVENT_TEST_PASS;\nvar EVENT_TEST_PENDING = events.EVENT_TEST_PENDING;\n\ndescribe('TAP reporter', function () {\n  var runReporter = makeRunReporter(TAP);\n  var expectedTitle = 'some title';\n  var countAfterTestEnd = 2;\n  var noop = function () {};\n\n  function createTest() {\n    return {\n      fullTitle: function () {\n        return expectedTitle;\n      },\n      slow: noop\n    };\n  }\n\n  describe('TAP12 spec', function () {\n    var options = {\n      reporterOptions: {\n        tapVersion: '12'\n      }\n    };\n\n    describe('event handlers', function () {\n      describe(\"on 'start' event\", function () {\n        var expectedSuite = 'some suite';\n        var stdout = [];\n\n        before(function () {\n          var runner = createMockRunner('start', EVENT_RUN_BEGIN);\n          runner.suite = expectedSuite;\n          stdout = runReporter({}, runner, options);\n        });\n\n        it('should not write a TAP specification version', function () {\n          expect(stdout, 'not to contain', 'TAP version');\n        });\n      });\n\n      describe(\"on 'pending' event\", function () {\n        var stdout = [];\n\n        before(function () {\n          var test = createTest();\n          var runner = createMockRunner(\n            'start test',\n            EVENT_TEST_END,\n            EVENT_TEST_PENDING,\n            null,\n            test\n          );\n          runner.suite = '';\n          stdout = runReporter({}, runner, options);\n        });\n\n        it('should write expected message including count and title', function () {\n          var expectedMessage =\n            'ok ' + countAfterTestEnd + ' ' + expectedTitle + ' # SKIP -\\n';\n          expect(stdout[0], 'to equal', expectedMessage);\n        });\n      });\n\n      describe(\"on 'pass' event\", function () {\n        var stdout;\n\n        before(function () {\n          var test = createTest();\n          var runner = createMockRunner(\n            'start test',\n            EVENT_TEST_END,\n            EVENT_TEST_PASS,\n            null,\n            test\n          );\n          runner.suite = '';\n          stdout = runReporter({}, runner, options);\n        });\n\n        it('should write expected message including count and title', function () {\n          var expectedMessage =\n            'ok ' + countAfterTestEnd + ' ' + expectedTitle + '\\n';\n          expect(stdout[0], 'to equal', expectedMessage);\n        });\n      });\n\n      describe(\"on 'fail' event\", function () {\n        var expectedErrorMessage = 'some error';\n        var expectedStack = 'some stack';\n\n        describe(\"when 'error' has only message\", function () {\n          var stdout;\n\n          before(function () {\n            var test = createTest();\n            var error = {\n              message: expectedErrorMessage\n            };\n            var runner = createMockRunner(\n              'test end fail',\n              EVENT_TEST_END,\n              EVENT_TEST_FAIL,\n              null,\n              test,\n              error\n            );\n            runner.on = function (event, callback) {\n              if (event === EVENT_TEST_END) {\n                callback();\n              } else if (event === EVENT_TEST_FAIL) {\n                callback(test, error);\n              }\n            };\n            runner.suite = '';\n            stdout = runReporter({}, runner, options);\n          });\n\n          it('should write expected message and error message', function () {\n            var expectedArray = [\n              'not ok ' + countAfterTestEnd + ' ' + expectedTitle + '\\n',\n              '  ' + expectedErrorMessage + '\\n'\n            ];\n            expect(stdout, 'to equal', expectedArray);\n          });\n        });\n\n        describe(\"when 'error' has only stack\", function () {\n          var stdout;\n\n          before(function () {\n            var test = createTest();\n            var error = {\n              stack: expectedStack\n            };\n            var runner = createMockRunner(\n              'test end fail',\n              EVENT_TEST_END,\n              EVENT_TEST_FAIL,\n              null,\n              test,\n              error\n            );\n            runner.suite = '';\n            stdout = runReporter({}, runner, options);\n          });\n\n          it('should write expected message and stack', function () {\n            var expectedArray = [\n              'not ok ' + countAfterTestEnd + ' ' + expectedTitle + '\\n',\n              '  ' + expectedStack + '\\n'\n            ];\n            expect(stdout, 'to equal', expectedArray);\n          });\n        });\n\n        describe(\"when 'error' has both message and stack\", function () {\n          var stdout;\n\n          before(function () {\n            var test = createTest();\n            var error = {\n              stack: expectedStack,\n              message: expectedErrorMessage\n            };\n            var runner = createMockRunner(\n              'test end fail',\n              EVENT_TEST_END,\n              EVENT_TEST_FAIL,\n              null,\n              test,\n              error\n            );\n            runner.on = function (event, callback) {\n              if (event === EVENT_TEST_END) {\n                callback();\n              } else if (event === EVENT_TEST_FAIL) {\n                callback(test, error);\n              }\n            };\n            runner.suite = '';\n            stdout = runReporter({}, runner, options);\n          });\n\n          it('should write expected message, error message, and stack', function () {\n            var expectedArray = [\n              'not ok ' + countAfterTestEnd + ' ' + expectedTitle + '\\n',\n              '  ' + expectedErrorMessage + '\\n',\n              '  ' + expectedStack + '\\n'\n            ];\n            expect(stdout, 'to equal', expectedArray);\n          });\n        });\n\n        describe(\"when 'error' has neither message nor stack\", function () {\n          var stdout;\n\n          before(function () {\n            var test = createTest();\n            var error = {};\n            var runner = createMockRunner(\n              'test end fail',\n              EVENT_TEST_END,\n              EVENT_TEST_FAIL,\n              null,\n              test,\n              error\n            );\n            runner.on = runner.once = function (event, callback) {\n              if (event === EVENT_TEST_END) {\n                callback();\n              } else if (event === EVENT_TEST_FAIL) {\n                callback(test, error);\n              }\n            };\n            runner.suite = '';\n            stdout = runReporter({}, runner, options);\n          });\n\n          it('should write expected message only', function () {\n            var expectedArray = [\n              'not ok ' + countAfterTestEnd + ' ' + expectedTitle + '\\n'\n            ];\n            expect(stdout, 'to equal', expectedArray);\n          });\n        });\n      });\n\n      describe(\"on 'end' event\", function () {\n        var stdout;\n\n        before(function () {\n          var test = createTest();\n          var runner = createMockRunner(\n            'fail end pass',\n            EVENT_TEST_FAIL,\n            EVENT_RUN_END,\n            EVENT_TEST_PASS,\n            test\n          );\n          runner.suite = '';\n          stdout = runReporter({}, runner, options);\n        });\n\n        it('should write total tests, passes, failures, & plan', function () {\n          var numberOfPasses = 1;\n          var numberOfFails = 1;\n          var totalTests = numberOfPasses + numberOfFails;\n          var expectedArray = [\n            'ok ' + numberOfPasses + ' ' + expectedTitle + '\\n',\n            'not ok ' + numberOfFails + ' ' + expectedTitle + '\\n',\n            '# tests ' + totalTests + '\\n',\n            '# pass ' + numberOfPasses + '\\n',\n            '# fail ' + numberOfFails + '\\n',\n            '1..' + totalTests + '\\n'\n          ];\n          expect(stdout, 'to equal', expectedArray);\n        });\n      });\n    });\n  });\n\n  describe('TAP13 spec', function () {\n    var options = {\n      reporterOptions: {\n        tapVersion: '13'\n      }\n    };\n\n    describe('event handlers', function () {\n      describe(\"on 'start' event\", function () {\n        var expectedSuite = 'some suite';\n        var stdout;\n\n        before(function () {\n          var runner = createMockRunner('start', EVENT_RUN_BEGIN);\n          runner.suite = expectedSuite;\n          stdout = runReporter({}, runner, options);\n        });\n\n        it('should write the TAP specification version', function () {\n          var tapVersion = options.reporterOptions.tapVersion;\n          var expectedFirstLine = 'TAP version ' + tapVersion + '\\n';\n          expect(stdout[0], 'to equal', expectedFirstLine);\n        });\n      });\n\n      describe(\"on 'pending' event\", function () {\n        var stdout;\n\n        before(function () {\n          var test = createTest();\n          var runner = createMockRunner(\n            'start test',\n            EVENT_TEST_END,\n            EVENT_TEST_PENDING,\n            null,\n            test\n          );\n          runner.suite = '';\n          stdout = runReporter({}, runner, options);\n        });\n\n        it('should write expected message including count and title', function () {\n          var expectedMessage =\n            'ok ' + countAfterTestEnd + ' ' + expectedTitle + ' # SKIP -\\n';\n          expect(stdout[0], 'to equal', expectedMessage);\n        });\n      });\n\n      describe(\"on 'pass' event\", function () {\n        var stdout;\n\n        before(function () {\n          var test = createTest();\n          var runner = createMockRunner(\n            'start test',\n            EVENT_TEST_END,\n            EVENT_TEST_PASS,\n            null,\n            test\n          );\n          runner.suite = '';\n          stdout = runReporter({}, runner, options);\n        });\n\n        it('should write expected message including count and title', function () {\n          var expectedMessage =\n            'ok ' + countAfterTestEnd + ' ' + expectedTitle + '\\n';\n          expect(stdout[0], 'to equal', expectedMessage);\n        });\n      });\n\n      describe(\"on 'fail' event\", function () {\n        var expectedErrorMessage = 'some error';\n        var expectedStack = 'some stack';\n\n        describe(\"when 'error' has only message\", function () {\n          var stdout;\n\n          before(function () {\n            var test = createTest();\n            var error = {\n              message: expectedErrorMessage\n            };\n            var runner = createMockRunner(\n              'test end fail',\n              EVENT_TEST_END,\n              EVENT_TEST_FAIL,\n              null,\n              test,\n              error\n            );\n            runner.on = function (event, callback) {\n              if (event === EVENT_TEST_END) {\n                callback();\n              } else if (event === EVENT_TEST_FAIL) {\n                callback(test, error);\n              }\n            };\n            runner.suite = '';\n            stdout = runReporter({}, runner, options);\n          });\n\n          it('should write expected message and error message', function () {\n            var expectedArray = [\n              'not ok ' + countAfterTestEnd + ' ' + expectedTitle + '\\n',\n              '  ---\\n',\n              '    message: |-\\n',\n              '      ' + expectedErrorMessage + '\\n',\n              '  ...\\n'\n            ];\n            expect(stdout, 'to equal', expectedArray);\n          });\n        });\n\n        describe(\"when 'error' has only stack\", function () {\n          var stdout;\n\n          before(function () {\n            var test = createTest();\n            var error = {\n              stack: expectedStack\n            };\n            var runner = createMockRunner(\n              'test end fail',\n              EVENT_TEST_END,\n              EVENT_TEST_FAIL,\n              null,\n              test,\n              error\n            );\n            runner.suite = '';\n            stdout = runReporter({}, runner, options);\n          });\n\n          it('should write expected message and stack', function () {\n            var expectedArray = [\n              'not ok ' + countAfterTestEnd + ' ' + expectedTitle + '\\n',\n              '  ---\\n',\n              '    stack: |-\\n',\n              '      ' + expectedStack + '\\n',\n              '  ...\\n'\n            ];\n            expect(stdout, 'to equal', expectedArray);\n          });\n        });\n\n        describe(\"when 'error' has both message and stack\", function () {\n          var stdout;\n\n          before(function () {\n            var test = createTest();\n            var error = {\n              stack: expectedStack,\n              message: expectedErrorMessage\n            };\n            var runner = createMockRunner(\n              'test end fail',\n              EVENT_TEST_END,\n              EVENT_TEST_FAIL,\n              null,\n              test,\n              error\n            );\n            runner.on = function (event, callback) {\n              if (event === EVENT_TEST_END) {\n                callback();\n              } else if (event === EVENT_TEST_FAIL) {\n                callback(test, error);\n              }\n            };\n            runner.suite = '';\n            stdout = runReporter({}, runner, options);\n          });\n\n          it('should write expected message, error message, and stack', function () {\n            var expectedArray = [\n              'not ok ' + countAfterTestEnd + ' ' + expectedTitle + '\\n',\n              '  ---\\n',\n              '    message: |-\\n',\n              '      ' + expectedErrorMessage + '\\n',\n              '    stack: |-\\n',\n              '      ' + expectedStack + '\\n',\n              '  ...\\n'\n            ];\n            expect(stdout, 'to equal', expectedArray);\n          });\n        });\n\n        describe(\"when 'error' has neither message nor stack\", function () {\n          var stdout;\n\n          before(function () {\n            var test = createTest();\n            var error = {};\n            var runner = createMockRunner(\n              'test end fail',\n              EVENT_TEST_END,\n              EVENT_TEST_FAIL,\n              null,\n              test,\n              error\n            );\n            runner.on = runner.once = function (event, callback) {\n              if (event === EVENT_TEST_END) {\n                callback();\n              } else if (event === EVENT_TEST_FAIL) {\n                callback(test, error);\n              }\n            };\n            runner.suite = '';\n            stdout = runReporter({}, runner, options);\n          });\n\n          it('should write expected message only', function () {\n            var expectedArray = [\n              'not ok ' + countAfterTestEnd + ' ' + expectedTitle + '\\n'\n            ];\n            expect(stdout, 'to equal', expectedArray);\n          });\n        });\n      });\n\n      describe(\"on 'end' event\", function () {\n        var stdout;\n\n        before(function () {\n          var test = createTest();\n          var runner = createMockRunner(\n            'fail end pass',\n            EVENT_TEST_FAIL,\n            EVENT_RUN_END,\n            EVENT_TEST_PASS,\n            test\n          );\n          runner.suite = '';\n          stdout = runReporter({}, runner, options);\n        });\n\n        it('should write total tests, passes, failures & plan', function () {\n          var numberOfPasses = 1;\n          var numberOfFails = 1;\n          var totalTests = numberOfPasses + numberOfFails;\n          var expectedArray = [\n            'ok ' + numberOfPasses + ' ' + expectedTitle + '\\n',\n            'not ok ' + numberOfFails + ' ' + expectedTitle + '\\n',\n            '# tests ' + totalTests + '\\n',\n            '# pass ' + numberOfPasses + '\\n',\n            '# fail ' + numberOfFails + '\\n',\n            '1..' + totalTests + '\\n'\n          ];\n          expect(stdout, 'to equal', expectedArray);\n        });\n      });\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nsuite.only('should run all tests in this tdd suite', function () {\n  test('should run this test #1', function () {});\n\n  test('should run this test #2', function () {});\n\n  test('should run this test #3', function () {});\n\n  test('should run this test #4', function () {});\n});\n\nsuite('should not run this suite', function () {\n  test('should not run this test', function () {\n    (true).should.equal(false);\n  });\n\n  test('should not run this test', function () {\n    (true).should.equal(false);\n  });\n\n  test('should not run this test', function () {\n    (true).should.equal(false);\n  });\n});\n\nsuite.only('should run this suite too', function () {\n  suite('should run this nested suite', function () {\n    test('should run this test', function () {});\n\n    test('should run this test', function () {});\n\n    test('should run this test', function () {});\n\n    test('should run this test', function () {});\n  });\n});"}
{"prompt":"Root-only test cases","test":"'use strict';\n\n// Root-only test cases\ntest.only('#Root-Suite, should run this tdd test-case #1', function () {\n  expect(true, 'to be', true);\n});\n\ntest('#Root-Suite, should not run this tdd test-case #2', function () {\n  expect(false, 'to be', true);\n});\n\ntest('#Root-Suite, should not run this tdd test-case #3', function () {\n  expect(false, 'to be', true);\n});"}
{"prompt":"a, function {","test":"describe('a', function() {\n  it('should pass', function() {});\n});"}
{"prompt":"b, function {","test":"describe('b', function() {\n  it('should be pending');\n});"}
{"prompt":"c, function {","test":"describe('c', function() {\n  it('should fail', function() {\n    throw new Error('failure');\n  });\n});"}
{"prompt":"d, function {","test":"describe('d', function() {\n  it('should pass, then fail', function() {\n    process.nextTick(function() {\n      throw new Error('uncaught!!');\n    });\n  });\n});"}
{"prompt":"This will be replaced in the tests","test":"// This will be replaced in the tests\nconst testShouldFail = true;\n\nit('checks dependency', () => {\n  if (testShouldFail === true) {\n    throw new Error('test failed');\n  }\n});"}
{"prompt":"pass","test":"'use strict';\n\ntest('pass', function () {\n  // pass\n});"}
{"prompt":"should not pass or even run because above import will fail,  => {","test":"import assert from 'assert';\nimport './this-module-does-not-exist.js';\n\nit('should not pass (or even run) because above import will fail', () => {\n  assert(true);\n});"}
{"prompt":"Test generated from existing file","test":"import 'non-existent-package';"}
{"prompt":"This file will be resolved to test-that-imports-non-existing-module.fixture.mjs by the loader","test":"// This file will be resolved to `test-that-imports-non-existing-module.fixture.mjs` by the loader\nimport 'non-existent-package';"}
{"prompt":"checks dependency,  => {","test":"const dependency = require('./lib/dependency');\n\nit('checks dependency', () => {\n  if (dependency.testShouldFail === true) {\n    throw new Error('test failed');\n  }\n});"}
{"prompt":"coffeescript, ->","test":"obj = foo: 'bar'\n\ndescribe 'coffeescript', ->\n  it 'should work', ->\n    expect(obj, 'to equal', foo: 'bar')"}
{"prompt":"Test generated from existing file","test":"1"}
{"prompt":"Test, function  {","test":"'use strict';\n\nvar sinon = require('sinon');\nvar mocha = require('../../lib/mocha');\nvar Test = mocha.Test;\nvar Runnable = mocha.Runnable;\n\ndescribe('Test', function () {\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('.clone()', function () {\n    beforeEach(function () {\n      this._test = new Test('To be cloned', function () {});\n      this._test._timeout = 3043;\n      this._test._slow = 101;\n      this._test._retries = 3;\n      this._test._currentRetry = 1;\n      this._test._allowedGlobals = ['foo'];\n      this._test.parent = 'foo';\n      this._test.file = 'bar';\n    });\n\n    it('should copy the title', function () {\n      expect(this._test.clone().title, 'to be', 'To be cloned');\n    });\n\n    it('should copy the timeout value', function () {\n      expect(this._test.clone().timeout(), 'to be', 3043);\n    });\n\n    it('should copy the slow value', function () {\n      expect(this._test.clone().slow(), 'to be', 101);\n    });\n\n    it('should copy the retries value', function () {\n      expect(this._test.clone().retries(), 'to be', 3);\n    });\n\n    it('should copy the currentRetry value', function () {\n      expect(this._test.clone().currentRetry(), 'to be', 1);\n    });\n\n    it('should add/keep the retriedTest value', function () {\n      var clone1 = this._test.clone();\n      expect(clone1.retriedTest(), 'to be', this._test);\n      expect(clone1.clone().retriedTest(), 'to be', this._test);\n    });\n\n    it('should copy the globals value', function () {\n      expect(this._test.clone().globals(), 'not to be empty');\n    });\n\n    it('should copy the parent value', function () {\n      expect(this._test.clone().parent, 'to be', 'foo');\n    });\n\n    it('should copy the file value', function () {\n      expect(this._test.clone().file, 'to be', 'bar');\n    });\n  });\n\n  describe('.reset()', function () {\n    beforeEach(function () {\n      this._test = new Test('Test to be reset', function () {});\n    });\n\n    it('should reset the run state', function () {\n      this._test.pending = true;\n      this._test.reset();\n      expect(this._test.pending, 'to be', false);\n    });\n\n    it('should call Runnable.reset', function () {\n      var runnableResetStub = sinon.stub(Runnable.prototype, 'reset');\n      this._test.reset();\n      expect(runnableResetStub, 'was called once');\n    });\n  });\n\n  describe('.isPending()', function () {\n    beforeEach(function () {\n      this._test = new Test('Is it skipped', function () {});\n    });\n\n    it('should not be pending by default', function () {\n      expect(this._test.isPending(), 'not to be', true);\n    });\n\n    it('should be pending when marked as such', function () {\n      this._test.pending = true;\n      expect(this._test.isPending(), 'to be', true);\n    });\n\n    it('should be pending when its parent is pending', function () {\n      this._test.parent = {\n        isPending: function () {\n          return true;\n        }\n      };\n      expect(this._test.isPending(), 'to be', true);\n    });\n  });\n\n  describe('.markOnly()', function () {\n    afterEach(function () {\n      sinon.restore();\n    });\n\n    it('should call appendOnlyTest on parent', function () {\n      var test = new Test('foo');\n      var spy = sinon.spy();\n      test.parent = {\n        appendOnlyTest: spy\n      };\n      test.markOnly();\n\n      expect(spy, 'to have a call exhaustively satisfying', [test]).and(\n        'was called once'\n      );\n    });\n  });\n});"}
{"prompt":"js, function  {","test":"var obj = {foo: 'bar'};\n\ndescribe('js', function () {\n  it('should work', function () {\n    expect(obj, 'to equal', {foo: 'bar'});\n  });\n});"}
{"prompt":"test1,  => {","test":"import {describe,it} from \"../../../../index.js\";\n\ndescribe('test1', () => {\n  it('should pass', () => {});\n});"}
{"prompt":"coffeescript, ->","test":"obj = foo: 'bar'\n\ndescribe 'coffeescript', ->\n  it 'should work', ->\n    expect(obj, 'to equal', foo: 'bar')"}
{"prompt":"test2,  => {","test":"import {describe,it} from \"../../../../index.js\";\n\ndescribe('test2', () => {\n  it('should pass', () => {});\n});"}
{"prompt":"test3,  => {","test":"import {describe,it} from \"../../../../index.js\";\n\ndescribe('test3', () => {\n  it('should fail', () => {\n    throw new Error('expecting this error to fail');\n  });\n});"}
{"prompt":"test1,  => {","test":"import assert from 'assert';\n\ndescribe('test1', () => {\n  it('should always run on worker with id 0', () => {\n    assert.ok(process.env.MOCHA_WORKER_ID === '0');\n  });\n});"}
{"prompt":"test2,  => {","test":"import assert from 'assert';\n\ndescribe('test2', () => {\n  it('should always run on worker with id 1', () => {\n    assert.ok(process.env.MOCHA_WORKER_ID === '1');\n  });\n});"}
{"prompt":"test3,  => {","test":"import assert from 'assert';\n\ndescribe('test3', () => {\n  it('should run on worker with either id 0 or 1', () => {\n    assert.ok(\n      process.env.MOCHA_WORKER_ID === '0' || process.env.MOCHA_WORKER_ID === '1'\n    );\n  });\n});"}
{"prompt":"test suite,  => {","test":"'use strict';\n\ndescribe('test suite', () => {\n    it('test1', function () { });\n    it('test2', function (done) {\n        var self = this;\n        setTimeout(function () {\n          self.skip();\n          throw new Error(\"should not throw\");\n        }, 10);\n    });\n    it('test3', function () {\n        this.skip();\n        throw new Error(\"should not throw\");\n    });\n    it('test4', function () { });\n    it('test5', function () {\n        this.skip();\n        throw new Error(\"should not throw\");\n    });\n});"}
{"prompt":"forbid pending - test calls skip, function {","test":"'use strict';\n\ndescribe('forbid pending - test calls `skip()`', function() {\n  it('test1', function() {});\n  it('test2', function() {\n    this.skip();\n  });\n  it('test3', function() {});\n});"}
{"prompt":"a test that throws, function  {","test":"'use strict';\n\n/* eslint no-throw-literal: off */\n\nvar sinon = require('sinon');\nvar Mocha = require('../../lib/mocha');\nvar Suite = Mocha.Suite;\nvar Test = Mocha.Test;\nvar Runnable = Mocha.Runnable;\nvar Runner = Mocha.Runner;\nvar EVENT_RUN_END = Runner.constants.EVENT_RUN_END;\nvar STATE_FAILED = Runnable.constants.STATE_FAILED;\n\ndescribe('a test that throws', function () {\n  var suite;\n  var runner;\n  var uncaughtHandlers;\n\n  beforeEach(function () {\n    suite = new Suite('Suite', 'root');\n    runner = new Runner(suite);\n\n    // see https://github.com/mochajs/mocha/pull/2983#issuecomment-350428522\n    uncaughtHandlers = process.listeners('uncaughtException') || [];\n    process.removeAllListeners('uncaughtException');\n  });\n\n  afterEach(function () {\n    process.removeAllListeners('uncaughtException');\n    uncaughtHandlers.forEach(function (listener) {\n      process.on('uncaughtException', listener);\n    });\n    sinon.restore(); \n  });\n\n  describe('non-extensible', function () {\n    it('should not pass if throwing sync and test is sync', function (done) {\n      var test = new Test('im sync and throw string sync', function () {\n        throw 'non-extensible';\n      });\n      suite.addTest(test);\n      runner = new Runner(suite);\n      runner.on(EVENT_RUN_END, function () {\n        expect(runner.failures, 'to be', 1);\n        expect(test.state, 'to be', STATE_FAILED);\n        done();\n      });\n      runner.run();\n    });\n\n    it('should not pass if throwing sync and test is async', function (done) {\n      var test = new Test('im async and throw string sync', function (done2) {\n        throw 'non-extensible';\n      });\n      suite.addTest(test);\n      runner = new Runner(suite);\n      runner.on(EVENT_RUN_END, function () {\n        expect(runner.failures, 'to be', 1);\n        expect(test.state, 'to be', STATE_FAILED);\n        done();\n      });\n      runner.run();\n    });\n\n    it('should not pass if throwing async and test is async', function (done) {\n      var test = new Test('im async and throw string async', function (done2) {\n        process.nextTick(function () {\n          throw 'non-extensible';\n        });\n      });\n      suite.addTest(test);\n      runner = new Runner(suite);\n      runner.on(EVENT_RUN_END, function () {\n        expect(runner.failures, 'to be', 1);\n        expect(test.state, 'to be', STATE_FAILED);\n        done();\n      });\n      runner.run();\n    });\n  });\n\n  describe('undefined', function () {\n    it('should not pass if throwing sync and test is sync', function (done) {\n      var test = new Test('im sync and throw undefined sync', function () {\n        throw undefined;\n      });\n      suite.addTest(test);\n      runner = new Runner(suite);\n      runner.on(EVENT_RUN_END, function () {\n        expect(runner.failures, 'to be', 1);\n        expect(test.state, 'to be', STATE_FAILED);\n        done();\n      });\n      runner.run();\n    });\n\n    it('should not pass if throwing sync and test is async', function (done) {\n      var test = new Test('im async and throw undefined sync', function (\n        done2\n      ) {\n        throw undefined;\n      });\n      suite.addTest(test);\n      runner = new Runner(suite);\n      runner.on(EVENT_RUN_END, function () {\n        expect(runner.failures, 'to be', 1);\n        expect(test.state, 'to be', STATE_FAILED);\n        done();\n      });\n      runner.run();\n    });\n\n    it('should not pass if throwing async and test is async', function (done) {\n      var test = new Test('im async and throw undefined async', function (\n        done2\n      ) {\n        process.nextTick(function () {\n          throw undefined;\n        });\n      });\n      suite.addTest(test);\n      runner = new Runner(suite);\n      runner.on(EVENT_RUN_END, function () {\n        expect(runner.failures, 'to be', 1);\n        expect(test.state, 'to be', STATE_FAILED);\n        done();\n      });\n      runner.run();\n    });\n  });\n\n  describe('null', function () {\n    it('should not pass if throwing sync and test is sync', function (done) {\n      var test = new Test('im sync and throw null sync', function () {\n        throw null;\n      });\n      suite.addTest(test);\n      runner = new Runner(suite);\n      runner.on(EVENT_RUN_END, function () {\n        expect(runner.failures, 'to be', 1);\n        expect(test.state, 'to be', STATE_FAILED);\n        done();\n      });\n      runner.run();\n    });\n\n    it('should not pass if throwing sync and test is async', function (done) {\n      var test = new Test('im async and throw null sync', function (done2) {\n        throw null;\n      });\n      suite.addTest(test);\n      runner = new Runner(suite);\n      runner.on(EVENT_RUN_END, function () {\n        expect(runner.failures, 'to be', 1);\n        expect(test.state, 'to be', STATE_FAILED);\n        done();\n      });\n      runner.run();\n    });\n\n    it('should not pass if throwing async and test is async', function (done) {\n      var test = new Test('im async and throw null async', function (done2) {\n        process.nextTick(function () {\n          throw null;\n        });\n      });\n      suite.addTest(test);\n      runner = new Runner(suite);\n      runner.on(EVENT_RUN_END, function () {\n        expect(runner.failures, 'to be', 1);\n        expect(test.state, 'to be', STATE_FAILED);\n        done();\n      });\n      runner.run();\n    });\n  });\n\n  describe('stack', function() {\n    it('should include the stack when throwing async', function(done) {\n      var test = new Test('im async and throw null async', function(done2) {\n        process.nextTick(function throwError() {\n          throw new Error('test error');\n        });\n      });\n      suite.addTest(test);\n      runner = new Runner(suite);\n      sinon.stub(runner, 'fail');\n\n      runner.on(EVENT_RUN_END, function() {\n        try {\n          expect(runner.fail, 'to have all calls satisfying', [\n            expect.it('to be a', Runnable),\n            expect.it('to be an', Error).and('to satisfy', {\n              message: /test error/i,\n              stack: /throwError/i,\n              uncaught: true\n            })\n          ]).and('was called once');\n        } catch (err) {\n          return done(err);\n        }\n\n        done();\n      });\n      runner.run();\n    });\n  });\n});"}
{"prompt":"timeout override, function {","test":"'use strict';\n\ndescribe('timeout override', function() {\n  it('should fail async test due to re-enable', function(done) {\n    this.timeout(0);\n    this.timeout(1);\n    setTimeout(done, 2);\n  });\n});"}
{"prompt":"unrefs a timeout, functiondone {","test":"it('unrefs a timeout', function(done) {\n  setTimeout(done, 10).unref();\n});"}
{"prompt":"timeout, function  {","test":"'use strict';\n\ndescribe('timeout', function () {\n  this.timeout(1);\n\n  it('should be honored with sync suites', function () {\n    sleep(2);\n  });\n\n  it('should be honored with async suites', function (done) {\n    sleep(2);\n    done();\n  });\n\n  function sleep (ms) {\n    var start = Date.now();\n    while (start + ms > Date.now());\n  }\n});"}
{"prompt":"timeouts, function  {","test":"'use strict';\n\ndescribe('timeouts', function () {\n  beforeEach(function (done) {\n    // uncomment\n    // setTimeout(done, 3000);\n    done();\n  });\n\n  it('should error on timeout', function (done) {\n    // uncomment\n    // setTimeout(done, 3000);\n    done();\n  });\n\n  it('should allow overriding per-test', function (done) {\n    this.timeout(1500);\n    setTimeout(function () {\n      done();\n    }, 50);\n  });\n\n  describe('disabling', function () {\n    it('should work with timeout(0)', function (done) {\n      this.timeout(0);\n      setTimeout(done, 1);\n    });\n\n    describe('using beforeEach', function () {\n      beforeEach(function () {\n        this.timeout(0);\n      });\n\n      it('should work with timeout(0)', function (done) {\n        setTimeout(done, 1);\n      });\n    });\n\n    describe('using before', function () {\n      before(function () {\n        this.timeout(0);\n      });\n\n      it('should work with timeout(0)', function (done) {\n        setTimeout(done, 1);\n      });\n    });\n\n    describe('using timeout(0)', function () {\n      this.timeout(4);\n\n      it('should suppress timeout(4)', function (done) {\n        this.slow(100);\n        // The test is in the before() call.\n        this.timeout(0);\n        setTimeout(done, 50);\n      });\n    });\n\n    describe('suite-level', function () {\n      this.timeout(0);\n\n      it('should work with timeout(0)', function (done) {\n        setTimeout(done, 1);\n      });\n\n      describe('nested suite', function () {\n        it('should work with timeout(0)', function (done) {\n          setTimeout(done, 1);\n        });\n      });\n    });\n\n    describe('chaining calls', function () {\n      before(function (done) {\n        setTimeout(function () {\n          done();\n        }, 50);\n      }).timeout(1500);\n\n      it('should allow overriding via chaining', function (done) {\n        setTimeout(function () {\n          done();\n        }, 50);\n      }).timeout(1500);\n\n      describe('suite-level', function () {\n        it('should work with timeout(0)', function (done) {\n          setTimeout(done, 1);\n        });\n\n        describe('nested suite', function () {\n          it('should work with timeout(0)', function (done) {\n            setTimeout(done, 1);\n          });\n        });\n      }).timeout(1000);\n    });\n  });\n});"}
{"prompt":"--ui, function  {","test":"'use strict';\n\nvar helpers = require('../helpers');\nvar runMochaJSON = helpers.runMochaJSON;\n\ndescribe('--ui', function () {\n  var simpleUiPath = require.resolve('../fixtures/simple-ui.fixture');\n\n  it('should load interface and run it', function (done) {\n    runMochaJSON(\n      'test-for-simple-ui',\n      ['--ui', simpleUiPath],\n      function (err, res) {\n        if (err) {\n          done(err);\n          return;\n        }\n        expect(res, 'to have passed');\n        done();\n      }\n    );\n  });\n\n  it(\"should work if required and name added to Mocha's `interfaces` prop\", function (done) {\n    runMochaJSON(\n      'test-for-simple-ui',\n      ['--require', simpleUiPath, '--ui', 'simple-ui'],\n      function (err, res) {\n        if (err) {\n          done(err);\n          return;\n        }\n        expect(res, 'to have passed');\n        done();\n      }\n    );\n  });\n});"}
{"prompt":"throws an uncaught exception, function done {","test":"'use strict';\n\nit('throws an uncaught exception', function (done) {\n  process.nextTick(function () {\n    throw new Error('existential isolation!!');\n  });\n});"}
{"prompt":"uncaught exceptions, function  {","test":"'use strict';\n\nconst {\n  runMocha,\n  runMochaJSON: run,\n  invokeMochaAsync,\n  invokeNode,\n  resolveFixturePath\n} = require('./helpers');\nvar args = [];\n\ndescribe('uncaught exceptions', function () {\n  it('handles uncaught exceptions from hooks', function (done) {\n    run('uncaught/hook', args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have failed with error', 'oh noes')\n        .and('to have passed test count', 0)\n        .and('to have pending test count', 0)\n        .and('to have failed test count', 1)\n        .and('to have failed test', '\"before each\" hook for \"test\"');\n\n      done();\n    });\n  });\n\n  it('handles uncaught exceptions from async specs', function (done) {\n    run('uncaught/double', args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have failed with error', 'global error', 'test error')\n        .and('to have passed test count', 0)\n        .and('to have pending test count', 0)\n        .and('to have failed test count', 2)\n        .and(\n          'to have failed test',\n          'fails exactly once when a global error is thrown first',\n          'fails exactly once when a global error is thrown second'\n        );\n\n      done();\n    });\n  });\n\n  it('handles uncaught exceptions from which Mocha cannot recover', function (done) {\n    run('uncaught/fatal', args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      var testName = 'should bail if a successful test asynchronously fails';\n      expect(res, 'to have failed with error', 'global error')\n        .and('to have passed test count', 1)\n        .and('to have failed test count', 1)\n        .and('to have passed test', testName)\n        .and('to have failed test', testName);\n\n      done();\n    });\n  });\n\n  it('handles uncaught exceptions within pending tests', function (done) {\n    run('uncaught/pending', args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have failed with error', 'I am uncaught!')\n        .and('to have passed test count', 3)\n        .and('to have pending test count', 1)\n        .and('to have failed test count', 1)\n        .and(\n          'to have passed test',\n          'test1',\n          'test3 - should run',\n          'test4 - should run'\n        )\n        .and('to have pending test order', 'test2')\n        .and('to have failed test', 'test2');\n\n      done();\n    });\n  });\n\n  it('handles uncaught exceptions within open tests', function (done) {\n    run('uncaught/recover', args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(\n        res,\n        'to have failed with error',\n        'Whoops!',\n        'Whoops!', // JSON reporter does not show the second error message\n        'should get upto here and throw'\n      )\n        .and('to have passed test count', 2)\n        .and('to have failed test count', 3)\n        .and('to have passed test', 'should wait 15ms', 'test 3')\n        .and(\n          'to have failed test',\n          'throw delayed error',\n          'throw delayed error',\n          '\"after all\" hook for \"test 3\"'\n        );\n\n      done();\n    });\n  });\n\n  it('removes uncaught exceptions handlers correctly', function (done) {\n    invokeNode([resolveFixturePath('uncaught/listeners')], function (err, res) {\n      if (err) {\n        return done(err);\n      }\n\n      expect(res, 'to have passed');\n      done();\n    });\n  });\n\n  it(\"handles uncaught exceptions after runner's end\", function (done) {\n    runMocha(\n      'uncaught/after-runner',\n      args,\n      function (err, res) {\n        if (err) {\n          return done(err);\n        }\n\n        expect(res, 'to have failed').and('to satisfy', {\n          failing: 0,\n          passing: 1,\n          pending: 0,\n          output: expect.it('to contain', 'Error: Unexpected crash')\n        });\n\n        done();\n      },\n      'pipe'\n    );\n  });\n\n  it('issue-1327: should run the first test and then bail', function (done) {\n    run('uncaught/issue-1327', args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n      expect(res, 'to have failed with error', 'Too bad')\n        .and('to have passed test count', 1)\n        .and('to have failed test count', 1)\n        .and('to have passed test', 'test 1')\n        .and('to have failed test', 'test 1');\n      done();\n    });\n  });\n\n  it('issue-1417: uncaught exceptions from async specs', function (done) {\n    run('uncaught/issue-1417', args, function (err, res) {\n      if (err) {\n        return done(err);\n      }\n      expect(res, 'to have failed with errors', 'sync error a', 'sync error b')\n        .and('to have exit code', 2)\n        .and('not to have passed tests')\n        .and('not to have pending tests')\n        .and('to have failed test order', [\n          'fails exactly once when a global error is thrown synchronously and done errors',\n          'fails exactly once when a global error is thrown synchronously and done completes'\n        ]);\n      done();\n    });\n  });\n\n  describe('issue-4481: behavior of non-Mocha-originating unhandled rejections', function () {\n    describe('when Node is in \"warn\" mode', function () {\n      it('should warn', async function () {\n        const [, promise] = invokeMochaAsync(\n          [\n            resolveFixturePath('uncaught/unhandled'),\n            '--unhandled-rejections=warn'\n          ],\n          {stdio: 'pipe'}\n        );\n\n        return expect(\n          promise,\n          'when fulfilled',\n          'to have passed with output',\n          /UnhandledPromiseRejectionWarning: Error: yikes/\n        );\n      });\n    });\n\n    describe('when Node is in \"strict\" mode', function () {\n      it('should fail with an uncaught exception', async function () {\n        const [, promise] = invokeMochaAsync(\n          [\n            resolveFixturePath('uncaught/unhandled'),\n            '--unhandled-rejections=strict'\n          ],\n          {stdio: 'pipe'}\n        );\n        return expect(\n          promise,\n          'when fulfilled',\n          'to have failed with output',\n          /Error: yikes/\n        );\n      });\n    });\n  });\n});"}
{"prompt":"should emit an unhandled rejection, async function {","test":"it('should emit an unhandled rejection', async function() {\n  setTimeout(() => {\n    Promise.resolve().then(() => {\n      throw new Error('yikes');\n    });\n  });\n});"}
{"prompt":"lib/utils, function  {","test":"/* global BigInt */\n'use strict';\n\nvar utils = require('../../lib/utils');\nvar sinon = require('sinon');\n\ndescribe('lib/utils', function () {\n  afterEach(function () {\n    sinon.restore();\n  });\n\n  describe('clean()', function () {\n    it('should remove the wrapping function declaration', function () {\n      expect(\n        utils.clean('function  (one, two, three)  {\\n//code\\n}'),\n        'to be',\n        '//code'\n      );\n    });\n\n    it('should handle newlines in the function declaration', function () {\n      expect(\n        utils.clean('function  (one, two, three)\\n  {\\n//code\\n}'),\n        'to be',\n        '//code'\n      );\n    });\n\n    it('should remove space character indentation from the function body', function () {\n      expect(\n        utils.clean('  //line1\\n    //line2'),\n        'to be',\n        '//line1\\n  //line2'\n      );\n    });\n\n    it('should remove tab character indentation from the function body', function () {\n      expect(\n        utils.clean('\\t//line1\\n\\t\\t//line2'),\n        'to be',\n        '//line1\\n\\t//line2'\n      );\n    });\n\n    it('should handle functions with tabs in their declarations', function () {\n      expect(utils.clean('function\\t(\\t)\\t{\\n//code\\n}'), 'to be', '//code');\n    });\n\n    it('should handle named functions without space after name', function () {\n      expect(\n        utils.clean('function withName() {\\n//code\\n}'),\n        'to be',\n        '//code'\n      );\n    });\n\n    it('should handle named functions with space after name', function () {\n      expect(\n        utils.clean('function withName () {\\n//code\\n}'),\n        'to be',\n        '//code'\n      );\n    });\n\n    it('should handle functions with no space between the end and the closing brace', function () {\n      expect(utils.clean('function() {/*code*/}'), 'to be', '/*code*/');\n    });\n\n    it('should handle functions with parentheses in the same line', function () {\n      expect(\n        utils.clean('function() { if (true) { /* code */ } }'),\n        'to be',\n        'if (true) { /* code */ }'\n      );\n    });\n\n    it('should handle empty functions', function () {\n      expect(utils.clean('function() {}'), 'to be', '');\n    });\n\n    it('should format a single line test function', function () {\n      var fn = ['function () {', '  var a = 1;', '}'].join('\\n');\n      expect(utils.clean(fn), 'to be', 'var a = 1;');\n    });\n\n    it('should format a multi line test indented with spaces', function () {\n      // and no new lines after curly braces, shouldn't matter\n      var fn = [\n        'function(){  var a = 1;',\n        // this one has more spaces\n        '    var b = 2;',\n        '  var c = 3;  }'\n      ].join('\\n');\n      expect(utils.clean(fn), 'to be', 'var a = 1;\\n  var b = 2;\\nvar c = 3;');\n    });\n\n    it('should format a multi line test indented with tabs', function () {\n      var fn = [\n        'function (arg1, arg2)   {',\n        '\\tif (true) {',\n        '\\t\\tvar a = 1;',\n        '\\t}',\n        '}'\n      ].join('\\n');\n      expect(utils.clean(fn), 'to be', 'if (true) {\\n\\tvar a = 1;\\n}');\n    });\n\n    it('should format functions saved in windows style - spaces', function () {\n      var fn = [\n        'function (one) {',\n        '   do {',\n        '    \"nothing\";',\n        '   } while (false);',\n        ' }'\n      ].join('\\r\\n');\n      expect(utils.clean(fn), 'to be', 'do {\\n \"nothing\";\\n} while (false);');\n    });\n\n    it('should format functions saved in windows style - tabs', function () {\n      var fn = [\n        'function ( )   {',\n        '\\tif (false) {',\n        '\\t\\tvar json = {',\n        '\\t\\t\\tone : 1',\n        '\\t\\t};',\n        '\\t}',\n        '}'\n      ].join('\\r\\n');\n      expect(\n        utils.clean(fn),\n        'to be',\n        'if (false) {\\n\\tvar json = {\\n\\t\\tone : 1\\n\\t};\\n}'\n      );\n    });\n\n    it('should format es6 arrow functions', function () {\n      var fn = ['() => {', '  var a = 1;', '}'].join('\\n');\n      expect(utils.clean(fn), 'to be', 'var a = 1;');\n    });\n\n    it('should format es6 arrow functions with implicit return', function () {\n      var fn = '() => foo()';\n      expect(utils.clean(fn), 'to be', 'foo()');\n    });\n  });\n\n  describe('stringify()', function () {\n    var stringify = utils.stringify;\n\n    it('should return an object representation of a string created with a String constructor', function () {\n      /* eslint no-new-wrappers: off */\n      expect(\n        stringify(new String('foo')),\n        'to be',\n        '{\\n  \"0\": \"f\"\\n  \"1\": \"o\"\\n  \"2\": \"o\"\\n}'\n      );\n    });\n\n    it('should return Buffer with .toJSON representation', function () {\n      expect(stringify(Buffer.from([0x01])), 'to be', '[\\n  1\\n]');\n      expect(stringify(Buffer.from([0x01, 0x02])), 'to be', '[\\n  1\\n  2\\n]');\n\n      expect(\n        stringify(Buffer.from('ABCD')),\n        'to be',\n        '[\\n  65\\n  66\\n  67\\n  68\\n]'\n      );\n    });\n\n    it('should return Date object with .toISOString() + string prefix', function () {\n      expect(\n        stringify(new Date(0)),\n        'to be',\n        '[Date: ' + new Date(0).toISOString() + ']'\n      );\n\n      var date = new Date(); // now\n      expect(stringify(date), 'to be', '[Date: ' + date.toISOString() + ']');\n    });\n\n    it('should return invalid Date object with .toString() + string prefix', function () {\n      expect(\n        stringify(new Date('')),\n        'to be',\n        '[Date: ' + new Date('').toString() + ']'\n      );\n    });\n\n    describe('#Number', function () {\n      it('should show the handle -0 situations', function () {\n        expect(stringify(-0), 'to be', '-0');\n        expect(stringify(0), 'to be', '0');\n        expect(stringify('-0'), 'to be', '\"-0\"');\n      });\n\n      it('should work well with `NaN` and `Infinity`', function () {\n        expect(stringify(NaN), 'to be', 'NaN');\n        expect(stringify(Infinity), 'to be', 'Infinity');\n        expect(stringify(-Infinity), 'to be', '-Infinity');\n      });\n\n      it('floats and ints', function () {\n        expect(stringify(1), 'to be', '1');\n        expect(stringify(1.2), 'to be', '1.2');\n        expect(stringify(1e9), 'to be', '1000000000');\n      });\n\n      if (typeof BigInt === 'function') {\n        it('should work with bigints when possible', function () {\n          expect(stringify(BigInt(1)), 'to be', '1n');\n          expect(stringify(BigInt(2)), 'to be', '2n');\n        });\n      }\n    });\n\n    describe('canonicalize example', function () {\n      it('should represent the actual full result', function () {\n        var expected = {\n          str: 'string',\n          int: 90,\n          float: 9.99,\n          boolean: false,\n          nil: null,\n          undef: undefined,\n          regex: /^[a-z|A-Z]/,\n          date: new Date(0),\n          func: function () {},\n          infi: Infinity,\n          nan: NaN,\n          zero: -0,\n          buffer: Buffer.from([0x01, 0x02]),\n          array: [1, 2, 3],\n          empArr: [],\n          matrix: [[1], [2, 3, 4]],\n          object: {a: 1, b: 2},\n          canObj: {a: {b: 1, c: 2}, b: {}},\n          empObj: {}\n        };\n        expected.circular = expected; // Make `Circular` situation\n        var actual = [\n          '{',\n          '  \"array\": [',\n          '    1',\n          '    2',\n          '    3',\n          '  ]',\n          '  \"boolean\": false',\n          '  \"buffer\": [Buffer: [',\n          '    1',\n          '    2',\n          '  ]]',\n          '  \"canObj\": {',\n          '    \"a\": {',\n          '      \"b\": 1',\n          '      \"c\": 2',\n          '    }',\n          '    \"b\": {}',\n          '  }',\n          '  \"circular\": [Circular]',\n          '  \"date\": [Date: 1970-01-01T00:00:00.000Z]',\n          '  \"empArr\": []',\n          '  \"empObj\": {}',\n          '  \"float\": 9.99',\n          '  \"func\": [Function]',\n          '  \"infi\": Infinity',\n          '  \"int\": 90',\n          '  \"matrix\": [',\n          '    [',\n          '      1',\n          '    ]',\n          '    [',\n          '      2',\n          '      3',\n          '      4',\n          '    ]',\n          '  ]',\n          '  \"nan\": NaN',\n          '  \"nil\": [null]',\n          '  \"object\": {',\n          '    \"a\": 1',\n          '    \"b\": 2',\n          '  }',\n          '  \"regex\": /^[a-z|A-Z]/',\n          '  \"str\": \"string\"',\n          '  \"undef\": [undefined]',\n          '  \"zero\": -0',\n          '}'\n        ].join('\\n');\n        expect(stringify(expected), 'to be', actual);\n      });\n\n      describe('should represent null prototypes', function () {\n        it('With explicit names', function () {\n          const foo = Object.create(null, {\n            [Symbol.toStringTag]: {value: 'Foo'},\n            bing: {get: () => 'bong', enumerable: true}\n          });\n          const expected = [\n            '{',\n            '  \"[Symbol.toStringTag]\": \"Foo\"',\n            '  \"bing\": \"bong\"',\n            '}'\n          ].join('\\n');\n\n          expect(stringify(foo), 'to be', expected);\n        });\n\n        it('Without names', function () {\n          const unnamed = {\n            bing: 'bong',\n            abc: 123\n          };\n          unnamed.self = unnamed;\n          const expected = [\n            '{',\n            '  \"abc\": 123',\n            '  \"bing\": \"bong\"',\n            '  \"self\": [Circular]',\n            '}'\n          ].join('\\n');\n\n          expect(\n            stringify(Object.setPrototypeOf(unnamed, null)),\n            'to be',\n            expected\n          );\n        });\n      });\n    });\n\n    it('should canonicalize the object', function () {\n      var travis = {name: 'travis', age: 24};\n      var travis2 = {age: 24, name: 'travis'};\n\n      expect(stringify(travis), 'to be', stringify(travis2));\n    });\n\n    it('should handle circular structures in objects', function () {\n      var travis = {name: 'travis'};\n      travis.whoami = travis;\n\n      expect(\n        stringify(travis),\n        'to be',\n        '{\\n  \"name\": \"travis\"\\n  \"whoami\": [Circular]\\n}'\n      );\n    });\n\n    it('should handle circular structures in arrays', function () {\n      var travis = ['travis'];\n      travis.push(travis);\n\n      expect(stringify(travis), 'to be', '[\\n  \"travis\"\\n  [Circular]\\n]');\n    });\n\n    it('should handle circular structures in functions', function () {\n      var travis = function () {};\n      travis.fn = travis;\n\n      expect(stringify(travis), 'to be', '{\\n  \"fn\": [Circular]\\n}');\n    });\n\n    it('should handle various non-undefined, non-null, non-object, non-array, non-date, and non-function values', function () {\n      var regexp = /(?:)/;\n      var regExpObj = {regexp};\n      var regexpString = '/(?:)/';\n\n      expect(\n        stringify(regExpObj),\n        'to be',\n        '{\\n  \"regexp\": ' + regexpString + '\\n}'\n      );\n      expect(stringify(regexp), 'to be', regexpString);\n\n      var number = 1;\n      var numberObj = {number};\n      var numberString = '1';\n\n      expect(stringify(numberObj), 'to be', '{\\n  \"number\": ' + number + '\\n}');\n      expect(stringify(number), 'to be', numberString);\n\n      var boolean = false;\n      var booleanObj = {boolean};\n      var booleanString = 'false';\n\n      expect(\n        stringify(booleanObj),\n        'to be',\n        '{\\n  \"boolean\": ' + boolean + '\\n}'\n      );\n      expect(stringify(boolean), 'to be', booleanString);\n\n      var string = 'sneepy';\n      var stringObj = {string};\n\n      expect(\n        stringify(stringObj),\n        'to be',\n        '{\\n  \"string\": \"' + string + '\"\\n}'\n      );\n      expect(stringify(string), 'to be', JSON.stringify(string));\n\n      var nullValue = null;\n      var nullObj = {null: null};\n      var nullString = '[null]';\n\n      expect(stringify(nullObj), 'to be', '{\\n  \"null\": [null]\\n}');\n      expect(stringify(nullValue), 'to be', nullString);\n    });\n\n    it('should handle arrays', function () {\n      var array = ['dave', 'dave', 'dave', 'dave'];\n      var arrayObj = {array};\n      var arrayString = '    \"dave\"\\n    \"dave\"\\n    \"dave\"\\n    \"dave\"';\n\n      expect(\n        stringify(arrayObj),\n        'to be',\n        '{\\n  \"array\": [\\n' + arrayString + '\\n  ]\\n}'\n      );\n      expect(\n        stringify(array),\n        'to be',\n        '[' + arrayString.replace(/\\s+/g, '\\n  ') + '\\n]'\n      );\n    });\n\n    it('should handle functions', function () {\n      var fn = function () {};\n      var fnObj = {fn};\n      var fnString = '[Function]';\n\n      expect(stringify(fnObj), 'to be', '{\\n  \"fn\": ' + fnString + '\\n}');\n      expect(stringify(fn), 'to be', '[Function]');\n    });\n\n    it('should handle empty objects', function () {\n      expect(stringify({}), 'to be', '{}');\n      expect(stringify({foo: {}}), 'to be', '{\\n  \"foo\": {}\\n}');\n    });\n\n    it('should handle empty arrays', function () {\n      expect(stringify([]), 'to be', '[]');\n      expect(stringify({foo: []}), 'to be', '{\\n  \"foo\": []\\n}');\n    });\n\n    it('should handle non-empty arrays', function () {\n      expect(stringify(['a', 'b', 'c']), 'to be', '[\\n  \"a\"\\n  \"b\"\\n  \"c\"\\n]');\n    });\n\n    it('should handle empty functions (with no properties)', function () {\n      expect(\n        stringify(function () {}),\n        'to be',\n        '[Function]'\n      );\n      expect(\n        stringify({foo: function () {}}),\n        'to be',\n        '{\\n  \"foo\": [Function]\\n}'\n      );\n      expect(\n        stringify({foo: function () {}, bar: 'baz'}),\n        'to be',\n        '{\\n  \"bar\": \"baz\"\\n  \"foo\": [Function]\\n}'\n      );\n    });\n\n    it('should handle functions w/ properties', function () {\n      var fn = function () {};\n      fn.bar = 'baz';\n      expect(stringify(fn), 'to be', '{\\n  \"bar\": \"baz\"\\n}');\n      expect(\n        stringify({foo: fn}),\n        'to be',\n        '{\\n  \"foo\": {\\n    \"bar\": \"baz\"\\n  }\\n}'\n      );\n    });\n\n    it('should handle undefined values', function () {\n      expect(\n        stringify({foo: undefined}),\n        'to be',\n        '{\\n  \"foo\": [undefined]\\n}'\n      );\n      expect(\n        stringify({foo: 'bar', baz: undefined}),\n        'to be',\n        '{\\n  \"baz\": [undefined]\\n  \"foo\": \"bar\"\\n}'\n      );\n      expect(stringify(), 'to be', '[undefined]');\n    });\n\n    it('should recurse', function () {\n      expect(\n        stringify({foo: {bar: {baz: {quux: {herp: 'derp'}}}}}),\n        'to be',\n        '{\\n  \"foo\": {\\n    \"bar\": {\\n      \"baz\": {\\n        \"quux\": {\\n          \"herp\": \"derp\"\\n        }\\n      }\\n    }\\n  }\\n}'\n      );\n    });\n\n    it('might get confusing', function () {\n      expect(stringify(null), 'to be', '[null]');\n    });\n\n    it('should not freak out if it sees a primitive twice', function () {\n      expect(\n        stringify({foo: null, bar: null}),\n        'to be',\n        '{\\n  \"bar\": [null]\\n  \"foo\": [null]\\n}'\n      );\n      expect(\n        stringify({foo: 1, bar: 1}),\n        'to be',\n        '{\\n  \"bar\": 1\\n  \"foo\": 1\\n}'\n      );\n    });\n\n    it('should stringify dates', function () {\n      var date = new Date(0);\n      expect(stringify(date), 'to be', '[Date: 1970-01-01T00:00:00.000Z]');\n      expect(\n        stringify({date}),\n        'to be',\n        '{\\n  \"date\": [Date: 1970-01-01T00:00:00.000Z]\\n}'\n      );\n    });\n\n    it('should handle object without an Object prototype', function () {\n      var a;\n      if (Object.create) {\n        a = Object.create(null);\n      } else {\n        a = {};\n      }\n      a.foo = 1;\n\n      expect(stringify(a), 'to be', '{\\n  \"foo\": 1\\n}');\n    });\n\n    // In old version node.js, Symbol is not available by default.\n    if (typeof global.Symbol === 'function') {\n      it('should handle Symbol', function () {\n        var symbol = Symbol('value');\n        expect(stringify(symbol), 'to match', /^Symbol\\(value\\)/);\n        expect(stringify({symbol}), 'to match', /\"symbol\": Symbol\\(value\\)/);\n      });\n    }\n\n    it('should handle length properties that cannot be coerced to a number', function () {\n      expect(\n        stringify({length: {nonBuiltinProperty: 0}}),\n        'to be',\n        '{\\n  \"length\": {\\n    \"nonBuiltinProperty\": 0\\n  }\\n}'\n      );\n      expect(\n        stringify({length: 'a string where length should be'}),\n        'to be',\n        '{\\n  \"length\": \"a string where length should be\"\\n}'\n      );\n    });\n  });\n\n  describe('type()', function () {\n    /* eslint no-extend-native: off */\n\n    var type = utils.type;\n    var toString = Object.prototype.toString;\n\n    beforeEach(function () {\n      // some JS engines such as PhantomJS 1.x exhibit this behavior\n      Object.prototype.toString = function () {\n        if (this === global) {\n          return '[object DOMWindow]';\n        }\n        return toString.call(this);\n      };\n    });\n\n    it('should recognize various types', function () {\n      expect(type({}), 'to be', 'object');\n      expect(type([]), 'to be', 'array');\n      expect(type(1), 'to be', 'number');\n      expect(type(Infinity), 'to be', 'number');\n      expect(type(null), 'to be', 'null');\n      expect(type(undefined), 'to be', 'undefined');\n      expect(type(new Date()), 'to be', 'object');\n      expect(type(/foo/), 'to be', 'object');\n      expect(type('type'), 'to be', 'string');\n      expect(type(new Error()), 'to be', 'error');\n      expect(type(global), 'to be', 'object');\n      expect(type(true), 'to be', 'boolean');\n      expect(type(Buffer.from('ff', 'hex')), 'to be', 'object');\n      expect(type(Symbol.iterator), 'to be', 'symbol');\n      expect(type(new Map()), 'to be', 'object');\n      expect(type(new WeakMap()), 'to be', 'object');\n      expect(type(new Set()), 'to be', 'object');\n      expect(type(new WeakSet()), 'to be', 'object');\n      expect(\n        type(async () => {}),\n        'to be',\n        'function'\n      );\n    });\n\n    describe('when toString on null or undefined stringifies window', function () {\n      it('should recognize null and undefined', function () {\n        expect(type(null), 'to be', 'null');\n        expect(type(undefined), 'to be', 'undefined');\n      });\n    });\n\n    afterEach(function () {\n      Object.prototype.toString = toString;\n    });\n  });\n\n  describe('canonicalType()', function () {\n    /* eslint no-extend-native: off */\n\n    var type = utils.canonicalType;\n    var toString = Object.prototype.toString;\n\n    beforeEach(function () {\n      // some JS engines such as PhantomJS 1.x exhibit this behavior\n      Object.prototype.toString = function () {\n        if (this === global) {\n          return '[object DOMWindow]';\n        }\n        return toString.call(this);\n      };\n    });\n\n    it('should recognize various types', function () {\n      expect(type({}), 'to be', 'object');\n      expect(type([]), 'to be', 'array');\n      expect(type(1), 'to be', 'number');\n      expect(type(Infinity), 'to be', 'number');\n      expect(type(null), 'to be', 'null');\n      expect(type(undefined), 'to be', 'undefined');\n      expect(type(new Date()), 'to be', 'date');\n      expect(type(/foo/), 'to be', 'regexp');\n      expect(type('type'), 'to be', 'string');\n      expect(type(global), 'to be', 'domwindow');\n      expect(type(true), 'to be', 'boolean');\n    });\n\n    describe('when toString on null or undefined stringifies window', function () {\n      it('should recognize null and undefined', function () {\n        expect(type(null), 'to be', 'null');\n        expect(type(undefined), 'to be', 'undefined');\n      });\n    });\n\n    afterEach(function () {\n      Object.prototype.toString = toString;\n    });\n  });\n\n  describe('isPromise()', function () {\n    it('should return true if the value is Promise-ish', function () {\n      expect(\n        utils.isPromise({\n          then: function () {}\n        }),\n        'to be',\n        true\n      );\n    });\n\n    it('should return false if the value is not an object', function () {\n      expect(utils.isPromise(1), 'to be', false);\n    });\n\n    it('should return false if the value is an object w/o a \"then\" function', function () {\n      expect(utils.isPromise({}), 'to be', false);\n    });\n\n    it('should return false if the object is null', function () {\n      expect(utils.isPromise(null), 'to be', false);\n    });\n  });\n\n  describe('escape()', function () {\n    it('replaces the usual xml suspects', function () {\n      expect(utils.escape('<a<bc<d<'), 'to be', '&#x3C;a&#x3C;bc&#x3C;d&#x3C;');\n      expect(utils.escape('>a>bc>d>'), 'to be', '&#x3E;a&#x3E;bc&#x3E;d&#x3E;');\n      expect(utils.escape('\"a\"bc\"d\"'), 'to be', '&#x22;a&#x22;bc&#x22;d&#x22;');\n      expect(utils.escape('<>\"&'), 'to be', '&#x3C;&#x3E;&#x22;&#x26;');\n\n      expect(utils.escape('&a&bc&d&'), 'to be', '&#x26;a&#x26;bc&#x26;d&#x26;');\n      expect(utils.escape('&amp;&lt;'), 'to be', '&#x26;amp;&#x26;lt;');\n    });\n\n    it('replaces invalid xml characters', function () {\n      expect(\n        utils.escape('\\x1B[32mfoo\\x1B[0m'),\n        'to be',\n        '&#x1B;[32mfoo&#x1B;[0m'\n      );\n      // Ensure we can handle non-trivial unicode characters as well\n      expect(utils.escape('💩'), 'to be', '&#x1F4A9;');\n    });\n  });\n\n  describe('createMap()', function () {\n    it('should return an object with a null prototype', function () {\n      expect(Object.getPrototypeOf(utils.createMap()), 'to be', null);\n    });\n\n    it('should add props to the object', function () {\n      expect(utils.createMap({foo: 'bar'}), 'to exhaustively satisfy', {\n        foo: 'bar'\n      });\n    });\n\n    it('should add props from all object parameters to the object', function () {\n      expect(\n        utils.createMap({foo: 'bar'}, {bar: 'baz'}),\n        'to exhaustively satisfy',\n        {foo: 'bar', bar: 'baz'}\n      );\n    });\n  });\n\n  describe('slug()', function () {\n    it('should convert the string to lowercase', function () {\n      expect(utils.slug('FOO'), 'to be', 'foo');\n    });\n\n    it('should convert whitespace to dashes', function () {\n      expect(\n        utils.slug('peanut butter\\nand\\tjelly'),\n        'to be',\n        'peanut-butter-and-jelly'\n      );\n    });\n\n    it('should strip non-alphanumeric and non-dash characters', function () {\n      expect(utils.slug('murder-hornets!!'), 'to be', 'murder-hornets');\n    });\n\n    it('should disallow consecutive dashes', function () {\n      expect(utils.slug('poppies & fritz'), 'to be', 'poppies-fritz');\n    });\n  });\n\n  describe('castArray()', function () {\n    describe('when provided an array value', function () {\n      it('should return a copy of the array', function () {\n        const v = ['foo', 'bar', 'baz'];\n        expect(utils.castArray(v), 'to equal', ['foo', 'bar', 'baz']).and(\n          'not to be',\n          v\n        );\n      });\n    });\n\n    describe('when provided an \"arguments\" value', function () {\n      it('should return an array containing the arguments', function () {\n        (function () {\n          expect(utils.castArray(arguments), 'to equal', [\n            'foo',\n            'bar',\n            'baz'\n          ]).and('not to be', arguments);\n        })('foo', 'bar', 'baz');\n      });\n    });\n\n    describe('when provided an object', function () {\n      it('should return an array containing the object only', function () {\n        const v = {foo: 'bar'};\n        expect(utils.castArray(v), 'to equal', [v]);\n      });\n    });\n\n    describe('when provided no parameters', function () {\n      it('should return an empty array', function () {\n        expect(utils.castArray(), 'to equal', []);\n      });\n    });\n\n    describe('when provided a primitive value', function () {\n      it('should return an array containing the primitive value only', function () {\n        expect(utils.castArray('butts'), 'to equal', ['butts']);\n      });\n    });\n\n    describe('when provided null', function () {\n      it('should return an array containing a null value only', function () {\n        expect(utils.castArray(null), 'to equal', [null]);\n      });\n    });\n  });\n\n  describe('uniqueID()', function () {\n    it('should return a non-empty string', function () {\n      expect(utils.uniqueID(), 'to be a string').and('not to be empty');\n    });\n    it('should have length of 21', function () {\n      expect(utils.uniqueID().length, 'to equal', 21);\n    });\n  });\n});"}
{"prompt":"--watch, function  {","test":"'use strict';\n\nconst fs = require('node:fs');\nconst path = require('node:path');\nconst {\n  copyFixture,\n  runMochaWatchJSONAsync,\n  sleep,\n  runMochaWatchAsync,\n  touchFile,\n  replaceFileContents,\n  createTempDir,\n  DEFAULT_FIXTURE\n} = require('../helpers');\n\ndescribe('--watch', function () {\n  describe('when enabled', function () {\n    /**\n     * @type {string}\n     */\n    let tempDir;\n    /**\n     * @type {import('../helpers').RemoveTempDirCallback}\n     */\n    let cleanup;\n\n    this.slow(5000);\n\n    beforeEach(async function () {\n      const {dirpath, removeTempDir} = await createTempDir();\n      tempDir = dirpath;\n      cleanup = removeTempDir;\n    });\n\n    afterEach(function () {\n      cleanup();\n    });\n\n    it('reruns test when watched test file is touched', function () {\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture(DEFAULT_FIXTURE, testFile);\n\n      return runMochaWatchJSONAsync([testFile], tempDir, () => {\n        touchFile(testFile);\n      }).then(results => {\n        expect(results, 'to have length', 2);\n      });\n    });\n\n    it('reruns test when watched test file crashes', function () {\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture(DEFAULT_FIXTURE, testFile);\n\n      replaceFileContents(testFile, 'done();', 'done((;');\n\n      return runMochaWatchJSONAsync([testFile], tempDir, () => {\n        replaceFileContents(testFile, 'done((;', 'done();');\n      }).then(results => {\n        expect(results, 'to have length', 1);\n      });\n    });\n\n    describe('when in parallel mode', function () {\n      it('reruns test when watched test file is touched', function () {\n        const testFile = path.join(tempDir, 'test.js');\n        copyFixture(DEFAULT_FIXTURE, testFile);\n\n        return runMochaWatchJSONAsync(['--parallel', testFile], tempDir, () => {\n          touchFile(testFile);\n        }).then(results => {\n          expect(results, 'to have length', 2);\n        });\n      });\n\n      it('reruns test when watched test file is crashed', function () {\n        const testFile = path.join(tempDir, 'test.js');\n        copyFixture(DEFAULT_FIXTURE, testFile);\n\n        replaceFileContents(testFile, 'done();', 'done((;');\n\n        return runMochaWatchJSONAsync([testFile], tempDir, () => {\n          replaceFileContents(testFile, 'done((;', 'done();');\n        }).then(results => {\n          expect(results, 'to have length', 1);\n        });\n      });\n    });\n\n    it('reruns test when file matching --watch-files changes', function () {\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture(DEFAULT_FIXTURE, testFile);\n\n      const watchedFile = path.join(tempDir, 'dir/file.xyz');\n      touchFile(watchedFile);\n\n      return runMochaWatchJSONAsync(\n        [testFile, '--watch-files', 'dir/*.xyz'],\n        tempDir,\n        () => {\n          touchFile(watchedFile);\n        }\n      ).then(results => {\n        expect(results.length, 'to equal', 2);\n      });\n    });\n\n    it('reruns test when file matching --watch-files is added', function () {\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture(DEFAULT_FIXTURE, testFile);\n\n      const watchedFile = path.join(tempDir, 'lib/file.xyz');\n      return runMochaWatchJSONAsync(\n        [testFile, '--watch-files', '**/*.xyz'],\n        tempDir,\n        () => {\n          touchFile(watchedFile);\n        }\n      ).then(results => {\n        expect(results, 'to have length', 2);\n      });\n    });\n\n    it('reruns test when file matching --watch-files is removed', function () {\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture(DEFAULT_FIXTURE, testFile);\n\n      const watchedFile = path.join(tempDir, 'lib/file.xyz');\n      touchFile(watchedFile);\n\n      return runMochaWatchJSONAsync(\n        [testFile, '--watch-files', 'lib/**/*.xyz'],\n        tempDir,\n        () => {\n          fs.rmSync(watchedFile, { recursive: true, force: true });\n        }\n      ).then(results => {\n        expect(results, 'to have length', 2);\n      });\n    });\n\n    it('does not rerun test when file not matching --watch-files is changed', function () {\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture(DEFAULT_FIXTURE, testFile);\n\n      const watchedFile = path.join(tempDir, 'dir/file.js');\n      touchFile(watchedFile);\n\n      return runMochaWatchJSONAsync(\n        [testFile, '--watch-files', 'dir/*.xyz'],\n        tempDir,\n        () => {\n          touchFile(watchedFile);\n        }\n      ).then(results => {\n        expect(results.length, 'to equal', 1);\n      });\n    });\n\n    it('picks up new test files when they are added', function () {\n      const testFile = path.join(tempDir, 'test/a.js');\n      copyFixture(DEFAULT_FIXTURE, testFile);\n\n      return runMochaWatchJSONAsync(\n        ['test/**/*.js', '--watch-files', 'test/**/*.js'],\n        tempDir,\n        () => {\n          const addedTestFile = path.join(tempDir, 'test/b.js');\n          copyFixture('passing', addedTestFile);\n        }\n      ).then(results => {\n        expect(results, 'to have length', 2);\n        expect(results[0].passes, 'to have length', 1);\n        expect(results[1].passes, 'to have length', 3);\n      });\n    });\n\n    it('reruns test when file matching --extension is changed', function () {\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture(DEFAULT_FIXTURE, testFile);\n\n      const watchedFile = path.join(tempDir, 'file.xyz');\n      touchFile(watchedFile);\n\n      return runMochaWatchJSONAsync(\n        [testFile, '--extension', 'xyz,js'],\n        tempDir,\n        () => {\n          touchFile(watchedFile);\n        }\n      ).then(results => {\n        expect(results, 'to have length', 2);\n      });\n    });\n\n    it('reruns when \"rs\\\\n\" typed', function () {\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture(DEFAULT_FIXTURE, testFile);\n\n      return runMochaWatchJSONAsync([testFile], tempDir, mochaProcess => {\n        mochaProcess.stdin.write('rs\\n');\n      }).then(results => {\n        expect(results, 'to have length', 2);\n      });\n    });\n\n    it('reruns test when file starting with . and matching --extension is changed', function () {\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture(DEFAULT_FIXTURE, testFile);\n\n      const watchedFile = path.join(tempDir, '.file.xyz');\n      touchFile(watchedFile);\n\n      return runMochaWatchJSONAsync(\n        [testFile, '--extension', 'xyz,js'],\n        tempDir,\n        () => {\n          touchFile(watchedFile);\n        }\n      ).then(results => {\n        expect(results, 'to have length', 2);\n      });\n    });\n\n    it('ignores files in \"node_modules\" and \".git\" by default', function () {\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture(DEFAULT_FIXTURE, testFile);\n\n      const nodeModulesFile = path.join(tempDir, 'node_modules', 'file.xyz');\n      const gitFile = path.join(tempDir, '.git', 'file.xyz');\n\n      touchFile(gitFile);\n      touchFile(nodeModulesFile);\n\n      return runMochaWatchJSONAsync(\n        [testFile, '--extension', 'xyz,js'],\n        tempDir,\n        () => {\n          touchFile(gitFile);\n          touchFile(nodeModulesFile);\n        }\n      ).then(results => {\n        expect(results, 'to have length', 1);\n      });\n    });\n\n    it('ignores files matching --watch-ignore', function () {\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture(DEFAULT_FIXTURE, testFile);\n\n      const watchedFile = path.join(tempDir, 'dir/file-to-ignore.xyz');\n      touchFile(watchedFile);\n\n      return runMochaWatchJSONAsync(\n        [\n          testFile,\n          '--watch-files',\n          'dir/*.xyz',\n          '--watch-ignore',\n          'dir/*ignore*'\n        ],\n        tempDir,\n        () => {\n          touchFile(watchedFile);\n        }\n      ).then(results => {\n        expect(results.length, 'to equal', 1);\n      });\n    });\n\n    it('reloads test files when they change', function () {\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture('options/watch/test-file-change', testFile);\n\n      return runMochaWatchJSONAsync(\n        [testFile, '--watch-files', '**/*.js'],\n        tempDir,\n        () => {\n          replaceFileContents(\n            testFile,\n            'testShouldFail = true',\n            'testShouldFail = false'\n          );\n        }\n      ).then(results => {\n        expect(results, 'to have length', 2);\n        expect(results[0].passes, 'to have length', 0);\n        expect(results[0].failures, 'to have length', 1);\n        expect(results[1].passes, 'to have length', 1);\n        expect(results[1].failures, 'to have length', 0);\n      });\n    });\n\n    it('reloads test dependencies when they change', function () {\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture('options/watch/test-with-dependency', testFile);\n\n      const dependency = path.join(tempDir, 'lib', 'dependency.js');\n      copyFixture('options/watch/dependency', dependency);\n\n      return runMochaWatchJSONAsync(\n        [testFile, '--watch-files', 'lib/**/*.js'],\n        tempDir,\n        () => {\n          replaceFileContents(\n            dependency,\n            'module.exports.testShouldFail = false',\n            'module.exports.testShouldFail = true'\n          );\n        }\n      ).then(results => {\n        expect(results, 'to have length', 2);\n        expect(results[0].passes, 'to have length', 1);\n        expect(results[0].failures, 'to have length', 0);\n        expect(results[1].passes, 'to have length', 0);\n        expect(results[1].failures, 'to have length', 1);\n      });\n    });\n\n    // Regression test for https://github.com/mochajs/mocha/issues/2027\n    it('respects --fgrep on re-runs', async function () {\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture('options/grep', testFile);\n\n      return expect(\n        runMochaWatchJSONAsync([testFile, '--fgrep', 'match'], tempDir, () => {\n          touchFile(testFile);\n        }),\n        'when fulfilled',\n        'to satisfy',\n        {\n          length: 2,\n          0: {tests: expect.it('to have length', 2)},\n          1: {tests: expect.it('to have length', 2)}\n        }\n      );\n    });\n\n    describe('with required hooks', function () {\n      /**\n       * Helper for setting up hook tests\n       *\n       * @param {string} hookName name of hook to test\n       * @return {function}\n       */\n      function setupHookTest(hookName) {\n        return function () {\n          const testFile = path.join(tempDir, 'test.js');\n          const hookFile = path.join(tempDir, 'hook.js');\n\n          copyFixture('__default__', testFile);\n          copyFixture('options/watch/hook', hookFile);\n\n          replaceFileContents(hookFile, '<hook>', hookName);\n\n          return runMochaWatchJSONAsync(\n            [testFile, '--require', hookFile],\n            tempDir,\n            () => {\n              touchFile(testFile);\n            }\n          ).then(results => {\n            expect(results.length, 'to equal', 2);\n            expect(results[0].failures, 'to have length', 1);\n            expect(results[1].failures, 'to have length', 1);\n          });\n        };\n      }\n\n      it('mochaHooks.beforeAll runs as expected', setupHookTest('beforeAll'));\n      it('mochaHooks.beforeEach runs as expected', setupHookTest('beforeEach'));\n      it('mochaHooks.afterAll runs as expected', setupHookTest('afterAll'));\n      it('mochaHooks.afterEach runs as expected', setupHookTest('afterEach'));\n    });\n\n    it('should not leak event listeners', function () {\n      this.timeout(20000);\n      const testFile = path.join(tempDir, 'test.js');\n      copyFixture(DEFAULT_FIXTURE, testFile);\n\n      return expect(\n        runMochaWatchAsync(\n          [testFile],\n          {cwd: tempDir, stdio: 'pipe'},\n          async () => {\n            // we want to cause _n + 1_ reruns, which should cause the warning\n            // to occur if the listeners aren't properly destroyed\n            const iterations = new Array(process.getMaxListeners() + 1);\n            // eslint-disable-next-line no-unused-vars\n            for await (const _ of iterations) {\n              touchFile(testFile);\n              await sleep(1000);\n            }\n          }\n        ),\n        'when fulfilled',\n        'to satisfy',\n        {\n          output: expect.it('not to match', /MaxListenersExceededWarning/)\n        }\n      );\n    });\n  });\n});"}
{"prompt":"Test generated from existing file","test":"'use strict';\n\nconst FailOnErrorsPlugin = require('fail-on-errors-webpack-plugin');\nconst {tmpdir} = require('node:os');\nconst {join} = require('node:path');\n\nconst outputPath = join(tmpdir(), 'mocha-test-webpack');\n\nconsole.error('output dir: %s', outputPath);\n\nmodule.exports = {\n  entry: require.resolve('./webpack.fixture.mjs'),\n  target: 'browserslist:last 2 Chrome versions',\n  output: {\n    path: outputPath\n  },\n  plugins: [\n    new FailOnErrorsPlugin({\n      failOnErrors: true,\n      failOnWarnings: false\n    })\n  ]\n};"}
{"prompt":"Test generated from existing file","test":"/* eslint-disable-next-line no-unused-vars */\nimport mocha from '../../../../mocha.js';"}
{"prompt":"Test generated from existing file","test":"throw new Error('bad weirdness in this one');"}
{"prompt":"worker, function  {","test":"'use strict';\n\nconst serializeJavascript = require('serialize-javascript');\nconst rewiremock = require('rewiremock/node');\nconst {SerializableWorkerResult} = require('../../lib/nodejs/serializer');\nconst sinon = require('sinon');\n\nconst WORKER_PATH = require.resolve('../../lib/nodejs/worker.js');\n\ndescribe('worker', function () {\n  let worker;\n  let stubs;\n\n  beforeEach(function () {\n    stubs = {\n      workerpool: {\n        isMainThread: false,\n        worker: sinon.stub()\n      }\n    };\n    sinon.spy(process, 'removeAllListeners');\n  });\n\n  describe('when run as main process', function () {\n    it('should throw', function () {\n      expect(() => {\n        rewiremock.proxy(WORKER_PATH, {\n          workerpool: {\n            isMainThread: true,\n            worker: stubs.workerpool.worker\n          }\n        });\n      }, 'to throw');\n    });\n  });\n\n  describe('when run as worker process', function () {\n    let mocha;\n\n    beforeEach(function () {\n      mocha = {\n        addFile: sinon.stub().returnsThis(),\n        loadFilesAsync: sinon.stub().resolves(),\n        run: sinon.stub().callsArgAsync(0),\n        unloadFiles: sinon.stub().returnsThis()\n      };\n      stubs.Mocha = Object.assign(sinon.stub().returns(mocha), {\n        bdd: sinon.stub(),\n        interfaces: {}\n      });\n\n      stubs.serializer = {\n        serialize: sinon.stub()\n      };\n\n      stubs.runHelpers = {\n        handleRequires: sinon.stub().resolves({}),\n        validateLegacyPlugin: sinon.stub()\n      };\n\n      stubs.plugin = {\n        aggregateRootHooks: sinon.stub().resolves()\n      };\n\n      worker = rewiremock.proxy(WORKER_PATH, {\n        workerpool: stubs.workerpool,\n        '../../lib/mocha': stubs.Mocha,\n        '../../lib/nodejs/serializer': stubs.serializer,\n        '../../lib/cli/run-helpers': stubs.runHelpers,\n        '../../lib/plugin-loader': stubs.plugin\n      });\n    });\n\n    it('should register itself with workerpool', function () {\n      expect(stubs.workerpool.worker, 'to have a call satisfying', [\n        {run: worker.run}\n      ]);\n    });\n\n    describe('function', function () {\n      describe('run()', function () {\n        describe('when called without arguments', function () {\n          it('should reject', async function () {\n            return expect(worker.run, 'to be rejected with error satisfying', {\n              code: 'ERR_MOCHA_INVALID_ARG_TYPE'\n            });\n          });\n        });\n\n        describe('when passed a non-string `options` value', function () {\n          it('should reject', async function () {\n            return expect(\n              () => worker.run('foo.js', 42),\n              'to be rejected with error satisfying',\n              {\n                code: 'ERR_MOCHA_INVALID_ARG_TYPE'\n              }\n            );\n          });\n        });\n\n        describe('when passed an invalid string `options` value', function () {\n          it('should reject', async function () {\n            return expect(\n              () => worker.run('foo.js', 'tomfoolery'),\n              'to be rejected with error satisfying',\n              {\n                code: 'ERR_MOCHA_INVALID_ARG_VALUE'\n              }\n            );\n          });\n        });\n\n        describe('when called with empty \"filepath\" argument', function () {\n          it('should reject', async function () {\n            return expect(\n              () => worker.run(''),\n              'to be rejected with error satisfying',\n              {\n                code: 'ERR_MOCHA_INVALID_ARG_TYPE'\n              }\n            );\n          });\n        });\n\n        describe('when the file at \"filepath\" argument is unloadable', function () {\n          it('should reject', async function () {\n            mocha.loadFilesAsync.rejects();\n            return expect(\n              () => worker.run('some-non-existent-file.js'),\n              'to be rejected'\n            );\n          });\n        });\n\n        describe('when the file at \"filepath\" is loadable', function () {\n          let result;\n          beforeEach(function () {\n            result = SerializableWorkerResult.create();\n\n            mocha.loadFilesAsync.resolves();\n            mocha.run.yields(result);\n          });\n\n          it('should handle \"--require\"', async function () {\n            await worker.run(\n              'some-file.js',\n              serializeJavascript({require: 'foo'})\n            );\n            expect(\n              stubs.runHelpers.handleRequires,\n              'to have a call satisfying',\n              [\n                'foo',\n                {ignoredPlugins: ['mochaGlobalSetup', 'mochaGlobalTeardown']}\n              ]\n            ).and('was called once');\n          });\n\n          it('should handle \"--ui\"', async function () {\n            const argv = {foo: 'bar'};\n            await worker.run('some-file.js', serializeJavascript(argv));\n\n            expect(\n              stubs.runHelpers.validateLegacyPlugin,\n              'to have a call satisfying',\n              [argv, 'ui', stubs.Mocha.interfaces]\n            ).and('was called once');\n          });\n\n          it('should call Mocha#run', async function () {\n            await worker.run('some-file.js');\n            expect(mocha.run, 'was called once');\n          });\n\n          it('should remove all uncaughtException listeners', async function () {\n            await worker.run('some-file.js');\n            expect(process.removeAllListeners, 'to have a call satisfying', [\n              'uncaughtException'\n            ]);\n          });\n\n          it('should remove all unhandledRejection listeners', async function () {\n            await worker.run('some-file.js');\n            expect(process.removeAllListeners, 'to have a call satisfying', [\n              'unhandledRejection'\n            ]);\n          });\n\n          describe('when serialization succeeds', function () {\n            beforeEach(function () {\n              stubs.serializer.serialize.returnsArg(0);\n            });\n\n            it('should resolve with a SerializedWorkerResult', async function () {\n              return expect(\n                worker.run('some-file.js'),\n                'to be fulfilled with',\n                result\n              );\n            });\n          });\n\n          describe('when serialization fails', function () {\n            beforeEach(function () {\n              stubs.serializer.serialize.throws();\n            });\n\n            it('should reject', async function () {\n              return expect(worker.run('some-file.js'), 'to be rejected');\n            });\n          });\n\n          describe('when run twice', function () {\n            it('should initialize only once', async function () {\n              await worker.run('some-file.js');\n              await worker.run('some-other-file.js');\n\n              expect(stubs.runHelpers, 'to satisfy', {\n                handleRequires: expect.it('was called once'),\n                validateLegacyPlugin: expect.it('was called once')\n              });\n            });\n          });\n        });\n      });\n    });\n  });\n\n  afterEach(function () {\n    sinon.restore();\n    // this is needed due to `require.cache` getting dumped in watch mode\n    process.removeAllListeners('beforeExit');\n  });\n});"}
{"prompt":"XUnit reporter, function  {","test":"'use strict';\n\nvar EventEmitter = require('node:events').EventEmitter;\nvar fs = require('node:fs');\nvar path = require('node:path');\nvar sinon = require('sinon');\nvar createStatsCollector = require('../../lib/stats-collector');\nvar events = require('../../').Runner.constants;\nvar reporters = require('../../').reporters;\nvar states = require('../../').Runnable.constants;\n\nconst {createTempDir, touchFile} = require('../integration/helpers');\n\nvar Base = reporters.Base;\nvar XUnit = reporters.XUnit;\n\nvar EVENT_RUN_END = events.EVENT_RUN_END;\nvar EVENT_TEST_END = events.EVENT_TEST_END;\nvar EVENT_TEST_FAIL = events.EVENT_TEST_FAIL;\nvar EVENT_TEST_PASS = events.EVENT_TEST_PASS;\nvar EVENT_TEST_PENDING = events.EVENT_TEST_PENDING;\n\nvar STATE_FAILED = states.STATE_FAILED;\nvar STATE_PASSED = states.STATE_PASSED;\n\ndescribe('XUnit reporter', function () {\n  var runner;\n  var noop = function () {};\n\n  var expectedLine = 'some-line';\n  var expectedClassName = 'fullTitle';\n  var expectedTitle = 'some title';\n  var expectedFile = 'testFile.spec.js';\n  var expectedMessage = 'some message';\n  var expectedDiff =\n    '\\n      + expected - actual\\n\\n      -foo\\n      +bar\\n      ';\n  var expectedStack = 'some-stack';\n\n  beforeEach(function () {\n    runner = {on: noop, once: noop};\n    createStatsCollector(runner);\n  });\n\n  describe(\"when 'reporterOptions.output' is provided\", function () {\n    var expectedOutput = path.join(path.sep, 'path', 'to', 'some-output');\n    var options = {\n      reporterOptions: {\n        output: expectedOutput\n      }\n    };\n\n    describe('when fileStream can be created', function () {\n      var fsMkdirSync;\n      var fsCreateWriteStream;\n\n      beforeEach(function () {\n        fsMkdirSync = sinon.stub(fs, 'mkdirSync');\n        fsCreateWriteStream = sinon.stub(fs, 'createWriteStream');\n      });\n\n      it('should open given file for writing, recursively creating directories in pathname', function () {\n        var fakeThis = {\n          fileStream: null\n        };\n        XUnit.call(fakeThis, runner, options);\n\n        var expectedDirectory = path.dirname(expectedOutput);\n        expect(\n          fsMkdirSync.calledWith(expectedDirectory, {\n            recursive: true\n          }),\n          'to be true'\n        );\n\n        expect(fsCreateWriteStream.calledWith(expectedOutput), 'to be true');\n      });\n\n      afterEach(function () {\n        sinon.restore();\n      });\n    });\n\n    describe('when fileStream cannot be created', function () {\n      describe('when given an invalid pathname', function () {\n        /**\n         * @type {string}\n         */\n        let tmpdir;\n\n        /**\n         * @type {import('../integration/helpers').RemoveTempDirCallback}\n         */\n        let cleanup;\n        var invalidPath;\n\n        beforeEach(async function () {\n          const {dirpath, removeTempDir} = await createTempDir();\n          tmpdir = dirpath;\n          cleanup = removeTempDir;\n\n          // Create path where file 'some-file' used as directory\n          invalidPath = path.join(\n            tmpdir,\n            'some-file',\n            path.basename(expectedOutput)\n          );\n          touchFile(path.dirname(invalidPath));\n        });\n\n        it('should throw system error', function () {\n          var options = {\n            reporterOptions: {\n              output: invalidPath\n            }\n          };\n          var boundXUnit = XUnit.bind({}, runner, options);\n          expect(\n            boundXUnit,\n            'to throw',\n            expect.it('to be an', Error).and('to satisfy', {\n              syscall: 'mkdir',\n              code: 'EEXIST',\n              path: path.dirname(invalidPath)\n            })\n          );\n        });\n\n        afterEach(function () {\n          cleanup();\n        });\n      });\n\n      describe('when run in browser', function () {\n        beforeEach(function () {\n          sinon.stub(fs, 'createWriteStream').value(false);\n        });\n\n        it('should throw unsupported error', function () {\n          var boundXUnit = XUnit.bind({}, runner, options);\n          expect(\n            boundXUnit,\n            'to throw',\n            'file output not supported in browser'\n          );\n        });\n\n        afterEach(function () {\n          sinon.restore();\n        });\n      });\n    });\n  });\n\n  describe('event handlers', function () {\n    describe(\"on 'pending', 'pass' and 'fail' events\", function () {\n      it(\"should add test to tests called on 'end' event\", function () {\n        var pendingTest = {\n          name: 'pending',\n          slow: noop\n        };\n        var failTest = {\n          name: 'fail',\n          slow: noop\n        };\n        var passTest = {\n          name: 'pass',\n          slow: noop\n        };\n        runner.on = runner.once = function (event, callback) {\n          if (event === EVENT_TEST_PENDING) {\n            callback(pendingTest);\n          } else if (event === EVENT_TEST_PASS) {\n            callback(passTest);\n          } else if (event === EVENT_TEST_FAIL) {\n            callback(failTest);\n          } else if (event === EVENT_RUN_END) {\n            callback();\n          }\n        };\n\n        var calledTests = [];\n        var fakeThis = {\n          write: noop,\n          test: function (test) {\n            calledTests.push(test);\n          }\n        };\n        XUnit.call(fakeThis, runner);\n\n        var expectedCalledTests = [pendingTest, passTest, failTest];\n        expect(calledTests, 'to equal', expectedCalledTests);\n      });\n    });\n  });\n\n  describe('#done', function () {\n    var xunit;\n    var options = {\n      reporterOptions: {}\n    };\n    var expectedNFailures = 13;\n    var callback;\n\n    beforeEach(function () {\n      callback = sinon.spy();\n    });\n\n    afterEach(function () {\n      callback = null;\n      xunit = null;\n      sinon.restore();\n    });\n\n    describe('when output directed to file', function () {\n      var fakeThis;\n\n      beforeEach(function () {\n        xunit = new XUnit(runner, options);\n\n        fakeThis = {\n          fileStream: {\n            end: sinon.stub().callsFake(function (chunk, encoding, cb) {\n              if (typeof arguments[0] === 'function') {\n                cb = arguments[0];\n              }\n              cb();\n            }),\n            write: function (chunk, encoding, cb) {}\n          }\n        };\n      });\n\n      it(\"should run completion callback via 'fileStream.end'\", function () {\n        xunit.done.call(fakeThis, expectedNFailures, callback);\n\n        expect(fakeThis.fileStream.end.calledOnce, 'to be true');\n        expect(callback.calledOnce, 'to be true');\n        expect(callback.calledWith(expectedNFailures), 'to be true');\n      });\n    });\n\n    describe('when output directed to stdout (or console)', function () {\n      var fakeThis;\n\n      beforeEach(function () {\n        xunit = new XUnit(runner, options);\n        fakeThis = {};\n      });\n\n      it('should run completion callback', function () {\n        xunit.done.call(fakeThis, expectedNFailures, callback);\n\n        expect(callback.calledOnce, 'to be true');\n        expect(callback.calledWith(expectedNFailures), 'to be true');\n      });\n    });\n  });\n\n  describe('#write', function () {\n    // :TODO: Method should be named 'writeln', not 'write'\n    describe('when output directed to file', function () {\n      var fileStream = {\n        write: sinon.spy()\n      };\n\n      it(\"should call 'fileStream.write' with line and newline\", function () {\n        var xunit = new XUnit(runner);\n        var fakeThis = {fileStream};\n        xunit.write.call(fakeThis, expectedLine);\n\n        expect(fileStream.write.calledWith(expectedLine + '\\n'), 'to be true');\n      });\n    });\n\n    describe('when output directed to stdout', function () {\n      it(\"should call 'process.stdout.write' with line and newline\", function () {\n        var xunit = new XUnit(runner);\n        var fakeThis = {fileStream: false};\n        var stdoutWriteStub = sinon.stub(process.stdout, 'write');\n        xunit.write.call(fakeThis, expectedLine);\n        stdoutWriteStub.restore();\n\n        expect(stdoutWriteStub.calledWith(expectedLine + '\\n'), 'to be true');\n      });\n    });\n\n    describe('when output directed to console', function () {\n      it(\"should call 'Base.consoleLog' with line\", function () {\n        // :TODO: XUnit needs a trivially testable means to force console.log()\n        var realProcess = process;\n        process = false; // eslint-disable-line no-native-reassign, no-global-assign\n\n        var xunit = new XUnit(runner);\n        var fakeThis = {fileStream: false};\n        var consoleLogStub = sinon.stub(Base, 'consoleLog');\n        xunit.write.call(fakeThis, expectedLine);\n        consoleLogStub.restore();\n\n        process = realProcess; // eslint-disable-line no-native-reassign, no-global-assign\n\n        expect(consoleLogStub.calledWith(expectedLine), 'to be true');\n      });\n    });\n  });\n\n  describe('#test', function () {\n    var expectedWrite;\n    var fakeThis = {\n      write: function (str) {\n        expectedWrite = str;\n      }\n    };\n\n    beforeEach(function () {\n      sinon.stub(Base, 'useColors').value(false);\n    });\n\n    afterEach(function () {\n      sinon.restore();\n      expectedWrite = null;\n    });\n\n    describe('on test failure', function () {\n      it('should write expected tag with error details', function () {\n        var xunit = new XUnit(runner);\n        var expectedTest = {\n          state: STATE_FAILED,\n          title: expectedTitle,\n          file: expectedFile,\n          parent: {\n            fullTitle: function () {\n              return expectedClassName;\n            }\n          },\n          duration: 1000,\n          err: {\n            actual: 'foo',\n            expected: 'bar',\n            message: expectedMessage,\n            stack: expectedStack\n          }\n        };\n\n        xunit.test.call(fakeThis, expectedTest);\n        sinon.restore();\n\n        var expectedTag =\n          '<testcase classname=\"' +\n          expectedClassName +\n          '\" name=\"' +\n          expectedTitle +\n          '\" file=\"' +\n          expectedFile +\n          '\" time=\"1\"><failure>' +\n          expectedMessage +\n          '\\n' +\n          expectedDiff +\n          '\\n' +\n          expectedStack +\n          '</failure></testcase>';\n        expect(expectedWrite, 'to be', expectedTag);\n      });\n\n      it('should handle non-string diff values', function () {\n        var runner = new EventEmitter();\n        createStatsCollector(runner);\n        var xunit = new XUnit(runner);\n\n        var expectedTest = {\n          state: STATE_FAILED,\n          title: expectedTitle,\n          file: expectedFile,\n          parent: {\n            fullTitle: function () {\n              return expectedClassName;\n            }\n          },\n          duration: 1000,\n          err: {\n            actual: 1,\n            expected: 2,\n            message: expectedMessage,\n            stack: expectedStack\n          }\n        };\n\n        sinon.stub(xunit, 'write').callsFake(function (str) {\n          expectedWrite += str;\n        });\n\n        runner.emit(EVENT_TEST_FAIL, expectedTest, expectedTest.err);\n        runner.emit(EVENT_RUN_END);\n        sinon.restore();\n\n        var expectedDiff =\n          '\\n      + expected - actual\\n\\n      -1\\n      +2\\n      ';\n\n        expect(expectedWrite, 'to contain', expectedDiff);\n      });\n    });\n\n    describe('on test pending', function () {\n      it('should write expected tag', function () {\n        var xunit = new XUnit(runner);\n        var expectedTest = {\n          isPending: function () {\n            return true;\n          },\n          title: expectedTitle,\n          file: expectedFile,\n          parent: {\n            fullTitle: function () {\n              return expectedClassName;\n            }\n          },\n          duration: 1000\n        };\n\n        xunit.test.call(fakeThis, expectedTest);\n        sinon.restore();\n\n        var expectedTag =\n          '<testcase classname=\"' +\n          expectedClassName +\n          '\" name=\"' +\n          expectedTitle +\n          '\" file=\"' +\n          expectedFile +\n          '\" time=\"1\"><skipped/></testcase>';\n        expect(expectedWrite, 'to be', expectedTag);\n      });\n    });\n\n    describe('on test in any other state', function () {\n      it('should write expected tag', function () {\n        var xunit = new XUnit(runner);\n        var expectedTest = {\n          isPending: function () {\n            return false;\n          },\n          title: expectedTitle,\n          file: expectedFile,\n          parent: {\n            fullTitle: function () {\n              return expectedClassName;\n            }\n          },\n          duration: false\n        };\n\n        xunit.test.call(fakeThis, expectedTest);\n        sinon.restore();\n\n        var expectedTag =\n          '<testcase classname=\"' +\n          expectedClassName +\n          '\" name=\"' +\n          expectedTitle +\n          '\" file=\"' +\n          expectedFile +\n          '\" time=\"0\"/>';\n        expect(expectedWrite, 'to be', expectedTag);\n      });\n    });\n\n    it('should write expected summary statistics', function () {\n      var numTests = 0;\n      var numPass = 0;\n      var numFail = 0;\n      var simpleError = {\n        actual: 'foo',\n        expected: 'bar',\n        message: expectedMessage,\n        stack: expectedStack\n      };\n      var generateTest = function (passed) {\n        numTests++;\n        if (passed) {\n          numPass++;\n        } else {\n          numFail++;\n        }\n        return {\n          title: [expectedTitle, numTests].join(': '),\n          state: passed ? STATE_PASSED : STATE_FAILED,\n          isPending: function () {\n            return false;\n          },\n          slow: function () {\n            return false;\n          },\n          parent: {\n            fullTitle: function () {\n              return expectedClassName;\n            }\n          },\n          duration: 1000\n        };\n      };\n\n      var runner = new EventEmitter();\n      createStatsCollector(runner);\n      var xunit = new XUnit(runner);\n      expectedWrite = '';\n      sinon.stub(xunit, 'write').callsFake(function (str) {\n        expectedWrite += str;\n      });\n\n      // 3 tests, no failures (i.e. tests that could not run), and 2 errors\n      runner.emit(EVENT_TEST_PASS, generateTest(true));\n      runner.emit(EVENT_TEST_END);\n      runner.emit(EVENT_TEST_FAIL, generateTest(false), simpleError);\n      runner.emit(EVENT_TEST_END);\n      runner.emit(EVENT_TEST_FAIL, generateTest(false), simpleError);\n      runner.emit(EVENT_TEST_END);\n      runner.emit(EVENT_RUN_END);\n\n      sinon.restore();\n\n      var expectedNumPass = 1;\n      var expectedNumFail = 2;\n      var expectedNumTests = 3;\n\n      expect(expectedNumPass, 'to be', numPass);\n      expect(expectedNumFail, 'to be', numFail);\n      expect(expectedNumTests, 'to be', numTests);\n\n      // :NOTE: Mocha test \"fail\" is an XUnit \"error\"\n      var expectedTag =\n        '<testsuite name=\"Mocha Tests\" tests=\"3\" failures=\"0\" errors=\"2\" skipped=\"0\"';\n\n      expect(expectedWrite, 'to contain', expectedTag);\n      expect(expectedWrite, 'to contain', '</testsuite>');\n    });\n  });\n\n  describe('suite name', function () {\n    // Capture the events that the reporter subscribes to\n    var events = {};\n    // Capture output lines (will contain the resulting XML of XUnit reporter)\n    var lines = [];\n    // File stream into which the XUnit reporter will write\n    var fileStream;\n\n    before(function () {\n      fileStream = {\n        write: function (chunk, encoding, cb) {\n          lines.push(chunk);\n        }\n      };\n    });\n\n    beforeEach(function () {\n      lines = [];\n      events = {};\n\n      runner.on = runner.once = function (eventName, eventHandler) {\n        // Capture the event handler\n        events[eventName] = eventHandler;\n      };\n    });\n\n    it('should use custom name if provided via reporter options', function () {\n      var customSuiteName = 'Mocha Is Great!';\n      var options = {\n        reporterOptions: {\n          suiteName: customSuiteName\n        }\n      };\n\n      var xunit = new XUnit(runner, options);\n      xunit.fileStream = fileStream;\n\n      // Trigger end event to force XUnit reporter to write its output\n      events[EVENT_RUN_END]();\n\n      expect(lines[0], 'to contain', customSuiteName);\n    });\n\n    it('should use default name otherwise', function () {\n      var defaultSuiteName = 'Mocha Tests';\n      var options = {\n        reporterOptions: {}\n      };\n\n      var xunit = new XUnit(runner, options);\n      xunit.fileStream = fileStream;\n\n      // Trigger end event to force XUnit reporter to write its output\n      events[EVENT_RUN_END]();\n\n      expect(lines[0], 'to contain', defaultSuiteName);\n    });\n  });\n\n  describe('showRelativePaths reporter option', function () {\n    const projectPath = path.join('home', 'username', 'demo-project');\n    const relativeTestPath = path.join('tests', 'demo-test.spec.js');\n    const absoluteTestPath = path.join(projectPath, relativeTestPath);\n\n    var expectedWrite = '';\n    const fakeThis = {\n      write: function (str) {\n        expectedWrite = expectedWrite + str;\n      }\n    };\n\n    const failingTest = {\n      state: STATE_FAILED,\n      title: expectedTitle,\n      file: absoluteTestPath,\n      parent: {\n        fullTitle: function () {\n          return expectedClassName;\n        }\n      },\n      duration: 1000,\n      err: {\n        actual: 'foo',\n        expected: 'bar',\n        message: expectedMessage,\n        stack: expectedStack\n      }\n    };\n\n    beforeEach(function () {\n      sinon.stub(process, 'cwd').returns(projectPath);\n    });\n\n    afterEach(function () {\n      sinon.restore();\n      expectedWrite = '';\n    });\n\n    it('shows relative paths for tests if showRelativePaths reporter option is set', function () {\n      const options = {\n        reporterOptions: {\n          showRelativePaths: true\n        }\n      };\n      const xunit = new XUnit(runner, options);\n\n      xunit.test.call(fakeThis, failingTest, options);\n\n      expect(expectedWrite, 'not to contain', absoluteTestPath);\n      expect(expectedWrite, 'to contain', relativeTestPath);\n    });\n\n    it('shows absolute paths for tests by default', function () {\n      const options = {};\n      const xunit = new XUnit(runner);\n\n      xunit.test.call(fakeThis, failingTest, options);\n\n      expect(expectedWrite, 'to contain', absoluteTestPath);\n      // Double quote included to ensure printed paths don't start with relative path. Example printed line: <testcase classname=\"suite\" name=\"test\" file=\"some/tesfile.js\" time=\"0\"/>\n      expect(expectedWrite, 'not to contain', `\"${relativeTestPath}`);\n    });\n  });\n});"}
{"prompt":"this generic fixture does nothing special and will be used if no fixture is supplied","test":"// this generic fixture does nothing special and will be used if no fixture is supplied\n\n'use strict';\n\ndescribe('a suite', function() {\n  it('should succeed', function(done) {\n    done();\n  });\n});"}